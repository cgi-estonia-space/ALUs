/* Autogenerated by mlir-tblgen; don't manually edit */
#ifdef GEN_PASS_CLASSES

//===----------------------------------------------------------------------===//
// ChloLegalizeToHloPass
//===----------------------------------------------------------------------===//

template <typename DerivedT>
class ChloLegalizeToHloPassBase : public ::mlir::OperationPass<FuncOp> {
public:
  ChloLegalizeToHloPassBase() : ::mlir::OperationPass<FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  ChloLegalizeToHloPassBase(const ChloLegalizeToHloPassBase &) : ::mlir::OperationPass<FuncOp>(::mlir::TypeID::get<DerivedT>()) {}

  /// Returns the command-line argument attached to this pass.
  ::llvm::StringRef getArgument() const override { return "chlo-legalize-to-hlo"; }

  /// Returns the derived pass name.
  ::llvm::StringRef getName() const override { return "ChloLegalizeToHloPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

protected:
};

//===----------------------------------------------------------------------===//
// HloLegalizeToLhloPass
//===----------------------------------------------------------------------===//

template <typename DerivedT>
class HloLegalizeToLhloPassBase : public ::mlir::OperationPass<ModuleOp> {
public:
  HloLegalizeToLhloPassBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  HloLegalizeToLhloPassBase(const HloLegalizeToLhloPassBase &) : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}

  /// Returns the command-line argument attached to this pass.
  ::llvm::StringRef getArgument() const override { return "hlo-legalize-to-lhlo"; }

  /// Returns the derived pass name.
  ::llvm::StringRef getName() const override { return "HloLegalizeToLhloPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

protected:
};

//===----------------------------------------------------------------------===//
// HloLegalizeToLinalgPass
//===----------------------------------------------------------------------===//

template <typename DerivedT>
class HloLegalizeToLinalgPassBase : public ::mlir::OperationPass<FuncOp> {
public:
  HloLegalizeToLinalgPassBase() : ::mlir::OperationPass<FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  HloLegalizeToLinalgPassBase(const HloLegalizeToLinalgPassBase &) : ::mlir::OperationPass<FuncOp>(::mlir::TypeID::get<DerivedT>()) {}

  /// Returns the command-line argument attached to this pass.
  ::llvm::StringRef getArgument() const override { return "hlo-legalize-to-linalg"; }

  /// Returns the derived pass name.
  ::llvm::StringRef getName() const override { return "HloLegalizeToLinalgPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

protected:
};

//===----------------------------------------------------------------------===//
// LegalizeControlFlowPass
//===----------------------------------------------------------------------===//

template <typename DerivedT>
class LegalizeControlFlowPassBase : public ::mlir::OperationPass<FuncOp> {
public:
  LegalizeControlFlowPassBase() : ::mlir::OperationPass<FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  LegalizeControlFlowPassBase(const LegalizeControlFlowPassBase &) : ::mlir::OperationPass<FuncOp>(::mlir::TypeID::get<DerivedT>()) {}

  /// Returns the command-line argument attached to this pass.
  ::llvm::StringRef getArgument() const override { return "mhlo-legalize-control-flow"; }

  /// Returns the derived pass name.
  ::llvm::StringRef getName() const override { return "LegalizeControlFlowPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

protected:
};

//===----------------------------------------------------------------------===//
// LegalizeControlFlowToScfPass
//===----------------------------------------------------------------------===//

template <typename DerivedT>
class LegalizeControlFlowToScfPassBase : public ::mlir::OperationPass<FuncOp> {
public:
  LegalizeControlFlowToScfPassBase() : ::mlir::OperationPass<FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  LegalizeControlFlowToScfPassBase(const LegalizeControlFlowToScfPassBase &) : ::mlir::OperationPass<FuncOp>(::mlir::TypeID::get<DerivedT>()) {}

  /// Returns the command-line argument attached to this pass.
  ::llvm::StringRef getArgument() const override { return "mhlo-control-flow-to-scf"; }

  /// Returns the derived pass name.
  ::llvm::StringRef getName() const override { return "LegalizeControlFlowToScfPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

protected:
};

//===----------------------------------------------------------------------===//
// LegalizeGatherToTorchIndexSelectPass
//===----------------------------------------------------------------------===//

template <typename DerivedT>
class LegalizeGatherToTorchIndexSelectPassBase : public ::mlir::OperationPass<FuncOp> {
public:
  LegalizeGatherToTorchIndexSelectPassBase() : ::mlir::OperationPass<FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  LegalizeGatherToTorchIndexSelectPassBase(const LegalizeGatherToTorchIndexSelectPassBase &) : ::mlir::OperationPass<FuncOp>(::mlir::TypeID::get<DerivedT>()) {}

  /// Returns the command-line argument attached to this pass.
  ::llvm::StringRef getArgument() const override { return "mhlo-legalize-gather-to-torch-index-select"; }

  /// Returns the derived pass name.
  ::llvm::StringRef getName() const override { return "LegalizeGatherToTorchIndexSelectPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

protected:
};

//===----------------------------------------------------------------------===//
// LegalizeGeneralDotPass
//===----------------------------------------------------------------------===//

template <typename DerivedT>
class LegalizeGeneralDotPassBase : public ::mlir::OperationPass<FuncOp> {
public:
  LegalizeGeneralDotPassBase() : ::mlir::OperationPass<FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  LegalizeGeneralDotPassBase(const LegalizeGeneralDotPassBase &) : ::mlir::OperationPass<FuncOp>(::mlir::TypeID::get<DerivedT>()) {}

  /// Returns the command-line argument attached to this pass.
  ::llvm::StringRef getArgument() const override { return "mhlo-test-lower-general-dot"; }

  /// Returns the derived pass name.
  ::llvm::StringRef getName() const override { return "LegalizeGeneralDotPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

protected:
};

//===----------------------------------------------------------------------===//
// LegalizeTanhToApproximationPass
//===----------------------------------------------------------------------===//

template <typename DerivedT>
class LegalizeTanhToApproximationPassBase : public ::mlir::OperationPass<FuncOp> {
public:
  LegalizeTanhToApproximationPassBase() : ::mlir::OperationPass<FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  LegalizeTanhToApproximationPassBase(const LegalizeTanhToApproximationPassBase &) : ::mlir::OperationPass<FuncOp>(::mlir::TypeID::get<DerivedT>()) {}

  /// Returns the command-line argument attached to this pass.
  ::llvm::StringRef getArgument() const override { return "mhlo-legalize-trigonometric-to-approximation"; }

  /// Returns the derived pass name.
  ::llvm::StringRef getName() const override { return "LegalizeTanhToApproximationPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

protected:
};

//===----------------------------------------------------------------------===//
// LegalizeToStandardPass
//===----------------------------------------------------------------------===//

template <typename DerivedT>
class LegalizeToStandardPassBase : public ::mlir::OperationPass<FuncOp> {
public:
  LegalizeToStandardPassBase() : ::mlir::OperationPass<FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  LegalizeToStandardPassBase(const LegalizeToStandardPassBase &) : ::mlir::OperationPass<FuncOp>(::mlir::TypeID::get<DerivedT>()) {}

  /// Returns the command-line argument attached to this pass.
  ::llvm::StringRef getArgument() const override { return "mhlo-legalize-to-std"; }

  /// Returns the derived pass name.
  ::llvm::StringRef getName() const override { return "LegalizeToStandardPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

protected:
};

//===----------------------------------------------------------------------===//
// LowerComplexPass
//===----------------------------------------------------------------------===//

template <typename DerivedT>
class LowerComplexPassBase : public ::mlir::OperationPass<FuncOp> {
public:
  LowerComplexPassBase() : ::mlir::OperationPass<FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  LowerComplexPassBase(const LowerComplexPassBase &) : ::mlir::OperationPass<FuncOp>(::mlir::TypeID::get<DerivedT>()) {}

  /// Returns the command-line argument attached to this pass.
  ::llvm::StringRef getArgument() const override { return "mhlo-test-lower-complex"; }

  /// Returns the derived pass name.
  ::llvm::StringRef getName() const override { return "LowerComplexPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

protected:
};

//===----------------------------------------------------------------------===//
// MhloFusionPass
//===----------------------------------------------------------------------===//

template <typename DerivedT>
class MhloFusionPassBase : public ::mlir::OperationPass<FuncOp> {
public:
  MhloFusionPassBase() : ::mlir::OperationPass<FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  MhloFusionPassBase(const MhloFusionPassBase &) : ::mlir::OperationPass<FuncOp>(::mlir::TypeID::get<DerivedT>()) {}

  /// Returns the command-line argument attached to this pass.
  ::llvm::StringRef getArgument() const override { return "mhlo-fusion"; }

  /// Returns the derived pass name.
  ::llvm::StringRef getName() const override { return "MhloFusionPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

protected:
};

//===----------------------------------------------------------------------===//
// OptimizeMhloPass
//===----------------------------------------------------------------------===//

template <typename DerivedT>
class OptimizeMhloPassBase : public ::mlir::OperationPass<FuncOp> {
public:
  OptimizeMhloPassBase() : ::mlir::OperationPass<FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  OptimizeMhloPassBase(const OptimizeMhloPassBase &) : ::mlir::OperationPass<FuncOp>(::mlir::TypeID::get<DerivedT>()) {}

  /// Returns the command-line argument attached to this pass.
  ::llvm::StringRef getArgument() const override { return "mhlo-test-optimize"; }

  /// Returns the derived pass name.
  ::llvm::StringRef getName() const override { return "OptimizeMhloPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

protected:
};

//===----------------------------------------------------------------------===//
// SinkConstantsToControlFlowPass
//===----------------------------------------------------------------------===//

template <typename DerivedT>
class SinkConstantsToControlFlowPassBase : public ::mlir::FunctionPass {
public:
  SinkConstantsToControlFlowPassBase() : ::mlir::FunctionPass(::mlir::TypeID::get<DerivedT>()) {}
  SinkConstantsToControlFlowPassBase(const SinkConstantsToControlFlowPassBase &) : ::mlir::FunctionPass(::mlir::TypeID::get<DerivedT>()) {}

  /// Returns the command-line argument attached to this pass.
  ::llvm::StringRef getArgument() const override { return "mhlo-sink-constants-to-control-flow"; }

  /// Returns the derived pass name.
  ::llvm::StringRef getName() const override { return "SinkConstantsToControlFlowPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

protected:
};

//===----------------------------------------------------------------------===//
// TestInferShapedTypeMethodsPass
//===----------------------------------------------------------------------===//

template <typename DerivedT>
class TestInferShapedTypeMethodsPassBase : public ::mlir::OperationPass<FuncOp> {
public:
  TestInferShapedTypeMethodsPassBase() : ::mlir::OperationPass<FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  TestInferShapedTypeMethodsPassBase(const TestInferShapedTypeMethodsPassBase &) : ::mlir::OperationPass<FuncOp>(::mlir::TypeID::get<DerivedT>()) {}

  /// Returns the command-line argument attached to this pass.
  ::llvm::StringRef getArgument() const override { return "mhlo-test-infer-shaped-type-methods"; }

  /// Returns the derived pass name.
  ::llvm::StringRef getName() const override { return "TestInferShapedTypeMethodsPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

protected:
};

//===----------------------------------------------------------------------===//
// TestMaterializeBroadcastsPass
//===----------------------------------------------------------------------===//

template <typename DerivedT>
class TestMaterializeBroadcastsPassBase : public ::mlir::OperationPass<FuncOp> {
public:
  TestMaterializeBroadcastsPassBase() : ::mlir::OperationPass<FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  TestMaterializeBroadcastsPassBase(const TestMaterializeBroadcastsPassBase &) : ::mlir::OperationPass<FuncOp>(::mlir::TypeID::get<DerivedT>()) {}

  /// Returns the command-line argument attached to this pass.
  ::llvm::StringRef getArgument() const override { return "mhlo-test-materialize-broadcasts"; }

  /// Returns the derived pass name.
  ::llvm::StringRef getName() const override { return "TestMaterializeBroadcastsPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

protected:
};

//===----------------------------------------------------------------------===//
// TestUnfuseBatchNormPass
//===----------------------------------------------------------------------===//

template <typename DerivedT>
class TestUnfuseBatchNormPassBase : public ::mlir::OperationPass<FuncOp> {
public:
  TestUnfuseBatchNormPassBase() : ::mlir::OperationPass<FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  TestUnfuseBatchNormPassBase(const TestUnfuseBatchNormPassBase &) : ::mlir::OperationPass<FuncOp>(::mlir::TypeID::get<DerivedT>()) {}

  /// Returns the command-line argument attached to this pass.
  ::llvm::StringRef getArgument() const override { return "mhlo-test-unfuse-batch-norm"; }

  /// Returns the derived pass name.
  ::llvm::StringRef getName() const override { return "TestUnfuseBatchNormPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

protected:
};

//===----------------------------------------------------------------------===//
// TransformUnrankedHloPass
//===----------------------------------------------------------------------===//

template <typename DerivedT>
class TransformUnrankedHloPassBase : public ::mlir::OperationPass<FuncOp> {
public:
  TransformUnrankedHloPassBase() : ::mlir::OperationPass<FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  TransformUnrankedHloPassBase(const TransformUnrankedHloPassBase &) : ::mlir::OperationPass<FuncOp>(::mlir::TypeID::get<DerivedT>()) {}

  /// Returns the command-line argument attached to this pass.
  ::llvm::StringRef getArgument() const override { return "transform-unranked-hlo"; }

  /// Returns the derived pass name.
  ::llvm::StringRef getName() const override { return "TransformUnrankedHloPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

protected:
};
#undef GEN_PASS_CLASSES
#endif // GEN_PASS_CLASSES
#ifdef GEN_PASS_REGISTRATION

//===----------------------------------------------------------------------===//
// ChloLegalizeToHloPass Registration
//===----------------------------------------------------------------------===//

inline void registerChloLegalizeToHloPassPass() {
  ::mlir::registerPass("chlo-legalize-to-hlo", "Legalize CHLO to HLO.", []() -> std::unique_ptr<::mlir::Pass> {
    return createChloLegalizeToHloPass();
  });
}

//===----------------------------------------------------------------------===//
// HloLegalizeToLhloPass Registration
//===----------------------------------------------------------------------===//

inline void registerHloLegalizeToLhloPassPass() {
  ::mlir::registerPass("hlo-legalize-to-lhlo", "Legalize from HLO dialect to LHLO dialect.", []() -> std::unique_ptr<::mlir::Pass> {
    return createLegalizeToLhloPass();
  });
}

//===----------------------------------------------------------------------===//
// HloLegalizeToLinalgPass Registration
//===----------------------------------------------------------------------===//

inline void registerHloLegalizeToLinalgPassPass() {
  ::mlir::registerPass("hlo-legalize-to-linalg", "Legalize from HLO dialect to Linalg dialect.", []() -> std::unique_ptr<::mlir::Pass> {
    return createLegalizeHloToLinalgPass();
  });
}

//===----------------------------------------------------------------------===//
// LegalizeControlFlowPass Registration
//===----------------------------------------------------------------------===//

inline void registerLegalizeControlFlowPassPass() {
  ::mlir::registerPass("mhlo-legalize-control-flow", "Legalize from MHLO control flow to CFG control flow.", []() -> std::unique_ptr<::mlir::Pass> {
    return createLegalizeControlFlowPass();
  });
}

//===----------------------------------------------------------------------===//
// LegalizeControlFlowToScfPass Registration
//===----------------------------------------------------------------------===//

inline void registerLegalizeControlFlowToScfPassPass() {
  ::mlir::registerPass("mhlo-control-flow-to-scf", "Legalize from MHLO control flow to SCF control flow.", []() -> std::unique_ptr<::mlir::Pass> {
    return createControlFlowToScfPass();
  });
}

//===----------------------------------------------------------------------===//
// LegalizeGatherToTorchIndexSelectPass Registration
//===----------------------------------------------------------------------===//

inline void registerLegalizeGatherToTorchIndexSelectPassPass() {
  ::mlir::registerPass("mhlo-legalize-gather-to-torch-index-select", "Legalizes gathers to a torch index select.", []() -> std::unique_ptr<::mlir::Pass> {
    return createLegalizeGatherToTorchIndexSelectPass();
  });
}

//===----------------------------------------------------------------------===//
// LegalizeGeneralDotPass Registration
//===----------------------------------------------------------------------===//

inline void registerLegalizeGeneralDotPassPass() {
  ::mlir::registerPass("mhlo-test-lower-general-dot", "Tests lowering general dot to a non-batched dot when possible.", []() -> std::unique_ptr<::mlir::Pass> {
    return createLegalizeGeneralDotPass();
  });
}

//===----------------------------------------------------------------------===//
// LegalizeTanhToApproximationPass Registration
//===----------------------------------------------------------------------===//

inline void registerLegalizeTanhToApproximationPassPass() {
  ::mlir::registerPass("mhlo-legalize-trigonometric-to-approximation", "Legalize trigonometric operations from standard dialect to an approximation.", []() -> std::unique_ptr<::mlir::Pass> {
    return createLegalizeTrigonometricToApproximationPass();
  });
}

//===----------------------------------------------------------------------===//
// LegalizeToStandardPass Registration
//===----------------------------------------------------------------------===//

inline void registerLegalizeToStandardPassPass() {
  ::mlir::registerPass("mhlo-legalize-to-std", "Legalize from MHLO dialect to standard dialect.", []() -> std::unique_ptr<::mlir::Pass> {
    return createLegalizeToStdPass();
  });
}

//===----------------------------------------------------------------------===//
// LowerComplexPass Registration
//===----------------------------------------------------------------------===//

inline void registerLowerComplexPassPass() {
  ::mlir::registerPass("mhlo-test-lower-complex", "Lower complex operations into non-complex operations.", []() -> std::unique_ptr<::mlir::Pass> {
    return createLowerComplexPass();
  });
}

//===----------------------------------------------------------------------===//
// MhloFusionPass Registration
//===----------------------------------------------------------------------===//

inline void registerMhloFusionPassPass() {
  ::mlir::registerPass("mhlo-fusion", "Fuse mhlo ops to kLoop/kInput fusion patterns.", []() -> std::unique_ptr<::mlir::Pass> {
    return createMhloFusionPass();
  });
}

//===----------------------------------------------------------------------===//
// OptimizeMhloPass Registration
//===----------------------------------------------------------------------===//

inline void registerOptimizeMhloPassPass() {
  ::mlir::registerPass("mhlo-test-optimize", "Run optional HLO optimizations.", []() -> std::unique_ptr<::mlir::Pass> {
    return createOptimizeMhloPass();
  });
}

//===----------------------------------------------------------------------===//
// SinkConstantsToControlFlowPass Registration
//===----------------------------------------------------------------------===//

inline void registerSinkConstantsToControlFlowPassPass() {
  ::mlir::registerPass("mhlo-sink-constants-to-control-flow", "Sink constants implicitly captured in control flow regions. This is necessary to export to XLA.", []() -> std::unique_ptr<::mlir::Pass> {
    return createSinkConstantsToControlFlowPass();
  });
}

//===----------------------------------------------------------------------===//
// TestInferShapedTypeMethodsPass Registration
//===----------------------------------------------------------------------===//

inline void registerTestInferShapedTypeMethodsPassPass() {
  ::mlir::registerPass("mhlo-test-infer-shaped-type-methods", "Uses test ops to invoke InferShapedTypeOpInterface methods.", []() -> std::unique_ptr<::mlir::Pass> {
    return createTestInferShapedTypeMethodsPass();
  });
}

//===----------------------------------------------------------------------===//
// TestMaterializeBroadcastsPass Registration
//===----------------------------------------------------------------------===//

inline void registerTestMaterializeBroadcastsPassPass() {
  ::mlir::registerPass("mhlo-test-materialize-broadcasts", "Test pass for materializing 'broadcast_dimensions' attributes.", []() -> std::unique_ptr<::mlir::Pass> {
    return createTestMaterializeBroadcastsPass();
  });
}

//===----------------------------------------------------------------------===//
// TestUnfuseBatchNormPass Registration
//===----------------------------------------------------------------------===//

inline void registerTestUnfuseBatchNormPassPass() {
  ::mlir::registerPass("mhlo-test-unfuse-batch-norm", "Test pass for materializing 'broadcast_dimensions' attributes.", []() -> std::unique_ptr<::mlir::Pass> {
    return createTestUnfuseBatchNormPass();
  });
}

//===----------------------------------------------------------------------===//
// TransformUnrankedHloPass Registration
//===----------------------------------------------------------------------===//

inline void registerTransformUnrankedHloPassPass() {
  ::mlir::registerPass("transform-unranked-hlo", "Realize element-wise operations on ranked tensors where possible.", []() -> std::unique_ptr<::mlir::Pass> {
    return createTransformUnrankedHloPass();
  });
}

//===----------------------------------------------------------------------===//
// MHLO Registration
//===----------------------------------------------------------------------===//

inline void registerMHLOPasses() {
  registerChloLegalizeToHloPassPass();
  registerHloLegalizeToLhloPassPass();
  registerHloLegalizeToLinalgPassPass();
  registerLegalizeControlFlowPassPass();
  registerLegalizeControlFlowToScfPassPass();
  registerLegalizeGatherToTorchIndexSelectPassPass();
  registerLegalizeGeneralDotPassPass();
  registerLegalizeTanhToApproximationPassPass();
  registerLegalizeToStandardPassPass();
  registerLowerComplexPassPass();
  registerMhloFusionPassPass();
  registerOptimizeMhloPassPass();
  registerSinkConstantsToControlFlowPassPass();
  registerTestInferShapedTypeMethodsPassPass();
  registerTestMaterializeBroadcastsPassPass();
  registerTestUnfuseBatchNormPassPass();
  registerTransformUnrankedHloPassPass();
}
#undef GEN_PASS_REGISTRATION
#endif // GEN_PASS_REGISTRATION
