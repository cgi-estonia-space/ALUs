/*===- TableGen'erated file -------------------------------------*- C++ -*-===*\
|*                                                                            *|
|* Op Definitions                                                             *|
|*                                                                            *|
|* Automatically generated file, do not edit!                                 *|
|*                                                                            *|
\*===----------------------------------------------------------------------===*/

#ifdef GET_OP_LIST
#undef GET_OP_LIST

::mlir::TF::AbsOp,
::mlir::TF::AcosOp,
::mlir::TF::AcoshOp,
::mlir::TF::AddNOp,
::mlir::TF::AddOp,
::mlir::TF::AddV2Op,
::mlir::TF::AdjustContrastv2Op,
::mlir::TF::AdjustHueOp,
::mlir::TF::AdjustSaturationOp,
::mlir::TF::AllOp,
::mlir::TF::AllToAllOp,
::mlir::TF::AngleOp,
::mlir::TF::AnonymousIteratorOp,
::mlir::TF::AnonymousIteratorV2Op,
::mlir::TF::AnonymousMemoryCacheOp,
::mlir::TF::AnonymousMultiDeviceIteratorOp,
::mlir::TF::AnonymousRandomSeedGeneratorOp,
::mlir::TF::AnonymousSeedGeneratorOp,
::mlir::TF::AnyOp,
::mlir::TF::ApproximateEqualOp,
::mlir::TF::ArgMaxOp,
::mlir::TF::ArgMinOp,
::mlir::TF::AsStringOp,
::mlir::TF::AsinOp,
::mlir::TF::AsinhOp,
::mlir::TF::AssertOp,
::mlir::TF::AssignAddVariableOp,
::mlir::TF::AssignSubVariableOp,
::mlir::TF::AssignVariableOp,
::mlir::TF::Atan2Op,
::mlir::TF::AtanOp,
::mlir::TF::AtanhOp,
::mlir::TF::AvgPool3DGradOp,
::mlir::TF::AvgPool3DOp,
::mlir::TF::AvgPoolGradOp,
::mlir::TF::AvgPoolOp,
::mlir::TF::BatchDatasetV2Op,
::mlir::TF::BatchFunctionOp,
::mlir::TF::BatchMatMulOp,
::mlir::TF::BatchMatMulV2Op,
::mlir::TF::BatchNormWithGlobalNormalizationOp,
::mlir::TF::BatchToSpaceNDOp,
::mlir::TF::BatchToSpaceOp,
::mlir::TF::BesselI0eOp,
::mlir::TF::BesselI1eOp,
::mlir::TF::BetaincOp,
::mlir::TF::BiasAddGradOp,
::mlir::TF::BiasAddOp,
::mlir::TF::BiasAddV1Op,
::mlir::TF::BitcastOp,
::mlir::TF::BitwiseAndOp,
::mlir::TF::BitwiseOrOp,
::mlir::TF::BitwiseXorOp,
::mlir::TF::BroadcastArgsOp,
::mlir::TF::BroadcastGradientArgsOp,
::mlir::TF::BroadcastToOp,
::mlir::TF::BucketizeOp,
::mlir::TF::CacheDatasetV2Op,
::mlir::TF::CaseOp,
::mlir::TF::CaseRegionOp,
::mlir::TF::CastOp,
::mlir::TF::CeilOp,
::mlir::TF::CheckNumericsOp,
::mlir::TF::CholeskyOp,
::mlir::TF::ClipByValueOp,
::mlir::TF::CloseSummaryWriterOp,
::mlir::TF::CollectiveBcastRecvOp,
::mlir::TF::CollectiveBcastSendOp,
::mlir::TF::CollectiveGatherOp,
::mlir::TF::CollectivePermuteOp,
::mlir::TF::CollectiveReduceOp,
::mlir::TF::CollectiveReduceV2Op,
::mlir::TF::ComplexAbsOp,
::mlir::TF::ComplexOp,
::mlir::TF::ConcatOffsetOp,
::mlir::TF::ConcatOp,
::mlir::TF::ConcatV2Op,
::mlir::TF::ConfigureDistributedTPUOp,
::mlir::TF::ConfigureTPUEmbeddingOp,
::mlir::TF::ConjOp,
::mlir::TF::ConjugateTransposeOp,
::mlir::TF::ConstOp,
::mlir::TF::Conv2DBackpropFilterOp,
::mlir::TF::Conv2DBackpropInputOp,
::mlir::TF::Conv2DOp,
::mlir::TF::Conv3DBackpropFilterV2Op,
::mlir::TF::Conv3DBackpropInputV2Op,
::mlir::TF::Conv3DOp,
::mlir::TF::CosOp,
::mlir::TF::CoshOp,
::mlir::TF::CreateSummaryDbWriterOp,
::mlir::TF::CreateSummaryFileWriterOp,
::mlir::TF::CrossOp,
::mlir::TF::CrossReplicaSumOp,
::mlir::TF::CumprodOp,
::mlir::TF::CumsumOp,
::mlir::TF::DataFormatDimMapOp,
::mlir::TF::DataFormatVecPermuteOp,
::mlir::TF::DebugIdentityV2Op,
::mlir::TF::DecodeAndCropJpegOp,
::mlir::TF::DecodeGifOp,
::mlir::TF::DecodeJpegOp,
::mlir::TF::DecodePngOp,
::mlir::TF::DeleteIteratorOp,
::mlir::TF::DeleteMemoryCacheOp,
::mlir::TF::DeleteMultiDeviceIteratorOp,
::mlir::TF::DeleteRandomSeedGeneratorOp,
::mlir::TF::DeleteSeedGeneratorOp,
::mlir::TF::DepthToSpaceOp,
::mlir::TF::DepthwiseConv2dNativeBackpropFilterOp,
::mlir::TF::DepthwiseConv2dNativeBackpropInputOp,
::mlir::TF::DepthwiseConv2dNativeOp,
::mlir::TF::DeserializeIteratorOp,
::mlir::TF::DestroyResourceOp,
::mlir::TF::DeviceIndexOp,
::mlir::TF::DiagOp,
::mlir::TF::DiagPartOp,
::mlir::TF::DigammaOp,
::mlir::TF::DivNoNanOp,
::mlir::TF::DivOp,
::mlir::TF::DummyMemoryCacheOp,
::mlir::TF::DummySeedGeneratorOp,
::mlir::TF::DynamicStitchOp,
::mlir::TF::EinsumOp,
::mlir::TF::EluGradOp,
::mlir::TF::EluOp,
::mlir::TF::EmptyOp,
::mlir::TF::EmptyTensorListOp,
::mlir::TF::EnqueueTPUEmbeddingRaggedTensorBatchOp,
::mlir::TF::EnqueueTPUEmbeddingSparseTensorBatchOp,
::mlir::TF::EnsureShapeOp,
::mlir::TF::EqualOp,
::mlir::TF::ErfOp,
::mlir::TF::ErfcOp,
::mlir::TF::ErfinvOp,
::mlir::TF::ExpOp,
::mlir::TF::ExpandDimsOp,
::mlir::TF::Expm1Op,
::mlir::TF::ExtractImagePatchesOp,
::mlir::TF::FFT2DOp,
::mlir::TF::FFT3DOp,
::mlir::TF::FFTOp,
::mlir::TF::FakeParamOp,
::mlir::TF::FakeQuantWithMinMaxArgsGradientOp,
::mlir::TF::FakeQuantWithMinMaxArgsOp,
::mlir::TF::FakeQuantWithMinMaxVarsGradientOp,
::mlir::TF::FakeQuantWithMinMaxVarsOp,
::mlir::TF::FakeQuantWithMinMaxVarsPerChannelOp,
::mlir::TF::FillOp,
::mlir::TF::FloorDivOp,
::mlir::TF::FloorModOp,
::mlir::TF::FloorOp,
::mlir::TF::FlushSummaryWriterOp,
::mlir::TF::FusedBatchNormGradOp,
::mlir::TF::FusedBatchNormGradV2Op,
::mlir::TF::FusedBatchNormGradV3Op,
::mlir::TF::FusedBatchNormOp,
::mlir::TF::FusedBatchNormV2Op,
::mlir::TF::FusedBatchNormV3Op,
::mlir::TF::GatherNdOp,
::mlir::TF::GatherOp,
::mlir::TF::GatherV2Op,
::mlir::TF::GreaterEqualOp,
::mlir::TF::GreaterOp,
::mlir::TF::HSVToRGBOp,
::mlir::TF::HashTableV2Op,
::mlir::TF::IFFT2DOp,
::mlir::TF::IFFT3DOp,
::mlir::TF::IFFTOp,
::mlir::TF::IRFFT2DOp,
::mlir::TF::IRFFT3DOp,
::mlir::TF::IRFFTOp,
::mlir::TF::IdentityNOp,
::mlir::TF::IdentityOp,
::mlir::TF::IfOp,
::mlir::TF::IfRegionOp,
::mlir::TF::IgammaGradAOp,
::mlir::TF::IgammaOp,
::mlir::TF::IgammacOp,
::mlir::TF::ImagOp,
::mlir::TF::ImportEventOp,
::mlir::TF::InTopKV2Op,
::mlir::TF::InfeedDequeueOp,
::mlir::TF::InfeedDequeueTupleOp,
::mlir::TF::InitializeTableFromDatasetOp,
::mlir::TF::InitializeTableFromTextFileV2Op,
::mlir::TF::InitializeTableV2Op,
::mlir::TF::InplaceUpdateOp,
::mlir::TF::InvOp,
::mlir::TF::InvertOp,
::mlir::TF::InvertPermutationOp,
::mlir::TF::IsFiniteOp,
::mlir::TF::IsInfOp,
::mlir::TF::IsNanOp,
::mlir::TF::IteratorFromStringHandleOp,
::mlir::TF::IteratorFromStringHandleV2Op,
::mlir::TF::IteratorGetNextAsOptionalOp,
::mlir::TF::IteratorGetNextOp,
::mlir::TF::IteratorGetNextSyncOp,
::mlir::TF::IteratorOp,
::mlir::TF::IteratorToStringHandleOp,
::mlir::TF::IteratorV2Op,
::mlir::TF::L2LossOp,
::mlir::TF::LRNGradOp,
::mlir::TF::LRNOp,
::mlir::TF::LeakyReluGradOp,
::mlir::TF::LeakyReluOp,
::mlir::TF::LeftShiftOp,
::mlir::TF::LegacyCallOp,
::mlir::TF::LessEqualOp,
::mlir::TF::LessOp,
::mlir::TF::LgammaOp,
::mlir::TF::LinSpaceOp,
::mlir::TF::ListDiffOp,
::mlir::TF::Log1pOp,
::mlir::TF::LogOp,
::mlir::TF::LogSoftmaxOp,
::mlir::TF::LogicalAndOp,
::mlir::TF::LogicalNotOp,
::mlir::TF::LogicalOrOp,
::mlir::TF::LookupTableExportV2Op,
::mlir::TF::LookupTableFindV2Op,
::mlir::TF::LookupTableImportV2Op,
::mlir::TF::LookupTableInsertV2Op,
::mlir::TF::LookupTableRemoveV2Op,
::mlir::TF::LookupTableSizeV2Op,
::mlir::TF::LowerBoundOp,
::mlir::TF::MakeIteratorOp,
::mlir::TF::MapAndBatchDatasetOp,
::mlir::TF::MapDatasetOp,
::mlir::TF::MatMulOp,
::mlir::TF::MatrixBandPartOp,
::mlir::TF::MatrixDiagOp,
::mlir::TF::MatrixDiagPartV3Op,
::mlir::TF::MatrixDiagV2Op,
::mlir::TF::MatrixDiagV3Op,
::mlir::TF::MatrixInverseOp,
::mlir::TF::MatrixSetDiagOp,
::mlir::TF::MatrixSetDiagV2Op,
::mlir::TF::MatrixSetDiagV3Op,
::mlir::TF::MatrixSolveOp,
::mlir::TF::MatrixTriangularSolveOp,
::mlir::TF::MaxOp,
::mlir::TF::MaxPool3DGradOp,
::mlir::TF::MaxPool3DOp,
::mlir::TF::MaxPoolGradOp,
::mlir::TF::MaxPoolOp,
::mlir::TF::MaximumOp,
::mlir::TF::MeanOp,
::mlir::TF::MergeSummaryOp,
::mlir::TF::MergeV2CheckpointsOp,
::mlir::TF::MinOp,
::mlir::TF::MinimumOp,
::mlir::TF::MirrorPadOp,
::mlir::TF::MlirLocalVarOp,
::mlir::TF::MlirPassthroughOp,
::mlir::TF::ModOp,
::mlir::TF::MulNoNanOp,
::mlir::TF::MulOp,
::mlir::TF::MultiDeviceIteratorFromStringHandleOp,
::mlir::TF::MultiDeviceIteratorGetNextFromShardOp,
::mlir::TF::MultiDeviceIteratorInitOp,
::mlir::TF::MultiDeviceIteratorOp,
::mlir::TF::MultiDeviceIteratorToStringHandleOp,
::mlir::TF::MultinomialOp,
::mlir::TF::MutableDenseHashTableV2Op,
::mlir::TF::MutableHashTableOfTensorsV2Op,
::mlir::TF::MutableHashTableV2Op
#endif  // GET_OP_LIST

#ifdef GET_OP_CLASSES
#undef GET_OP_CLASSES

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::AbsOp definitions
//===----------------------------------------------------------------------===//

AbsOpAdaptor::AbsOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

AbsOpAdaptor::AbsOpAdaptor(AbsOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> AbsOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange AbsOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value AbsOpAdaptor::x() {
  return *getODSOperands(0).begin();
}

::mlir::LogicalResult AbsOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

::llvm::StringRef AbsOp::getOperationName() {
  return "tf.Abs";
}

std::pair<unsigned, unsigned> AbsOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range AbsOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value AbsOp::x() {
  return *getODSOperands(0).begin();
}

::mlir::MutableOperandRange AbsOp::xMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> AbsOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range AbsOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value AbsOp::y() {
  return *getODSResults(0).begin();
}

Type AbsOp::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

bool AbsOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "T") return true;
 return false;
}

::mlir::DictionaryAttr AbsOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())}
    }, ctx);
}

void AbsOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type y, ::mlir::Value x) {
  odsState.addOperands(x);
  odsState.addTypes(y);
}

void AbsOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value x) {
  odsState.addOperands(x);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void AbsOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

void AbsOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value x) {
  odsState.addOperands(x);
  odsState.addTypes({x.getType()});

}

void AbsOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  odsState.addTypes({operands[0].getType()});

}

::mlir::LogicalResult AbsOp::verify() {
  if (failed(AbsOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of bfloat16 or 16-bit float or 32-bit float or 64-bit float or 16-bit integer or 32-bit integer or 64-bit integer or 8-bit integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>())))))) {
        return emitOpError("result #") << index << " must be tensor of bfloat16 or 16-bit float or 32-bit float or 64-bit float or 16-bit integer or 32-bit integer or 64-bit integer or 8-bit integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void AbsOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::AcosOp definitions
//===----------------------------------------------------------------------===//

AcosOpAdaptor::AcosOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

AcosOpAdaptor::AcosOpAdaptor(AcosOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> AcosOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange AcosOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value AcosOpAdaptor::x() {
  return *getODSOperands(0).begin();
}

::mlir::LogicalResult AcosOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

::llvm::StringRef AcosOp::getOperationName() {
  return "tf.Acos";
}

std::pair<unsigned, unsigned> AcosOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range AcosOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value AcosOp::x() {
  return *getODSOperands(0).begin();
}

::mlir::MutableOperandRange AcosOp::xMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> AcosOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range AcosOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value AcosOp::y() {
  return *getODSResults(0).begin();
}

Type AcosOp::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

bool AcosOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "T") return true;
 return false;
}

::mlir::DictionaryAttr AcosOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())}
    }, ctx);
}

void AcosOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type y, ::mlir::Value x) {
  odsState.addOperands(x);
  odsState.addTypes(y);
}

void AcosOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value x) {
  odsState.addOperands(x);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void AcosOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

void AcosOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value x) {
  odsState.addOperands(x);
  odsState.addTypes({x.getType()});

}

void AcosOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  odsState.addTypes({operands[0].getType()});

}

::mlir::LogicalResult AcosOp::verify() {
  if (failed(AcosOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of bfloat16 or 128-bit complex or 64-bit complex or 16-bit float or 32-bit float or 64-bit float or 16-bit integer or 32-bit integer or 64-bit integer or 8-bit integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>())))))) {
        return emitOpError("result #") << index << " must be tensor of bfloat16 or 128-bit complex or 64-bit complex or 16-bit float or 32-bit float or 64-bit float or 16-bit integer or 32-bit integer or 64-bit integer or 8-bit integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void AcosOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::AcoshOp definitions
//===----------------------------------------------------------------------===//

AcoshOpAdaptor::AcoshOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

AcoshOpAdaptor::AcoshOpAdaptor(AcoshOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> AcoshOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange AcoshOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value AcoshOpAdaptor::x() {
  return *getODSOperands(0).begin();
}

::mlir::LogicalResult AcoshOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

::llvm::StringRef AcoshOp::getOperationName() {
  return "tf.Acosh";
}

std::pair<unsigned, unsigned> AcoshOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range AcoshOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value AcoshOp::x() {
  return *getODSOperands(0).begin();
}

::mlir::MutableOperandRange AcoshOp::xMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> AcoshOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range AcoshOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value AcoshOp::y() {
  return *getODSResults(0).begin();
}

Type AcoshOp::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

bool AcoshOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "T") return true;
 return false;
}

::mlir::DictionaryAttr AcoshOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())}
    }, ctx);
}

void AcoshOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type y, ::mlir::Value x) {
  odsState.addOperands(x);
  odsState.addTypes(y);
}

void AcoshOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value x) {
  odsState.addOperands(x);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void AcoshOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

void AcoshOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value x) {
  odsState.addOperands(x);
  odsState.addTypes({x.getType()});

}

void AcoshOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  odsState.addTypes({operands[0].getType()});

}

::mlir::LogicalResult AcoshOp::verify() {
  if (failed(AcoshOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))))))) {
        return emitOpError("operand #") << index << " must be tensor of floating-point or complex values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))))))) {
        return emitOpError("result #") << index << " must be tensor of floating-point or complex values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void AcoshOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::AddNOp definitions
//===----------------------------------------------------------------------===//

AddNOpAdaptor::AddNOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

AddNOpAdaptor::AddNOpAdaptor(AddNOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> AddNOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  bool isVariadic[] = {true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (odsOperands.size() - 0) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::mlir::ValueRange AddNOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::ValueRange AddNOpAdaptor::inputs() {
  return getODSOperands(0);
}

::mlir::LogicalResult AddNOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

::llvm::StringRef AddNOp::getOperationName() {
  return "tf.AddN";
}

std::pair<unsigned, unsigned> AddNOp::getODSOperandIndexAndLength(unsigned index) {
  bool isVariadic[] = {true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (getOperation()->getNumOperands() - 0) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::mlir::Operation::operand_range AddNOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Operation::operand_range AddNOp::inputs() {
  return getODSOperands(0);
}

::mlir::MutableOperandRange AddNOp::inputsMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> AddNOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range AddNOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value AddNOp::sum() {
  return *getODSResults(0).begin();
}

Type AddNOp::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

size_t AddNOp::N() {
  auto range = getODSOperands(0);
return std::distance(range.begin(), range.end());
}

bool AddNOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "T") return true;
  if (name == "N") return true;
 return false;
}

::mlir::DictionaryAttr AddNOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())},
    {::mlir::Identifier::get("N", ctx),
odsBuilder.getI64IntegerAttr(N())}
    }, ctx);
}

void AddNOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type sum, ::mlir::ValueRange inputs) {
  odsState.addOperands(inputs);
  odsState.addTypes(sum);
}

void AddNOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult AddNOp::verify() {
  if (failed(AddNOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::VariantType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::VariantRefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of bfloat16 or 128-bit complex or 64-bit complex or 16-bit float or 32-bit float or 64-bit float or 16-bit integer or 32-bit integer or 64-bit integer or 8-bit integer or 32-bit quantized integer or 8-bit quantized integer or 8-bit quantized unsigned integer or 16-bit unsigned integer or 32-bit unsigned integer or 64-bit unsigned integer or 8-bit unsigned integer or variant values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::VariantType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::VariantRefType>())))))) {
        return emitOpError("result #") << index << " must be tensor of bfloat16 or 128-bit complex or 64-bit complex or 16-bit float or 32-bit float or 64-bit float or 16-bit integer or 32-bit integer or 64-bit integer or 8-bit integer or 32-bit quantized integer or 8-bit quantized integer or 8-bit quantized unsigned integer or 16-bit unsigned integer or 32-bit unsigned integer or 64-bit unsigned integer or 8-bit unsigned integer or variant values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}



void AddNOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::AddOp definitions
//===----------------------------------------------------------------------===//

AddOpAdaptor::AddOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

AddOpAdaptor::AddOpAdaptor(AddOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> AddOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange AddOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value AddOpAdaptor::x() {
  return *getODSOperands(0).begin();
}

::mlir::Value AddOpAdaptor::y() {
  return *getODSOperands(1).begin();
}

::mlir::LogicalResult AddOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

::llvm::StringRef AddOp::getOperationName() {
  return "tf.Add";
}

std::pair<unsigned, unsigned> AddOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range AddOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value AddOp::x() {
  return *getODSOperands(0).begin();
}

::mlir::Value AddOp::y() {
  return *getODSOperands(1).begin();
}

::mlir::MutableOperandRange AddOp::xMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange AddOp::yMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> AddOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range AddOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value AddOp::z() {
  return *getODSResults(0).begin();
}

Type AddOp::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

bool AddOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "T") return true;
 return false;
}

::mlir::DictionaryAttr AddOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())}
    }, ctx);
}

void AddOp::build(OpBuilder &builder, OperationState &result, Value  x, Value  y) {
  auto resultType =
      OpTrait::util::getBroadcastedType(x.getType(), y.getType());
  if (!resultType)
    mlir::emitError(result.location, "non-broadcastable operands");
  return build(builder, result, resultType, x, y);
}

void AddOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type z, ::mlir::Value x, ::mlir::Value y) {
  odsState.addOperands(x);
  odsState.addOperands(y);
  odsState.addTypes(z);
}

void AddOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value x, ::mlir::Value y) {
  odsState.addOperands(x);
  odsState.addOperands(y);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void AddOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult AddOp::verify() {
  if (failed(AddOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>())))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::StringType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::StringRefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of floating-point or signed integer or complex or 8-bit unsigned integer or string values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>())))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::StringType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::StringRefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of floating-point or signed integer or complex or 8-bit unsigned integer or string values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>())))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::StringType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::StringRefType>())))))) {
        return emitOpError("result #") << index << " must be tensor of floating-point or signed integer or complex or 8-bit unsigned integer or string values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}



void AddOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::AddV2Op definitions
//===----------------------------------------------------------------------===//

AddV2OpAdaptor::AddV2OpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

AddV2OpAdaptor::AddV2OpAdaptor(AddV2Op&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> AddV2OpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange AddV2OpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value AddV2OpAdaptor::x() {
  return *getODSOperands(0).begin();
}

::mlir::Value AddV2OpAdaptor::y() {
  return *getODSOperands(1).begin();
}

::mlir::LogicalResult AddV2OpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

::llvm::StringRef AddV2Op::getOperationName() {
  return "tf.AddV2";
}

std::pair<unsigned, unsigned> AddV2Op::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range AddV2Op::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value AddV2Op::x() {
  return *getODSOperands(0).begin();
}

::mlir::Value AddV2Op::y() {
  return *getODSOperands(1).begin();
}

::mlir::MutableOperandRange AddV2Op::xMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange AddV2Op::yMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> AddV2Op::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range AddV2Op::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value AddV2Op::z() {
  return *getODSResults(0).begin();
}

Type AddV2Op::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

bool AddV2Op::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "T") return true;
 return false;
}

::mlir::DictionaryAttr AddV2Op::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())}
    }, ctx);
}

void AddV2Op::build(OpBuilder &builder, OperationState &result, Value  x, Value  y) {
  auto resultType =
      OpTrait::util::getBroadcastedType(x.getType(), y.getType());
  if (!resultType)
    mlir::emitError(result.location, "non-broadcastable operands");
  return build(builder, result, resultType, x, y);
}

void AddV2Op::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type z, ::mlir::Value x, ::mlir::Value y) {
  odsState.addOperands(x);
  odsState.addOperands(y);
  odsState.addTypes(z);
}

void AddV2Op::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value x, ::mlir::Value y) {
  odsState.addOperands(x);
  odsState.addOperands(y);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void AddV2Op::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult AddV2Op::verify() {
  if (failed(AddV2OpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>())))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of floating-point or signed integer or complex or 8-bit unsigned integer or 32-bit unsigned integer values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>())))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of floating-point or signed integer or complex or 8-bit unsigned integer or 32-bit unsigned integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>())))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>())))))) {
        return emitOpError("result #") << index << " must be tensor of floating-point or signed integer or complex or 8-bit unsigned integer or 32-bit unsigned integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}





void AddV2Op::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::AdjustContrastv2Op definitions
//===----------------------------------------------------------------------===//

AdjustContrastv2OpAdaptor::AdjustContrastv2OpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

AdjustContrastv2OpAdaptor::AdjustContrastv2OpAdaptor(AdjustContrastv2Op&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> AdjustContrastv2OpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange AdjustContrastv2OpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value AdjustContrastv2OpAdaptor::images() {
  return *getODSOperands(0).begin();
}

::mlir::Value AdjustContrastv2OpAdaptor::contrast_factor() {
  return *getODSOperands(1).begin();
}

::mlir::LogicalResult AdjustContrastv2OpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

::llvm::StringRef AdjustContrastv2Op::getOperationName() {
  return "tf.AdjustContrastv2";
}

std::pair<unsigned, unsigned> AdjustContrastv2Op::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range AdjustContrastv2Op::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value AdjustContrastv2Op::images() {
  return *getODSOperands(0).begin();
}

::mlir::Value AdjustContrastv2Op::contrast_factor() {
  return *getODSOperands(1).begin();
}

::mlir::MutableOperandRange AdjustContrastv2Op::imagesMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange AdjustContrastv2Op::contrast_factorMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> AdjustContrastv2Op::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range AdjustContrastv2Op::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value AdjustContrastv2Op::output() {
  return *getODSResults(0).begin();
}

Type AdjustContrastv2Op::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

bool AdjustContrastv2Op::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "T") return true;
 return false;
}

::mlir::DictionaryAttr AdjustContrastv2Op::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())}
    }, ctx);
}

void AdjustContrastv2Op::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value images, ::mlir::Value contrast_factor) {
  odsState.addOperands(images);
  odsState.addOperands(contrast_factor);
  odsState.addTypes(output);
}

void AdjustContrastv2Op::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value images, ::mlir::Value contrast_factor) {
  odsState.addOperands(images);
  odsState.addOperands(contrast_factor);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void AdjustContrastv2Op::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult AdjustContrastv2Op::verify() {
  if (failed(AdjustContrastv2OpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of 16-bit float or 32-bit float values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of 32-bit float values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())))))) {
        return emitOpError("result #") << index << " must be tensor of 16-bit float or 32-bit float values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void AdjustContrastv2Op::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::AdjustHueOp definitions
//===----------------------------------------------------------------------===//

AdjustHueOpAdaptor::AdjustHueOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

AdjustHueOpAdaptor::AdjustHueOpAdaptor(AdjustHueOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> AdjustHueOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange AdjustHueOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value AdjustHueOpAdaptor::images() {
  return *getODSOperands(0).begin();
}

::mlir::Value AdjustHueOpAdaptor::delta() {
  return *getODSOperands(1).begin();
}

::mlir::LogicalResult AdjustHueOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

::llvm::StringRef AdjustHueOp::getOperationName() {
  return "tf.AdjustHue";
}

std::pair<unsigned, unsigned> AdjustHueOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range AdjustHueOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value AdjustHueOp::images() {
  return *getODSOperands(0).begin();
}

::mlir::Value AdjustHueOp::delta() {
  return *getODSOperands(1).begin();
}

::mlir::MutableOperandRange AdjustHueOp::imagesMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange AdjustHueOp::deltaMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> AdjustHueOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range AdjustHueOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value AdjustHueOp::output() {
  return *getODSResults(0).begin();
}

Type AdjustHueOp::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

bool AdjustHueOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "T") return true;
 return false;
}

::mlir::DictionaryAttr AdjustHueOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())}
    }, ctx);
}

void AdjustHueOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value images, ::mlir::Value delta) {
  odsState.addOperands(images);
  odsState.addOperands(delta);
  odsState.addTypes(output);
}

void AdjustHueOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value images, ::mlir::Value delta) {
  odsState.addOperands(images);
  odsState.addOperands(delta);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void AdjustHueOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult AdjustHueOp::verify() {
  if (failed(AdjustHueOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of 16-bit float or 32-bit float values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of 32-bit float values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())))))) {
        return emitOpError("result #") << index << " must be tensor of 16-bit float or 32-bit float values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void AdjustHueOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::AdjustSaturationOp definitions
//===----------------------------------------------------------------------===//

AdjustSaturationOpAdaptor::AdjustSaturationOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

AdjustSaturationOpAdaptor::AdjustSaturationOpAdaptor(AdjustSaturationOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> AdjustSaturationOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange AdjustSaturationOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value AdjustSaturationOpAdaptor::images() {
  return *getODSOperands(0).begin();
}

::mlir::Value AdjustSaturationOpAdaptor::scale() {
  return *getODSOperands(1).begin();
}

::mlir::LogicalResult AdjustSaturationOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

::llvm::StringRef AdjustSaturationOp::getOperationName() {
  return "tf.AdjustSaturation";
}

std::pair<unsigned, unsigned> AdjustSaturationOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range AdjustSaturationOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value AdjustSaturationOp::images() {
  return *getODSOperands(0).begin();
}

::mlir::Value AdjustSaturationOp::scale() {
  return *getODSOperands(1).begin();
}

::mlir::MutableOperandRange AdjustSaturationOp::imagesMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange AdjustSaturationOp::scaleMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> AdjustSaturationOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range AdjustSaturationOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value AdjustSaturationOp::output() {
  return *getODSResults(0).begin();
}

Type AdjustSaturationOp::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

bool AdjustSaturationOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "T") return true;
 return false;
}

::mlir::DictionaryAttr AdjustSaturationOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())}
    }, ctx);
}

void AdjustSaturationOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value images, ::mlir::Value scale) {
  odsState.addOperands(images);
  odsState.addOperands(scale);
  odsState.addTypes(output);
}

void AdjustSaturationOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value images, ::mlir::Value scale) {
  odsState.addOperands(images);
  odsState.addOperands(scale);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void AdjustSaturationOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult AdjustSaturationOp::verify() {
  if (failed(AdjustSaturationOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of 16-bit float or 32-bit float values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of 32-bit float values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())))))) {
        return emitOpError("result #") << index << " must be tensor of 16-bit float or 32-bit float values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void AdjustSaturationOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::AllOp definitions
//===----------------------------------------------------------------------===//

AllOpAdaptor::AllOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

AllOpAdaptor::AllOpAdaptor(AllOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> AllOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange AllOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value AllOpAdaptor::input() {
  return *getODSOperands(0).begin();
}

::mlir::Value AllOpAdaptor::reduction_indices() {
  return *getODSOperands(1).begin();
}

::mlir::BoolAttr AllOpAdaptor::keep_dims() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::BoolAttr attr = odsAttrs.get("keep_dims").dyn_cast_or_null<::mlir::BoolAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getBoolAttr(false);
  return attr;
}

::mlir::LogicalResult AllOpAdaptor::verify(::mlir::Location loc) {
  {
  auto tblgen_keep_dims = odsAttrs.get("keep_dims");
  if (tblgen_keep_dims) {
    if (!((tblgen_keep_dims.isa<::mlir::BoolAttr>()))) return emitError(loc, "'tf.All' op ""attribute 'keep_dims' failed to satisfy constraint: bool attribute");
  }
  }
  return ::mlir::success();
}

::llvm::StringRef AllOp::getOperationName() {
  return "tf.All";
}

std::pair<unsigned, unsigned> AllOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range AllOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value AllOp::input() {
  return *getODSOperands(0).begin();
}

::mlir::Value AllOp::reduction_indices() {
  return *getODSOperands(1).begin();
}

::mlir::MutableOperandRange AllOp::inputMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange AllOp::reduction_indicesMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> AllOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range AllOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value AllOp::output() {
  return *getODSResults(0).begin();
}

::mlir::BoolAttr AllOp::keep_dimsAttr() {
  return this->getAttr("keep_dims").dyn_cast_or_null<::mlir::BoolAttr>();
}

bool AllOp::keep_dims() {
  auto attr = keep_dimsAttr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getBoolAttr(false).getValue();
  return attr.getValue();
}

Type AllOp::Tidx() {
  return mlir::getElementTypeOrSelf(*getODSOperands(1).begin());
}

bool AllOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "Tidx") return true;
 return false;
}

::mlir::DictionaryAttr AllOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("Tidx", ctx),
::mlir::TypeAttr::get(Tidx())}
    }, ctx);
}

void AllOp::keep_dimsAttr(::mlir::BoolAttr attr) {
  this->getOperation()->setAttr("keep_dims", attr);
}

void AllOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value input, ::mlir::Value reduction_indices, ::mlir::BoolAttr keep_dims) {
  odsState.addOperands(input);
  odsState.addOperands(reduction_indices);
  odsState.addAttribute("keep_dims", keep_dims);
  odsState.addTypes(output);
}

void AllOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input, ::mlir::Value reduction_indices, ::mlir::BoolAttr keep_dims) {
  odsState.addOperands(input);
  odsState.addOperands(reduction_indices);
  odsState.addAttribute("keep_dims", keep_dims);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void AllOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value input, ::mlir::Value reduction_indices, bool keep_dims) {
  odsState.addOperands(input);
  odsState.addOperands(reduction_indices);
  odsState.addAttribute("keep_dims", odsBuilder.getBoolAttr(keep_dims));
  odsState.addTypes(output);
}

void AllOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input, ::mlir::Value reduction_indices, bool keep_dims) {
  odsState.addOperands(input);
  odsState.addOperands(reduction_indices);
  odsState.addAttribute("keep_dims", odsBuilder.getBoolAttr(keep_dims));
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void AllOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult AllOp::verify() {
  if (failed(AllOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of bool values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of 32/64-bit signed integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))))) {
        return emitOpError("result #") << index << " must be tensor of bool values, but got " << v.getType();
      }
      ++index;
    }
  }
  return Verify(*this);
}

void AllOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::AllToAllOp definitions
//===----------------------------------------------------------------------===//

AllToAllOpAdaptor::AllToAllOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

AllToAllOpAdaptor::AllToAllOpAdaptor(AllToAllOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> AllToAllOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange AllToAllOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value AllToAllOpAdaptor::input() {
  return *getODSOperands(0).begin();
}

::mlir::Value AllToAllOpAdaptor::group_assignment() {
  return *getODSOperands(1).begin();
}

::mlir::IntegerAttr AllToAllOpAdaptor::concat_dimension() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::IntegerAttr attr = odsAttrs.get("concat_dimension").cast<::mlir::IntegerAttr>();
  return attr;
}

::mlir::IntegerAttr AllToAllOpAdaptor::split_dimension() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::IntegerAttr attr = odsAttrs.get("split_dimension").cast<::mlir::IntegerAttr>();
  return attr;
}

::mlir::IntegerAttr AllToAllOpAdaptor::split_count() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::IntegerAttr attr = odsAttrs.get("split_count").cast<::mlir::IntegerAttr>();
  return attr;
}

::mlir::LogicalResult AllToAllOpAdaptor::verify(::mlir::Location loc) {
  {
  auto tblgen_concat_dimension = odsAttrs.get("concat_dimension");
  if (!tblgen_concat_dimension) return emitError(loc, "'tf.AllToAll' op ""requires attribute 'concat_dimension'");
    if (!(((tblgen_concat_dimension.isa<::mlir::IntegerAttr>())) && ((tblgen_concat_dimension.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(64))))) return emitError(loc, "'tf.AllToAll' op ""attribute 'concat_dimension' failed to satisfy constraint: 64-bit signless integer attribute");
  }
  {
  auto tblgen_split_dimension = odsAttrs.get("split_dimension");
  if (!tblgen_split_dimension) return emitError(loc, "'tf.AllToAll' op ""requires attribute 'split_dimension'");
    if (!(((tblgen_split_dimension.isa<::mlir::IntegerAttr>())) && ((tblgen_split_dimension.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(64))))) return emitError(loc, "'tf.AllToAll' op ""attribute 'split_dimension' failed to satisfy constraint: 64-bit signless integer attribute");
  }
  {
  auto tblgen_split_count = odsAttrs.get("split_count");
  if (!tblgen_split_count) return emitError(loc, "'tf.AllToAll' op ""requires attribute 'split_count'");
    if (!(((tblgen_split_count.isa<::mlir::IntegerAttr>())) && ((tblgen_split_count.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(64))))) return emitError(loc, "'tf.AllToAll' op ""attribute 'split_count' failed to satisfy constraint: 64-bit signless integer attribute");
  }
  return ::mlir::success();
}

::llvm::StringRef AllToAllOp::getOperationName() {
  return "tf.AllToAll";
}

std::pair<unsigned, unsigned> AllToAllOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range AllToAllOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value AllToAllOp::input() {
  return *getODSOperands(0).begin();
}

::mlir::Value AllToAllOp::group_assignment() {
  return *getODSOperands(1).begin();
}

::mlir::MutableOperandRange AllToAllOp::inputMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange AllToAllOp::group_assignmentMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> AllToAllOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range AllToAllOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value AllToAllOp::output() {
  return *getODSResults(0).begin();
}

::mlir::IntegerAttr AllToAllOp::concat_dimensionAttr() {
  return this->getAttr("concat_dimension").cast<::mlir::IntegerAttr>();
}

uint64_t AllToAllOp::concat_dimension() {
  auto attr = concat_dimensionAttr();
  return attr.getValue().getZExtValue();
}

::mlir::IntegerAttr AllToAllOp::split_dimensionAttr() {
  return this->getAttr("split_dimension").cast<::mlir::IntegerAttr>();
}

uint64_t AllToAllOp::split_dimension() {
  auto attr = split_dimensionAttr();
  return attr.getValue().getZExtValue();
}

::mlir::IntegerAttr AllToAllOp::split_countAttr() {
  return this->getAttr("split_count").cast<::mlir::IntegerAttr>();
}

uint64_t AllToAllOp::split_count() {
  auto attr = split_countAttr();
  return attr.getValue().getZExtValue();
}

Type AllToAllOp::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

bool AllToAllOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "T") return true;
 return false;
}

::mlir::DictionaryAttr AllToAllOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())}
    }, ctx);
}

void AllToAllOp::concat_dimensionAttr(::mlir::IntegerAttr attr) {
  this->getOperation()->setAttr("concat_dimension", attr);
}

void AllToAllOp::split_dimensionAttr(::mlir::IntegerAttr attr) {
  this->getOperation()->setAttr("split_dimension", attr);
}

void AllToAllOp::split_countAttr(::mlir::IntegerAttr attr) {
  this->getOperation()->setAttr("split_count", attr);
}

void AllToAllOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value input, ::mlir::Value group_assignment, ::mlir::IntegerAttr concat_dimension, ::mlir::IntegerAttr split_dimension, ::mlir::IntegerAttr split_count) {
  odsState.addOperands(input);
  odsState.addOperands(group_assignment);
  odsState.addAttribute("concat_dimension", concat_dimension);
  odsState.addAttribute("split_dimension", split_dimension);
  odsState.addAttribute("split_count", split_count);
  odsState.addTypes(output);
}

void AllToAllOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input, ::mlir::Value group_assignment, ::mlir::IntegerAttr concat_dimension, ::mlir::IntegerAttr split_dimension, ::mlir::IntegerAttr split_count) {
  odsState.addOperands(input);
  odsState.addOperands(group_assignment);
  odsState.addAttribute("concat_dimension", concat_dimension);
  odsState.addAttribute("split_dimension", split_dimension);
  odsState.addAttribute("split_count", split_count);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void AllToAllOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value input, ::mlir::Value group_assignment, uint64_t concat_dimension, uint64_t split_dimension, uint64_t split_count) {
  odsState.addOperands(input);
  odsState.addOperands(group_assignment);
  odsState.addAttribute("concat_dimension", odsBuilder.getIntegerAttr(odsBuilder.getIntegerType(64), concat_dimension));
  odsState.addAttribute("split_dimension", odsBuilder.getIntegerAttr(odsBuilder.getIntegerType(64), split_dimension));
  odsState.addAttribute("split_count", odsBuilder.getIntegerAttr(odsBuilder.getIntegerType(64), split_count));
  odsState.addTypes(output);
}

void AllToAllOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input, ::mlir::Value group_assignment, uint64_t concat_dimension, uint64_t split_dimension, uint64_t split_count) {
  odsState.addOperands(input);
  odsState.addOperands(group_assignment);
  odsState.addAttribute("concat_dimension", odsBuilder.getIntegerAttr(odsBuilder.getIntegerType(64), concat_dimension));
  odsState.addAttribute("split_dimension", odsBuilder.getIntegerAttr(odsBuilder.getIntegerType(64), split_dimension));
  odsState.addAttribute("split_count", odsBuilder.getIntegerAttr(odsBuilder.getIntegerType(64), split_count));
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void AllToAllOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult AllToAllOp::verify() {
  if (failed(AllToAllOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of bfloat16 or bool or 128-bit complex or 64-bit complex or 16-bit float or 32-bit float or 64-bit float or 16-bit integer or 32-bit integer or 64-bit integer or 8-bit integer or 32-bit quantized integer or 8-bit quantized integer or 8-bit quantized unsigned integer or 16-bit unsigned integer or 32-bit unsigned integer or 64-bit unsigned integer or 8-bit unsigned integer values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of 32-bit integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>())))))) {
        return emitOpError("result #") << index << " must be tensor of bfloat16 or bool or 128-bit complex or 64-bit complex or 16-bit float or 32-bit float or 64-bit float or 16-bit integer or 32-bit integer or 64-bit integer or 8-bit integer or 32-bit quantized integer or 8-bit quantized integer or 8-bit quantized unsigned integer or 16-bit unsigned integer or 32-bit unsigned integer or 64-bit unsigned integer or 8-bit unsigned integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void AllToAllOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::AngleOp definitions
//===----------------------------------------------------------------------===//

AngleOpAdaptor::AngleOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

AngleOpAdaptor::AngleOpAdaptor(AngleOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> AngleOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange AngleOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value AngleOpAdaptor::input() {
  return *getODSOperands(0).begin();
}

::mlir::LogicalResult AngleOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

::llvm::StringRef AngleOp::getOperationName() {
  return "tf.Angle";
}

std::pair<unsigned, unsigned> AngleOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range AngleOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value AngleOp::input() {
  return *getODSOperands(0).begin();
}

::mlir::MutableOperandRange AngleOp::inputMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> AngleOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range AngleOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value AngleOp::output() {
  return *getODSResults(0).begin();
}

Type AngleOp::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

Type AngleOp::Tout() {
  return mlir::getElementTypeOrSelf(*getODSResults(0).begin());
}

bool AngleOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "T") return true;
  if (name == "Tout") return true;
 return false;
}

::mlir::DictionaryAttr AngleOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())},
    {::mlir::Identifier::get("Tout", ctx),
::mlir::TypeAttr::get(Tout())}
    }, ctx);
}

void AngleOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value input) {
  odsState.addOperands(input);
  odsState.addTypes(output);
}

void AngleOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input) {
  odsState.addOperands(input);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void AngleOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult AngleOp::verify() {
  if (failed(AngleOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of 128-bit complex or 64-bit complex values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())))))) {
        return emitOpError("result #") << index << " must be tensor of 32/64-bit float values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void AngleOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::AnonymousIteratorOp definitions
//===----------------------------------------------------------------------===//

AnonymousIteratorOpAdaptor::AnonymousIteratorOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

AnonymousIteratorOpAdaptor::AnonymousIteratorOpAdaptor(AnonymousIteratorOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> AnonymousIteratorOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange AnonymousIteratorOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::ArrayAttr AnonymousIteratorOpAdaptor::output_types() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::ArrayAttr attr = odsAttrs.get("output_types").cast<::mlir::ArrayAttr>();
  return attr;
}

::mlir::ArrayAttr AnonymousIteratorOpAdaptor::output_shapes() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::ArrayAttr attr = odsAttrs.get("output_shapes").cast<::mlir::ArrayAttr>();
  return attr;
}

::mlir::LogicalResult AnonymousIteratorOpAdaptor::verify(::mlir::Location loc) {
  {
  auto tblgen_output_types = odsAttrs.get("output_types");
  if (!tblgen_output_types) return emitError(loc, "'tf.AnonymousIterator' op ""requires attribute 'output_types'");
    if (!((((tblgen_output_types.isa<::mlir::ArrayAttr>())) && (::llvm::all_of(tblgen_output_types.cast<::mlir::ArrayAttr>(), [](::mlir::Attribute attr) { return ((attr.isa<::mlir::TypeAttr>())) && ((attr.cast<::mlir::TypeAttr>().getValue().isa<::mlir::Type>())); }))) && ((tblgen_output_types.cast<::mlir::ArrayAttr>().size() >= 1)))) return emitError(loc, "'tf.AnonymousIterator' op ""attribute 'output_types' failed to satisfy constraint: type array attribute with at least 1 elements");
  }
  {
  auto tblgen_output_shapes = odsAttrs.get("output_shapes");
  if (!tblgen_output_shapes) return emitError(loc, "'tf.AnonymousIterator' op ""requires attribute 'output_shapes'");
    if (!((((tblgen_output_shapes.isa<::mlir::ArrayAttr>())) && (::llvm::all_of(tblgen_output_shapes.cast<::mlir::ArrayAttr>(), [](::mlir::Attribute attr) { return (attr.isa<mlir::TF::ShapeAttr>()); }))) && ((tblgen_output_shapes.cast<::mlir::ArrayAttr>().size() >= 1)))) return emitError(loc, "'tf.AnonymousIterator' op ""attribute 'output_shapes' failed to satisfy constraint: tensorflow shape attribute array with at least 1 elements");
  }
  return ::mlir::success();
}

::llvm::StringRef AnonymousIteratorOp::getOperationName() {
  return "tf.AnonymousIterator";
}

std::pair<unsigned, unsigned> AnonymousIteratorOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range AnonymousIteratorOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

std::pair<unsigned, unsigned> AnonymousIteratorOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range AnonymousIteratorOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value AnonymousIteratorOp::handle() {
  return *getODSResults(0).begin();
}

::mlir::ArrayAttr AnonymousIteratorOp::output_typesAttr() {
  return this->getAttr("output_types").cast<::mlir::ArrayAttr>();
}

::mlir::ArrayAttr AnonymousIteratorOp::output_types() {
  auto attr = output_typesAttr();
  return attr;
}

::mlir::ArrayAttr AnonymousIteratorOp::output_shapesAttr() {
  return this->getAttr("output_shapes").cast<::mlir::ArrayAttr>();
}

::mlir::ArrayAttr AnonymousIteratorOp::output_shapes() {
  auto attr = output_shapesAttr();
  return attr;
}

void AnonymousIteratorOp::output_typesAttr(::mlir::ArrayAttr attr) {
  this->getOperation()->setAttr("output_types", attr);
}

void AnonymousIteratorOp::output_shapesAttr(::mlir::ArrayAttr attr) {
  this->getOperation()->setAttr("output_shapes", attr);
}

void AnonymousIteratorOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type handle, ::mlir::ArrayAttr output_types, ::mlir::ArrayAttr output_shapes) {
  odsState.addAttribute("output_types", output_types);
  odsState.addAttribute("output_shapes", output_shapes);
  odsState.addTypes(handle);
}

void AnonymousIteratorOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ArrayAttr output_types, ::mlir::ArrayAttr output_shapes) {
  odsState.addAttribute("output_types", output_types);
  odsState.addAttribute("output_shapes", output_shapes);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void AnonymousIteratorOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 0u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult AnonymousIteratorOp::verify() {
  if (failed(AnonymousIteratorOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::ResourceType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::ResourceRefType>()))))) {
        return emitOpError("result #") << index << " must be tensor of resource values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void AnonymousIteratorOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
  for (::mlir::Value value : getODSResults(0))
    effects.emplace_back(MemoryEffects::Allocate::get(), value, ::mlir::TF::ResourceEffects::DatasetIterator::get());
}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::AnonymousIteratorV2Op definitions
//===----------------------------------------------------------------------===//

AnonymousIteratorV2OpAdaptor::AnonymousIteratorV2OpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

AnonymousIteratorV2OpAdaptor::AnonymousIteratorV2OpAdaptor(AnonymousIteratorV2Op&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> AnonymousIteratorV2OpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange AnonymousIteratorV2OpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::ArrayAttr AnonymousIteratorV2OpAdaptor::output_types() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::ArrayAttr attr = odsAttrs.get("output_types").cast<::mlir::ArrayAttr>();
  return attr;
}

::mlir::ArrayAttr AnonymousIteratorV2OpAdaptor::output_shapes() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::ArrayAttr attr = odsAttrs.get("output_shapes").cast<::mlir::ArrayAttr>();
  return attr;
}

::mlir::LogicalResult AnonymousIteratorV2OpAdaptor::verify(::mlir::Location loc) {
  {
  auto tblgen_output_types = odsAttrs.get("output_types");
  if (!tblgen_output_types) return emitError(loc, "'tf.AnonymousIteratorV2' op ""requires attribute 'output_types'");
    if (!((((tblgen_output_types.isa<::mlir::ArrayAttr>())) && (::llvm::all_of(tblgen_output_types.cast<::mlir::ArrayAttr>(), [](::mlir::Attribute attr) { return ((attr.isa<::mlir::TypeAttr>())) && ((attr.cast<::mlir::TypeAttr>().getValue().isa<::mlir::Type>())); }))) && ((tblgen_output_types.cast<::mlir::ArrayAttr>().size() >= 1)))) return emitError(loc, "'tf.AnonymousIteratorV2' op ""attribute 'output_types' failed to satisfy constraint: type array attribute with at least 1 elements");
  }
  {
  auto tblgen_output_shapes = odsAttrs.get("output_shapes");
  if (!tblgen_output_shapes) return emitError(loc, "'tf.AnonymousIteratorV2' op ""requires attribute 'output_shapes'");
    if (!((((tblgen_output_shapes.isa<::mlir::ArrayAttr>())) && (::llvm::all_of(tblgen_output_shapes.cast<::mlir::ArrayAttr>(), [](::mlir::Attribute attr) { return (attr.isa<mlir::TF::ShapeAttr>()); }))) && ((tblgen_output_shapes.cast<::mlir::ArrayAttr>().size() >= 1)))) return emitError(loc, "'tf.AnonymousIteratorV2' op ""attribute 'output_shapes' failed to satisfy constraint: tensorflow shape attribute array with at least 1 elements");
  }
  return ::mlir::success();
}

void AnonymousIteratorV2Op::getAsmResultNames(::mlir::OpAsmSetValueNameFn setNameFn) {
  auto resultGroup0 = getODSResults(0);
  if (!llvm::empty(resultGroup0))
    setNameFn(*resultGroup0.begin(), "handle");
  auto resultGroup1 = getODSResults(1);
  if (!llvm::empty(resultGroup1))
    setNameFn(*resultGroup1.begin(), "deleter");
}

::llvm::StringRef AnonymousIteratorV2Op::getOperationName() {
  return "tf.AnonymousIteratorV2";
}

std::pair<unsigned, unsigned> AnonymousIteratorV2Op::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range AnonymousIteratorV2Op::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

std::pair<unsigned, unsigned> AnonymousIteratorV2Op::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range AnonymousIteratorV2Op::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value AnonymousIteratorV2Op::handle() {
  return *getODSResults(0).begin();
}

::mlir::Value AnonymousIteratorV2Op::deleter() {
  return *getODSResults(1).begin();
}

::mlir::ArrayAttr AnonymousIteratorV2Op::output_typesAttr() {
  return this->getAttr("output_types").cast<::mlir::ArrayAttr>();
}

::mlir::ArrayAttr AnonymousIteratorV2Op::output_types() {
  auto attr = output_typesAttr();
  return attr;
}

::mlir::ArrayAttr AnonymousIteratorV2Op::output_shapesAttr() {
  return this->getAttr("output_shapes").cast<::mlir::ArrayAttr>();
}

::mlir::ArrayAttr AnonymousIteratorV2Op::output_shapes() {
  auto attr = output_shapesAttr();
  return attr;
}

void AnonymousIteratorV2Op::output_typesAttr(::mlir::ArrayAttr attr) {
  this->getOperation()->setAttr("output_types", attr);
}

void AnonymousIteratorV2Op::output_shapesAttr(::mlir::ArrayAttr attr) {
  this->getOperation()->setAttr("output_shapes", attr);
}

void AnonymousIteratorV2Op::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type handle, ::mlir::Type deleter, ::mlir::ArrayAttr output_types, ::mlir::ArrayAttr output_shapes) {
  odsState.addAttribute("output_types", output_types);
  odsState.addAttribute("output_shapes", output_shapes);
  odsState.addTypes(handle);
  odsState.addTypes(deleter);
}

void AnonymousIteratorV2Op::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ArrayAttr output_types, ::mlir::ArrayAttr output_shapes) {
  odsState.addAttribute("output_types", output_types);
  odsState.addAttribute("output_shapes", output_shapes);
  assert(resultTypes.size() == 2u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void AnonymousIteratorV2Op::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 0u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 2u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult AnonymousIteratorV2Op::verify() {
  if (failed(AnonymousIteratorV2OpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::ResourceType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::ResourceRefType>()))))) {
        return emitOpError("result #") << index << " must be tensor of resource values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSResults(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::VariantType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::VariantRefType>()))))) {
        return emitOpError("result #") << index << " must be tensor of variant values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void AnonymousIteratorV2Op::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
  for (::mlir::Value value : getODSResults(0))
    effects.emplace_back(MemoryEffects::Allocate::get(), value, ::mlir::TF::ResourceEffects::DatasetIterator::get());
}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::AnonymousMemoryCacheOp definitions
//===----------------------------------------------------------------------===//

AnonymousMemoryCacheOpAdaptor::AnonymousMemoryCacheOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

AnonymousMemoryCacheOpAdaptor::AnonymousMemoryCacheOpAdaptor(AnonymousMemoryCacheOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> AnonymousMemoryCacheOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange AnonymousMemoryCacheOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::LogicalResult AnonymousMemoryCacheOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

void AnonymousMemoryCacheOp::getAsmResultNames(::mlir::OpAsmSetValueNameFn setNameFn) {
  auto resultGroup0 = getODSResults(0);
  if (!llvm::empty(resultGroup0))
    setNameFn(*resultGroup0.begin(), "handle");
  auto resultGroup1 = getODSResults(1);
  if (!llvm::empty(resultGroup1))
    setNameFn(*resultGroup1.begin(), "deleter");
}

::llvm::StringRef AnonymousMemoryCacheOp::getOperationName() {
  return "tf.AnonymousMemoryCache";
}

std::pair<unsigned, unsigned> AnonymousMemoryCacheOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range AnonymousMemoryCacheOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

std::pair<unsigned, unsigned> AnonymousMemoryCacheOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range AnonymousMemoryCacheOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value AnonymousMemoryCacheOp::handle() {
  return *getODSResults(0).begin();
}

::mlir::Value AnonymousMemoryCacheOp::deleter() {
  return *getODSResults(1).begin();
}

void AnonymousMemoryCacheOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type handle, ::mlir::Type deleter) {
  odsState.addTypes(handle);
  odsState.addTypes(deleter);
}

void AnonymousMemoryCacheOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes) {
  assert(resultTypes.size() == 2u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void AnonymousMemoryCacheOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 0u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 2u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult AnonymousMemoryCacheOp::verify() {
  if (failed(AnonymousMemoryCacheOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::ResourceType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::ResourceRefType>()))))) {
        return emitOpError("result #") << index << " must be tensor of resource values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSResults(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::VariantType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::VariantRefType>()))))) {
        return emitOpError("result #") << index << " must be tensor of variant values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void AnonymousMemoryCacheOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
  for (::mlir::Value value : getODSResults(0))
    effects.emplace_back(MemoryEffects::Allocate::get(), value, ::mlir::TF::ResourceEffects::DatasetMemoryCache::get());
}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::AnonymousMultiDeviceIteratorOp definitions
//===----------------------------------------------------------------------===//

AnonymousMultiDeviceIteratorOpAdaptor::AnonymousMultiDeviceIteratorOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

AnonymousMultiDeviceIteratorOpAdaptor::AnonymousMultiDeviceIteratorOpAdaptor(AnonymousMultiDeviceIteratorOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> AnonymousMultiDeviceIteratorOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange AnonymousMultiDeviceIteratorOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::ArrayAttr AnonymousMultiDeviceIteratorOpAdaptor::devices() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::ArrayAttr attr = odsAttrs.get("devices").cast<::mlir::ArrayAttr>();
  return attr;
}

::mlir::ArrayAttr AnonymousMultiDeviceIteratorOpAdaptor::output_types() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::ArrayAttr attr = odsAttrs.get("output_types").cast<::mlir::ArrayAttr>();
  return attr;
}

::mlir::ArrayAttr AnonymousMultiDeviceIteratorOpAdaptor::output_shapes() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::ArrayAttr attr = odsAttrs.get("output_shapes").cast<::mlir::ArrayAttr>();
  return attr;
}

::mlir::LogicalResult AnonymousMultiDeviceIteratorOpAdaptor::verify(::mlir::Location loc) {
  {
  auto tblgen_devices = odsAttrs.get("devices");
  if (!tblgen_devices) return emitError(loc, "'tf.AnonymousMultiDeviceIterator' op ""requires attribute 'devices'");
    if (!((((tblgen_devices.isa<::mlir::ArrayAttr>())) && (::llvm::all_of(tblgen_devices.cast<::mlir::ArrayAttr>(), [](::mlir::Attribute attr) { return (attr.isa<::mlir::StringAttr>()); }))) && ((tblgen_devices.cast<::mlir::ArrayAttr>().size() >= 1)))) return emitError(loc, "'tf.AnonymousMultiDeviceIterator' op ""attribute 'devices' failed to satisfy constraint: string array attribute with at least 1 elements");
  }
  {
  auto tblgen_output_types = odsAttrs.get("output_types");
  if (!tblgen_output_types) return emitError(loc, "'tf.AnonymousMultiDeviceIterator' op ""requires attribute 'output_types'");
    if (!((((tblgen_output_types.isa<::mlir::ArrayAttr>())) && (::llvm::all_of(tblgen_output_types.cast<::mlir::ArrayAttr>(), [](::mlir::Attribute attr) { return ((attr.isa<::mlir::TypeAttr>())) && ((attr.cast<::mlir::TypeAttr>().getValue().isa<::mlir::Type>())); }))) && ((tblgen_output_types.cast<::mlir::ArrayAttr>().size() >= 1)))) return emitError(loc, "'tf.AnonymousMultiDeviceIterator' op ""attribute 'output_types' failed to satisfy constraint: type array attribute with at least 1 elements");
  }
  {
  auto tblgen_output_shapes = odsAttrs.get("output_shapes");
  if (!tblgen_output_shapes) return emitError(loc, "'tf.AnonymousMultiDeviceIterator' op ""requires attribute 'output_shapes'");
    if (!((((tblgen_output_shapes.isa<::mlir::ArrayAttr>())) && (::llvm::all_of(tblgen_output_shapes.cast<::mlir::ArrayAttr>(), [](::mlir::Attribute attr) { return (attr.isa<mlir::TF::ShapeAttr>()); }))) && ((tblgen_output_shapes.cast<::mlir::ArrayAttr>().size() >= 1)))) return emitError(loc, "'tf.AnonymousMultiDeviceIterator' op ""attribute 'output_shapes' failed to satisfy constraint: tensorflow shape attribute array with at least 1 elements");
  }
  return ::mlir::success();
}

void AnonymousMultiDeviceIteratorOp::getAsmResultNames(::mlir::OpAsmSetValueNameFn setNameFn) {
  auto resultGroup0 = getODSResults(0);
  if (!llvm::empty(resultGroup0))
    setNameFn(*resultGroup0.begin(), "handle");
  auto resultGroup1 = getODSResults(1);
  if (!llvm::empty(resultGroup1))
    setNameFn(*resultGroup1.begin(), "deleter");
}

::llvm::StringRef AnonymousMultiDeviceIteratorOp::getOperationName() {
  return "tf.AnonymousMultiDeviceIterator";
}

std::pair<unsigned, unsigned> AnonymousMultiDeviceIteratorOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range AnonymousMultiDeviceIteratorOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

std::pair<unsigned, unsigned> AnonymousMultiDeviceIteratorOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range AnonymousMultiDeviceIteratorOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value AnonymousMultiDeviceIteratorOp::handle() {
  return *getODSResults(0).begin();
}

::mlir::Value AnonymousMultiDeviceIteratorOp::deleter() {
  return *getODSResults(1).begin();
}

::mlir::ArrayAttr AnonymousMultiDeviceIteratorOp::devicesAttr() {
  return this->getAttr("devices").cast<::mlir::ArrayAttr>();
}

::mlir::ArrayAttr AnonymousMultiDeviceIteratorOp::devices() {
  auto attr = devicesAttr();
  return attr;
}

::mlir::ArrayAttr AnonymousMultiDeviceIteratorOp::output_typesAttr() {
  return this->getAttr("output_types").cast<::mlir::ArrayAttr>();
}

::mlir::ArrayAttr AnonymousMultiDeviceIteratorOp::output_types() {
  auto attr = output_typesAttr();
  return attr;
}

::mlir::ArrayAttr AnonymousMultiDeviceIteratorOp::output_shapesAttr() {
  return this->getAttr("output_shapes").cast<::mlir::ArrayAttr>();
}

::mlir::ArrayAttr AnonymousMultiDeviceIteratorOp::output_shapes() {
  auto attr = output_shapesAttr();
  return attr;
}

void AnonymousMultiDeviceIteratorOp::devicesAttr(::mlir::ArrayAttr attr) {
  this->getOperation()->setAttr("devices", attr);
}

void AnonymousMultiDeviceIteratorOp::output_typesAttr(::mlir::ArrayAttr attr) {
  this->getOperation()->setAttr("output_types", attr);
}

void AnonymousMultiDeviceIteratorOp::output_shapesAttr(::mlir::ArrayAttr attr) {
  this->getOperation()->setAttr("output_shapes", attr);
}

void AnonymousMultiDeviceIteratorOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type handle, ::mlir::Type deleter, ::mlir::ArrayAttr devices, ::mlir::ArrayAttr output_types, ::mlir::ArrayAttr output_shapes) {
  odsState.addAttribute("devices", devices);
  odsState.addAttribute("output_types", output_types);
  odsState.addAttribute("output_shapes", output_shapes);
  odsState.addTypes(handle);
  odsState.addTypes(deleter);
}

void AnonymousMultiDeviceIteratorOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ArrayAttr devices, ::mlir::ArrayAttr output_types, ::mlir::ArrayAttr output_shapes) {
  odsState.addAttribute("devices", devices);
  odsState.addAttribute("output_types", output_types);
  odsState.addAttribute("output_shapes", output_shapes);
  assert(resultTypes.size() == 2u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void AnonymousMultiDeviceIteratorOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 0u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 2u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult AnonymousMultiDeviceIteratorOp::verify() {
  if (failed(AnonymousMultiDeviceIteratorOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::ResourceType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::ResourceRefType>()))))) {
        return emitOpError("result #") << index << " must be tensor of resource values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSResults(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::VariantType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::VariantRefType>()))))) {
        return emitOpError("result #") << index << " must be tensor of variant values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void AnonymousMultiDeviceIteratorOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
  for (::mlir::Value value : getODSResults(0))
    effects.emplace_back(MemoryEffects::Allocate::get(), value, ::mlir::TF::ResourceEffects::DatasetIterator::get());
}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::AnonymousRandomSeedGeneratorOp definitions
//===----------------------------------------------------------------------===//

AnonymousRandomSeedGeneratorOpAdaptor::AnonymousRandomSeedGeneratorOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

AnonymousRandomSeedGeneratorOpAdaptor::AnonymousRandomSeedGeneratorOpAdaptor(AnonymousRandomSeedGeneratorOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> AnonymousRandomSeedGeneratorOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange AnonymousRandomSeedGeneratorOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value AnonymousRandomSeedGeneratorOpAdaptor::seed() {
  return *getODSOperands(0).begin();
}

::mlir::Value AnonymousRandomSeedGeneratorOpAdaptor::seed2() {
  return *getODSOperands(1).begin();
}

::mlir::LogicalResult AnonymousRandomSeedGeneratorOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

void AnonymousRandomSeedGeneratorOp::getAsmResultNames(::mlir::OpAsmSetValueNameFn setNameFn) {
  auto resultGroup0 = getODSResults(0);
  if (!llvm::empty(resultGroup0))
    setNameFn(*resultGroup0.begin(), "handle");
  auto resultGroup1 = getODSResults(1);
  if (!llvm::empty(resultGroup1))
    setNameFn(*resultGroup1.begin(), "deleter");
}

::llvm::StringRef AnonymousRandomSeedGeneratorOp::getOperationName() {
  return "tf.AnonymousRandomSeedGenerator";
}

std::pair<unsigned, unsigned> AnonymousRandomSeedGeneratorOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range AnonymousRandomSeedGeneratorOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value AnonymousRandomSeedGeneratorOp::seed() {
  return *getODSOperands(0).begin();
}

::mlir::Value AnonymousRandomSeedGeneratorOp::seed2() {
  return *getODSOperands(1).begin();
}

::mlir::MutableOperandRange AnonymousRandomSeedGeneratorOp::seedMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange AnonymousRandomSeedGeneratorOp::seed2Mutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> AnonymousRandomSeedGeneratorOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range AnonymousRandomSeedGeneratorOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value AnonymousRandomSeedGeneratorOp::handle() {
  return *getODSResults(0).begin();
}

::mlir::Value AnonymousRandomSeedGeneratorOp::deleter() {
  return *getODSResults(1).begin();
}

void AnonymousRandomSeedGeneratorOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type handle, ::mlir::Type deleter, ::mlir::Value seed, ::mlir::Value seed2) {
  odsState.addOperands(seed);
  odsState.addOperands(seed2);
  odsState.addTypes(handle);
  odsState.addTypes(deleter);
}

void AnonymousRandomSeedGeneratorOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value seed, ::mlir::Value seed2) {
  odsState.addOperands(seed);
  odsState.addOperands(seed2);
  assert(resultTypes.size() == 2u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void AnonymousRandomSeedGeneratorOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 2u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult AnonymousRandomSeedGeneratorOp::verify() {
  if (failed(AnonymousRandomSeedGeneratorOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of 64-bit integer values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of 64-bit integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::ResourceType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::ResourceRefType>()))))) {
        return emitOpError("result #") << index << " must be tensor of resource values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSResults(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::VariantType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::VariantRefType>()))))) {
        return emitOpError("result #") << index << " must be tensor of variant values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void AnonymousRandomSeedGeneratorOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
  for (::mlir::Value value : getODSResults(0))
    effects.emplace_back(MemoryEffects::Allocate::get(), value, ::mlir::TF::ResourceEffects::DatasetSeedGenerator::get());
}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::AnonymousSeedGeneratorOp definitions
//===----------------------------------------------------------------------===//

AnonymousSeedGeneratorOpAdaptor::AnonymousSeedGeneratorOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

AnonymousSeedGeneratorOpAdaptor::AnonymousSeedGeneratorOpAdaptor(AnonymousSeedGeneratorOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> AnonymousSeedGeneratorOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange AnonymousSeedGeneratorOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value AnonymousSeedGeneratorOpAdaptor::seed() {
  return *getODSOperands(0).begin();
}

::mlir::Value AnonymousSeedGeneratorOpAdaptor::seed2() {
  return *getODSOperands(1).begin();
}

::mlir::Value AnonymousSeedGeneratorOpAdaptor::reshuffle() {
  return *getODSOperands(2).begin();
}

::mlir::LogicalResult AnonymousSeedGeneratorOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

void AnonymousSeedGeneratorOp::getAsmResultNames(::mlir::OpAsmSetValueNameFn setNameFn) {
  auto resultGroup0 = getODSResults(0);
  if (!llvm::empty(resultGroup0))
    setNameFn(*resultGroup0.begin(), "handle");
  auto resultGroup1 = getODSResults(1);
  if (!llvm::empty(resultGroup1))
    setNameFn(*resultGroup1.begin(), "deleter");
}

::llvm::StringRef AnonymousSeedGeneratorOp::getOperationName() {
  return "tf.AnonymousSeedGenerator";
}

std::pair<unsigned, unsigned> AnonymousSeedGeneratorOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range AnonymousSeedGeneratorOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value AnonymousSeedGeneratorOp::seed() {
  return *getODSOperands(0).begin();
}

::mlir::Value AnonymousSeedGeneratorOp::seed2() {
  return *getODSOperands(1).begin();
}

::mlir::Value AnonymousSeedGeneratorOp::reshuffle() {
  return *getODSOperands(2).begin();
}

::mlir::MutableOperandRange AnonymousSeedGeneratorOp::seedMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange AnonymousSeedGeneratorOp::seed2Mutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange AnonymousSeedGeneratorOp::reshuffleMutable() {
  auto range = getODSOperandIndexAndLength(2);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> AnonymousSeedGeneratorOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range AnonymousSeedGeneratorOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value AnonymousSeedGeneratorOp::handle() {
  return *getODSResults(0).begin();
}

::mlir::Value AnonymousSeedGeneratorOp::deleter() {
  return *getODSResults(1).begin();
}

void AnonymousSeedGeneratorOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type handle, ::mlir::Type deleter, ::mlir::Value seed, ::mlir::Value seed2, ::mlir::Value reshuffle) {
  odsState.addOperands(seed);
  odsState.addOperands(seed2);
  odsState.addOperands(reshuffle);
  odsState.addTypes(handle);
  odsState.addTypes(deleter);
}

void AnonymousSeedGeneratorOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value seed, ::mlir::Value seed2, ::mlir::Value reshuffle) {
  odsState.addOperands(seed);
  odsState.addOperands(seed2);
  odsState.addOperands(reshuffle);
  assert(resultTypes.size() == 2u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void AnonymousSeedGeneratorOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 3u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 2u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult AnonymousSeedGeneratorOp::verify() {
  if (failed(AnonymousSeedGeneratorOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of 64-bit integer values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of 64-bit integer values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup2 = getODSOperands(2);
    for (::mlir::Value v : valueGroup2) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of bool values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::ResourceType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::ResourceRefType>()))))) {
        return emitOpError("result #") << index << " must be tensor of resource values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSResults(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::VariantType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::VariantRefType>()))))) {
        return emitOpError("result #") << index << " must be tensor of variant values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void AnonymousSeedGeneratorOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
  for (::mlir::Value value : getODSResults(0))
    effects.emplace_back(MemoryEffects::Allocate::get(), value, ::mlir::TF::ResourceEffects::DatasetSeedGenerator::get());
}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::AnyOp definitions
//===----------------------------------------------------------------------===//

AnyOpAdaptor::AnyOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

AnyOpAdaptor::AnyOpAdaptor(AnyOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> AnyOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange AnyOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value AnyOpAdaptor::input() {
  return *getODSOperands(0).begin();
}

::mlir::Value AnyOpAdaptor::reduction_indices() {
  return *getODSOperands(1).begin();
}

::mlir::BoolAttr AnyOpAdaptor::keep_dims() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::BoolAttr attr = odsAttrs.get("keep_dims").dyn_cast_or_null<::mlir::BoolAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getBoolAttr(false);
  return attr;
}

::mlir::LogicalResult AnyOpAdaptor::verify(::mlir::Location loc) {
  {
  auto tblgen_keep_dims = odsAttrs.get("keep_dims");
  if (tblgen_keep_dims) {
    if (!((tblgen_keep_dims.isa<::mlir::BoolAttr>()))) return emitError(loc, "'tf.Any' op ""attribute 'keep_dims' failed to satisfy constraint: bool attribute");
  }
  }
  return ::mlir::success();
}

::llvm::StringRef AnyOp::getOperationName() {
  return "tf.Any";
}

std::pair<unsigned, unsigned> AnyOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range AnyOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value AnyOp::input() {
  return *getODSOperands(0).begin();
}

::mlir::Value AnyOp::reduction_indices() {
  return *getODSOperands(1).begin();
}

::mlir::MutableOperandRange AnyOp::inputMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange AnyOp::reduction_indicesMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> AnyOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range AnyOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value AnyOp::output() {
  return *getODSResults(0).begin();
}

::mlir::BoolAttr AnyOp::keep_dimsAttr() {
  return this->getAttr("keep_dims").dyn_cast_or_null<::mlir::BoolAttr>();
}

bool AnyOp::keep_dims() {
  auto attr = keep_dimsAttr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getBoolAttr(false).getValue();
  return attr.getValue();
}

Type AnyOp::Tidx() {
  return mlir::getElementTypeOrSelf(*getODSOperands(1).begin());
}

bool AnyOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "Tidx") return true;
 return false;
}

::mlir::DictionaryAttr AnyOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("Tidx", ctx),
::mlir::TypeAttr::get(Tidx())}
    }, ctx);
}

void AnyOp::keep_dimsAttr(::mlir::BoolAttr attr) {
  this->getOperation()->setAttr("keep_dims", attr);
}

void AnyOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value input, ::mlir::Value reduction_indices, ::mlir::BoolAttr keep_dims) {
  odsState.addOperands(input);
  odsState.addOperands(reduction_indices);
  odsState.addAttribute("keep_dims", keep_dims);
  odsState.addTypes(output);
}

void AnyOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input, ::mlir::Value reduction_indices, ::mlir::BoolAttr keep_dims) {
  odsState.addOperands(input);
  odsState.addOperands(reduction_indices);
  odsState.addAttribute("keep_dims", keep_dims);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void AnyOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value input, ::mlir::Value reduction_indices, bool keep_dims) {
  odsState.addOperands(input);
  odsState.addOperands(reduction_indices);
  odsState.addAttribute("keep_dims", odsBuilder.getBoolAttr(keep_dims));
  odsState.addTypes(output);
}

void AnyOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input, ::mlir::Value reduction_indices, bool keep_dims) {
  odsState.addOperands(input);
  odsState.addOperands(reduction_indices);
  odsState.addAttribute("keep_dims", odsBuilder.getBoolAttr(keep_dims));
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void AnyOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult AnyOp::verify() {
  if (failed(AnyOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of bool values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of 32/64-bit signed integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))))) {
        return emitOpError("result #") << index << " must be tensor of bool values, but got " << v.getType();
      }
      ++index;
    }
  }
  return Verify(*this);
}

void AnyOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::ApproximateEqualOp definitions
//===----------------------------------------------------------------------===//

ApproximateEqualOpAdaptor::ApproximateEqualOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

ApproximateEqualOpAdaptor::ApproximateEqualOpAdaptor(ApproximateEqualOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> ApproximateEqualOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange ApproximateEqualOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value ApproximateEqualOpAdaptor::x() {
  return *getODSOperands(0).begin();
}

::mlir::Value ApproximateEqualOpAdaptor::y() {
  return *getODSOperands(1).begin();
}

::mlir::FloatAttr ApproximateEqualOpAdaptor::tolerance() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::FloatAttr attr = odsAttrs.get("tolerance").dyn_cast_or_null<::mlir::FloatAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getFloatAttr(::mlir::Builder(odsAttrs.getContext()).getF32Type(), 1e-05f);
  return attr;
}

::mlir::LogicalResult ApproximateEqualOpAdaptor::verify(::mlir::Location loc) {
  {
  auto tblgen_tolerance = odsAttrs.get("tolerance");
  if (tblgen_tolerance) {
    if (!(((tblgen_tolerance.isa<::mlir::FloatAttr>())) && ((tblgen_tolerance.cast<::mlir::FloatAttr>().getType().isF32())))) return emitError(loc, "'tf.ApproximateEqual' op ""attribute 'tolerance' failed to satisfy constraint: 32-bit float attribute");
  }
  }
  return ::mlir::success();
}

::llvm::StringRef ApproximateEqualOp::getOperationName() {
  return "tf.ApproximateEqual";
}

std::pair<unsigned, unsigned> ApproximateEqualOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range ApproximateEqualOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value ApproximateEqualOp::x() {
  return *getODSOperands(0).begin();
}

::mlir::Value ApproximateEqualOp::y() {
  return *getODSOperands(1).begin();
}

::mlir::MutableOperandRange ApproximateEqualOp::xMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange ApproximateEqualOp::yMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> ApproximateEqualOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range ApproximateEqualOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value ApproximateEqualOp::z() {
  return *getODSResults(0).begin();
}

::mlir::FloatAttr ApproximateEqualOp::toleranceAttr() {
  return this->getAttr("tolerance").dyn_cast_or_null<::mlir::FloatAttr>();
}

::llvm::APFloat ApproximateEqualOp::tolerance() {
  auto attr = toleranceAttr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getFloatAttr(::mlir::Builder(this->getContext()).getF32Type(), 1e-05f).getValue();
  return attr.getValue();
}

Type ApproximateEqualOp::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

bool ApproximateEqualOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "T") return true;
 return false;
}

::mlir::DictionaryAttr ApproximateEqualOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())}
    }, ctx);
}

void ApproximateEqualOp::toleranceAttr(::mlir::FloatAttr attr) {
  this->getOperation()->setAttr("tolerance", attr);
}

void ApproximateEqualOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type z, ::mlir::Value x, ::mlir::Value y, ::mlir::FloatAttr tolerance) {
  odsState.addOperands(x);
  odsState.addOperands(y);
  odsState.addAttribute("tolerance", tolerance);
  odsState.addTypes(z);
}

void ApproximateEqualOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value x, ::mlir::Value y, ::mlir::FloatAttr tolerance) {
  odsState.addOperands(x);
  odsState.addOperands(y);
  odsState.addAttribute("tolerance", tolerance);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void ApproximateEqualOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type z, ::mlir::Value x, ::mlir::Value y, ::llvm::APFloat tolerance) {
  odsState.addOperands(x);
  odsState.addOperands(y);
  odsState.addAttribute("tolerance", odsBuilder.getFloatAttr(odsBuilder.getF32Type(), tolerance));
  odsState.addTypes(z);
}

void ApproximateEqualOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value x, ::mlir::Value y, ::llvm::APFloat tolerance) {
  odsState.addOperands(x);
  odsState.addOperands(y);
  odsState.addAttribute("tolerance", odsBuilder.getFloatAttr(odsBuilder.getF32Type(), tolerance));
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void ApproximateEqualOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult ApproximateEqualOp::verify() {
  if (failed(ApproximateEqualOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of bfloat16 or 128-bit complex or 64-bit complex or 16-bit float or 32-bit float or 64-bit float or 16-bit integer or 32-bit integer or 64-bit integer or 8-bit integer or 32-bit quantized integer or 8-bit quantized integer or 8-bit quantized unsigned integer or 16-bit unsigned integer or 32-bit unsigned integer or 64-bit unsigned integer or 8-bit unsigned integer values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of bfloat16 or 128-bit complex or 64-bit complex or 16-bit float or 32-bit float or 64-bit float or 16-bit integer or 32-bit integer or 64-bit integer or 8-bit integer or 32-bit quantized integer or 8-bit quantized integer or 8-bit quantized unsigned integer or 16-bit unsigned integer or 32-bit unsigned integer or 64-bit unsigned integer or 8-bit unsigned integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))))) {
        return emitOpError("result #") << index << " must be tensor of bool values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void ApproximateEqualOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::ArgMaxOp definitions
//===----------------------------------------------------------------------===//

ArgMaxOpAdaptor::ArgMaxOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

ArgMaxOpAdaptor::ArgMaxOpAdaptor(ArgMaxOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> ArgMaxOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange ArgMaxOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value ArgMaxOpAdaptor::input() {
  return *getODSOperands(0).begin();
}

::mlir::Value ArgMaxOpAdaptor::dimension() {
  return *getODSOperands(1).begin();
}

::mlir::LogicalResult ArgMaxOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

::llvm::StringRef ArgMaxOp::getOperationName() {
  return "tf.ArgMax";
}

std::pair<unsigned, unsigned> ArgMaxOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range ArgMaxOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value ArgMaxOp::input() {
  return *getODSOperands(0).begin();
}

::mlir::Value ArgMaxOp::dimension() {
  return *getODSOperands(1).begin();
}

::mlir::MutableOperandRange ArgMaxOp::inputMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange ArgMaxOp::dimensionMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> ArgMaxOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range ArgMaxOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value ArgMaxOp::output() {
  return *getODSResults(0).begin();
}

Type ArgMaxOp::output_type() {
  return mlir::getElementTypeOrSelf(*getODSResults(0).begin());
}

Type ArgMaxOp::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

Type ArgMaxOp::Tidx() {
  return mlir::getElementTypeOrSelf(*getODSOperands(1).begin());
}

bool ArgMaxOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "output_type") return true;
  if (name == "T") return true;
  if (name == "Tidx") return true;
 return false;
}

::mlir::DictionaryAttr ArgMaxOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("output_type", ctx),
::mlir::TypeAttr::get(output_type())},
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())},
    {::mlir::Identifier::get("Tidx", ctx),
::mlir::TypeAttr::get(Tidx())}
    }, ctx);
}

void ArgMaxOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value input, ::mlir::Value dimension) {
  odsState.addOperands(input);
  odsState.addOperands(dimension);
  odsState.addTypes(output);
}

void ArgMaxOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input, ::mlir::Value dimension) {
  odsState.addOperands(input);
  odsState.addOperands(dimension);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void ArgMaxOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult ArgMaxOp::verify() {
  if (failed(ArgMaxOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of bfloat16 or bool or 128-bit complex or 64-bit complex or 16-bit float or 32-bit float or 64-bit float or 16-bit integer or 32-bit integer or 64-bit integer or 8-bit integer or 32-bit quantized integer or 8-bit quantized integer or 8-bit quantized unsigned integer or 16-bit unsigned integer or 32-bit unsigned integer or 64-bit unsigned integer or 8-bit unsigned integer values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of 32/64-bit signed integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))))) {
        return emitOpError("result #") << index << " must be tensor of 32/64-bit signed integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void ArgMaxOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::ArgMinOp definitions
//===----------------------------------------------------------------------===//

ArgMinOpAdaptor::ArgMinOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

ArgMinOpAdaptor::ArgMinOpAdaptor(ArgMinOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> ArgMinOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange ArgMinOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value ArgMinOpAdaptor::input() {
  return *getODSOperands(0).begin();
}

::mlir::Value ArgMinOpAdaptor::dimension() {
  return *getODSOperands(1).begin();
}

::mlir::LogicalResult ArgMinOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

::llvm::StringRef ArgMinOp::getOperationName() {
  return "tf.ArgMin";
}

std::pair<unsigned, unsigned> ArgMinOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range ArgMinOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value ArgMinOp::input() {
  return *getODSOperands(0).begin();
}

::mlir::Value ArgMinOp::dimension() {
  return *getODSOperands(1).begin();
}

::mlir::MutableOperandRange ArgMinOp::inputMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange ArgMinOp::dimensionMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> ArgMinOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range ArgMinOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value ArgMinOp::output() {
  return *getODSResults(0).begin();
}

Type ArgMinOp::output_type() {
  return mlir::getElementTypeOrSelf(*getODSResults(0).begin());
}

Type ArgMinOp::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

Type ArgMinOp::Tidx() {
  return mlir::getElementTypeOrSelf(*getODSOperands(1).begin());
}

bool ArgMinOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "output_type") return true;
  if (name == "T") return true;
  if (name == "Tidx") return true;
 return false;
}

::mlir::DictionaryAttr ArgMinOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("output_type", ctx),
::mlir::TypeAttr::get(output_type())},
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())},
    {::mlir::Identifier::get("Tidx", ctx),
::mlir::TypeAttr::get(Tidx())}
    }, ctx);
}

void ArgMinOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value input, ::mlir::Value dimension) {
  odsState.addOperands(input);
  odsState.addOperands(dimension);
  odsState.addTypes(output);
}

void ArgMinOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input, ::mlir::Value dimension) {
  odsState.addOperands(input);
  odsState.addOperands(dimension);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void ArgMinOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult ArgMinOp::verify() {
  if (failed(ArgMinOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of bfloat16 or bool or 128-bit complex or 64-bit complex or 16-bit float or 32-bit float or 64-bit float or 16-bit integer or 32-bit integer or 64-bit integer or 8-bit integer or 32-bit quantized integer or 8-bit quantized integer or 8-bit quantized unsigned integer or 16-bit unsigned integer or 32-bit unsigned integer or 64-bit unsigned integer or 8-bit unsigned integer values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of 32/64-bit signed integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))))) {
        return emitOpError("result #") << index << " must be tensor of 32/64-bit signed integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void ArgMinOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::AsStringOp definitions
//===----------------------------------------------------------------------===//

AsStringOpAdaptor::AsStringOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

AsStringOpAdaptor::AsStringOpAdaptor(AsStringOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> AsStringOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange AsStringOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value AsStringOpAdaptor::input() {
  return *getODSOperands(0).begin();
}

::mlir::IntegerAttr AsStringOpAdaptor::precision() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::IntegerAttr attr = odsAttrs.get("precision").dyn_cast_or_null<::mlir::IntegerAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getIntegerAttr(::mlir::Builder(odsAttrs.getContext()).getIntegerType(64), -1);
  return attr;
}

::mlir::BoolAttr AsStringOpAdaptor::scientific() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::BoolAttr attr = odsAttrs.get("scientific").dyn_cast_or_null<::mlir::BoolAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getBoolAttr(false);
  return attr;
}

::mlir::BoolAttr AsStringOpAdaptor::shortest() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::BoolAttr attr = odsAttrs.get("shortest").dyn_cast_or_null<::mlir::BoolAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getBoolAttr(false);
  return attr;
}

::mlir::IntegerAttr AsStringOpAdaptor::width() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::IntegerAttr attr = odsAttrs.get("width").dyn_cast_or_null<::mlir::IntegerAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getIntegerAttr(::mlir::Builder(odsAttrs.getContext()).getIntegerType(64), -1);
  return attr;
}

::mlir::StringAttr AsStringOpAdaptor::fill() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::StringAttr attr = odsAttrs.get("fill").cast<::mlir::StringAttr>();
  return attr;
}

::mlir::LogicalResult AsStringOpAdaptor::verify(::mlir::Location loc) {
  {
  auto tblgen_precision = odsAttrs.get("precision");
  if (tblgen_precision) {
    if (!(((tblgen_precision.isa<::mlir::IntegerAttr>())) && ((tblgen_precision.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(64))))) return emitError(loc, "'tf.AsString' op ""attribute 'precision' failed to satisfy constraint: 64-bit signless integer attribute");
  }
  }
  {
  auto tblgen_scientific = odsAttrs.get("scientific");
  if (tblgen_scientific) {
    if (!((tblgen_scientific.isa<::mlir::BoolAttr>()))) return emitError(loc, "'tf.AsString' op ""attribute 'scientific' failed to satisfy constraint: bool attribute");
  }
  }
  {
  auto tblgen_shortest = odsAttrs.get("shortest");
  if (tblgen_shortest) {
    if (!((tblgen_shortest.isa<::mlir::BoolAttr>()))) return emitError(loc, "'tf.AsString' op ""attribute 'shortest' failed to satisfy constraint: bool attribute");
  }
  }
  {
  auto tblgen_width = odsAttrs.get("width");
  if (tblgen_width) {
    if (!(((tblgen_width.isa<::mlir::IntegerAttr>())) && ((tblgen_width.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(64))))) return emitError(loc, "'tf.AsString' op ""attribute 'width' failed to satisfy constraint: 64-bit signless integer attribute");
  }
  }
  {
  auto tblgen_fill = odsAttrs.get("fill");
  if (!tblgen_fill) return emitError(loc, "'tf.AsString' op ""requires attribute 'fill'");
    if (!((tblgen_fill.isa<::mlir::StringAttr>()))) return emitError(loc, "'tf.AsString' op ""attribute 'fill' failed to satisfy constraint: string attribute");
  }
  return ::mlir::success();
}

::llvm::StringRef AsStringOp::getOperationName() {
  return "tf.AsString";
}

std::pair<unsigned, unsigned> AsStringOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range AsStringOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value AsStringOp::input() {
  return *getODSOperands(0).begin();
}

::mlir::MutableOperandRange AsStringOp::inputMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> AsStringOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range AsStringOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value AsStringOp::output() {
  return *getODSResults(0).begin();
}

::mlir::IntegerAttr AsStringOp::precisionAttr() {
  return this->getAttr("precision").dyn_cast_or_null<::mlir::IntegerAttr>();
}

uint64_t AsStringOp::precision() {
  auto attr = precisionAttr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getIntegerAttr(::mlir::Builder(this->getContext()).getIntegerType(64), -1).getValue().getZExtValue();
  return attr.getValue().getZExtValue();
}

::mlir::BoolAttr AsStringOp::scientificAttr() {
  return this->getAttr("scientific").dyn_cast_or_null<::mlir::BoolAttr>();
}

bool AsStringOp::scientific() {
  auto attr = scientificAttr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getBoolAttr(false).getValue();
  return attr.getValue();
}

::mlir::BoolAttr AsStringOp::shortestAttr() {
  return this->getAttr("shortest").dyn_cast_or_null<::mlir::BoolAttr>();
}

bool AsStringOp::shortest() {
  auto attr = shortestAttr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getBoolAttr(false).getValue();
  return attr.getValue();
}

::mlir::IntegerAttr AsStringOp::widthAttr() {
  return this->getAttr("width").dyn_cast_or_null<::mlir::IntegerAttr>();
}

uint64_t AsStringOp::width() {
  auto attr = widthAttr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getIntegerAttr(::mlir::Builder(this->getContext()).getIntegerType(64), -1).getValue().getZExtValue();
  return attr.getValue().getZExtValue();
}

::mlir::StringAttr AsStringOp::fillAttr() {
  return this->getAttr("fill").cast<::mlir::StringAttr>();
}

::llvm::StringRef AsStringOp::fill() {
  auto attr = fillAttr();
  return attr.getValue();
}

Type AsStringOp::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

bool AsStringOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "T") return true;
 return false;
}

::mlir::DictionaryAttr AsStringOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())}
    }, ctx);
}

void AsStringOp::precisionAttr(::mlir::IntegerAttr attr) {
  this->getOperation()->setAttr("precision", attr);
}

void AsStringOp::scientificAttr(::mlir::BoolAttr attr) {
  this->getOperation()->setAttr("scientific", attr);
}

void AsStringOp::shortestAttr(::mlir::BoolAttr attr) {
  this->getOperation()->setAttr("shortest", attr);
}

void AsStringOp::widthAttr(::mlir::IntegerAttr attr) {
  this->getOperation()->setAttr("width", attr);
}

void AsStringOp::fillAttr(::mlir::StringAttr attr) {
  this->getOperation()->setAttr("fill", attr);
}

void AsStringOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value input, ::mlir::IntegerAttr precision, ::mlir::BoolAttr scientific, ::mlir::BoolAttr shortest, ::mlir::IntegerAttr width, ::mlir::StringAttr fill) {
  odsState.addOperands(input);
  odsState.addAttribute("precision", precision);
  odsState.addAttribute("scientific", scientific);
  odsState.addAttribute("shortest", shortest);
  odsState.addAttribute("width", width);
  odsState.addAttribute("fill", fill);
  odsState.addTypes(output);
}

void AsStringOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input, ::mlir::IntegerAttr precision, ::mlir::BoolAttr scientific, ::mlir::BoolAttr shortest, ::mlir::IntegerAttr width, ::mlir::StringAttr fill) {
  odsState.addOperands(input);
  odsState.addAttribute("precision", precision);
  odsState.addAttribute("scientific", scientific);
  odsState.addAttribute("shortest", shortest);
  odsState.addAttribute("width", width);
  odsState.addAttribute("fill", fill);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void AsStringOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value input, uint64_t precision, bool scientific, bool shortest, uint64_t width, ::llvm::StringRef fill) {
  odsState.addOperands(input);
  odsState.addAttribute("precision", odsBuilder.getIntegerAttr(odsBuilder.getIntegerType(64), precision));
  odsState.addAttribute("scientific", odsBuilder.getBoolAttr(scientific));
  odsState.addAttribute("shortest", odsBuilder.getBoolAttr(shortest));
  odsState.addAttribute("width", odsBuilder.getIntegerAttr(odsBuilder.getIntegerType(64), width));
  odsState.addAttribute("fill", odsBuilder.getStringAttr(fill));
  odsState.addTypes(output);
}

void AsStringOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input, uint64_t precision, bool scientific, bool shortest, uint64_t width, ::llvm::StringRef fill) {
  odsState.addOperands(input);
  odsState.addAttribute("precision", odsBuilder.getIntegerAttr(odsBuilder.getIntegerType(64), precision));
  odsState.addAttribute("scientific", odsBuilder.getBoolAttr(scientific));
  odsState.addAttribute("shortest", odsBuilder.getBoolAttr(shortest));
  odsState.addAttribute("width", odsBuilder.getIntegerAttr(odsBuilder.getIntegerType(64), width));
  odsState.addAttribute("fill", odsBuilder.getStringAttr(fill));
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void AsStringOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult AsStringOp::verify() {
  if (failed(AsStringOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of bool or 128-bit complex or 64-bit complex or 32-bit float or 64-bit float or 16-bit integer or 32-bit integer or 64-bit integer or 8-bit integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::StringType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::StringRefType>()))))) {
        return emitOpError("result #") << index << " must be tensor of string values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void AsStringOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::AsinOp definitions
//===----------------------------------------------------------------------===//

AsinOpAdaptor::AsinOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

AsinOpAdaptor::AsinOpAdaptor(AsinOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> AsinOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange AsinOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value AsinOpAdaptor::x() {
  return *getODSOperands(0).begin();
}

::mlir::LogicalResult AsinOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

::llvm::StringRef AsinOp::getOperationName() {
  return "tf.Asin";
}

std::pair<unsigned, unsigned> AsinOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range AsinOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value AsinOp::x() {
  return *getODSOperands(0).begin();
}

::mlir::MutableOperandRange AsinOp::xMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> AsinOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range AsinOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value AsinOp::y() {
  return *getODSResults(0).begin();
}

Type AsinOp::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

bool AsinOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "T") return true;
 return false;
}

::mlir::DictionaryAttr AsinOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())}
    }, ctx);
}

void AsinOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type y, ::mlir::Value x) {
  odsState.addOperands(x);
  odsState.addTypes(y);
}

void AsinOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value x) {
  odsState.addOperands(x);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void AsinOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

void AsinOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value x) {
  odsState.addOperands(x);
  odsState.addTypes({x.getType()});

}

void AsinOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  odsState.addTypes({operands[0].getType()});

}

::mlir::LogicalResult AsinOp::verify() {
  if (failed(AsinOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of bfloat16 or 128-bit complex or 64-bit complex or 16-bit float or 32-bit float or 64-bit float or 16-bit integer or 32-bit integer or 64-bit integer or 8-bit integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>())))))) {
        return emitOpError("result #") << index << " must be tensor of bfloat16 or 128-bit complex or 64-bit complex or 16-bit float or 32-bit float or 64-bit float or 16-bit integer or 32-bit integer or 64-bit integer or 8-bit integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void AsinOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::AsinhOp definitions
//===----------------------------------------------------------------------===//

AsinhOpAdaptor::AsinhOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

AsinhOpAdaptor::AsinhOpAdaptor(AsinhOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> AsinhOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange AsinhOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value AsinhOpAdaptor::x() {
  return *getODSOperands(0).begin();
}

::mlir::LogicalResult AsinhOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

::llvm::StringRef AsinhOp::getOperationName() {
  return "tf.Asinh";
}

std::pair<unsigned, unsigned> AsinhOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range AsinhOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value AsinhOp::x() {
  return *getODSOperands(0).begin();
}

::mlir::MutableOperandRange AsinhOp::xMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> AsinhOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range AsinhOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value AsinhOp::y() {
  return *getODSResults(0).begin();
}

Type AsinhOp::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

bool AsinhOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "T") return true;
 return false;
}

::mlir::DictionaryAttr AsinhOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())}
    }, ctx);
}

void AsinhOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type y, ::mlir::Value x) {
  odsState.addOperands(x);
  odsState.addTypes(y);
}

void AsinhOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value x) {
  odsState.addOperands(x);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void AsinhOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

void AsinhOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value x) {
  odsState.addOperands(x);
  odsState.addTypes({x.getType()});

}

void AsinhOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  odsState.addTypes({operands[0].getType()});

}

::mlir::LogicalResult AsinhOp::verify() {
  if (failed(AsinhOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))))))) {
        return emitOpError("operand #") << index << " must be tensor of floating-point or complex values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))))))) {
        return emitOpError("result #") << index << " must be tensor of floating-point or complex values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void AsinhOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::AssertOp definitions
//===----------------------------------------------------------------------===//

AssertOpAdaptor::AssertOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

AssertOpAdaptor::AssertOpAdaptor(AssertOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> AssertOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  bool isVariadic[] = {false, true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (odsOperands.size() - 1) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::mlir::ValueRange AssertOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value AssertOpAdaptor::condition() {
  return *getODSOperands(0).begin();
}

::mlir::ValueRange AssertOpAdaptor::data() {
  return getODSOperands(1);
}

::mlir::IntegerAttr AssertOpAdaptor::summarize() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::IntegerAttr attr = odsAttrs.get("summarize").dyn_cast_or_null<::mlir::IntegerAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getIntegerAttr(::mlir::Builder(odsAttrs.getContext()).getIntegerType(64), 3);
  return attr;
}

::mlir::LogicalResult AssertOpAdaptor::verify(::mlir::Location loc) {
  {
  auto tblgen_summarize = odsAttrs.get("summarize");
  if (tblgen_summarize) {
    if (!(((tblgen_summarize.isa<::mlir::IntegerAttr>())) && ((tblgen_summarize.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(64))))) return emitError(loc, "'tf.Assert' op ""attribute 'summarize' failed to satisfy constraint: 64-bit signless integer attribute");
  }
  }
  return ::mlir::success();
}

::llvm::StringRef AssertOp::getOperationName() {
  return "tf.Assert";
}

std::pair<unsigned, unsigned> AssertOp::getODSOperandIndexAndLength(unsigned index) {
  bool isVariadic[] = {false, true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (getOperation()->getNumOperands() - 1) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::mlir::Operation::operand_range AssertOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value AssertOp::condition() {
  return *getODSOperands(0).begin();
}

::mlir::Operation::operand_range AssertOp::data() {
  return getODSOperands(1);
}

::mlir::MutableOperandRange AssertOp::conditionMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange AssertOp::dataMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> AssertOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range AssertOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::IntegerAttr AssertOp::summarizeAttr() {
  return this->getAttr("summarize").dyn_cast_or_null<::mlir::IntegerAttr>();
}

uint64_t AssertOp::summarize() {
  auto attr = summarizeAttr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getIntegerAttr(::mlir::Builder(this->getContext()).getIntegerType(64), 3).getValue().getZExtValue();
  return attr.getValue().getZExtValue();
}

mlir::OperandElementTypeRange AssertOp::T() {
  auto values = getODSOperands(1);
return {mlir::OperandElementTypeIterator(values.begin()), mlir::OperandElementTypeIterator(values.end())};
}

bool AssertOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "T") return true;
 return false;
}

::mlir::DictionaryAttr AssertOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("T", ctx),
ArrayAttr::get(
    [&]() {
      llvm::SmallVector<Attribute, 4> ret;
      for (auto t : T())
        ret.push_back(TypeAttr::get(t));
      return ret;
    }(), ctx)}
    }, ctx);
}

void AssertOp::summarizeAttr(::mlir::IntegerAttr attr) {
  this->getOperation()->setAttr("summarize", attr);
}

void AssertOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value condition, ::mlir::ValueRange data, ::mlir::IntegerAttr summarize) {
  odsState.addOperands(condition);
  odsState.addOperands(data);
  odsState.addAttribute("summarize", summarize);
}

void AssertOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value condition, ::mlir::ValueRange data, ::mlir::IntegerAttr summarize) {
  odsState.addOperands(condition);
  odsState.addOperands(data);
  odsState.addAttribute("summarize", summarize);
  assert(resultTypes.size() == 0u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void AssertOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value condition, ::mlir::ValueRange data, uint64_t summarize) {
  odsState.addOperands(condition);
  odsState.addOperands(data);
  odsState.addAttribute("summarize", odsBuilder.getIntegerAttr(odsBuilder.getIntegerType(64), summarize));
}

void AssertOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value condition, ::mlir::ValueRange data, uint64_t summarize) {
  odsState.addOperands(condition);
  odsState.addOperands(data);
  odsState.addAttribute("summarize", odsBuilder.getIntegerAttr(odsBuilder.getIntegerType(64), summarize));
  assert(resultTypes.size() == 0u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void AssertOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() >= 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 0u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult AssertOp::verify() {
  if (failed(AssertOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of bool values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>())))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::TensorFlowType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of tf.dtype values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
  }
  return ::mlir::success();
}



} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::AssignAddVariableOp definitions
//===----------------------------------------------------------------------===//

AssignAddVariableOpAdaptor::AssignAddVariableOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

AssignAddVariableOpAdaptor::AssignAddVariableOpAdaptor(AssignAddVariableOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> AssignAddVariableOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange AssignAddVariableOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value AssignAddVariableOpAdaptor::resource() {
  return *getODSOperands(0).begin();
}

::mlir::Value AssignAddVariableOpAdaptor::value() {
  return *getODSOperands(1).begin();
}

::mlir::LogicalResult AssignAddVariableOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

::llvm::StringRef AssignAddVariableOp::getOperationName() {
  return "tf.AssignAddVariableOp";
}

std::pair<unsigned, unsigned> AssignAddVariableOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range AssignAddVariableOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value AssignAddVariableOp::resource() {
  return *getODSOperands(0).begin();
}

::mlir::Value AssignAddVariableOp::value() {
  return *getODSOperands(1).begin();
}

::mlir::MutableOperandRange AssignAddVariableOp::resourceMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange AssignAddVariableOp::valueMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> AssignAddVariableOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range AssignAddVariableOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

Type AssignAddVariableOp::dtype() {
  return mlir::getElementTypeOrSelf(*getODSOperands(1).begin());
}

bool AssignAddVariableOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "dtype") return true;
 return false;
}

::mlir::DictionaryAttr AssignAddVariableOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("dtype", ctx),
::mlir::TypeAttr::get(dtype())}
    }, ctx);
}

void AssignAddVariableOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value resource, ::mlir::Value value) {
  odsState.addOperands(resource);
  odsState.addOperands(value);
}

void AssignAddVariableOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value resource, ::mlir::Value value) {
  odsState.addOperands(resource);
  odsState.addOperands(value);
  assert(resultTypes.size() == 0u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void AssignAddVariableOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 0u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult AssignAddVariableOp::verify() {
  if (failed(AssignAddVariableOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::ResourceType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::ResourceRefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of resource values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>())))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::TensorFlowType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of tf.dtype values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
  }
  return ::mlir::success();
}

void AssignAddVariableOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
  for (::mlir::Value value : getODSOperands(0))
    effects.emplace_back(MemoryEffects::Read::get(), value, ::mlir::TF::ResourceEffects::Variable::get());
  for (::mlir::Value value : getODSOperands(0))
    effects.emplace_back(MemoryEffects::Write::get(), value, ::mlir::TF::ResourceEffects::Variable::get());
}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::AssignSubVariableOp definitions
//===----------------------------------------------------------------------===//

AssignSubVariableOpAdaptor::AssignSubVariableOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

AssignSubVariableOpAdaptor::AssignSubVariableOpAdaptor(AssignSubVariableOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> AssignSubVariableOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange AssignSubVariableOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value AssignSubVariableOpAdaptor::resource() {
  return *getODSOperands(0).begin();
}

::mlir::Value AssignSubVariableOpAdaptor::value() {
  return *getODSOperands(1).begin();
}

::mlir::LogicalResult AssignSubVariableOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

::llvm::StringRef AssignSubVariableOp::getOperationName() {
  return "tf.AssignSubVariableOp";
}

std::pair<unsigned, unsigned> AssignSubVariableOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range AssignSubVariableOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value AssignSubVariableOp::resource() {
  return *getODSOperands(0).begin();
}

::mlir::Value AssignSubVariableOp::value() {
  return *getODSOperands(1).begin();
}

::mlir::MutableOperandRange AssignSubVariableOp::resourceMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange AssignSubVariableOp::valueMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> AssignSubVariableOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range AssignSubVariableOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

Type AssignSubVariableOp::dtype() {
  return mlir::getElementTypeOrSelf(*getODSOperands(1).begin());
}

bool AssignSubVariableOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "dtype") return true;
 return false;
}

::mlir::DictionaryAttr AssignSubVariableOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("dtype", ctx),
::mlir::TypeAttr::get(dtype())}
    }, ctx);
}

void AssignSubVariableOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value resource, ::mlir::Value value) {
  odsState.addOperands(resource);
  odsState.addOperands(value);
}

void AssignSubVariableOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value resource, ::mlir::Value value) {
  odsState.addOperands(resource);
  odsState.addOperands(value);
  assert(resultTypes.size() == 0u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void AssignSubVariableOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 0u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult AssignSubVariableOp::verify() {
  if (failed(AssignSubVariableOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::ResourceType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::ResourceRefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of resource values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>())))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::TensorFlowType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of tf.dtype values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
  }
  return ::mlir::success();
}

void AssignSubVariableOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
  for (::mlir::Value value : getODSOperands(0))
    effects.emplace_back(MemoryEffects::Read::get(), value, ::mlir::TF::ResourceEffects::Variable::get());
  for (::mlir::Value value : getODSOperands(0))
    effects.emplace_back(MemoryEffects::Write::get(), value, ::mlir::TF::ResourceEffects::Variable::get());
}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::AssignVariableOp definitions
//===----------------------------------------------------------------------===//

AssignVariableOpAdaptor::AssignVariableOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

AssignVariableOpAdaptor::AssignVariableOpAdaptor(AssignVariableOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> AssignVariableOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange AssignVariableOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value AssignVariableOpAdaptor::resource() {
  return *getODSOperands(0).begin();
}

::mlir::Value AssignVariableOpAdaptor::value() {
  return *getODSOperands(1).begin();
}

::mlir::LogicalResult AssignVariableOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

::llvm::StringRef AssignVariableOp::getOperationName() {
  return "tf.AssignVariableOp";
}

std::pair<unsigned, unsigned> AssignVariableOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range AssignVariableOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value AssignVariableOp::resource() {
  return *getODSOperands(0).begin();
}

::mlir::Value AssignVariableOp::value() {
  return *getODSOperands(1).begin();
}

::mlir::MutableOperandRange AssignVariableOp::resourceMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange AssignVariableOp::valueMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> AssignVariableOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range AssignVariableOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

Type AssignVariableOp::dtype() {
  return mlir::getElementTypeOrSelf(*getODSOperands(1).begin());
}

bool AssignVariableOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "dtype") return true;
 return false;
}

::mlir::DictionaryAttr AssignVariableOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("dtype", ctx),
::mlir::TypeAttr::get(dtype())}
    }, ctx);
}

void AssignVariableOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value resource, ::mlir::Value value) {
  odsState.addOperands(resource);
  odsState.addOperands(value);
}

void AssignVariableOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value resource, ::mlir::Value value) {
  odsState.addOperands(resource);
  odsState.addOperands(value);
  assert(resultTypes.size() == 0u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void AssignVariableOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 0u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult AssignVariableOp::verify() {
  if (failed(AssignVariableOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::ResourceType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::ResourceRefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of resource values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>())))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::TensorFlowType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of tf.dtype values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
  }
  return ::mlir::success();
}

void AssignVariableOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
  for (::mlir::Value value : getODSOperands(0))
    effects.emplace_back(MemoryEffects::Write::get(), value, ::mlir::TF::ResourceEffects::Variable::get());
}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::Atan2Op definitions
//===----------------------------------------------------------------------===//

Atan2OpAdaptor::Atan2OpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

Atan2OpAdaptor::Atan2OpAdaptor(Atan2Op&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> Atan2OpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange Atan2OpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value Atan2OpAdaptor::y() {
  return *getODSOperands(0).begin();
}

::mlir::Value Atan2OpAdaptor::x() {
  return *getODSOperands(1).begin();
}

::mlir::LogicalResult Atan2OpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

::llvm::StringRef Atan2Op::getOperationName() {
  return "tf.Atan2";
}

std::pair<unsigned, unsigned> Atan2Op::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range Atan2Op::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value Atan2Op::y() {
  return *getODSOperands(0).begin();
}

::mlir::Value Atan2Op::x() {
  return *getODSOperands(1).begin();
}

::mlir::MutableOperandRange Atan2Op::yMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange Atan2Op::xMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> Atan2Op::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range Atan2Op::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value Atan2Op::z() {
  return *getODSResults(0).begin();
}

Type Atan2Op::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

bool Atan2Op::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "T") return true;
 return false;
}

::mlir::DictionaryAttr Atan2Op::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())}
    }, ctx);
}

void Atan2Op::build(OpBuilder &builder, OperationState &result, Value  x, Value  y) {
  auto resultType =
      OpTrait::util::getBroadcastedType(x.getType(), y.getType());
  if (!resultType)
    mlir::emitError(result.location, "non-broadcastable operands");
  return build(builder, result, resultType, x, y);
}

void Atan2Op::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type z, ::mlir::Value y, ::mlir::Value x) {
  odsState.addOperands(y);
  odsState.addOperands(x);
  odsState.addTypes(z);
}

void Atan2Op::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value y, ::mlir::Value x) {
  odsState.addOperands(y);
  odsState.addOperands(x);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void Atan2Op::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult Atan2Op::verify() {
  if (failed(Atan2OpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of floating-point values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of floating-point values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))))) {
        return emitOpError("result #") << index << " must be tensor of floating-point values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void Atan2Op::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::AtanOp definitions
//===----------------------------------------------------------------------===//

AtanOpAdaptor::AtanOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

AtanOpAdaptor::AtanOpAdaptor(AtanOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> AtanOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange AtanOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value AtanOpAdaptor::x() {
  return *getODSOperands(0).begin();
}

::mlir::LogicalResult AtanOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

::llvm::StringRef AtanOp::getOperationName() {
  return "tf.Atan";
}

std::pair<unsigned, unsigned> AtanOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range AtanOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value AtanOp::x() {
  return *getODSOperands(0).begin();
}

::mlir::MutableOperandRange AtanOp::xMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> AtanOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range AtanOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value AtanOp::y() {
  return *getODSResults(0).begin();
}

Type AtanOp::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

bool AtanOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "T") return true;
 return false;
}

::mlir::DictionaryAttr AtanOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())}
    }, ctx);
}

void AtanOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type y, ::mlir::Value x) {
  odsState.addOperands(x);
  odsState.addTypes(y);
}

void AtanOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value x) {
  odsState.addOperands(x);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void AtanOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

void AtanOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value x) {
  odsState.addOperands(x);
  odsState.addTypes({x.getType()});

}

void AtanOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  odsState.addTypes({operands[0].getType()});

}

::mlir::LogicalResult AtanOp::verify() {
  if (failed(AtanOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of bfloat16 or 128-bit complex or 64-bit complex or 16-bit float or 32-bit float or 64-bit float or 16-bit integer or 32-bit integer or 64-bit integer or 8-bit integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>())))))) {
        return emitOpError("result #") << index << " must be tensor of bfloat16 or 128-bit complex or 64-bit complex or 16-bit float or 32-bit float or 64-bit float or 16-bit integer or 32-bit integer or 64-bit integer or 8-bit integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void AtanOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::AtanhOp definitions
//===----------------------------------------------------------------------===//

AtanhOpAdaptor::AtanhOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

AtanhOpAdaptor::AtanhOpAdaptor(AtanhOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> AtanhOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange AtanhOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value AtanhOpAdaptor::x() {
  return *getODSOperands(0).begin();
}

::mlir::LogicalResult AtanhOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

::llvm::StringRef AtanhOp::getOperationName() {
  return "tf.Atanh";
}

std::pair<unsigned, unsigned> AtanhOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range AtanhOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value AtanhOp::x() {
  return *getODSOperands(0).begin();
}

::mlir::MutableOperandRange AtanhOp::xMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> AtanhOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range AtanhOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value AtanhOp::y() {
  return *getODSResults(0).begin();
}

Type AtanhOp::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

bool AtanhOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "T") return true;
 return false;
}

::mlir::DictionaryAttr AtanhOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())}
    }, ctx);
}

void AtanhOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type y, ::mlir::Value x) {
  odsState.addOperands(x);
  odsState.addTypes(y);
}

void AtanhOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value x) {
  odsState.addOperands(x);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void AtanhOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

void AtanhOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value x) {
  odsState.addOperands(x);
  odsState.addTypes({x.getType()});

}

void AtanhOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  odsState.addTypes({operands[0].getType()});

}

::mlir::LogicalResult AtanhOp::verify() {
  if (failed(AtanhOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))))))) {
        return emitOpError("operand #") << index << " must be tensor of floating-point or complex values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))))))) {
        return emitOpError("result #") << index << " must be tensor of floating-point or complex values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void AtanhOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::AvgPool3DGradOp definitions
//===----------------------------------------------------------------------===//

AvgPool3DGradOpAdaptor::AvgPool3DGradOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

AvgPool3DGradOpAdaptor::AvgPool3DGradOpAdaptor(AvgPool3DGradOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> AvgPool3DGradOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange AvgPool3DGradOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value AvgPool3DGradOpAdaptor::orig_input_shape() {
  return *getODSOperands(0).begin();
}

::mlir::Value AvgPool3DGradOpAdaptor::grad() {
  return *getODSOperands(1).begin();
}

::mlir::ArrayAttr AvgPool3DGradOpAdaptor::ksize() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::ArrayAttr attr = odsAttrs.get("ksize").cast<::mlir::ArrayAttr>();
  return attr;
}

::mlir::ArrayAttr AvgPool3DGradOpAdaptor::strides() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::ArrayAttr attr = odsAttrs.get("strides").cast<::mlir::ArrayAttr>();
  return attr;
}

::mlir::StringAttr AvgPool3DGradOpAdaptor::padding() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::StringAttr attr = odsAttrs.get("padding").cast<::mlir::StringAttr>();
  return attr;
}

::mlir::StringAttr AvgPool3DGradOpAdaptor::data_format() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::StringAttr attr = odsAttrs.get("data_format").dyn_cast_or_null<::mlir::StringAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getStringAttr("NDHWC");
  return attr;
}

::mlir::LogicalResult AvgPool3DGradOpAdaptor::verify(::mlir::Location loc) {
  {
  auto tblgen_ksize = odsAttrs.get("ksize");
  if (!tblgen_ksize) return emitError(loc, "'tf.AvgPool3DGrad' op ""requires attribute 'ksize'");
    if (!((((tblgen_ksize.isa<::mlir::ArrayAttr>())) && (::llvm::all_of(tblgen_ksize.cast<::mlir::ArrayAttr>(), [](::mlir::Attribute attr) { return ((attr.isa<::mlir::IntegerAttr>())) && ((attr.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(64))); }))) && ((tblgen_ksize.cast<::mlir::ArrayAttr>().size() >= 5)))) return emitError(loc, "'tf.AvgPool3DGrad' op ""attribute 'ksize' failed to satisfy constraint: 64-bit integer array attribute with at least 5 elements");
  }
  {
  auto tblgen_strides = odsAttrs.get("strides");
  if (!tblgen_strides) return emitError(loc, "'tf.AvgPool3DGrad' op ""requires attribute 'strides'");
    if (!((((tblgen_strides.isa<::mlir::ArrayAttr>())) && (::llvm::all_of(tblgen_strides.cast<::mlir::ArrayAttr>(), [](::mlir::Attribute attr) { return ((attr.isa<::mlir::IntegerAttr>())) && ((attr.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(64))); }))) && ((tblgen_strides.cast<::mlir::ArrayAttr>().size() >= 5)))) return emitError(loc, "'tf.AvgPool3DGrad' op ""attribute 'strides' failed to satisfy constraint: 64-bit integer array attribute with at least 5 elements");
  }
  {
  auto tblgen_padding = odsAttrs.get("padding");
  if (!tblgen_padding) return emitError(loc, "'tf.AvgPool3DGrad' op ""requires attribute 'padding'");
    if (!((tblgen_padding.cast<StringAttr>().getValue() == "SAME" || tblgen_padding.cast<StringAttr>().getValue() == "VALID"))) return emitError(loc, "'tf.AvgPool3DGrad' op ""attribute 'padding' failed to satisfy constraint: string attribute whose value is SAME, or VALID");
  }
  {
  auto tblgen_data_format = odsAttrs.get("data_format");
  if (tblgen_data_format) {
    if (!((tblgen_data_format.cast<StringAttr>().getValue() == "NDHWC" || tblgen_data_format.cast<StringAttr>().getValue() == "NCDHW"))) return emitError(loc, "'tf.AvgPool3DGrad' op ""attribute 'data_format' failed to satisfy constraint: string attribute whose value is NDHWC, or NCDHW");
  }
  }
  return ::mlir::success();
}

::llvm::StringRef AvgPool3DGradOp::getOperationName() {
  return "tf.AvgPool3DGrad";
}

std::pair<unsigned, unsigned> AvgPool3DGradOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range AvgPool3DGradOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value AvgPool3DGradOp::orig_input_shape() {
  return *getODSOperands(0).begin();
}

::mlir::Value AvgPool3DGradOp::grad() {
  return *getODSOperands(1).begin();
}

::mlir::MutableOperandRange AvgPool3DGradOp::orig_input_shapeMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange AvgPool3DGradOp::gradMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> AvgPool3DGradOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range AvgPool3DGradOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value AvgPool3DGradOp::output() {
  return *getODSResults(0).begin();
}

::mlir::ArrayAttr AvgPool3DGradOp::ksizeAttr() {
  return this->getAttr("ksize").cast<::mlir::ArrayAttr>();
}

::mlir::ArrayAttr AvgPool3DGradOp::ksize() {
  auto attr = ksizeAttr();
  return attr;
}

::mlir::ArrayAttr AvgPool3DGradOp::stridesAttr() {
  return this->getAttr("strides").cast<::mlir::ArrayAttr>();
}

::mlir::ArrayAttr AvgPool3DGradOp::strides() {
  auto attr = stridesAttr();
  return attr;
}

::mlir::StringAttr AvgPool3DGradOp::paddingAttr() {
  return this->getAttr("padding").cast<::mlir::StringAttr>();
}

::llvm::StringRef AvgPool3DGradOp::padding() {
  auto attr = paddingAttr();
  return attr.getValue();
}

::mlir::StringAttr AvgPool3DGradOp::data_formatAttr() {
  return this->getAttr("data_format").dyn_cast_or_null<::mlir::StringAttr>();
}

::llvm::StringRef AvgPool3DGradOp::data_format() {
  auto attr = data_formatAttr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getStringAttr("NDHWC").getValue();
  return attr.getValue();
}

Type AvgPool3DGradOp::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(1).begin());
}

bool AvgPool3DGradOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "T") return true;
 return false;
}

::mlir::DictionaryAttr AvgPool3DGradOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())}
    }, ctx);
}

void AvgPool3DGradOp::ksizeAttr(::mlir::ArrayAttr attr) {
  this->getOperation()->setAttr("ksize", attr);
}

void AvgPool3DGradOp::stridesAttr(::mlir::ArrayAttr attr) {
  this->getOperation()->setAttr("strides", attr);
}

void AvgPool3DGradOp::paddingAttr(::mlir::StringAttr attr) {
  this->getOperation()->setAttr("padding", attr);
}

void AvgPool3DGradOp::data_formatAttr(::mlir::StringAttr attr) {
  this->getOperation()->setAttr("data_format", attr);
}

void AvgPool3DGradOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value orig_input_shape, ::mlir::Value grad, ::mlir::ArrayAttr ksize, ::mlir::ArrayAttr strides, ::mlir::StringAttr padding, ::mlir::StringAttr data_format) {
  odsState.addOperands(orig_input_shape);
  odsState.addOperands(grad);
  odsState.addAttribute("ksize", ksize);
  odsState.addAttribute("strides", strides);
  odsState.addAttribute("padding", padding);
  odsState.addAttribute("data_format", data_format);
  odsState.addTypes(output);
}

void AvgPool3DGradOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value orig_input_shape, ::mlir::Value grad, ::mlir::ArrayAttr ksize, ::mlir::ArrayAttr strides, ::mlir::StringAttr padding, ::mlir::StringAttr data_format) {
  odsState.addOperands(orig_input_shape);
  odsState.addOperands(grad);
  odsState.addAttribute("ksize", ksize);
  odsState.addAttribute("strides", strides);
  odsState.addAttribute("padding", padding);
  odsState.addAttribute("data_format", data_format);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void AvgPool3DGradOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value orig_input_shape, ::mlir::Value grad, ::mlir::ArrayAttr ksize, ::mlir::ArrayAttr strides, ::llvm::StringRef padding, ::llvm::StringRef data_format) {
  odsState.addOperands(orig_input_shape);
  odsState.addOperands(grad);
  odsState.addAttribute("ksize", ksize);
  odsState.addAttribute("strides", strides);
  odsState.addAttribute("padding", odsBuilder.getStringAttr(padding));
  odsState.addAttribute("data_format", odsBuilder.getStringAttr(data_format));
  odsState.addTypes(output);
}

void AvgPool3DGradOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value orig_input_shape, ::mlir::Value grad, ::mlir::ArrayAttr ksize, ::mlir::ArrayAttr strides, ::llvm::StringRef padding, ::llvm::StringRef data_format) {
  odsState.addOperands(orig_input_shape);
  odsState.addOperands(grad);
  odsState.addAttribute("ksize", ksize);
  odsState.addAttribute("strides", strides);
  odsState.addAttribute("padding", odsBuilder.getStringAttr(padding));
  odsState.addAttribute("data_format", odsBuilder.getStringAttr(data_format));
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void AvgPool3DGradOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult AvgPool3DGradOp::verify() {
  if (failed(AvgPool3DGradOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of 32-bit integer values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of floating-point values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))))) {
        return emitOpError("result #") << index << " must be tensor of floating-point values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void AvgPool3DGradOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::AvgPool3DOp definitions
//===----------------------------------------------------------------------===//

AvgPool3DOpAdaptor::AvgPool3DOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

AvgPool3DOpAdaptor::AvgPool3DOpAdaptor(AvgPool3DOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> AvgPool3DOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange AvgPool3DOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value AvgPool3DOpAdaptor::input() {
  return *getODSOperands(0).begin();
}

::mlir::ArrayAttr AvgPool3DOpAdaptor::ksize() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::ArrayAttr attr = odsAttrs.get("ksize").cast<::mlir::ArrayAttr>();
  return attr;
}

::mlir::ArrayAttr AvgPool3DOpAdaptor::strides() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::ArrayAttr attr = odsAttrs.get("strides").cast<::mlir::ArrayAttr>();
  return attr;
}

::mlir::StringAttr AvgPool3DOpAdaptor::padding() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::StringAttr attr = odsAttrs.get("padding").cast<::mlir::StringAttr>();
  return attr;
}

::mlir::StringAttr AvgPool3DOpAdaptor::data_format() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::StringAttr attr = odsAttrs.get("data_format").dyn_cast_or_null<::mlir::StringAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getStringAttr("NDHWC");
  return attr;
}

::mlir::LogicalResult AvgPool3DOpAdaptor::verify(::mlir::Location loc) {
  {
  auto tblgen_ksize = odsAttrs.get("ksize");
  if (!tblgen_ksize) return emitError(loc, "'tf.AvgPool3D' op ""requires attribute 'ksize'");
    if (!((((tblgen_ksize.isa<::mlir::ArrayAttr>())) && (::llvm::all_of(tblgen_ksize.cast<::mlir::ArrayAttr>(), [](::mlir::Attribute attr) { return ((attr.isa<::mlir::IntegerAttr>())) && ((attr.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(64))); }))) && ((tblgen_ksize.cast<::mlir::ArrayAttr>().size() >= 5)))) return emitError(loc, "'tf.AvgPool3D' op ""attribute 'ksize' failed to satisfy constraint: 64-bit integer array attribute with at least 5 elements");
  }
  {
  auto tblgen_strides = odsAttrs.get("strides");
  if (!tblgen_strides) return emitError(loc, "'tf.AvgPool3D' op ""requires attribute 'strides'");
    if (!((((tblgen_strides.isa<::mlir::ArrayAttr>())) && (::llvm::all_of(tblgen_strides.cast<::mlir::ArrayAttr>(), [](::mlir::Attribute attr) { return ((attr.isa<::mlir::IntegerAttr>())) && ((attr.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(64))); }))) && ((tblgen_strides.cast<::mlir::ArrayAttr>().size() >= 5)))) return emitError(loc, "'tf.AvgPool3D' op ""attribute 'strides' failed to satisfy constraint: 64-bit integer array attribute with at least 5 elements");
  }
  {
  auto tblgen_padding = odsAttrs.get("padding");
  if (!tblgen_padding) return emitError(loc, "'tf.AvgPool3D' op ""requires attribute 'padding'");
    if (!((tblgen_padding.cast<StringAttr>().getValue() == "SAME" || tblgen_padding.cast<StringAttr>().getValue() == "VALID"))) return emitError(loc, "'tf.AvgPool3D' op ""attribute 'padding' failed to satisfy constraint: string attribute whose value is SAME, or VALID");
  }
  {
  auto tblgen_data_format = odsAttrs.get("data_format");
  if (tblgen_data_format) {
    if (!((tblgen_data_format.cast<StringAttr>().getValue() == "NDHWC" || tblgen_data_format.cast<StringAttr>().getValue() == "NCDHW"))) return emitError(loc, "'tf.AvgPool3D' op ""attribute 'data_format' failed to satisfy constraint: string attribute whose value is NDHWC, or NCDHW");
  }
  }
  return ::mlir::success();
}

::llvm::StringRef AvgPool3DOp::getOperationName() {
  return "tf.AvgPool3D";
}

std::pair<unsigned, unsigned> AvgPool3DOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range AvgPool3DOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value AvgPool3DOp::input() {
  return *getODSOperands(0).begin();
}

::mlir::MutableOperandRange AvgPool3DOp::inputMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> AvgPool3DOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range AvgPool3DOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value AvgPool3DOp::output() {
  return *getODSResults(0).begin();
}

::mlir::ArrayAttr AvgPool3DOp::ksizeAttr() {
  return this->getAttr("ksize").cast<::mlir::ArrayAttr>();
}

::mlir::ArrayAttr AvgPool3DOp::ksize() {
  auto attr = ksizeAttr();
  return attr;
}

::mlir::ArrayAttr AvgPool3DOp::stridesAttr() {
  return this->getAttr("strides").cast<::mlir::ArrayAttr>();
}

::mlir::ArrayAttr AvgPool3DOp::strides() {
  auto attr = stridesAttr();
  return attr;
}

::mlir::StringAttr AvgPool3DOp::paddingAttr() {
  return this->getAttr("padding").cast<::mlir::StringAttr>();
}

::llvm::StringRef AvgPool3DOp::padding() {
  auto attr = paddingAttr();
  return attr.getValue();
}

::mlir::StringAttr AvgPool3DOp::data_formatAttr() {
  return this->getAttr("data_format").dyn_cast_or_null<::mlir::StringAttr>();
}

::llvm::StringRef AvgPool3DOp::data_format() {
  auto attr = data_formatAttr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getStringAttr("NDHWC").getValue();
  return attr.getValue();
}

Type AvgPool3DOp::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

bool AvgPool3DOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "T") return true;
 return false;
}

::mlir::DictionaryAttr AvgPool3DOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())}
    }, ctx);
}

void AvgPool3DOp::ksizeAttr(::mlir::ArrayAttr attr) {
  this->getOperation()->setAttr("ksize", attr);
}

void AvgPool3DOp::stridesAttr(::mlir::ArrayAttr attr) {
  this->getOperation()->setAttr("strides", attr);
}

void AvgPool3DOp::paddingAttr(::mlir::StringAttr attr) {
  this->getOperation()->setAttr("padding", attr);
}

void AvgPool3DOp::data_formatAttr(::mlir::StringAttr attr) {
  this->getOperation()->setAttr("data_format", attr);
}

void AvgPool3DOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value input, ::mlir::ArrayAttr ksize, ::mlir::ArrayAttr strides, ::mlir::StringAttr padding, ::mlir::StringAttr data_format) {
  odsState.addOperands(input);
  odsState.addAttribute("ksize", ksize);
  odsState.addAttribute("strides", strides);
  odsState.addAttribute("padding", padding);
  odsState.addAttribute("data_format", data_format);
  odsState.addTypes(output);
}

void AvgPool3DOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input, ::mlir::ArrayAttr ksize, ::mlir::ArrayAttr strides, ::mlir::StringAttr padding, ::mlir::StringAttr data_format) {
  odsState.addOperands(input);
  odsState.addAttribute("ksize", ksize);
  odsState.addAttribute("strides", strides);
  odsState.addAttribute("padding", padding);
  odsState.addAttribute("data_format", data_format);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void AvgPool3DOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value input, ::mlir::ArrayAttr ksize, ::mlir::ArrayAttr strides, ::llvm::StringRef padding, ::llvm::StringRef data_format) {
  odsState.addOperands(input);
  odsState.addAttribute("ksize", ksize);
  odsState.addAttribute("strides", strides);
  odsState.addAttribute("padding", odsBuilder.getStringAttr(padding));
  odsState.addAttribute("data_format", odsBuilder.getStringAttr(data_format));
  odsState.addTypes(output);
}

void AvgPool3DOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input, ::mlir::ArrayAttr ksize, ::mlir::ArrayAttr strides, ::llvm::StringRef padding, ::llvm::StringRef data_format) {
  odsState.addOperands(input);
  odsState.addAttribute("ksize", ksize);
  odsState.addAttribute("strides", strides);
  odsState.addAttribute("padding", odsBuilder.getStringAttr(padding));
  odsState.addAttribute("data_format", odsBuilder.getStringAttr(data_format));
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void AvgPool3DOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult AvgPool3DOp::verify() {
  if (failed(AvgPool3DOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of floating-point values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))))) {
        return emitOpError("result #") << index << " must be tensor of floating-point values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void AvgPool3DOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::AvgPoolGradOp definitions
//===----------------------------------------------------------------------===//

AvgPoolGradOpAdaptor::AvgPoolGradOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

AvgPoolGradOpAdaptor::AvgPoolGradOpAdaptor(AvgPoolGradOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> AvgPoolGradOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange AvgPoolGradOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value AvgPoolGradOpAdaptor::orig_input_shape() {
  return *getODSOperands(0).begin();
}

::mlir::Value AvgPoolGradOpAdaptor::grad() {
  return *getODSOperands(1).begin();
}

::mlir::ArrayAttr AvgPoolGradOpAdaptor::ksize() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::ArrayAttr attr = odsAttrs.get("ksize").cast<::mlir::ArrayAttr>();
  return attr;
}

::mlir::ArrayAttr AvgPoolGradOpAdaptor::strides() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::ArrayAttr attr = odsAttrs.get("strides").cast<::mlir::ArrayAttr>();
  return attr;
}

::mlir::StringAttr AvgPoolGradOpAdaptor::padding() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::StringAttr attr = odsAttrs.get("padding").cast<::mlir::StringAttr>();
  return attr;
}

::mlir::StringAttr AvgPoolGradOpAdaptor::data_format() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::StringAttr attr = odsAttrs.get("data_format").dyn_cast_or_null<::mlir::StringAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getStringAttr("NHWC");
  return attr;
}

::mlir::LogicalResult AvgPoolGradOpAdaptor::verify(::mlir::Location loc) {
  {
  auto tblgen_ksize = odsAttrs.get("ksize");
  if (!tblgen_ksize) return emitError(loc, "'tf.AvgPoolGrad' op ""requires attribute 'ksize'");
    if (!((((tblgen_ksize.isa<::mlir::ArrayAttr>())) && (::llvm::all_of(tblgen_ksize.cast<::mlir::ArrayAttr>(), [](::mlir::Attribute attr) { return ((attr.isa<::mlir::IntegerAttr>())) && ((attr.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(64))); }))) && ((tblgen_ksize.cast<::mlir::ArrayAttr>().size() >= 4)))) return emitError(loc, "'tf.AvgPoolGrad' op ""attribute 'ksize' failed to satisfy constraint: 64-bit integer array attribute with at least 4 elements");
  }
  {
  auto tblgen_strides = odsAttrs.get("strides");
  if (!tblgen_strides) return emitError(loc, "'tf.AvgPoolGrad' op ""requires attribute 'strides'");
    if (!((((tblgen_strides.isa<::mlir::ArrayAttr>())) && (::llvm::all_of(tblgen_strides.cast<::mlir::ArrayAttr>(), [](::mlir::Attribute attr) { return ((attr.isa<::mlir::IntegerAttr>())) && ((attr.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(64))); }))) && ((tblgen_strides.cast<::mlir::ArrayAttr>().size() >= 4)))) return emitError(loc, "'tf.AvgPoolGrad' op ""attribute 'strides' failed to satisfy constraint: 64-bit integer array attribute with at least 4 elements");
  }
  {
  auto tblgen_padding = odsAttrs.get("padding");
  if (!tblgen_padding) return emitError(loc, "'tf.AvgPoolGrad' op ""requires attribute 'padding'");
    if (!((tblgen_padding.cast<StringAttr>().getValue() == "SAME" || tblgen_padding.cast<StringAttr>().getValue() == "VALID"))) return emitError(loc, "'tf.AvgPoolGrad' op ""attribute 'padding' failed to satisfy constraint: string attribute whose value is SAME, or VALID");
  }
  {
  auto tblgen_data_format = odsAttrs.get("data_format");
  if (tblgen_data_format) {
    if (!((tblgen_data_format.cast<StringAttr>().getValue() == "NHWC" || tblgen_data_format.cast<StringAttr>().getValue() == "NCHW"))) return emitError(loc, "'tf.AvgPoolGrad' op ""attribute 'data_format' failed to satisfy constraint: 'NHWC' or 'NCHW' convnet data format");
  }
  }
  return ::mlir::success();
}

::llvm::StringRef AvgPoolGradOp::getOperationName() {
  return "tf.AvgPoolGrad";
}

std::pair<unsigned, unsigned> AvgPoolGradOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range AvgPoolGradOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value AvgPoolGradOp::orig_input_shape() {
  return *getODSOperands(0).begin();
}

::mlir::Value AvgPoolGradOp::grad() {
  return *getODSOperands(1).begin();
}

::mlir::MutableOperandRange AvgPoolGradOp::orig_input_shapeMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange AvgPoolGradOp::gradMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> AvgPoolGradOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range AvgPoolGradOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value AvgPoolGradOp::output() {
  return *getODSResults(0).begin();
}

::mlir::ArrayAttr AvgPoolGradOp::ksizeAttr() {
  return this->getAttr("ksize").cast<::mlir::ArrayAttr>();
}

::mlir::ArrayAttr AvgPoolGradOp::ksize() {
  auto attr = ksizeAttr();
  return attr;
}

::mlir::ArrayAttr AvgPoolGradOp::stridesAttr() {
  return this->getAttr("strides").cast<::mlir::ArrayAttr>();
}

::mlir::ArrayAttr AvgPoolGradOp::strides() {
  auto attr = stridesAttr();
  return attr;
}

::mlir::StringAttr AvgPoolGradOp::paddingAttr() {
  return this->getAttr("padding").cast<::mlir::StringAttr>();
}

::llvm::StringRef AvgPoolGradOp::padding() {
  auto attr = paddingAttr();
  return attr.getValue();
}

::mlir::StringAttr AvgPoolGradOp::data_formatAttr() {
  return this->getAttr("data_format").dyn_cast_or_null<::mlir::StringAttr>();
}

::llvm::StringRef AvgPoolGradOp::data_format() {
  auto attr = data_formatAttr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getStringAttr("NHWC").getValue();
  return attr.getValue();
}

Type AvgPoolGradOp::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(1).begin());
}

bool AvgPoolGradOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "T") return true;
 return false;
}

::mlir::DictionaryAttr AvgPoolGradOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())}
    }, ctx);
}

void AvgPoolGradOp::ksizeAttr(::mlir::ArrayAttr attr) {
  this->getOperation()->setAttr("ksize", attr);
}

void AvgPoolGradOp::stridesAttr(::mlir::ArrayAttr attr) {
  this->getOperation()->setAttr("strides", attr);
}

void AvgPoolGradOp::paddingAttr(::mlir::StringAttr attr) {
  this->getOperation()->setAttr("padding", attr);
}

void AvgPoolGradOp::data_formatAttr(::mlir::StringAttr attr) {
  this->getOperation()->setAttr("data_format", attr);
}

void AvgPoolGradOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value orig_input_shape, ::mlir::Value grad, ::mlir::ArrayAttr ksize, ::mlir::ArrayAttr strides, ::mlir::StringAttr padding, ::mlir::StringAttr data_format) {
  odsState.addOperands(orig_input_shape);
  odsState.addOperands(grad);
  odsState.addAttribute("ksize", ksize);
  odsState.addAttribute("strides", strides);
  odsState.addAttribute("padding", padding);
  odsState.addAttribute("data_format", data_format);
  odsState.addTypes(output);
}

void AvgPoolGradOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value orig_input_shape, ::mlir::Value grad, ::mlir::ArrayAttr ksize, ::mlir::ArrayAttr strides, ::mlir::StringAttr padding, ::mlir::StringAttr data_format) {
  odsState.addOperands(orig_input_shape);
  odsState.addOperands(grad);
  odsState.addAttribute("ksize", ksize);
  odsState.addAttribute("strides", strides);
  odsState.addAttribute("padding", padding);
  odsState.addAttribute("data_format", data_format);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void AvgPoolGradOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value orig_input_shape, ::mlir::Value grad, ::mlir::ArrayAttr ksize, ::mlir::ArrayAttr strides, ::llvm::StringRef padding, ::llvm::StringRef data_format) {
  odsState.addOperands(orig_input_shape);
  odsState.addOperands(grad);
  odsState.addAttribute("ksize", ksize);
  odsState.addAttribute("strides", strides);
  odsState.addAttribute("padding", odsBuilder.getStringAttr(padding));
  odsState.addAttribute("data_format", odsBuilder.getStringAttr(data_format));
  odsState.addTypes(output);
}

void AvgPoolGradOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value orig_input_shape, ::mlir::Value grad, ::mlir::ArrayAttr ksize, ::mlir::ArrayAttr strides, ::llvm::StringRef padding, ::llvm::StringRef data_format) {
  odsState.addOperands(orig_input_shape);
  odsState.addOperands(grad);
  odsState.addAttribute("ksize", ksize);
  odsState.addAttribute("strides", strides);
  odsState.addAttribute("padding", odsBuilder.getStringAttr(padding));
  odsState.addAttribute("data_format", odsBuilder.getStringAttr(data_format));
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void AvgPoolGradOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult AvgPoolGradOp::verify() {
  if (failed(AvgPoolGradOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of 32-bit integer values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of floating-point values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))))) {
        return emitOpError("result #") << index << " must be tensor of floating-point values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void AvgPoolGradOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::AvgPoolOp definitions
//===----------------------------------------------------------------------===//

AvgPoolOpAdaptor::AvgPoolOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

AvgPoolOpAdaptor::AvgPoolOpAdaptor(AvgPoolOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> AvgPoolOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange AvgPoolOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value AvgPoolOpAdaptor::value() {
  return *getODSOperands(0).begin();
}

::mlir::ArrayAttr AvgPoolOpAdaptor::ksize() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::ArrayAttr attr = odsAttrs.get("ksize").cast<::mlir::ArrayAttr>();
  return attr;
}

::mlir::ArrayAttr AvgPoolOpAdaptor::strides() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::ArrayAttr attr = odsAttrs.get("strides").cast<::mlir::ArrayAttr>();
  return attr;
}

::mlir::StringAttr AvgPoolOpAdaptor::padding() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::StringAttr attr = odsAttrs.get("padding").cast<::mlir::StringAttr>();
  return attr;
}

::mlir::StringAttr AvgPoolOpAdaptor::data_format() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::StringAttr attr = odsAttrs.get("data_format").dyn_cast_or_null<::mlir::StringAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getStringAttr("NHWC");
  return attr;
}

::mlir::LogicalResult AvgPoolOpAdaptor::verify(::mlir::Location loc) {
  {
  auto tblgen_ksize = odsAttrs.get("ksize");
  if (!tblgen_ksize) return emitError(loc, "'tf.AvgPool' op ""requires attribute 'ksize'");
    if (!((((tblgen_ksize.isa<::mlir::ArrayAttr>())) && (::llvm::all_of(tblgen_ksize.cast<::mlir::ArrayAttr>(), [](::mlir::Attribute attr) { return ((attr.isa<::mlir::IntegerAttr>())) && ((attr.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(64))); }))) && ((tblgen_ksize.cast<::mlir::ArrayAttr>().size() >= 4)))) return emitError(loc, "'tf.AvgPool' op ""attribute 'ksize' failed to satisfy constraint: 64-bit integer array attribute with at least 4 elements");
  }
  {
  auto tblgen_strides = odsAttrs.get("strides");
  if (!tblgen_strides) return emitError(loc, "'tf.AvgPool' op ""requires attribute 'strides'");
    if (!((((tblgen_strides.isa<::mlir::ArrayAttr>())) && (::llvm::all_of(tblgen_strides.cast<::mlir::ArrayAttr>(), [](::mlir::Attribute attr) { return ((attr.isa<::mlir::IntegerAttr>())) && ((attr.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(64))); }))) && ((tblgen_strides.cast<::mlir::ArrayAttr>().size() >= 4)))) return emitError(loc, "'tf.AvgPool' op ""attribute 'strides' failed to satisfy constraint: 64-bit integer array attribute with at least 4 elements");
  }
  {
  auto tblgen_padding = odsAttrs.get("padding");
  if (!tblgen_padding) return emitError(loc, "'tf.AvgPool' op ""requires attribute 'padding'");
    if (!((tblgen_padding.cast<StringAttr>().getValue() == "SAME" || tblgen_padding.cast<StringAttr>().getValue() == "VALID"))) return emitError(loc, "'tf.AvgPool' op ""attribute 'padding' failed to satisfy constraint: string attribute whose value is SAME, or VALID");
  }
  {
  auto tblgen_data_format = odsAttrs.get("data_format");
  if (tblgen_data_format) {
    if (!((tblgen_data_format.cast<StringAttr>().getValue() == "NHWC" || tblgen_data_format.cast<StringAttr>().getValue() == "NCHW"))) return emitError(loc, "'tf.AvgPool' op ""attribute 'data_format' failed to satisfy constraint: 'NHWC' or 'NCHW' convnet data format");
  }
  }
  return ::mlir::success();
}

::llvm::StringRef AvgPoolOp::getOperationName() {
  return "tf.AvgPool";
}

std::pair<unsigned, unsigned> AvgPoolOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range AvgPoolOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value AvgPoolOp::value() {
  return *getODSOperands(0).begin();
}

::mlir::MutableOperandRange AvgPoolOp::valueMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> AvgPoolOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range AvgPoolOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value AvgPoolOp::output() {
  return *getODSResults(0).begin();
}

::mlir::ArrayAttr AvgPoolOp::ksizeAttr() {
  return this->getAttr("ksize").cast<::mlir::ArrayAttr>();
}

::mlir::ArrayAttr AvgPoolOp::ksize() {
  auto attr = ksizeAttr();
  return attr;
}

::mlir::ArrayAttr AvgPoolOp::stridesAttr() {
  return this->getAttr("strides").cast<::mlir::ArrayAttr>();
}

::mlir::ArrayAttr AvgPoolOp::strides() {
  auto attr = stridesAttr();
  return attr;
}

::mlir::StringAttr AvgPoolOp::paddingAttr() {
  return this->getAttr("padding").cast<::mlir::StringAttr>();
}

::llvm::StringRef AvgPoolOp::padding() {
  auto attr = paddingAttr();
  return attr.getValue();
}

::mlir::StringAttr AvgPoolOp::data_formatAttr() {
  return this->getAttr("data_format").dyn_cast_or_null<::mlir::StringAttr>();
}

::llvm::StringRef AvgPoolOp::data_format() {
  auto attr = data_formatAttr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getStringAttr("NHWC").getValue();
  return attr.getValue();
}

Type AvgPoolOp::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

bool AvgPoolOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "T") return true;
 return false;
}

::mlir::DictionaryAttr AvgPoolOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())}
    }, ctx);
}

void AvgPoolOp::ksizeAttr(::mlir::ArrayAttr attr) {
  this->getOperation()->setAttr("ksize", attr);
}

void AvgPoolOp::stridesAttr(::mlir::ArrayAttr attr) {
  this->getOperation()->setAttr("strides", attr);
}

void AvgPoolOp::paddingAttr(::mlir::StringAttr attr) {
  this->getOperation()->setAttr("padding", attr);
}

void AvgPoolOp::data_formatAttr(::mlir::StringAttr attr) {
  this->getOperation()->setAttr("data_format", attr);
}

void AvgPoolOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value value, ::mlir::ArrayAttr ksize, ::mlir::ArrayAttr strides, ::mlir::StringAttr padding, ::mlir::StringAttr data_format) {
  odsState.addOperands(value);
  odsState.addAttribute("ksize", ksize);
  odsState.addAttribute("strides", strides);
  odsState.addAttribute("padding", padding);
  odsState.addAttribute("data_format", data_format);
  odsState.addTypes(output);
}

void AvgPoolOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value value, ::mlir::ArrayAttr ksize, ::mlir::ArrayAttr strides, ::mlir::StringAttr padding, ::mlir::StringAttr data_format) {
  odsState.addOperands(value);
  odsState.addAttribute("ksize", ksize);
  odsState.addAttribute("strides", strides);
  odsState.addAttribute("padding", padding);
  odsState.addAttribute("data_format", data_format);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void AvgPoolOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value value, ::mlir::ArrayAttr ksize, ::mlir::ArrayAttr strides, ::llvm::StringRef padding, ::llvm::StringRef data_format) {
  odsState.addOperands(value);
  odsState.addAttribute("ksize", ksize);
  odsState.addAttribute("strides", strides);
  odsState.addAttribute("padding", odsBuilder.getStringAttr(padding));
  odsState.addAttribute("data_format", odsBuilder.getStringAttr(data_format));
  odsState.addTypes(output);
}

void AvgPoolOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value value, ::mlir::ArrayAttr ksize, ::mlir::ArrayAttr strides, ::llvm::StringRef padding, ::llvm::StringRef data_format) {
  odsState.addOperands(value);
  odsState.addAttribute("ksize", ksize);
  odsState.addAttribute("strides", strides);
  odsState.addAttribute("padding", odsBuilder.getStringAttr(padding));
  odsState.addAttribute("data_format", odsBuilder.getStringAttr(data_format));
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void AvgPoolOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult AvgPoolOp::verify() {
  if (failed(AvgPoolOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of floating-point values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))))) {
        return emitOpError("result #") << index << " must be tensor of floating-point values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void AvgPoolOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::BatchDatasetV2Op definitions
//===----------------------------------------------------------------------===//

BatchDatasetV2OpAdaptor::BatchDatasetV2OpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

BatchDatasetV2OpAdaptor::BatchDatasetV2OpAdaptor(BatchDatasetV2Op&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> BatchDatasetV2OpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange BatchDatasetV2OpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value BatchDatasetV2OpAdaptor::input_dataset() {
  return *getODSOperands(0).begin();
}

::mlir::Value BatchDatasetV2OpAdaptor::batch_size() {
  return *getODSOperands(1).begin();
}

::mlir::Value BatchDatasetV2OpAdaptor::drop_remainder() {
  return *getODSOperands(2).begin();
}

::mlir::BoolAttr BatchDatasetV2OpAdaptor::parallel_copy() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::BoolAttr attr = odsAttrs.get("parallel_copy").dyn_cast_or_null<::mlir::BoolAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getBoolAttr(false);
  return attr;
}

::mlir::ArrayAttr BatchDatasetV2OpAdaptor::output_types() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::ArrayAttr attr = odsAttrs.get("output_types").cast<::mlir::ArrayAttr>();
  return attr;
}

::mlir::ArrayAttr BatchDatasetV2OpAdaptor::output_shapes() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::ArrayAttr attr = odsAttrs.get("output_shapes").cast<::mlir::ArrayAttr>();
  return attr;
}

::mlir::LogicalResult BatchDatasetV2OpAdaptor::verify(::mlir::Location loc) {
  {
  auto tblgen_parallel_copy = odsAttrs.get("parallel_copy");
  if (tblgen_parallel_copy) {
    if (!((tblgen_parallel_copy.isa<::mlir::BoolAttr>()))) return emitError(loc, "'tf.BatchDatasetV2' op ""attribute 'parallel_copy' failed to satisfy constraint: bool attribute");
  }
  }
  {
  auto tblgen_output_types = odsAttrs.get("output_types");
  if (!tblgen_output_types) return emitError(loc, "'tf.BatchDatasetV2' op ""requires attribute 'output_types'");
    if (!((((tblgen_output_types.isa<::mlir::ArrayAttr>())) && (::llvm::all_of(tblgen_output_types.cast<::mlir::ArrayAttr>(), [](::mlir::Attribute attr) { return ((attr.isa<::mlir::TypeAttr>())) && ((attr.cast<::mlir::TypeAttr>().getValue().isa<::mlir::Type>())); }))) && ((tblgen_output_types.cast<::mlir::ArrayAttr>().size() >= 1)))) return emitError(loc, "'tf.BatchDatasetV2' op ""attribute 'output_types' failed to satisfy constraint: type array attribute with at least 1 elements");
  }
  {
  auto tblgen_output_shapes = odsAttrs.get("output_shapes");
  if (!tblgen_output_shapes) return emitError(loc, "'tf.BatchDatasetV2' op ""requires attribute 'output_shapes'");
    if (!((((tblgen_output_shapes.isa<::mlir::ArrayAttr>())) && (::llvm::all_of(tblgen_output_shapes.cast<::mlir::ArrayAttr>(), [](::mlir::Attribute attr) { return (attr.isa<mlir::TF::ShapeAttr>()); }))) && ((tblgen_output_shapes.cast<::mlir::ArrayAttr>().size() >= 1)))) return emitError(loc, "'tf.BatchDatasetV2' op ""attribute 'output_shapes' failed to satisfy constraint: tensorflow shape attribute array with at least 1 elements");
  }
  return ::mlir::success();
}

::llvm::StringRef BatchDatasetV2Op::getOperationName() {
  return "tf.BatchDatasetV2";
}

std::pair<unsigned, unsigned> BatchDatasetV2Op::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range BatchDatasetV2Op::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value BatchDatasetV2Op::input_dataset() {
  return *getODSOperands(0).begin();
}

::mlir::Value BatchDatasetV2Op::batch_size() {
  return *getODSOperands(1).begin();
}

::mlir::Value BatchDatasetV2Op::drop_remainder() {
  return *getODSOperands(2).begin();
}

::mlir::MutableOperandRange BatchDatasetV2Op::input_datasetMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange BatchDatasetV2Op::batch_sizeMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange BatchDatasetV2Op::drop_remainderMutable() {
  auto range = getODSOperandIndexAndLength(2);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> BatchDatasetV2Op::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range BatchDatasetV2Op::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value BatchDatasetV2Op::handle() {
  return *getODSResults(0).begin();
}

::mlir::BoolAttr BatchDatasetV2Op::parallel_copyAttr() {
  return this->getAttr("parallel_copy").dyn_cast_or_null<::mlir::BoolAttr>();
}

bool BatchDatasetV2Op::parallel_copy() {
  auto attr = parallel_copyAttr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getBoolAttr(false).getValue();
  return attr.getValue();
}

::mlir::ArrayAttr BatchDatasetV2Op::output_typesAttr() {
  return this->getAttr("output_types").cast<::mlir::ArrayAttr>();
}

::mlir::ArrayAttr BatchDatasetV2Op::output_types() {
  auto attr = output_typesAttr();
  return attr;
}

::mlir::ArrayAttr BatchDatasetV2Op::output_shapesAttr() {
  return this->getAttr("output_shapes").cast<::mlir::ArrayAttr>();
}

::mlir::ArrayAttr BatchDatasetV2Op::output_shapes() {
  auto attr = output_shapesAttr();
  return attr;
}

void BatchDatasetV2Op::parallel_copyAttr(::mlir::BoolAttr attr) {
  this->getOperation()->setAttr("parallel_copy", attr);
}

void BatchDatasetV2Op::output_typesAttr(::mlir::ArrayAttr attr) {
  this->getOperation()->setAttr("output_types", attr);
}

void BatchDatasetV2Op::output_shapesAttr(::mlir::ArrayAttr attr) {
  this->getOperation()->setAttr("output_shapes", attr);
}

void BatchDatasetV2Op::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type handle, ::mlir::Value input_dataset, ::mlir::Value batch_size, ::mlir::Value drop_remainder, ::mlir::BoolAttr parallel_copy, ::mlir::ArrayAttr output_types, ::mlir::ArrayAttr output_shapes) {
  odsState.addOperands(input_dataset);
  odsState.addOperands(batch_size);
  odsState.addOperands(drop_remainder);
  odsState.addAttribute("parallel_copy", parallel_copy);
  odsState.addAttribute("output_types", output_types);
  odsState.addAttribute("output_shapes", output_shapes);
  odsState.addTypes(handle);
}

void BatchDatasetV2Op::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input_dataset, ::mlir::Value batch_size, ::mlir::Value drop_remainder, ::mlir::BoolAttr parallel_copy, ::mlir::ArrayAttr output_types, ::mlir::ArrayAttr output_shapes) {
  odsState.addOperands(input_dataset);
  odsState.addOperands(batch_size);
  odsState.addOperands(drop_remainder);
  odsState.addAttribute("parallel_copy", parallel_copy);
  odsState.addAttribute("output_types", output_types);
  odsState.addAttribute("output_shapes", output_shapes);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void BatchDatasetV2Op::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type handle, ::mlir::Value input_dataset, ::mlir::Value batch_size, ::mlir::Value drop_remainder, bool parallel_copy, ::mlir::ArrayAttr output_types, ::mlir::ArrayAttr output_shapes) {
  odsState.addOperands(input_dataset);
  odsState.addOperands(batch_size);
  odsState.addOperands(drop_remainder);
  odsState.addAttribute("parallel_copy", odsBuilder.getBoolAttr(parallel_copy));
  odsState.addAttribute("output_types", output_types);
  odsState.addAttribute("output_shapes", output_shapes);
  odsState.addTypes(handle);
}

void BatchDatasetV2Op::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input_dataset, ::mlir::Value batch_size, ::mlir::Value drop_remainder, bool parallel_copy, ::mlir::ArrayAttr output_types, ::mlir::ArrayAttr output_shapes) {
  odsState.addOperands(input_dataset);
  odsState.addOperands(batch_size);
  odsState.addOperands(drop_remainder);
  odsState.addAttribute("parallel_copy", odsBuilder.getBoolAttr(parallel_copy));
  odsState.addAttribute("output_types", output_types);
  odsState.addAttribute("output_shapes", output_shapes);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void BatchDatasetV2Op::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 3u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult BatchDatasetV2Op::verify() {
  if (failed(BatchDatasetV2OpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::VariantType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::VariantRefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of variant values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of 64-bit integer values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup2 = getODSOperands(2);
    for (::mlir::Value v : valueGroup2) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of bool values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::VariantType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::VariantRefType>()))))) {
        return emitOpError("result #") << index << " must be tensor of variant values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void BatchDatasetV2Op::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::BatchFunctionOp definitions
//===----------------------------------------------------------------------===//

BatchFunctionOpAdaptor::BatchFunctionOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

BatchFunctionOpAdaptor::BatchFunctionOpAdaptor(BatchFunctionOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> BatchFunctionOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  assert(odsAttrs && "missing segment size attribute for op");
  auto sizeAttr = odsAttrs.get("operand_segment_sizes").cast<::mlir::DenseIntElementsAttr>();

  unsigned start = 0;
  for (unsigned i = 0; i < index; ++i)
    start += (*(sizeAttr.begin() + i)).getZExtValue();
  unsigned size = (*(sizeAttr.begin() + index)).getZExtValue();
  return {start, size};
}

::mlir::ValueRange BatchFunctionOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::ValueRange BatchFunctionOpAdaptor::in_tensors() {
  return getODSOperands(0);
}

::mlir::ValueRange BatchFunctionOpAdaptor::captured_tensors() {
  return getODSOperands(1);
}

::mlir::SymbolRefAttr BatchFunctionOpAdaptor::f() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::SymbolRefAttr attr = odsAttrs.get("f").cast<::mlir::SymbolRefAttr>();
  return attr;
}

::mlir::IntegerAttr BatchFunctionOpAdaptor::num_batch_threads() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::IntegerAttr attr = odsAttrs.get("num_batch_threads").cast<::mlir::IntegerAttr>();
  return attr;
}

::mlir::IntegerAttr BatchFunctionOpAdaptor::max_batch_size() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::IntegerAttr attr = odsAttrs.get("max_batch_size").cast<::mlir::IntegerAttr>();
  return attr;
}

::mlir::IntegerAttr BatchFunctionOpAdaptor::batch_timeout_micros() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::IntegerAttr attr = odsAttrs.get("batch_timeout_micros").cast<::mlir::IntegerAttr>();
  return attr;
}

::mlir::IntegerAttr BatchFunctionOpAdaptor::max_enqueued_batches() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::IntegerAttr attr = odsAttrs.get("max_enqueued_batches").dyn_cast_or_null<::mlir::IntegerAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getIntegerAttr(::mlir::Builder(odsAttrs.getContext()).getIntegerType(64), 10);
  return attr;
}

::mlir::ArrayAttr BatchFunctionOpAdaptor::allowed_batch_sizes() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::ArrayAttr attr = odsAttrs.get("allowed_batch_sizes").dyn_cast_or_null<::mlir::ArrayAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getI64ArrayAttr({});
  return attr;
}

::mlir::StringAttr BatchFunctionOpAdaptor::container() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::StringAttr attr = odsAttrs.get("container").cast<::mlir::StringAttr>();
  return attr;
}

::mlir::StringAttr BatchFunctionOpAdaptor::shared_name() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::StringAttr attr = odsAttrs.get("shared_name").cast<::mlir::StringAttr>();
  return attr;
}

::mlir::StringAttr BatchFunctionOpAdaptor::batching_queue() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::StringAttr attr = odsAttrs.get("batching_queue").cast<::mlir::StringAttr>();
  return attr;
}

::mlir::BoolAttr BatchFunctionOpAdaptor::enable_large_batch_splitting() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::BoolAttr attr = odsAttrs.get("enable_large_batch_splitting").dyn_cast_or_null<::mlir::BoolAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getBoolAttr(false);
  return attr;
}

::mlir::DenseIntElementsAttr BatchFunctionOpAdaptor::operand_segment_sizes() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::DenseIntElementsAttr attr = odsAttrs.get("operand_segment_sizes").cast<::mlir::DenseIntElementsAttr>();
  return attr;
}

::mlir::LogicalResult BatchFunctionOpAdaptor::verify(::mlir::Location loc) {
  {
    auto sizeAttr = odsAttrs.get("operand_segment_sizes").cast<::mlir::DenseIntElementsAttr>();
    auto numElements = sizeAttr.getType().cast<::mlir::ShapedType>().getNumElements();
    if (numElements != 2)
      return emitError(loc, "'operand_segment_sizes' attribute for specifying operand segments "
                       "must have 2 elements");
  }
    {
  auto tblgen_f = odsAttrs.get("f");
  if (!tblgen_f) return emitError(loc, "'tf.BatchFunction' op ""requires attribute 'f'");
    if (!((tblgen_f.isa<::mlir::SymbolRefAttr>()))) return emitError(loc, "'tf.BatchFunction' op ""attribute 'f' failed to satisfy constraint: symbol reference attribute");
  }
  {
  auto tblgen_num_batch_threads = odsAttrs.get("num_batch_threads");
  if (!tblgen_num_batch_threads) return emitError(loc, "'tf.BatchFunction' op ""requires attribute 'num_batch_threads'");
    if (!(((tblgen_num_batch_threads.isa<::mlir::IntegerAttr>())) && ((tblgen_num_batch_threads.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(64))))) return emitError(loc, "'tf.BatchFunction' op ""attribute 'num_batch_threads' failed to satisfy constraint: 64-bit signless integer attribute");
  }
  {
  auto tblgen_max_batch_size = odsAttrs.get("max_batch_size");
  if (!tblgen_max_batch_size) return emitError(loc, "'tf.BatchFunction' op ""requires attribute 'max_batch_size'");
    if (!(((tblgen_max_batch_size.isa<::mlir::IntegerAttr>())) && ((tblgen_max_batch_size.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(64))))) return emitError(loc, "'tf.BatchFunction' op ""attribute 'max_batch_size' failed to satisfy constraint: 64-bit signless integer attribute");
  }
  {
  auto tblgen_batch_timeout_micros = odsAttrs.get("batch_timeout_micros");
  if (!tblgen_batch_timeout_micros) return emitError(loc, "'tf.BatchFunction' op ""requires attribute 'batch_timeout_micros'");
    if (!(((tblgen_batch_timeout_micros.isa<::mlir::IntegerAttr>())) && ((tblgen_batch_timeout_micros.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(64))))) return emitError(loc, "'tf.BatchFunction' op ""attribute 'batch_timeout_micros' failed to satisfy constraint: 64-bit signless integer attribute");
  }
  {
  auto tblgen_max_enqueued_batches = odsAttrs.get("max_enqueued_batches");
  if (tblgen_max_enqueued_batches) {
    if (!(((tblgen_max_enqueued_batches.isa<::mlir::IntegerAttr>())) && ((tblgen_max_enqueued_batches.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(64))))) return emitError(loc, "'tf.BatchFunction' op ""attribute 'max_enqueued_batches' failed to satisfy constraint: 64-bit signless integer attribute");
  }
  }
  {
  auto tblgen_allowed_batch_sizes = odsAttrs.get("allowed_batch_sizes");
  if (tblgen_allowed_batch_sizes) {
    if (!(((tblgen_allowed_batch_sizes.isa<::mlir::ArrayAttr>())) && (::llvm::all_of(tblgen_allowed_batch_sizes.cast<::mlir::ArrayAttr>(), [](::mlir::Attribute attr) { return ((attr.isa<::mlir::IntegerAttr>())) && ((attr.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(64))); })))) return emitError(loc, "'tf.BatchFunction' op ""attribute 'allowed_batch_sizes' failed to satisfy constraint: 64-bit integer array attribute");
  }
  }
  {
  auto tblgen_container = odsAttrs.get("container");
  if (!tblgen_container) return emitError(loc, "'tf.BatchFunction' op ""requires attribute 'container'");
    if (!((tblgen_container.isa<::mlir::StringAttr>()))) return emitError(loc, "'tf.BatchFunction' op ""attribute 'container' failed to satisfy constraint: string attribute");
  }
  {
  auto tblgen_shared_name = odsAttrs.get("shared_name");
  if (!tblgen_shared_name) return emitError(loc, "'tf.BatchFunction' op ""requires attribute 'shared_name'");
    if (!((tblgen_shared_name.isa<::mlir::StringAttr>()))) return emitError(loc, "'tf.BatchFunction' op ""attribute 'shared_name' failed to satisfy constraint: string attribute");
  }
  {
  auto tblgen_batching_queue = odsAttrs.get("batching_queue");
  if (!tblgen_batching_queue) return emitError(loc, "'tf.BatchFunction' op ""requires attribute 'batching_queue'");
    if (!((tblgen_batching_queue.isa<::mlir::StringAttr>()))) return emitError(loc, "'tf.BatchFunction' op ""attribute 'batching_queue' failed to satisfy constraint: string attribute");
  }
  {
  auto tblgen_enable_large_batch_splitting = odsAttrs.get("enable_large_batch_splitting");
  if (tblgen_enable_large_batch_splitting) {
    if (!((tblgen_enable_large_batch_splitting.isa<::mlir::BoolAttr>()))) return emitError(loc, "'tf.BatchFunction' op ""attribute 'enable_large_batch_splitting' failed to satisfy constraint: bool attribute");
  }
  }
  {
  auto tblgen_operand_segment_sizes = odsAttrs.get("operand_segment_sizes");
  if (!tblgen_operand_segment_sizes) return emitError(loc, "'tf.BatchFunction' op ""requires attribute 'operand_segment_sizes'");
    if (!(((tblgen_operand_segment_sizes.isa<::mlir::DenseIntElementsAttr>())) && ((tblgen_operand_segment_sizes.cast<::mlir::DenseIntElementsAttr>().getType().getElementType().isSignlessInteger(32))))) return emitError(loc, "'tf.BatchFunction' op ""attribute 'operand_segment_sizes' failed to satisfy constraint: 32-bit signless integer elements attribute");
  }
  return ::mlir::success();
}

::llvm::StringRef BatchFunctionOp::getOperationName() {
  return "tf.BatchFunction";
}

std::pair<unsigned, unsigned> BatchFunctionOp::getODSOperandIndexAndLength(unsigned index) {
  auto sizeAttr = getAttrOfType<::mlir::DenseIntElementsAttr>("operand_segment_sizes");

  unsigned start = 0;
  for (unsigned i = 0; i < index; ++i)
    start += (*(sizeAttr.begin() + i)).getZExtValue();
  unsigned size = (*(sizeAttr.begin() + index)).getZExtValue();
  return {start, size};
}

::mlir::Operation::operand_range BatchFunctionOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Operation::operand_range BatchFunctionOp::in_tensors() {
  return getODSOperands(0);
}

::mlir::Operation::operand_range BatchFunctionOp::captured_tensors() {
  return getODSOperands(1);
}

::mlir::MutableOperandRange BatchFunctionOp::in_tensorsMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second, ::mlir::MutableOperandRange::OperandSegment(0u, *getOperation()->getMutableAttrDict().getNamed("operand_segment_sizes")));
}

::mlir::MutableOperandRange BatchFunctionOp::captured_tensorsMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second, ::mlir::MutableOperandRange::OperandSegment(1u, *getOperation()->getMutableAttrDict().getNamed("operand_segment_sizes")));
}

std::pair<unsigned, unsigned> BatchFunctionOp::getODSResultIndexAndLength(unsigned index) {
  bool isVariadic[] = {true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (getOperation()->getNumResults() - 0) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::mlir::Operation::result_range BatchFunctionOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Operation::result_range BatchFunctionOp::out_tensors() {
  return getODSResults(0);
}

::mlir::SymbolRefAttr BatchFunctionOp::fAttr() {
  return this->getAttr("f").cast<::mlir::SymbolRefAttr>();
}

::mlir::SymbolRefAttr BatchFunctionOp::f() {
  auto attr = fAttr();
  return attr;
}

::mlir::IntegerAttr BatchFunctionOp::num_batch_threadsAttr() {
  return this->getAttr("num_batch_threads").cast<::mlir::IntegerAttr>();
}

uint64_t BatchFunctionOp::num_batch_threads() {
  auto attr = num_batch_threadsAttr();
  return attr.getValue().getZExtValue();
}

::mlir::IntegerAttr BatchFunctionOp::max_batch_sizeAttr() {
  return this->getAttr("max_batch_size").cast<::mlir::IntegerAttr>();
}

uint64_t BatchFunctionOp::max_batch_size() {
  auto attr = max_batch_sizeAttr();
  return attr.getValue().getZExtValue();
}

::mlir::IntegerAttr BatchFunctionOp::batch_timeout_microsAttr() {
  return this->getAttr("batch_timeout_micros").cast<::mlir::IntegerAttr>();
}

uint64_t BatchFunctionOp::batch_timeout_micros() {
  auto attr = batch_timeout_microsAttr();
  return attr.getValue().getZExtValue();
}

::mlir::IntegerAttr BatchFunctionOp::max_enqueued_batchesAttr() {
  return this->getAttr("max_enqueued_batches").dyn_cast_or_null<::mlir::IntegerAttr>();
}

uint64_t BatchFunctionOp::max_enqueued_batches() {
  auto attr = max_enqueued_batchesAttr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getIntegerAttr(::mlir::Builder(this->getContext()).getIntegerType(64), 10).getValue().getZExtValue();
  return attr.getValue().getZExtValue();
}

::mlir::ArrayAttr BatchFunctionOp::allowed_batch_sizesAttr() {
  return this->getAttr("allowed_batch_sizes").dyn_cast_or_null<::mlir::ArrayAttr>();
}

::mlir::ArrayAttr BatchFunctionOp::allowed_batch_sizes() {
  auto attr = allowed_batch_sizesAttr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getI64ArrayAttr({});
  return attr;
}

::mlir::StringAttr BatchFunctionOp::containerAttr() {
  return this->getAttr("container").cast<::mlir::StringAttr>();
}

::llvm::StringRef BatchFunctionOp::container() {
  auto attr = containerAttr();
  return attr.getValue();
}

::mlir::StringAttr BatchFunctionOp::shared_nameAttr() {
  return this->getAttr("shared_name").cast<::mlir::StringAttr>();
}

::llvm::StringRef BatchFunctionOp::shared_name() {
  auto attr = shared_nameAttr();
  return attr.getValue();
}

::mlir::StringAttr BatchFunctionOp::batching_queueAttr() {
  return this->getAttr("batching_queue").cast<::mlir::StringAttr>();
}

::llvm::StringRef BatchFunctionOp::batching_queue() {
  auto attr = batching_queueAttr();
  return attr.getValue();
}

::mlir::BoolAttr BatchFunctionOp::enable_large_batch_splittingAttr() {
  return this->getAttr("enable_large_batch_splitting").dyn_cast_or_null<::mlir::BoolAttr>();
}

bool BatchFunctionOp::enable_large_batch_splitting() {
  auto attr = enable_large_batch_splittingAttr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getBoolAttr(false).getValue();
  return attr.getValue();
}

::mlir::DenseIntElementsAttr BatchFunctionOp::operand_segment_sizesAttr() {
  return this->getAttr("operand_segment_sizes").cast<::mlir::DenseIntElementsAttr>();
}

::mlir::DenseIntElementsAttr BatchFunctionOp::operand_segment_sizes() {
  auto attr = operand_segment_sizesAttr();
  return attr;
}

mlir::OperandElementTypeRange BatchFunctionOp::Tin() {
  auto values = getODSOperands(0);
return {mlir::OperandElementTypeIterator(values.begin()), mlir::OperandElementTypeIterator(values.end())};
}

mlir::OperandElementTypeRange BatchFunctionOp::Tcaptured() {
  auto values = getODSOperands(1);
return {mlir::OperandElementTypeIterator(values.begin()), mlir::OperandElementTypeIterator(values.end())};
}

mlir::ResultElementTypeRange BatchFunctionOp::Tout() {
  auto values = getODSResults(0);
return {mlir::ResultElementTypeIterator(values.begin()), mlir::ResultElementTypeIterator(values.end())};
}

bool BatchFunctionOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "Tin") return true;
  if (name == "Tcaptured") return true;
  if (name == "Tout") return true;
 return false;
}

::mlir::DictionaryAttr BatchFunctionOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("Tin", ctx),
ArrayAttr::get(
    [&]() {
      llvm::SmallVector<Attribute, 4> ret;
      for (auto t : Tin())
        ret.push_back(TypeAttr::get(t));
      return ret;
    }(), ctx)},
    {::mlir::Identifier::get("Tcaptured", ctx),
ArrayAttr::get(
    [&]() {
      llvm::SmallVector<Attribute, 4> ret;
      for (auto t : Tcaptured())
        ret.push_back(TypeAttr::get(t));
      return ret;
    }(), ctx)},
    {::mlir::Identifier::get("Tout", ctx),
ArrayAttr::get(
    [&]() {
      llvm::SmallVector<Attribute, 4> ret;
      for (auto t : Tout())
        ret.push_back(TypeAttr::get(t));
      return ret;
    }(), ctx)}
    }, ctx);
}

void BatchFunctionOp::fAttr(::mlir::SymbolRefAttr attr) {
  this->getOperation()->setAttr("f", attr);
}

void BatchFunctionOp::num_batch_threadsAttr(::mlir::IntegerAttr attr) {
  this->getOperation()->setAttr("num_batch_threads", attr);
}

void BatchFunctionOp::max_batch_sizeAttr(::mlir::IntegerAttr attr) {
  this->getOperation()->setAttr("max_batch_size", attr);
}

void BatchFunctionOp::batch_timeout_microsAttr(::mlir::IntegerAttr attr) {
  this->getOperation()->setAttr("batch_timeout_micros", attr);
}

void BatchFunctionOp::max_enqueued_batchesAttr(::mlir::IntegerAttr attr) {
  this->getOperation()->setAttr("max_enqueued_batches", attr);
}

void BatchFunctionOp::allowed_batch_sizesAttr(::mlir::ArrayAttr attr) {
  this->getOperation()->setAttr("allowed_batch_sizes", attr);
}

void BatchFunctionOp::containerAttr(::mlir::StringAttr attr) {
  this->getOperation()->setAttr("container", attr);
}

void BatchFunctionOp::shared_nameAttr(::mlir::StringAttr attr) {
  this->getOperation()->setAttr("shared_name", attr);
}

void BatchFunctionOp::batching_queueAttr(::mlir::StringAttr attr) {
  this->getOperation()->setAttr("batching_queue", attr);
}

void BatchFunctionOp::enable_large_batch_splittingAttr(::mlir::BoolAttr attr) {
  this->getOperation()->setAttr("enable_large_batch_splitting", attr);
}

void BatchFunctionOp::operand_segment_sizesAttr(::mlir::DenseIntElementsAttr attr) {
  this->getOperation()->setAttr("operand_segment_sizes", attr);
}

void BatchFunctionOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange out_tensors, ::mlir::ValueRange in_tensors, ::mlir::ValueRange captured_tensors, ::mlir::SymbolRefAttr f, ::mlir::IntegerAttr num_batch_threads, ::mlir::IntegerAttr max_batch_size, ::mlir::IntegerAttr batch_timeout_micros, ::mlir::IntegerAttr max_enqueued_batches, ::mlir::ArrayAttr allowed_batch_sizes, ::mlir::StringAttr container, ::mlir::StringAttr shared_name, ::mlir::StringAttr batching_queue, ::mlir::BoolAttr enable_large_batch_splitting, ::mlir::DenseIntElementsAttr operand_segment_sizes) {
  odsState.addOperands(in_tensors);
  odsState.addOperands(captured_tensors);
  odsState.addAttribute("operand_segment_sizes", odsBuilder.getI32VectorAttr({static_cast<int32_t>(in_tensors.size()), static_cast<int32_t>(captured_tensors.size())}));
  odsState.addAttribute("f", f);
  odsState.addAttribute("num_batch_threads", num_batch_threads);
  odsState.addAttribute("max_batch_size", max_batch_size);
  odsState.addAttribute("batch_timeout_micros", batch_timeout_micros);
  odsState.addAttribute("max_enqueued_batches", max_enqueued_batches);
  odsState.addAttribute("allowed_batch_sizes", allowed_batch_sizes);
  odsState.addAttribute("container", container);
  odsState.addAttribute("shared_name", shared_name);
  odsState.addAttribute("batching_queue", batching_queue);
  odsState.addAttribute("enable_large_batch_splitting", enable_large_batch_splitting);
  odsState.addAttribute("operand_segment_sizes", operand_segment_sizes);
  odsState.addTypes(out_tensors);
}

void BatchFunctionOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange out_tensors, ::mlir::ValueRange in_tensors, ::mlir::ValueRange captured_tensors, ::mlir::SymbolRefAttr f, uint64_t num_batch_threads, uint64_t max_batch_size, uint64_t batch_timeout_micros, uint64_t max_enqueued_batches, ::mlir::ArrayAttr allowed_batch_sizes, ::llvm::StringRef container, ::llvm::StringRef shared_name, ::llvm::StringRef batching_queue, bool enable_large_batch_splitting, ::mlir::DenseIntElementsAttr operand_segment_sizes) {
  odsState.addOperands(in_tensors);
  odsState.addOperands(captured_tensors);
  odsState.addAttribute("operand_segment_sizes", odsBuilder.getI32VectorAttr({static_cast<int32_t>(in_tensors.size()), static_cast<int32_t>(captured_tensors.size())}));
  odsState.addAttribute("f", f);
  odsState.addAttribute("num_batch_threads", odsBuilder.getIntegerAttr(odsBuilder.getIntegerType(64), num_batch_threads));
  odsState.addAttribute("max_batch_size", odsBuilder.getIntegerAttr(odsBuilder.getIntegerType(64), max_batch_size));
  odsState.addAttribute("batch_timeout_micros", odsBuilder.getIntegerAttr(odsBuilder.getIntegerType(64), batch_timeout_micros));
  odsState.addAttribute("max_enqueued_batches", odsBuilder.getIntegerAttr(odsBuilder.getIntegerType(64), max_enqueued_batches));
  odsState.addAttribute("allowed_batch_sizes", allowed_batch_sizes);
  odsState.addAttribute("container", odsBuilder.getStringAttr(container));
  odsState.addAttribute("shared_name", odsBuilder.getStringAttr(shared_name));
  odsState.addAttribute("batching_queue", odsBuilder.getStringAttr(batching_queue));
  odsState.addAttribute("enable_large_batch_splitting", odsBuilder.getBoolAttr(enable_large_batch_splitting));
  odsState.addAttribute("operand_segment_sizes", operand_segment_sizes);
  odsState.addTypes(out_tensors);
}

void BatchFunctionOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult BatchFunctionOp::verify() {
  if (failed(BatchFunctionOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>())))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::TensorFlowType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of tf.dtype values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>())))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::TensorFlowType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of tf.dtype values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>())))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::TensorFlowType>()))))) {
        return emitOpError("result #") << index << " must be tensor of tf.dtype values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::BatchMatMulOp definitions
//===----------------------------------------------------------------------===//

BatchMatMulOpAdaptor::BatchMatMulOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

BatchMatMulOpAdaptor::BatchMatMulOpAdaptor(BatchMatMulOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> BatchMatMulOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange BatchMatMulOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value BatchMatMulOpAdaptor::x() {
  return *getODSOperands(0).begin();
}

::mlir::Value BatchMatMulOpAdaptor::y() {
  return *getODSOperands(1).begin();
}

::mlir::BoolAttr BatchMatMulOpAdaptor::adj_x() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::BoolAttr attr = odsAttrs.get("adj_x").dyn_cast_or_null<::mlir::BoolAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getBoolAttr(false);
  return attr;
}

::mlir::BoolAttr BatchMatMulOpAdaptor::adj_y() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::BoolAttr attr = odsAttrs.get("adj_y").dyn_cast_or_null<::mlir::BoolAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getBoolAttr(false);
  return attr;
}

::mlir::LogicalResult BatchMatMulOpAdaptor::verify(::mlir::Location loc) {
  {
  auto tblgen_adj_x = odsAttrs.get("adj_x");
  if (tblgen_adj_x) {
    if (!((tblgen_adj_x.isa<::mlir::BoolAttr>()))) return emitError(loc, "'tf.BatchMatMul' op ""attribute 'adj_x' failed to satisfy constraint: bool attribute");
  }
  }
  {
  auto tblgen_adj_y = odsAttrs.get("adj_y");
  if (tblgen_adj_y) {
    if (!((tblgen_adj_y.isa<::mlir::BoolAttr>()))) return emitError(loc, "'tf.BatchMatMul' op ""attribute 'adj_y' failed to satisfy constraint: bool attribute");
  }
  }
  return ::mlir::success();
}

::llvm::StringRef BatchMatMulOp::getOperationName() {
  return "tf.BatchMatMul";
}

std::pair<unsigned, unsigned> BatchMatMulOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range BatchMatMulOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value BatchMatMulOp::x() {
  return *getODSOperands(0).begin();
}

::mlir::Value BatchMatMulOp::y() {
  return *getODSOperands(1).begin();
}

::mlir::MutableOperandRange BatchMatMulOp::xMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange BatchMatMulOp::yMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> BatchMatMulOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range BatchMatMulOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value BatchMatMulOp::output() {
  return *getODSResults(0).begin();
}

::mlir::BoolAttr BatchMatMulOp::adj_xAttr() {
  return this->getAttr("adj_x").dyn_cast_or_null<::mlir::BoolAttr>();
}

bool BatchMatMulOp::adj_x() {
  auto attr = adj_xAttr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getBoolAttr(false).getValue();
  return attr.getValue();
}

::mlir::BoolAttr BatchMatMulOp::adj_yAttr() {
  return this->getAttr("adj_y").dyn_cast_or_null<::mlir::BoolAttr>();
}

bool BatchMatMulOp::adj_y() {
  auto attr = adj_yAttr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getBoolAttr(false).getValue();
  return attr.getValue();
}

Type BatchMatMulOp::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

bool BatchMatMulOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "T") return true;
 return false;
}

::mlir::DictionaryAttr BatchMatMulOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())}
    }, ctx);
}

void BatchMatMulOp::adj_xAttr(::mlir::BoolAttr attr) {
  this->getOperation()->setAttr("adj_x", attr);
}

void BatchMatMulOp::adj_yAttr(::mlir::BoolAttr attr) {
  this->getOperation()->setAttr("adj_y", attr);
}

void BatchMatMulOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value x, ::mlir::Value y, ::mlir::BoolAttr adj_x, ::mlir::BoolAttr adj_y) {
  odsState.addOperands(x);
  odsState.addOperands(y);
  odsState.addAttribute("adj_x", adj_x);
  odsState.addAttribute("adj_y", adj_y);
  odsState.addTypes(output);
}

void BatchMatMulOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value x, ::mlir::Value y, ::mlir::BoolAttr adj_x, ::mlir::BoolAttr adj_y) {
  odsState.addOperands(x);
  odsState.addOperands(y);
  odsState.addAttribute("adj_x", adj_x);
  odsState.addAttribute("adj_y", adj_y);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void BatchMatMulOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value x, ::mlir::Value y, bool adj_x, bool adj_y) {
  odsState.addOperands(x);
  odsState.addOperands(y);
  odsState.addAttribute("adj_x", odsBuilder.getBoolAttr(adj_x));
  odsState.addAttribute("adj_y", odsBuilder.getBoolAttr(adj_y));
  odsState.addTypes(output);
}

void BatchMatMulOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value x, ::mlir::Value y, bool adj_x, bool adj_y) {
  odsState.addOperands(x);
  odsState.addOperands(y);
  odsState.addAttribute("adj_x", odsBuilder.getBoolAttr(adj_x));
  odsState.addAttribute("adj_y", odsBuilder.getBoolAttr(adj_y));
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void BatchMatMulOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult BatchMatMulOp::verify() {
  if (failed(BatchMatMulOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of bfloat16 or 128-bit complex or 64-bit complex or 16-bit float or 32-bit float or 64-bit float or 32-bit integer or 64-bit integer values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of bfloat16 or 128-bit complex or 64-bit complex or 16-bit float or 32-bit float or 64-bit float or 32-bit integer or 64-bit integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))))) {
        return emitOpError("result #") << index << " must be tensor of bfloat16 or 128-bit complex or 64-bit complex or 16-bit float or 32-bit float or 64-bit float or 32-bit integer or 64-bit integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}



void BatchMatMulOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::BatchMatMulV2Op definitions
//===----------------------------------------------------------------------===//

BatchMatMulV2OpAdaptor::BatchMatMulV2OpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

BatchMatMulV2OpAdaptor::BatchMatMulV2OpAdaptor(BatchMatMulV2Op&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> BatchMatMulV2OpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange BatchMatMulV2OpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value BatchMatMulV2OpAdaptor::x() {
  return *getODSOperands(0).begin();
}

::mlir::Value BatchMatMulV2OpAdaptor::y() {
  return *getODSOperands(1).begin();
}

::mlir::BoolAttr BatchMatMulV2OpAdaptor::adj_x() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::BoolAttr attr = odsAttrs.get("adj_x").dyn_cast_or_null<::mlir::BoolAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getBoolAttr(false);
  return attr;
}

::mlir::BoolAttr BatchMatMulV2OpAdaptor::adj_y() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::BoolAttr attr = odsAttrs.get("adj_y").dyn_cast_or_null<::mlir::BoolAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getBoolAttr(false);
  return attr;
}

::mlir::LogicalResult BatchMatMulV2OpAdaptor::verify(::mlir::Location loc) {
  {
  auto tblgen_adj_x = odsAttrs.get("adj_x");
  if (tblgen_adj_x) {
    if (!((tblgen_adj_x.isa<::mlir::BoolAttr>()))) return emitError(loc, "'tf.BatchMatMulV2' op ""attribute 'adj_x' failed to satisfy constraint: bool attribute");
  }
  }
  {
  auto tblgen_adj_y = odsAttrs.get("adj_y");
  if (tblgen_adj_y) {
    if (!((tblgen_adj_y.isa<::mlir::BoolAttr>()))) return emitError(loc, "'tf.BatchMatMulV2' op ""attribute 'adj_y' failed to satisfy constraint: bool attribute");
  }
  }
  return ::mlir::success();
}

::llvm::StringRef BatchMatMulV2Op::getOperationName() {
  return "tf.BatchMatMulV2";
}

std::pair<unsigned, unsigned> BatchMatMulV2Op::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range BatchMatMulV2Op::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value BatchMatMulV2Op::x() {
  return *getODSOperands(0).begin();
}

::mlir::Value BatchMatMulV2Op::y() {
  return *getODSOperands(1).begin();
}

::mlir::MutableOperandRange BatchMatMulV2Op::xMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange BatchMatMulV2Op::yMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> BatchMatMulV2Op::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range BatchMatMulV2Op::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value BatchMatMulV2Op::output() {
  return *getODSResults(0).begin();
}

::mlir::BoolAttr BatchMatMulV2Op::adj_xAttr() {
  return this->getAttr("adj_x").dyn_cast_or_null<::mlir::BoolAttr>();
}

bool BatchMatMulV2Op::adj_x() {
  auto attr = adj_xAttr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getBoolAttr(false).getValue();
  return attr.getValue();
}

::mlir::BoolAttr BatchMatMulV2Op::adj_yAttr() {
  return this->getAttr("adj_y").dyn_cast_or_null<::mlir::BoolAttr>();
}

bool BatchMatMulV2Op::adj_y() {
  auto attr = adj_yAttr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getBoolAttr(false).getValue();
  return attr.getValue();
}

Type BatchMatMulV2Op::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

bool BatchMatMulV2Op::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "T") return true;
 return false;
}

::mlir::DictionaryAttr BatchMatMulV2Op::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())}
    }, ctx);
}

void BatchMatMulV2Op::adj_xAttr(::mlir::BoolAttr attr) {
  this->getOperation()->setAttr("adj_x", attr);
}

void BatchMatMulV2Op::adj_yAttr(::mlir::BoolAttr attr) {
  this->getOperation()->setAttr("adj_y", attr);
}

void BatchMatMulV2Op::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value x, ::mlir::Value y, ::mlir::BoolAttr adj_x, ::mlir::BoolAttr adj_y) {
  odsState.addOperands(x);
  odsState.addOperands(y);
  odsState.addAttribute("adj_x", adj_x);
  odsState.addAttribute("adj_y", adj_y);
  odsState.addTypes(output);
}

void BatchMatMulV2Op::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value x, ::mlir::Value y, ::mlir::BoolAttr adj_x, ::mlir::BoolAttr adj_y) {
  odsState.addOperands(x);
  odsState.addOperands(y);
  odsState.addAttribute("adj_x", adj_x);
  odsState.addAttribute("adj_y", adj_y);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void BatchMatMulV2Op::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value x, ::mlir::Value y, bool adj_x, bool adj_y) {
  odsState.addOperands(x);
  odsState.addOperands(y);
  odsState.addAttribute("adj_x", odsBuilder.getBoolAttr(adj_x));
  odsState.addAttribute("adj_y", odsBuilder.getBoolAttr(adj_y));
  odsState.addTypes(output);
}

void BatchMatMulV2Op::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value x, ::mlir::Value y, bool adj_x, bool adj_y) {
  odsState.addOperands(x);
  odsState.addOperands(y);
  odsState.addAttribute("adj_x", odsBuilder.getBoolAttr(adj_x));
  odsState.addAttribute("adj_y", odsBuilder.getBoolAttr(adj_y));
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void BatchMatMulV2Op::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult BatchMatMulV2Op::verify() {
  if (failed(BatchMatMulV2OpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of bfloat16 or 128-bit complex or 64-bit complex or 16-bit float or 32-bit float or 64-bit float or 16-bit integer or 32-bit integer or 64-bit integer values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of bfloat16 or 128-bit complex or 64-bit complex or 16-bit float or 32-bit float or 64-bit float or 16-bit integer or 32-bit integer or 64-bit integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))))) {
        return emitOpError("result #") << index << " must be tensor of bfloat16 or 128-bit complex or 64-bit complex or 16-bit float or 32-bit float or 64-bit float or 16-bit integer or 32-bit integer or 64-bit integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  return Verify(*this);
}



void BatchMatMulV2Op::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::BatchNormWithGlobalNormalizationOp definitions
//===----------------------------------------------------------------------===//

BatchNormWithGlobalNormalizationOpAdaptor::BatchNormWithGlobalNormalizationOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

BatchNormWithGlobalNormalizationOpAdaptor::BatchNormWithGlobalNormalizationOpAdaptor(BatchNormWithGlobalNormalizationOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> BatchNormWithGlobalNormalizationOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange BatchNormWithGlobalNormalizationOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value BatchNormWithGlobalNormalizationOpAdaptor::t() {
  return *getODSOperands(0).begin();
}

::mlir::Value BatchNormWithGlobalNormalizationOpAdaptor::m() {
  return *getODSOperands(1).begin();
}

::mlir::Value BatchNormWithGlobalNormalizationOpAdaptor::v() {
  return *getODSOperands(2).begin();
}

::mlir::Value BatchNormWithGlobalNormalizationOpAdaptor::beta() {
  return *getODSOperands(3).begin();
}

::mlir::Value BatchNormWithGlobalNormalizationOpAdaptor::gamma() {
  return *getODSOperands(4).begin();
}

::mlir::FloatAttr BatchNormWithGlobalNormalizationOpAdaptor::variance_epsilon() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::FloatAttr attr = odsAttrs.get("variance_epsilon").cast<::mlir::FloatAttr>();
  return attr;
}

::mlir::BoolAttr BatchNormWithGlobalNormalizationOpAdaptor::scale_after_normalization() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::BoolAttr attr = odsAttrs.get("scale_after_normalization").cast<::mlir::BoolAttr>();
  return attr;
}

::mlir::LogicalResult BatchNormWithGlobalNormalizationOpAdaptor::verify(::mlir::Location loc) {
  {
  auto tblgen_variance_epsilon = odsAttrs.get("variance_epsilon");
  if (!tblgen_variance_epsilon) return emitError(loc, "'tf.BatchNormWithGlobalNormalization' op ""requires attribute 'variance_epsilon'");
    if (!(((tblgen_variance_epsilon.isa<::mlir::FloatAttr>())) && ((tblgen_variance_epsilon.cast<::mlir::FloatAttr>().getType().isF32())))) return emitError(loc, "'tf.BatchNormWithGlobalNormalization' op ""attribute 'variance_epsilon' failed to satisfy constraint: 32-bit float attribute");
  }
  {
  auto tblgen_scale_after_normalization = odsAttrs.get("scale_after_normalization");
  if (!tblgen_scale_after_normalization) return emitError(loc, "'tf.BatchNormWithGlobalNormalization' op ""requires attribute 'scale_after_normalization'");
    if (!((tblgen_scale_after_normalization.isa<::mlir::BoolAttr>()))) return emitError(loc, "'tf.BatchNormWithGlobalNormalization' op ""attribute 'scale_after_normalization' failed to satisfy constraint: bool attribute");
  }
  return ::mlir::success();
}

::llvm::StringRef BatchNormWithGlobalNormalizationOp::getOperationName() {
  return "tf.BatchNormWithGlobalNormalization";
}

std::pair<unsigned, unsigned> BatchNormWithGlobalNormalizationOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range BatchNormWithGlobalNormalizationOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value BatchNormWithGlobalNormalizationOp::t() {
  return *getODSOperands(0).begin();
}

::mlir::Value BatchNormWithGlobalNormalizationOp::m() {
  return *getODSOperands(1).begin();
}

::mlir::Value BatchNormWithGlobalNormalizationOp::v() {
  return *getODSOperands(2).begin();
}

::mlir::Value BatchNormWithGlobalNormalizationOp::beta() {
  return *getODSOperands(3).begin();
}

::mlir::Value BatchNormWithGlobalNormalizationOp::gamma() {
  return *getODSOperands(4).begin();
}

::mlir::MutableOperandRange BatchNormWithGlobalNormalizationOp::tMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange BatchNormWithGlobalNormalizationOp::mMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange BatchNormWithGlobalNormalizationOp::vMutable() {
  auto range = getODSOperandIndexAndLength(2);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange BatchNormWithGlobalNormalizationOp::betaMutable() {
  auto range = getODSOperandIndexAndLength(3);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange BatchNormWithGlobalNormalizationOp::gammaMutable() {
  auto range = getODSOperandIndexAndLength(4);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> BatchNormWithGlobalNormalizationOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range BatchNormWithGlobalNormalizationOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value BatchNormWithGlobalNormalizationOp::result() {
  return *getODSResults(0).begin();
}

::mlir::FloatAttr BatchNormWithGlobalNormalizationOp::variance_epsilonAttr() {
  return this->getAttr("variance_epsilon").cast<::mlir::FloatAttr>();
}

::llvm::APFloat BatchNormWithGlobalNormalizationOp::variance_epsilon() {
  auto attr = variance_epsilonAttr();
  return attr.getValue();
}

::mlir::BoolAttr BatchNormWithGlobalNormalizationOp::scale_after_normalizationAttr() {
  return this->getAttr("scale_after_normalization").cast<::mlir::BoolAttr>();
}

bool BatchNormWithGlobalNormalizationOp::scale_after_normalization() {
  auto attr = scale_after_normalizationAttr();
  return attr.getValue();
}

Type BatchNormWithGlobalNormalizationOp::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

bool BatchNormWithGlobalNormalizationOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "T") return true;
 return false;
}

::mlir::DictionaryAttr BatchNormWithGlobalNormalizationOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())}
    }, ctx);
}

void BatchNormWithGlobalNormalizationOp::variance_epsilonAttr(::mlir::FloatAttr attr) {
  this->getOperation()->setAttr("variance_epsilon", attr);
}

void BatchNormWithGlobalNormalizationOp::scale_after_normalizationAttr(::mlir::BoolAttr attr) {
  this->getOperation()->setAttr("scale_after_normalization", attr);
}

void BatchNormWithGlobalNormalizationOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value t, ::mlir::Value m, ::mlir::Value v, ::mlir::Value beta, ::mlir::Value gamma, ::mlir::FloatAttr variance_epsilon, ::mlir::BoolAttr scale_after_normalization) {
  odsState.addOperands(t);
  odsState.addOperands(m);
  odsState.addOperands(v);
  odsState.addOperands(beta);
  odsState.addOperands(gamma);
  odsState.addAttribute("variance_epsilon", variance_epsilon);
  odsState.addAttribute("scale_after_normalization", scale_after_normalization);
  odsState.addTypes(result);
}

void BatchNormWithGlobalNormalizationOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value t, ::mlir::Value m, ::mlir::Value v, ::mlir::Value beta, ::mlir::Value gamma, ::mlir::FloatAttr variance_epsilon, ::mlir::BoolAttr scale_after_normalization) {
  odsState.addOperands(t);
  odsState.addOperands(m);
  odsState.addOperands(v);
  odsState.addOperands(beta);
  odsState.addOperands(gamma);
  odsState.addAttribute("variance_epsilon", variance_epsilon);
  odsState.addAttribute("scale_after_normalization", scale_after_normalization);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void BatchNormWithGlobalNormalizationOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value t, ::mlir::Value m, ::mlir::Value v, ::mlir::Value beta, ::mlir::Value gamma, ::llvm::APFloat variance_epsilon, bool scale_after_normalization) {
  odsState.addOperands(t);
  odsState.addOperands(m);
  odsState.addOperands(v);
  odsState.addOperands(beta);
  odsState.addOperands(gamma);
  odsState.addAttribute("variance_epsilon", odsBuilder.getFloatAttr(odsBuilder.getF32Type(), variance_epsilon));
  odsState.addAttribute("scale_after_normalization", odsBuilder.getBoolAttr(scale_after_normalization));
  odsState.addTypes(result);
}

void BatchNormWithGlobalNormalizationOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value t, ::mlir::Value m, ::mlir::Value v, ::mlir::Value beta, ::mlir::Value gamma, ::llvm::APFloat variance_epsilon, bool scale_after_normalization) {
  odsState.addOperands(t);
  odsState.addOperands(m);
  odsState.addOperands(v);
  odsState.addOperands(beta);
  odsState.addOperands(gamma);
  odsState.addAttribute("variance_epsilon", odsBuilder.getFloatAttr(odsBuilder.getF32Type(), variance_epsilon));
  odsState.addAttribute("scale_after_normalization", odsBuilder.getBoolAttr(scale_after_normalization));
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void BatchNormWithGlobalNormalizationOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 5u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult BatchNormWithGlobalNormalizationOp::verify() {
  if (failed(BatchNormWithGlobalNormalizationOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of bfloat16 or 128-bit complex or 64-bit complex or 16-bit float or 32-bit float or 64-bit float or 16-bit integer or 32-bit integer or 64-bit integer or 8-bit integer or 32-bit quantized integer or 8-bit quantized integer or 8-bit quantized unsigned integer or 16-bit unsigned integer or 32-bit unsigned integer or 64-bit unsigned integer or 8-bit unsigned integer values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of bfloat16 or 128-bit complex or 64-bit complex or 16-bit float or 32-bit float or 64-bit float or 16-bit integer or 32-bit integer or 64-bit integer or 8-bit integer or 32-bit quantized integer or 8-bit quantized integer or 8-bit quantized unsigned integer or 16-bit unsigned integer or 32-bit unsigned integer or 64-bit unsigned integer or 8-bit unsigned integer values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup2 = getODSOperands(2);
    for (::mlir::Value v : valueGroup2) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of bfloat16 or 128-bit complex or 64-bit complex or 16-bit float or 32-bit float or 64-bit float or 16-bit integer or 32-bit integer or 64-bit integer or 8-bit integer or 32-bit quantized integer or 8-bit quantized integer or 8-bit quantized unsigned integer or 16-bit unsigned integer or 32-bit unsigned integer or 64-bit unsigned integer or 8-bit unsigned integer values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup3 = getODSOperands(3);
    for (::mlir::Value v : valueGroup3) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of bfloat16 or 128-bit complex or 64-bit complex or 16-bit float or 32-bit float or 64-bit float or 16-bit integer or 32-bit integer or 64-bit integer or 8-bit integer or 32-bit quantized integer or 8-bit quantized integer or 8-bit quantized unsigned integer or 16-bit unsigned integer or 32-bit unsigned integer or 64-bit unsigned integer or 8-bit unsigned integer values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup4 = getODSOperands(4);
    for (::mlir::Value v : valueGroup4) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of bfloat16 or 128-bit complex or 64-bit complex or 16-bit float or 32-bit float or 64-bit float or 16-bit integer or 32-bit integer or 64-bit integer or 8-bit integer or 32-bit quantized integer or 8-bit quantized integer or 8-bit quantized unsigned integer or 16-bit unsigned integer or 32-bit unsigned integer or 64-bit unsigned integer or 8-bit unsigned integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>())))))) {
        return emitOpError("result #") << index << " must be tensor of bfloat16 or 128-bit complex or 64-bit complex or 16-bit float or 32-bit float or 64-bit float or 16-bit integer or 32-bit integer or 64-bit integer or 8-bit integer or 32-bit quantized integer or 8-bit quantized integer or 8-bit quantized unsigned integer or 16-bit unsigned integer or 32-bit unsigned integer or 64-bit unsigned integer or 8-bit unsigned integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void BatchNormWithGlobalNormalizationOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::BatchToSpaceNDOp definitions
//===----------------------------------------------------------------------===//

BatchToSpaceNDOpAdaptor::BatchToSpaceNDOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

BatchToSpaceNDOpAdaptor::BatchToSpaceNDOpAdaptor(BatchToSpaceNDOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> BatchToSpaceNDOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange BatchToSpaceNDOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value BatchToSpaceNDOpAdaptor::input() {
  return *getODSOperands(0).begin();
}

::mlir::Value BatchToSpaceNDOpAdaptor::block_shape() {
  return *getODSOperands(1).begin();
}

::mlir::Value BatchToSpaceNDOpAdaptor::crops() {
  return *getODSOperands(2).begin();
}

::mlir::LogicalResult BatchToSpaceNDOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

::llvm::StringRef BatchToSpaceNDOp::getOperationName() {
  return "tf.BatchToSpaceND";
}

std::pair<unsigned, unsigned> BatchToSpaceNDOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range BatchToSpaceNDOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value BatchToSpaceNDOp::input() {
  return *getODSOperands(0).begin();
}

::mlir::Value BatchToSpaceNDOp::block_shape() {
  return *getODSOperands(1).begin();
}

::mlir::Value BatchToSpaceNDOp::crops() {
  return *getODSOperands(2).begin();
}

::mlir::MutableOperandRange BatchToSpaceNDOp::inputMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange BatchToSpaceNDOp::block_shapeMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange BatchToSpaceNDOp::cropsMutable() {
  auto range = getODSOperandIndexAndLength(2);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> BatchToSpaceNDOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range BatchToSpaceNDOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value BatchToSpaceNDOp::output() {
  return *getODSResults(0).begin();
}

Type BatchToSpaceNDOp::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

Type BatchToSpaceNDOp::Tcrops() {
  return mlir::getElementTypeOrSelf(*getODSOperands(2).begin());
}

Type BatchToSpaceNDOp::Tblock_shape() {
  return mlir::getElementTypeOrSelf(*getODSOperands(1).begin());
}

bool BatchToSpaceNDOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "T") return true;
  if (name == "Tcrops") return true;
  if (name == "Tblock_shape") return true;
 return false;
}

::mlir::DictionaryAttr BatchToSpaceNDOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())},
    {::mlir::Identifier::get("Tcrops", ctx),
::mlir::TypeAttr::get(Tcrops())},
    {::mlir::Identifier::get("Tblock_shape", ctx),
::mlir::TypeAttr::get(Tblock_shape())}
    }, ctx);
}

void BatchToSpaceNDOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value input, ::mlir::Value block_shape, ::mlir::Value crops) {
  odsState.addOperands(input);
  odsState.addOperands(block_shape);
  odsState.addOperands(crops);
  odsState.addTypes(output);
}

void BatchToSpaceNDOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input, ::mlir::Value block_shape, ::mlir::Value crops) {
  odsState.addOperands(input);
  odsState.addOperands(block_shape);
  odsState.addOperands(crops);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void BatchToSpaceNDOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 3u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult BatchToSpaceNDOp::verify() {
  if (failed(BatchToSpaceNDOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>())))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::TensorFlowType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of tf.dtype values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of 32/64-bit signed integer values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup2 = getODSOperands(2);
    for (::mlir::Value v : valueGroup2) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of 32/64-bit signed integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>())))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::TensorFlowType>()))))) {
        return emitOpError("result #") << index << " must be tensor of tf.dtype values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void BatchToSpaceNDOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::BatchToSpaceOp definitions
//===----------------------------------------------------------------------===//

BatchToSpaceOpAdaptor::BatchToSpaceOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

BatchToSpaceOpAdaptor::BatchToSpaceOpAdaptor(BatchToSpaceOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> BatchToSpaceOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange BatchToSpaceOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value BatchToSpaceOpAdaptor::input() {
  return *getODSOperands(0).begin();
}

::mlir::Value BatchToSpaceOpAdaptor::crops() {
  return *getODSOperands(1).begin();
}

::mlir::IntegerAttr BatchToSpaceOpAdaptor::block_size() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::IntegerAttr attr = odsAttrs.get("block_size").cast<::mlir::IntegerAttr>();
  return attr;
}

::mlir::LogicalResult BatchToSpaceOpAdaptor::verify(::mlir::Location loc) {
  {
  auto tblgen_block_size = odsAttrs.get("block_size");
  if (!tblgen_block_size) return emitError(loc, "'tf.BatchToSpace' op ""requires attribute 'block_size'");
    if (!((((tblgen_block_size.isa<::mlir::IntegerAttr>())) && ((tblgen_block_size.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(64)))) && ((tblgen_block_size.cast<::mlir::IntegerAttr>().getInt() >= 2)))) return emitError(loc, "'tf.BatchToSpace' op ""attribute 'block_size' failed to satisfy constraint: 64-bit signless integer attribute whose minimum value is 2");
  }
  return ::mlir::success();
}

::llvm::StringRef BatchToSpaceOp::getOperationName() {
  return "tf.BatchToSpace";
}

std::pair<unsigned, unsigned> BatchToSpaceOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range BatchToSpaceOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value BatchToSpaceOp::input() {
  return *getODSOperands(0).begin();
}

::mlir::Value BatchToSpaceOp::crops() {
  return *getODSOperands(1).begin();
}

::mlir::MutableOperandRange BatchToSpaceOp::inputMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange BatchToSpaceOp::cropsMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> BatchToSpaceOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range BatchToSpaceOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value BatchToSpaceOp::output() {
  return *getODSResults(0).begin();
}

::mlir::IntegerAttr BatchToSpaceOp::block_sizeAttr() {
  return this->getAttr("block_size").cast<::mlir::IntegerAttr>();
}

uint64_t BatchToSpaceOp::block_size() {
  auto attr = block_sizeAttr();
  return attr.getValue().getZExtValue();
}

Type BatchToSpaceOp::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

Type BatchToSpaceOp::Tidx() {
  return mlir::getElementTypeOrSelf(*getODSOperands(1).begin());
}

bool BatchToSpaceOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "T") return true;
  if (name == "Tidx") return true;
 return false;
}

::mlir::DictionaryAttr BatchToSpaceOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())},
    {::mlir::Identifier::get("Tidx", ctx),
::mlir::TypeAttr::get(Tidx())}
    }, ctx);
}

void BatchToSpaceOp::block_sizeAttr(::mlir::IntegerAttr attr) {
  this->getOperation()->setAttr("block_size", attr);
}

void BatchToSpaceOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value input, ::mlir::Value crops, ::mlir::IntegerAttr block_size) {
  odsState.addOperands(input);
  odsState.addOperands(crops);
  odsState.addAttribute("block_size", block_size);
  odsState.addTypes(output);
}

void BatchToSpaceOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input, ::mlir::Value crops, ::mlir::IntegerAttr block_size) {
  odsState.addOperands(input);
  odsState.addOperands(crops);
  odsState.addAttribute("block_size", block_size);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void BatchToSpaceOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value input, ::mlir::Value crops, uint64_t block_size) {
  odsState.addOperands(input);
  odsState.addOperands(crops);
  odsState.addAttribute("block_size", odsBuilder.getIntegerAttr(odsBuilder.getIntegerType(64), block_size));
  odsState.addTypes(output);
}

void BatchToSpaceOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input, ::mlir::Value crops, uint64_t block_size) {
  odsState.addOperands(input);
  odsState.addOperands(crops);
  odsState.addAttribute("block_size", odsBuilder.getIntegerAttr(odsBuilder.getIntegerType(64), block_size));
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void BatchToSpaceOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult BatchToSpaceOp::verify() {
  if (failed(BatchToSpaceOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>())))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::TensorFlowType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of tf.dtype values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of 32/64-bit signed integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>())))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::TensorFlowType>()))))) {
        return emitOpError("result #") << index << " must be tensor of tf.dtype values, but got " << v.getType();
      }
      ++index;
    }
  }
  return Verify(*this);
}



void BatchToSpaceOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::BesselI0eOp definitions
//===----------------------------------------------------------------------===//

BesselI0eOpAdaptor::BesselI0eOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

BesselI0eOpAdaptor::BesselI0eOpAdaptor(BesselI0eOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> BesselI0eOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange BesselI0eOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value BesselI0eOpAdaptor::x() {
  return *getODSOperands(0).begin();
}

::mlir::LogicalResult BesselI0eOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

::llvm::StringRef BesselI0eOp::getOperationName() {
  return "tf.BesselI0e";
}

std::pair<unsigned, unsigned> BesselI0eOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range BesselI0eOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value BesselI0eOp::x() {
  return *getODSOperands(0).begin();
}

::mlir::MutableOperandRange BesselI0eOp::xMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> BesselI0eOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range BesselI0eOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value BesselI0eOp::y() {
  return *getODSResults(0).begin();
}

Type BesselI0eOp::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

bool BesselI0eOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "T") return true;
 return false;
}

::mlir::DictionaryAttr BesselI0eOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())}
    }, ctx);
}

void BesselI0eOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type y, ::mlir::Value x) {
  odsState.addOperands(x);
  odsState.addTypes(y);
}

void BesselI0eOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value x) {
  odsState.addOperands(x);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void BesselI0eOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

void BesselI0eOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value x) {
  odsState.addOperands(x);
  odsState.addTypes({x.getType()});

}

void BesselI0eOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  odsState.addTypes({operands[0].getType()});

}

::mlir::LogicalResult BesselI0eOp::verify() {
  if (failed(BesselI0eOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of floating-point values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))))) {
        return emitOpError("result #") << index << " must be tensor of floating-point values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void BesselI0eOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::BesselI1eOp definitions
//===----------------------------------------------------------------------===//

BesselI1eOpAdaptor::BesselI1eOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

BesselI1eOpAdaptor::BesselI1eOpAdaptor(BesselI1eOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> BesselI1eOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange BesselI1eOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value BesselI1eOpAdaptor::x() {
  return *getODSOperands(0).begin();
}

::mlir::LogicalResult BesselI1eOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

::llvm::StringRef BesselI1eOp::getOperationName() {
  return "tf.BesselI1e";
}

std::pair<unsigned, unsigned> BesselI1eOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range BesselI1eOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value BesselI1eOp::x() {
  return *getODSOperands(0).begin();
}

::mlir::MutableOperandRange BesselI1eOp::xMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> BesselI1eOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range BesselI1eOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value BesselI1eOp::y() {
  return *getODSResults(0).begin();
}

Type BesselI1eOp::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

bool BesselI1eOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "T") return true;
 return false;
}

::mlir::DictionaryAttr BesselI1eOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())}
    }, ctx);
}

void BesselI1eOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type y, ::mlir::Value x) {
  odsState.addOperands(x);
  odsState.addTypes(y);
}

void BesselI1eOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value x) {
  odsState.addOperands(x);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void BesselI1eOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

void BesselI1eOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value x) {
  odsState.addOperands(x);
  odsState.addTypes({x.getType()});

}

void BesselI1eOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  odsState.addTypes({operands[0].getType()});

}

::mlir::LogicalResult BesselI1eOp::verify() {
  if (failed(BesselI1eOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of floating-point values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))))) {
        return emitOpError("result #") << index << " must be tensor of floating-point values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void BesselI1eOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::BetaincOp definitions
//===----------------------------------------------------------------------===//

BetaincOpAdaptor::BetaincOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

BetaincOpAdaptor::BetaincOpAdaptor(BetaincOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> BetaincOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange BetaincOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value BetaincOpAdaptor::a() {
  return *getODSOperands(0).begin();
}

::mlir::Value BetaincOpAdaptor::b() {
  return *getODSOperands(1).begin();
}

::mlir::Value BetaincOpAdaptor::x() {
  return *getODSOperands(2).begin();
}

::mlir::LogicalResult BetaincOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

::llvm::StringRef BetaincOp::getOperationName() {
  return "tf.Betainc";
}

std::pair<unsigned, unsigned> BetaincOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range BetaincOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value BetaincOp::a() {
  return *getODSOperands(0).begin();
}

::mlir::Value BetaincOp::b() {
  return *getODSOperands(1).begin();
}

::mlir::Value BetaincOp::x() {
  return *getODSOperands(2).begin();
}

::mlir::MutableOperandRange BetaincOp::aMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange BetaincOp::bMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange BetaincOp::xMutable() {
  auto range = getODSOperandIndexAndLength(2);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> BetaincOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range BetaincOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value BetaincOp::z() {
  return *getODSResults(0).begin();
}

Type BetaincOp::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

bool BetaincOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "T") return true;
 return false;
}

::mlir::DictionaryAttr BetaincOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())}
    }, ctx);
}

void BetaincOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type z, ::mlir::Value a, ::mlir::Value b, ::mlir::Value x) {
  odsState.addOperands(a);
  odsState.addOperands(b);
  odsState.addOperands(x);
  odsState.addTypes(z);
}

void BetaincOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value a, ::mlir::Value b, ::mlir::Value x) {
  odsState.addOperands(a);
  odsState.addOperands(b);
  odsState.addOperands(x);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void BetaincOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 3u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult BetaincOp::verify() {
  if (failed(BetaincOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of 32/64-bit float values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of 32/64-bit float values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup2 = getODSOperands(2);
    for (::mlir::Value v : valueGroup2) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of 32/64-bit float values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())))))) {
        return emitOpError("result #") << index << " must be tensor of 32/64-bit float values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void BetaincOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::BiasAddGradOp definitions
//===----------------------------------------------------------------------===//

BiasAddGradOpAdaptor::BiasAddGradOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

BiasAddGradOpAdaptor::BiasAddGradOpAdaptor(BiasAddGradOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> BiasAddGradOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange BiasAddGradOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value BiasAddGradOpAdaptor::out_backprop() {
  return *getODSOperands(0).begin();
}

::mlir::StringAttr BiasAddGradOpAdaptor::data_format() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::StringAttr attr = odsAttrs.get("data_format").dyn_cast_or_null<::mlir::StringAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getStringAttr("NHWC");
  return attr;
}

::mlir::LogicalResult BiasAddGradOpAdaptor::verify(::mlir::Location loc) {
  {
  auto tblgen_data_format = odsAttrs.get("data_format");
  if (tblgen_data_format) {
    if (!((tblgen_data_format.cast<StringAttr>().getValue() == "NHWC" || tblgen_data_format.cast<StringAttr>().getValue() == "NCHW"))) return emitError(loc, "'tf.BiasAddGrad' op ""attribute 'data_format' failed to satisfy constraint: 'NHWC' or 'NCHW' convnet data format");
  }
  }
  return ::mlir::success();
}

::llvm::StringRef BiasAddGradOp::getOperationName() {
  return "tf.BiasAddGrad";
}

std::pair<unsigned, unsigned> BiasAddGradOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range BiasAddGradOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value BiasAddGradOp::out_backprop() {
  return *getODSOperands(0).begin();
}

::mlir::MutableOperandRange BiasAddGradOp::out_backpropMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> BiasAddGradOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range BiasAddGradOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value BiasAddGradOp::output() {
  return *getODSResults(0).begin();
}

::mlir::StringAttr BiasAddGradOp::data_formatAttr() {
  return this->getAttr("data_format").dyn_cast_or_null<::mlir::StringAttr>();
}

::llvm::StringRef BiasAddGradOp::data_format() {
  auto attr = data_formatAttr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getStringAttr("NHWC").getValue();
  return attr.getValue();
}

Type BiasAddGradOp::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

bool BiasAddGradOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "T") return true;
 return false;
}

::mlir::DictionaryAttr BiasAddGradOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())}
    }, ctx);
}

void BiasAddGradOp::data_formatAttr(::mlir::StringAttr attr) {
  this->getOperation()->setAttr("data_format", attr);
}

void BiasAddGradOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value out_backprop, ::mlir::StringAttr data_format) {
  odsState.addOperands(out_backprop);
  odsState.addAttribute("data_format", data_format);
  odsState.addTypes(output);
}

void BiasAddGradOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value out_backprop, ::mlir::StringAttr data_format) {
  odsState.addOperands(out_backprop);
  odsState.addAttribute("data_format", data_format);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void BiasAddGradOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value out_backprop, ::llvm::StringRef data_format) {
  odsState.addOperands(out_backprop);
  odsState.addAttribute("data_format", odsBuilder.getStringAttr(data_format));
  odsState.addTypes(output);
}

void BiasAddGradOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value out_backprop, ::llvm::StringRef data_format) {
  odsState.addOperands(out_backprop);
  odsState.addAttribute("data_format", odsBuilder.getStringAttr(data_format));
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void BiasAddGradOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult BiasAddGradOp::verify() {
  if (failed(BiasAddGradOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of bfloat16 or 128-bit complex or 64-bit complex or 16-bit float or 32-bit float or 64-bit float or 16-bit integer or 32-bit integer or 64-bit integer or 8-bit integer or 32-bit quantized integer or 8-bit quantized integer or 8-bit quantized unsigned integer or 16-bit unsigned integer or 32-bit unsigned integer or 64-bit unsigned integer or 8-bit unsigned integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>())))))) {
        return emitOpError("result #") << index << " must be tensor of bfloat16 or 128-bit complex or 64-bit complex or 16-bit float or 32-bit float or 64-bit float or 16-bit integer or 32-bit integer or 64-bit integer or 8-bit integer or 32-bit quantized integer or 8-bit quantized integer or 8-bit quantized unsigned integer or 16-bit unsigned integer or 32-bit unsigned integer or 64-bit unsigned integer or 8-bit unsigned integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  return Verify(*this);
}

void BiasAddGradOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::BiasAddOp definitions
//===----------------------------------------------------------------------===//

BiasAddOpAdaptor::BiasAddOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

BiasAddOpAdaptor::BiasAddOpAdaptor(BiasAddOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> BiasAddOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange BiasAddOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value BiasAddOpAdaptor::value() {
  return *getODSOperands(0).begin();
}

::mlir::Value BiasAddOpAdaptor::bias() {
  return *getODSOperands(1).begin();
}

::mlir::StringAttr BiasAddOpAdaptor::data_format() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::StringAttr attr = odsAttrs.get("data_format").dyn_cast_or_null<::mlir::StringAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getStringAttr("NHWC");
  return attr;
}

::mlir::LogicalResult BiasAddOpAdaptor::verify(::mlir::Location loc) {
  {
  auto tblgen_data_format = odsAttrs.get("data_format");
  if (tblgen_data_format) {
    if (!((tblgen_data_format.cast<StringAttr>().getValue() == "NHWC" || tblgen_data_format.cast<StringAttr>().getValue() == "NCHW"))) return emitError(loc, "'tf.BiasAdd' op ""attribute 'data_format' failed to satisfy constraint: 'NHWC' or 'NCHW' convnet data format");
  }
  }
  return ::mlir::success();
}

::llvm::StringRef BiasAddOp::getOperationName() {
  return "tf.BiasAdd";
}

std::pair<unsigned, unsigned> BiasAddOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range BiasAddOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value BiasAddOp::value() {
  return *getODSOperands(0).begin();
}

::mlir::Value BiasAddOp::bias() {
  return *getODSOperands(1).begin();
}

::mlir::MutableOperandRange BiasAddOp::valueMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange BiasAddOp::biasMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> BiasAddOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range BiasAddOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value BiasAddOp::output() {
  return *getODSResults(0).begin();
}

::mlir::StringAttr BiasAddOp::data_formatAttr() {
  return this->getAttr("data_format").dyn_cast_or_null<::mlir::StringAttr>();
}

::llvm::StringRef BiasAddOp::data_format() {
  auto attr = data_formatAttr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getStringAttr("NHWC").getValue();
  return attr.getValue();
}

Type BiasAddOp::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

bool BiasAddOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "T") return true;
 return false;
}

::mlir::DictionaryAttr BiasAddOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())}
    }, ctx);
}

void BiasAddOp::data_formatAttr(::mlir::StringAttr attr) {
  this->getOperation()->setAttr("data_format", attr);
}

void BiasAddOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value value, ::mlir::Value bias, ::mlir::StringAttr data_format) {
  odsState.addOperands(value);
  odsState.addOperands(bias);
  odsState.addAttribute("data_format", data_format);
  odsState.addTypes(output);
}

void BiasAddOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value value, ::mlir::Value bias, ::mlir::StringAttr data_format) {
  odsState.addOperands(value);
  odsState.addOperands(bias);
  odsState.addAttribute("data_format", data_format);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void BiasAddOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value value, ::mlir::Value bias, ::llvm::StringRef data_format) {
  odsState.addOperands(value);
  odsState.addOperands(bias);
  odsState.addAttribute("data_format", odsBuilder.getStringAttr(data_format));
  odsState.addTypes(output);
}

void BiasAddOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value value, ::mlir::Value bias, ::llvm::StringRef data_format) {
  odsState.addOperands(value);
  odsState.addOperands(bias);
  odsState.addAttribute("data_format", odsBuilder.getStringAttr(data_format));
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void BiasAddOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult BiasAddOp::verify() {
  if (failed(BiasAddOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of bfloat16 or 128-bit complex or 64-bit complex or 16-bit float or 32-bit float or 64-bit float or 16-bit integer or 32-bit integer or 64-bit integer or 8-bit integer or 32-bit quantized integer or 8-bit quantized integer or 8-bit quantized unsigned integer or 16-bit unsigned integer or 32-bit unsigned integer or 64-bit unsigned integer or 8-bit unsigned integer values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of bfloat16 or 128-bit complex or 64-bit complex or 16-bit float or 32-bit float or 64-bit float or 16-bit integer or 32-bit integer or 64-bit integer or 8-bit integer or 32-bit quantized integer or 8-bit quantized integer or 8-bit quantized unsigned integer or 16-bit unsigned integer or 32-bit unsigned integer or 64-bit unsigned integer or 8-bit unsigned integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>())))))) {
        return emitOpError("result #") << index << " must be tensor of bfloat16 or 128-bit complex or 64-bit complex or 16-bit float or 32-bit float or 64-bit float or 16-bit integer or 32-bit integer or 64-bit integer or 8-bit integer or 32-bit quantized integer or 8-bit quantized integer or 8-bit quantized unsigned integer or 16-bit unsigned integer or 32-bit unsigned integer or 64-bit unsigned integer or 8-bit unsigned integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  return Verify(*this);
}

void BiasAddOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::BiasAddV1Op definitions
//===----------------------------------------------------------------------===//

BiasAddV1OpAdaptor::BiasAddV1OpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

BiasAddV1OpAdaptor::BiasAddV1OpAdaptor(BiasAddV1Op&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> BiasAddV1OpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange BiasAddV1OpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value BiasAddV1OpAdaptor::value() {
  return *getODSOperands(0).begin();
}

::mlir::Value BiasAddV1OpAdaptor::bias() {
  return *getODSOperands(1).begin();
}

::mlir::LogicalResult BiasAddV1OpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

::llvm::StringRef BiasAddV1Op::getOperationName() {
  return "tf.BiasAddV1";
}

std::pair<unsigned, unsigned> BiasAddV1Op::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range BiasAddV1Op::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value BiasAddV1Op::value() {
  return *getODSOperands(0).begin();
}

::mlir::Value BiasAddV1Op::bias() {
  return *getODSOperands(1).begin();
}

::mlir::MutableOperandRange BiasAddV1Op::valueMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange BiasAddV1Op::biasMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> BiasAddV1Op::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range BiasAddV1Op::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value BiasAddV1Op::output() {
  return *getODSResults(0).begin();
}

Type BiasAddV1Op::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

bool BiasAddV1Op::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "T") return true;
 return false;
}

::mlir::DictionaryAttr BiasAddV1Op::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())}
    }, ctx);
}

void BiasAddV1Op::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value value, ::mlir::Value bias) {
  odsState.addOperands(value);
  odsState.addOperands(bias);
  odsState.addTypes(output);
}

void BiasAddV1Op::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value value, ::mlir::Value bias) {
  odsState.addOperands(value);
  odsState.addOperands(bias);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void BiasAddV1Op::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult BiasAddV1Op::verify() {
  if (failed(BiasAddV1OpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of bfloat16 or 128-bit complex or 64-bit complex or 16-bit float or 32-bit float or 64-bit float or 16-bit integer or 32-bit integer or 64-bit integer or 8-bit integer or 32-bit quantized integer or 8-bit quantized integer or 8-bit quantized unsigned integer or 16-bit unsigned integer or 32-bit unsigned integer or 64-bit unsigned integer or 8-bit unsigned integer values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of bfloat16 or 128-bit complex or 64-bit complex or 16-bit float or 32-bit float or 64-bit float or 16-bit integer or 32-bit integer or 64-bit integer or 8-bit integer or 32-bit quantized integer or 8-bit quantized integer or 8-bit quantized unsigned integer or 16-bit unsigned integer or 32-bit unsigned integer or 64-bit unsigned integer or 8-bit unsigned integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>())))))) {
        return emitOpError("result #") << index << " must be tensor of bfloat16 or 128-bit complex or 64-bit complex or 16-bit float or 32-bit float or 64-bit float or 16-bit integer or 32-bit integer or 64-bit integer or 8-bit integer or 32-bit quantized integer or 8-bit quantized integer or 8-bit quantized unsigned integer or 16-bit unsigned integer or 32-bit unsigned integer or 64-bit unsigned integer or 8-bit unsigned integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}



void BiasAddV1Op::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::BitcastOp definitions
//===----------------------------------------------------------------------===//

BitcastOpAdaptor::BitcastOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

BitcastOpAdaptor::BitcastOpAdaptor(BitcastOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> BitcastOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange BitcastOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value BitcastOpAdaptor::input() {
  return *getODSOperands(0).begin();
}

::mlir::LogicalResult BitcastOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

::llvm::StringRef BitcastOp::getOperationName() {
  return "tf.Bitcast";
}

std::pair<unsigned, unsigned> BitcastOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range BitcastOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value BitcastOp::input() {
  return *getODSOperands(0).begin();
}

::mlir::MutableOperandRange BitcastOp::inputMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> BitcastOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range BitcastOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value BitcastOp::output() {
  return *getODSResults(0).begin();
}

Type BitcastOp::type() {
  return mlir::getElementTypeOrSelf(*getODSResults(0).begin());
}

Type BitcastOp::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

bool BitcastOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "type") return true;
  if (name == "T") return true;
 return false;
}

::mlir::DictionaryAttr BitcastOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("type", ctx),
::mlir::TypeAttr::get(type())},
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())}
    }, ctx);
}

void BitcastOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value input) {
  odsState.addOperands(input);
  odsState.addTypes(output);
}

void BitcastOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input) {
  odsState.addOperands(input);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void BitcastOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult BitcastOp::verify() {
  if (failed(BitcastOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint16Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint16Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint16RefType>())))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))))))) {
        return emitOpError("operand #") << index << " must be tensor of number values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint16Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint16Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint16RefType>())))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))))))) {
        return emitOpError("result #") << index << " must be tensor of number values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}



void BitcastOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::BitwiseAndOp definitions
//===----------------------------------------------------------------------===//

BitwiseAndOpAdaptor::BitwiseAndOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

BitwiseAndOpAdaptor::BitwiseAndOpAdaptor(BitwiseAndOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> BitwiseAndOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange BitwiseAndOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value BitwiseAndOpAdaptor::x() {
  return *getODSOperands(0).begin();
}

::mlir::Value BitwiseAndOpAdaptor::y() {
  return *getODSOperands(1).begin();
}

::mlir::LogicalResult BitwiseAndOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

::llvm::StringRef BitwiseAndOp::getOperationName() {
  return "tf.BitwiseAnd";
}

std::pair<unsigned, unsigned> BitwiseAndOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range BitwiseAndOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value BitwiseAndOp::x() {
  return *getODSOperands(0).begin();
}

::mlir::Value BitwiseAndOp::y() {
  return *getODSOperands(1).begin();
}

::mlir::MutableOperandRange BitwiseAndOp::xMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange BitwiseAndOp::yMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> BitwiseAndOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range BitwiseAndOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value BitwiseAndOp::z() {
  return *getODSResults(0).begin();
}

Type BitwiseAndOp::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

bool BitwiseAndOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "T") return true;
 return false;
}

::mlir::DictionaryAttr BitwiseAndOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())}
    }, ctx);
}

void BitwiseAndOp::build(OpBuilder &builder, OperationState &result, Value  x, Value  y) {
  auto resultType =
      OpTrait::util::getBroadcastedType(x.getType(), y.getType());
  if (!resultType)
    mlir::emitError(result.location, "non-broadcastable operands");
  return build(builder, result, resultType, x, y);
}

void BitwiseAndOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type z, ::mlir::Value x, ::mlir::Value y) {
  odsState.addOperands(x);
  odsState.addOperands(y);
  odsState.addTypes(z);
}

void BitwiseAndOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value x, ::mlir::Value y) {
  odsState.addOperands(x);
  odsState.addOperands(y);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void BitwiseAndOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult BitwiseAndOp::verify() {
  if (failed(BitwiseAndOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))))) {
        return emitOpError("operand #") << index << " must be tensor of integer values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))))) {
        return emitOpError("operand #") << index << " must be tensor of integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))))) {
        return emitOpError("result #") << index << " must be tensor of integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void BitwiseAndOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::BitwiseOrOp definitions
//===----------------------------------------------------------------------===//

BitwiseOrOpAdaptor::BitwiseOrOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

BitwiseOrOpAdaptor::BitwiseOrOpAdaptor(BitwiseOrOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> BitwiseOrOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange BitwiseOrOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value BitwiseOrOpAdaptor::x() {
  return *getODSOperands(0).begin();
}

::mlir::Value BitwiseOrOpAdaptor::y() {
  return *getODSOperands(1).begin();
}

::mlir::LogicalResult BitwiseOrOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

::llvm::StringRef BitwiseOrOp::getOperationName() {
  return "tf.BitwiseOr";
}

std::pair<unsigned, unsigned> BitwiseOrOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range BitwiseOrOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value BitwiseOrOp::x() {
  return *getODSOperands(0).begin();
}

::mlir::Value BitwiseOrOp::y() {
  return *getODSOperands(1).begin();
}

::mlir::MutableOperandRange BitwiseOrOp::xMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange BitwiseOrOp::yMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> BitwiseOrOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range BitwiseOrOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value BitwiseOrOp::z() {
  return *getODSResults(0).begin();
}

Type BitwiseOrOp::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

bool BitwiseOrOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "T") return true;
 return false;
}

::mlir::DictionaryAttr BitwiseOrOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())}
    }, ctx);
}

void BitwiseOrOp::build(OpBuilder &builder, OperationState &result, Value  x, Value  y) {
  auto resultType =
      OpTrait::util::getBroadcastedType(x.getType(), y.getType());
  if (!resultType)
    mlir::emitError(result.location, "non-broadcastable operands");
  return build(builder, result, resultType, x, y);
}

void BitwiseOrOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type z, ::mlir::Value x, ::mlir::Value y) {
  odsState.addOperands(x);
  odsState.addOperands(y);
  odsState.addTypes(z);
}

void BitwiseOrOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value x, ::mlir::Value y) {
  odsState.addOperands(x);
  odsState.addOperands(y);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void BitwiseOrOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult BitwiseOrOp::verify() {
  if (failed(BitwiseOrOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))))) {
        return emitOpError("operand #") << index << " must be tensor of integer values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))))) {
        return emitOpError("operand #") << index << " must be tensor of integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))))) {
        return emitOpError("result #") << index << " must be tensor of integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void BitwiseOrOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::BitwiseXorOp definitions
//===----------------------------------------------------------------------===//

BitwiseXorOpAdaptor::BitwiseXorOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

BitwiseXorOpAdaptor::BitwiseXorOpAdaptor(BitwiseXorOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> BitwiseXorOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange BitwiseXorOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value BitwiseXorOpAdaptor::x() {
  return *getODSOperands(0).begin();
}

::mlir::Value BitwiseXorOpAdaptor::y() {
  return *getODSOperands(1).begin();
}

::mlir::LogicalResult BitwiseXorOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

::llvm::StringRef BitwiseXorOp::getOperationName() {
  return "tf.BitwiseXor";
}

std::pair<unsigned, unsigned> BitwiseXorOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range BitwiseXorOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value BitwiseXorOp::x() {
  return *getODSOperands(0).begin();
}

::mlir::Value BitwiseXorOp::y() {
  return *getODSOperands(1).begin();
}

::mlir::MutableOperandRange BitwiseXorOp::xMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange BitwiseXorOp::yMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> BitwiseXorOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range BitwiseXorOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value BitwiseXorOp::z() {
  return *getODSResults(0).begin();
}

Type BitwiseXorOp::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

bool BitwiseXorOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "T") return true;
 return false;
}

::mlir::DictionaryAttr BitwiseXorOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())}
    }, ctx);
}

void BitwiseXorOp::build(OpBuilder &builder, OperationState &result, Value  x, Value  y) {
  auto resultType =
      OpTrait::util::getBroadcastedType(x.getType(), y.getType());
  if (!resultType)
    mlir::emitError(result.location, "non-broadcastable operands");
  return build(builder, result, resultType, x, y);
}

void BitwiseXorOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type z, ::mlir::Value x, ::mlir::Value y) {
  odsState.addOperands(x);
  odsState.addOperands(y);
  odsState.addTypes(z);
}

void BitwiseXorOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value x, ::mlir::Value y) {
  odsState.addOperands(x);
  odsState.addOperands(y);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void BitwiseXorOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult BitwiseXorOp::verify() {
  if (failed(BitwiseXorOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))))) {
        return emitOpError("operand #") << index << " must be tensor of integer values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))))) {
        return emitOpError("operand #") << index << " must be tensor of integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))))) {
        return emitOpError("result #") << index << " must be tensor of integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void BitwiseXorOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::BroadcastArgsOp definitions
//===----------------------------------------------------------------------===//

BroadcastArgsOpAdaptor::BroadcastArgsOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

BroadcastArgsOpAdaptor::BroadcastArgsOpAdaptor(BroadcastArgsOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> BroadcastArgsOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange BroadcastArgsOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value BroadcastArgsOpAdaptor::s0() {
  return *getODSOperands(0).begin();
}

::mlir::Value BroadcastArgsOpAdaptor::s1() {
  return *getODSOperands(1).begin();
}

::mlir::LogicalResult BroadcastArgsOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

::llvm::StringRef BroadcastArgsOp::getOperationName() {
  return "tf.BroadcastArgs";
}

std::pair<unsigned, unsigned> BroadcastArgsOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range BroadcastArgsOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value BroadcastArgsOp::s0() {
  return *getODSOperands(0).begin();
}

::mlir::Value BroadcastArgsOp::s1() {
  return *getODSOperands(1).begin();
}

::mlir::MutableOperandRange BroadcastArgsOp::s0Mutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange BroadcastArgsOp::s1Mutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> BroadcastArgsOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range BroadcastArgsOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value BroadcastArgsOp::r0() {
  return *getODSResults(0).begin();
}

Type BroadcastArgsOp::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

bool BroadcastArgsOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "T") return true;
 return false;
}

::mlir::DictionaryAttr BroadcastArgsOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())}
    }, ctx);
}

void BroadcastArgsOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type r0, ::mlir::Value s0, ::mlir::Value s1) {
  odsState.addOperands(s0);
  odsState.addOperands(s1);
  odsState.addTypes(r0);
}

void BroadcastArgsOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value s0, ::mlir::Value s1) {
  odsState.addOperands(s0);
  odsState.addOperands(s1);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void BroadcastArgsOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult BroadcastArgsOp::verify() {
  if (failed(BroadcastArgsOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of 32/64-bit signed integer values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of 32/64-bit signed integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))))) {
        return emitOpError("result #") << index << " must be tensor of 32/64-bit signed integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void BroadcastArgsOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::BroadcastGradientArgsOp definitions
//===----------------------------------------------------------------------===//

BroadcastGradientArgsOpAdaptor::BroadcastGradientArgsOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

BroadcastGradientArgsOpAdaptor::BroadcastGradientArgsOpAdaptor(BroadcastGradientArgsOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> BroadcastGradientArgsOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange BroadcastGradientArgsOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value BroadcastGradientArgsOpAdaptor::s0() {
  return *getODSOperands(0).begin();
}

::mlir::Value BroadcastGradientArgsOpAdaptor::s1() {
  return *getODSOperands(1).begin();
}

::mlir::LogicalResult BroadcastGradientArgsOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

void BroadcastGradientArgsOp::getAsmResultNames(::mlir::OpAsmSetValueNameFn setNameFn) {
  auto resultGroup0 = getODSResults(0);
  if (!llvm::empty(resultGroup0))
    setNameFn(*resultGroup0.begin(), "r0");
  auto resultGroup1 = getODSResults(1);
  if (!llvm::empty(resultGroup1))
    setNameFn(*resultGroup1.begin(), "r1");
}

::llvm::StringRef BroadcastGradientArgsOp::getOperationName() {
  return "tf.BroadcastGradientArgs";
}

std::pair<unsigned, unsigned> BroadcastGradientArgsOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range BroadcastGradientArgsOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value BroadcastGradientArgsOp::s0() {
  return *getODSOperands(0).begin();
}

::mlir::Value BroadcastGradientArgsOp::s1() {
  return *getODSOperands(1).begin();
}

::mlir::MutableOperandRange BroadcastGradientArgsOp::s0Mutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange BroadcastGradientArgsOp::s1Mutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> BroadcastGradientArgsOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range BroadcastGradientArgsOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value BroadcastGradientArgsOp::r0() {
  return *getODSResults(0).begin();
}

::mlir::Value BroadcastGradientArgsOp::r1() {
  return *getODSResults(1).begin();
}

Type BroadcastGradientArgsOp::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

bool BroadcastGradientArgsOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "T") return true;
 return false;
}

::mlir::DictionaryAttr BroadcastGradientArgsOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())}
    }, ctx);
}

void BroadcastGradientArgsOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type r0, ::mlir::Type r1, ::mlir::Value s0, ::mlir::Value s1) {
  odsState.addOperands(s0);
  odsState.addOperands(s1);
  odsState.addTypes(r0);
  odsState.addTypes(r1);
}

void BroadcastGradientArgsOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value s0, ::mlir::Value s1) {
  odsState.addOperands(s0);
  odsState.addOperands(s1);
  assert(resultTypes.size() == 2u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void BroadcastGradientArgsOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 2u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult BroadcastGradientArgsOp::verify() {
  if (failed(BroadcastGradientArgsOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of 32/64-bit signed integer values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of 32/64-bit signed integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))))) {
        return emitOpError("result #") << index << " must be tensor of 32/64-bit signed integer values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSResults(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))))) {
        return emitOpError("result #") << index << " must be tensor of 32/64-bit signed integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void BroadcastGradientArgsOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::BroadcastToOp definitions
//===----------------------------------------------------------------------===//

BroadcastToOpAdaptor::BroadcastToOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

BroadcastToOpAdaptor::BroadcastToOpAdaptor(BroadcastToOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> BroadcastToOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange BroadcastToOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value BroadcastToOpAdaptor::input() {
  return *getODSOperands(0).begin();
}

::mlir::Value BroadcastToOpAdaptor::shape() {
  return *getODSOperands(1).begin();
}

::mlir::LogicalResult BroadcastToOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

::llvm::StringRef BroadcastToOp::getOperationName() {
  return "tf.BroadcastTo";
}

std::pair<unsigned, unsigned> BroadcastToOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range BroadcastToOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value BroadcastToOp::input() {
  return *getODSOperands(0).begin();
}

::mlir::Value BroadcastToOp::shape() {
  return *getODSOperands(1).begin();
}

::mlir::MutableOperandRange BroadcastToOp::inputMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange BroadcastToOp::shapeMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> BroadcastToOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range BroadcastToOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value BroadcastToOp::output() {
  return *getODSResults(0).begin();
}

Type BroadcastToOp::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

Type BroadcastToOp::Tidx() {
  return mlir::getElementTypeOrSelf(*getODSOperands(1).begin());
}

bool BroadcastToOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "T") return true;
  if (name == "Tidx") return true;
 return false;
}

::mlir::DictionaryAttr BroadcastToOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())},
    {::mlir::Identifier::get("Tidx", ctx),
::mlir::TypeAttr::get(Tidx())}
    }, ctx);
}

void BroadcastToOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value input, ::mlir::Value shape) {
  odsState.addOperands(input);
  odsState.addOperands(shape);
  odsState.addTypes(output);
}

void BroadcastToOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input, ::mlir::Value shape) {
  odsState.addOperands(input);
  odsState.addOperands(shape);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void BroadcastToOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult BroadcastToOp::verify() {
  if (failed(BroadcastToOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>())))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::TensorFlowType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of tf.dtype values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of 32/64-bit signed integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>())))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::TensorFlowType>()))))) {
        return emitOpError("result #") << index << " must be tensor of tf.dtype values, but got " << v.getType();
      }
      ++index;
    }
  }
  return Verify(*this);
}



void BroadcastToOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::BucketizeOp definitions
//===----------------------------------------------------------------------===//

BucketizeOpAdaptor::BucketizeOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

BucketizeOpAdaptor::BucketizeOpAdaptor(BucketizeOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> BucketizeOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange BucketizeOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value BucketizeOpAdaptor::input() {
  return *getODSOperands(0).begin();
}

::mlir::ArrayAttr BucketizeOpAdaptor::boundaries() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::ArrayAttr attr = odsAttrs.get("boundaries").cast<::mlir::ArrayAttr>();
  return attr;
}

::mlir::LogicalResult BucketizeOpAdaptor::verify(::mlir::Location loc) {
  {
  auto tblgen_boundaries = odsAttrs.get("boundaries");
  if (!tblgen_boundaries) return emitError(loc, "'tf.Bucketize' op ""requires attribute 'boundaries'");
    if (!(((tblgen_boundaries.isa<::mlir::ArrayAttr>())) && (::llvm::all_of(tblgen_boundaries.cast<::mlir::ArrayAttr>(), [](::mlir::Attribute attr) { return ((attr.isa<::mlir::FloatAttr>())) && ((attr.cast<::mlir::FloatAttr>().getType().isF32())); })))) return emitError(loc, "'tf.Bucketize' op ""attribute 'boundaries' failed to satisfy constraint: 32-bit float array attribute");
  }
  return ::mlir::success();
}

::llvm::StringRef BucketizeOp::getOperationName() {
  return "tf.Bucketize";
}

std::pair<unsigned, unsigned> BucketizeOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range BucketizeOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value BucketizeOp::input() {
  return *getODSOperands(0).begin();
}

::mlir::MutableOperandRange BucketizeOp::inputMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> BucketizeOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range BucketizeOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value BucketizeOp::output() {
  return *getODSResults(0).begin();
}

::mlir::ArrayAttr BucketizeOp::boundariesAttr() {
  return this->getAttr("boundaries").cast<::mlir::ArrayAttr>();
}

::mlir::ArrayAttr BucketizeOp::boundaries() {
  auto attr = boundariesAttr();
  return attr;
}

Type BucketizeOp::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

bool BucketizeOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "T") return true;
 return false;
}

::mlir::DictionaryAttr BucketizeOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())}
    }, ctx);
}

void BucketizeOp::boundariesAttr(::mlir::ArrayAttr attr) {
  this->getOperation()->setAttr("boundaries", attr);
}

void BucketizeOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value input, ::mlir::ArrayAttr boundaries) {
  odsState.addOperands(input);
  odsState.addAttribute("boundaries", boundaries);
  odsState.addTypes(output);
}

void BucketizeOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input, ::mlir::ArrayAttr boundaries) {
  odsState.addOperands(input);
  odsState.addAttribute("boundaries", boundaries);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void BucketizeOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult BucketizeOp::verify() {
  if (failed(BucketizeOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of 32-bit float or 64-bit float or 32-bit integer or 64-bit integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))))) {
        return emitOpError("result #") << index << " must be tensor of 32-bit integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void BucketizeOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::CacheDatasetV2Op definitions
//===----------------------------------------------------------------------===//

CacheDatasetV2OpAdaptor::CacheDatasetV2OpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

CacheDatasetV2OpAdaptor::CacheDatasetV2OpAdaptor(CacheDatasetV2Op&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> CacheDatasetV2OpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange CacheDatasetV2OpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value CacheDatasetV2OpAdaptor::input_dataset() {
  return *getODSOperands(0).begin();
}

::mlir::Value CacheDatasetV2OpAdaptor::filename() {
  return *getODSOperands(1).begin();
}

::mlir::Value CacheDatasetV2OpAdaptor::cache() {
  return *getODSOperands(2).begin();
}

::mlir::ArrayAttr CacheDatasetV2OpAdaptor::output_types() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::ArrayAttr attr = odsAttrs.get("output_types").cast<::mlir::ArrayAttr>();
  return attr;
}

::mlir::ArrayAttr CacheDatasetV2OpAdaptor::output_shapes() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::ArrayAttr attr = odsAttrs.get("output_shapes").cast<::mlir::ArrayAttr>();
  return attr;
}

::mlir::LogicalResult CacheDatasetV2OpAdaptor::verify(::mlir::Location loc) {
  {
  auto tblgen_output_types = odsAttrs.get("output_types");
  if (!tblgen_output_types) return emitError(loc, "'tf.CacheDatasetV2' op ""requires attribute 'output_types'");
    if (!((((tblgen_output_types.isa<::mlir::ArrayAttr>())) && (::llvm::all_of(tblgen_output_types.cast<::mlir::ArrayAttr>(), [](::mlir::Attribute attr) { return ((attr.isa<::mlir::TypeAttr>())) && ((attr.cast<::mlir::TypeAttr>().getValue().isa<::mlir::Type>())); }))) && ((tblgen_output_types.cast<::mlir::ArrayAttr>().size() >= 1)))) return emitError(loc, "'tf.CacheDatasetV2' op ""attribute 'output_types' failed to satisfy constraint: type array attribute with at least 1 elements");
  }
  {
  auto tblgen_output_shapes = odsAttrs.get("output_shapes");
  if (!tblgen_output_shapes) return emitError(loc, "'tf.CacheDatasetV2' op ""requires attribute 'output_shapes'");
    if (!((((tblgen_output_shapes.isa<::mlir::ArrayAttr>())) && (::llvm::all_of(tblgen_output_shapes.cast<::mlir::ArrayAttr>(), [](::mlir::Attribute attr) { return (attr.isa<mlir::TF::ShapeAttr>()); }))) && ((tblgen_output_shapes.cast<::mlir::ArrayAttr>().size() >= 1)))) return emitError(loc, "'tf.CacheDatasetV2' op ""attribute 'output_shapes' failed to satisfy constraint: tensorflow shape attribute array with at least 1 elements");
  }
  return ::mlir::success();
}

::llvm::StringRef CacheDatasetV2Op::getOperationName() {
  return "tf.CacheDatasetV2";
}

std::pair<unsigned, unsigned> CacheDatasetV2Op::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range CacheDatasetV2Op::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value CacheDatasetV2Op::input_dataset() {
  return *getODSOperands(0).begin();
}

::mlir::Value CacheDatasetV2Op::filename() {
  return *getODSOperands(1).begin();
}

::mlir::Value CacheDatasetV2Op::cache() {
  return *getODSOperands(2).begin();
}

::mlir::MutableOperandRange CacheDatasetV2Op::input_datasetMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange CacheDatasetV2Op::filenameMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange CacheDatasetV2Op::cacheMutable() {
  auto range = getODSOperandIndexAndLength(2);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> CacheDatasetV2Op::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range CacheDatasetV2Op::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value CacheDatasetV2Op::handle() {
  return *getODSResults(0).begin();
}

::mlir::ArrayAttr CacheDatasetV2Op::output_typesAttr() {
  return this->getAttr("output_types").cast<::mlir::ArrayAttr>();
}

::mlir::ArrayAttr CacheDatasetV2Op::output_types() {
  auto attr = output_typesAttr();
  return attr;
}

::mlir::ArrayAttr CacheDatasetV2Op::output_shapesAttr() {
  return this->getAttr("output_shapes").cast<::mlir::ArrayAttr>();
}

::mlir::ArrayAttr CacheDatasetV2Op::output_shapes() {
  auto attr = output_shapesAttr();
  return attr;
}

void CacheDatasetV2Op::output_typesAttr(::mlir::ArrayAttr attr) {
  this->getOperation()->setAttr("output_types", attr);
}

void CacheDatasetV2Op::output_shapesAttr(::mlir::ArrayAttr attr) {
  this->getOperation()->setAttr("output_shapes", attr);
}

void CacheDatasetV2Op::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type handle, ::mlir::Value input_dataset, ::mlir::Value filename, ::mlir::Value cache, ::mlir::ArrayAttr output_types, ::mlir::ArrayAttr output_shapes) {
  odsState.addOperands(input_dataset);
  odsState.addOperands(filename);
  odsState.addOperands(cache);
  odsState.addAttribute("output_types", output_types);
  odsState.addAttribute("output_shapes", output_shapes);
  odsState.addTypes(handle);
}

void CacheDatasetV2Op::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input_dataset, ::mlir::Value filename, ::mlir::Value cache, ::mlir::ArrayAttr output_types, ::mlir::ArrayAttr output_shapes) {
  odsState.addOperands(input_dataset);
  odsState.addOperands(filename);
  odsState.addOperands(cache);
  odsState.addAttribute("output_types", output_types);
  odsState.addAttribute("output_shapes", output_shapes);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void CacheDatasetV2Op::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 3u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult CacheDatasetV2Op::verify() {
  if (failed(CacheDatasetV2OpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::VariantType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::VariantRefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of variant values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::StringType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::StringRefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of string values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup2 = getODSOperands(2);
    for (::mlir::Value v : valueGroup2) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::ResourceType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::ResourceRefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of resource values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::VariantType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::VariantRefType>()))))) {
        return emitOpError("result #") << index << " must be tensor of variant values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void CacheDatasetV2Op::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
  for (::mlir::Value value : getODSOperands(2))
    effects.emplace_back(MemoryEffects::Read::get(), value, ::mlir::TF::ResourceEffects::DatasetMemoryCache::get());
  for (::mlir::Value value : getODSOperands(2))
    effects.emplace_back(MemoryEffects::Write::get(), value, ::mlir::TF::ResourceEffects::DatasetMemoryCache::get());
}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::CaseOp definitions
//===----------------------------------------------------------------------===//

CaseOpAdaptor::CaseOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

CaseOpAdaptor::CaseOpAdaptor(CaseOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> CaseOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  bool isVariadic[] = {false, true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (odsOperands.size() - 1) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::mlir::ValueRange CaseOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value CaseOpAdaptor::branch_index() {
  return *getODSOperands(0).begin();
}

::mlir::ValueRange CaseOpAdaptor::input() {
  return getODSOperands(1);
}

::mlir::ArrayAttr CaseOpAdaptor::branches() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::ArrayAttr attr = odsAttrs.get("branches").cast<::mlir::ArrayAttr>();
  return attr;
}

::mlir::BoolAttr CaseOpAdaptor::is_stateless() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::BoolAttr attr = odsAttrs.get("is_stateless").cast<::mlir::BoolAttr>();
  return attr;
}

::mlir::LogicalResult CaseOpAdaptor::verify(::mlir::Location loc) {
  {
  auto tblgen_branches = odsAttrs.get("branches");
  if (!tblgen_branches) return emitError(loc, "'tf.Case' op ""requires attribute 'branches'");
    if (!((((tblgen_branches.isa<::mlir::ArrayAttr>())) && (::llvm::all_of(tblgen_branches.cast<::mlir::ArrayAttr>(), [](::mlir::Attribute attr) { return (attr.isa<::mlir::SymbolRefAttr>()); }))) && ((tblgen_branches.cast<::mlir::ArrayAttr>().size() >= 1)))) return emitError(loc, "'tf.Case' op ""attribute 'branches' failed to satisfy constraint: symbol ref array attribute with at least 1 elements");
  }
  {
  auto tblgen_is_stateless = odsAttrs.get("is_stateless");
  if (!tblgen_is_stateless) return emitError(loc, "'tf.Case' op ""requires attribute 'is_stateless'");
    if (!((tblgen_is_stateless.isa<::mlir::BoolAttr>()))) return emitError(loc, "'tf.Case' op ""attribute 'is_stateless' failed to satisfy constraint: bool attribute");
  }
  return ::mlir::success();
}

::llvm::StringRef CaseOp::getOperationName() {
  return "tf.Case";
}

std::pair<unsigned, unsigned> CaseOp::getODSOperandIndexAndLength(unsigned index) {
  bool isVariadic[] = {false, true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (getOperation()->getNumOperands() - 1) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::mlir::Operation::operand_range CaseOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value CaseOp::branch_index() {
  return *getODSOperands(0).begin();
}

::mlir::Operation::operand_range CaseOp::input() {
  return getODSOperands(1);
}

::mlir::MutableOperandRange CaseOp::branch_indexMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange CaseOp::inputMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> CaseOp::getODSResultIndexAndLength(unsigned index) {
  bool isVariadic[] = {true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (getOperation()->getNumResults() - 0) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::mlir::Operation::result_range CaseOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Operation::result_range CaseOp::output() {
  return getODSResults(0);
}

::mlir::ArrayAttr CaseOp::branchesAttr() {
  return this->getAttr("branches").cast<::mlir::ArrayAttr>();
}

::mlir::ArrayAttr CaseOp::branches() {
  auto attr = branchesAttr();
  return attr;
}

::mlir::BoolAttr CaseOp::is_statelessAttr() {
  return this->getAttr("is_stateless").cast<::mlir::BoolAttr>();
}

bool CaseOp::is_stateless() {
  auto attr = is_statelessAttr();
  return attr.getValue();
}

mlir::OperandElementTypeRange CaseOp::Tin() {
  auto values = getODSOperands(1);
return {mlir::OperandElementTypeIterator(values.begin()), mlir::OperandElementTypeIterator(values.end())};
}

mlir::ResultElementTypeRange CaseOp::Tout() {
  auto values = getODSResults(0);
return {mlir::ResultElementTypeIterator(values.begin()), mlir::ResultElementTypeIterator(values.end())};
}

mlir::TF::ResultShapeRange CaseOp::output_shapes() {
  auto values = getODSResults(0);
return {mlir::TF::ResultShapeIterator(values.begin()), mlir::TF::ResultShapeIterator(values.end())};
}

bool CaseOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "Tin") return true;
  if (name == "Tout") return true;
  if (name == "output_shapes") return true;
 return false;
}

::mlir::DictionaryAttr CaseOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("Tin", ctx),
ArrayAttr::get(
    [&]() {
      llvm::SmallVector<Attribute, 4> ret;
      for (auto t : Tin())
        ret.push_back(TypeAttr::get(t));
      return ret;
    }(), ctx)},
    {::mlir::Identifier::get("Tout", ctx),
ArrayAttr::get(
    [&]() {
      llvm::SmallVector<Attribute, 4> ret;
      for (auto t : Tout())
        ret.push_back(TypeAttr::get(t));
      return ret;
    }(), ctx)},
    {::mlir::Identifier::get("output_shapes", ctx),
ArrayAttr::get(
      [&](){
        llvm::SmallVector<Attribute, 4> ret;
        for (auto shape : output_shapes())
          ret.push_back(mlir::TF::ShapeAttr::get(ctx, shape));
        return ret;
      }(), ctx)}
    }, ctx);
}

void CaseOp::branchesAttr(::mlir::ArrayAttr attr) {
  this->getOperation()->setAttr("branches", attr);
}

void CaseOp::is_statelessAttr(::mlir::BoolAttr attr) {
  this->getOperation()->setAttr("is_stateless", attr);
}

void CaseOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange output, ::mlir::Value branch_index, ::mlir::ValueRange input, ::mlir::ArrayAttr branches, ::mlir::BoolAttr is_stateless) {
  odsState.addOperands(branch_index);
  odsState.addOperands(input);
  odsState.addAttribute("branches", branches);
  odsState.addAttribute("is_stateless", is_stateless);
  odsState.addTypes(output);
}

void CaseOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange output, ::mlir::Value branch_index, ::mlir::ValueRange input, ::mlir::ArrayAttr branches, bool is_stateless) {
  odsState.addOperands(branch_index);
  odsState.addOperands(input);
  odsState.addAttribute("branches", branches);
  odsState.addAttribute("is_stateless", odsBuilder.getBoolAttr(is_stateless));
  odsState.addTypes(output);
}

void CaseOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() >= 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult CaseOp::verify() {
  if (failed(CaseOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))))) {
        return emitOpError("operand #") << index << " must be tensor of 32-bit signless integer values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>())))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::TensorFlowType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of tf.dtype values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>())))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::TensorFlowType>()))))) {
        return emitOpError("result #") << index << " must be tensor of tf.dtype values, but got " << v.getType();
      }
      ++index;
    }
  }
  return Verify(*this);
}



} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::CaseRegionOp definitions
//===----------------------------------------------------------------------===//

CaseRegionOpAdaptor::CaseRegionOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

CaseRegionOpAdaptor::CaseRegionOpAdaptor(CaseRegionOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> CaseRegionOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange CaseRegionOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value CaseRegionOpAdaptor::branch_index() {
  return *getODSOperands(0).begin();
}

::mlir::BoolAttr CaseRegionOpAdaptor::is_stateless() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::BoolAttr attr = odsAttrs.get("is_stateless").cast<::mlir::BoolAttr>();
  return attr;
}

::mlir::LogicalResult CaseRegionOpAdaptor::verify(::mlir::Location loc) {
  {
  auto tblgen_is_stateless = odsAttrs.get("is_stateless");
  if (!tblgen_is_stateless) return emitError(loc, "'tf.CaseRegion' op ""requires attribute 'is_stateless'");
    if (!((tblgen_is_stateless.isa<::mlir::BoolAttr>()))) return emitError(loc, "'tf.CaseRegion' op ""attribute 'is_stateless' failed to satisfy constraint: bool attribute");
  }
  return ::mlir::success();
}

::llvm::StringRef CaseRegionOp::getOperationName() {
  return "tf.CaseRegion";
}

std::pair<unsigned, unsigned> CaseRegionOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range CaseRegionOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value CaseRegionOp::branch_index() {
  return *getODSOperands(0).begin();
}

::mlir::MutableOperandRange CaseRegionOp::branch_indexMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> CaseRegionOp::getODSResultIndexAndLength(unsigned index) {
  bool isVariadic[] = {true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (getOperation()->getNumResults() - 0) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::mlir::Operation::result_range CaseRegionOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Operation::result_range CaseRegionOp::output() {
  return getODSResults(0);
}

::mlir::MutableArrayRef<Region> CaseRegionOp::branches() {
  return this->getOperation()->getRegions().drop_front(0);
}

::mlir::BoolAttr CaseRegionOp::is_statelessAttr() {
  return this->getAttr("is_stateless").cast<::mlir::BoolAttr>();
}

bool CaseRegionOp::is_stateless() {
  auto attr = is_statelessAttr();
  return attr.getValue();
}

void CaseRegionOp::is_statelessAttr(::mlir::BoolAttr attr) {
  this->getOperation()->setAttr("is_stateless", attr);
}

void CaseRegionOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange output, ::mlir::Value branch_index, ::mlir::BoolAttr is_stateless, unsigned branchesCount) {
  odsState.addOperands(branch_index);
  odsState.addAttribute("is_stateless", is_stateless);
  for (unsigned i = 0; i < branchesCount; ++i)
    (void)odsState.addRegion();
  odsState.addTypes(output);
}

void CaseRegionOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange output, ::mlir::Value branch_index, bool is_stateless, unsigned branchesCount) {
  odsState.addOperands(branch_index);
  odsState.addAttribute("is_stateless", odsBuilder.getBoolAttr(is_stateless));
  for (unsigned i = 0; i < branchesCount; ++i)
    (void)odsState.addRegion();
  odsState.addTypes(output);
}

void CaseRegionOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes, unsigned numRegions) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  for (unsigned i = 0; i != numRegions; ++i)
    (void)odsState.addRegion();
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult CaseRegionOp::verify() {
  if (failed(CaseRegionOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))))) {
        return emitOpError("operand #") << index << " must be tensor of 32-bit signless integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>())))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::TensorFlowType>()))))) {
        return emitOpError("result #") << index << " must be tensor of tf.dtype values, but got " << v.getType();
      }
      ++index;
    }
  }
{
    unsigned index = 0; (void)index;
    for (::mlir::Region &region : branches()) {
      (void)region;
      if (!((::llvm::hasNItems(region, 1)))) {
        return emitOpError("region #") << index << " ('branches') failed to verify constraint: region with 1 blocks";
      }
      ++index;
    }
  }
  return Verify(*this);
}



} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::CastOp definitions
//===----------------------------------------------------------------------===//

CastOpAdaptor::CastOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

CastOpAdaptor::CastOpAdaptor(CastOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> CastOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange CastOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value CastOpAdaptor::x() {
  return *getODSOperands(0).begin();
}

::mlir::BoolAttr CastOpAdaptor::Truncate() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::BoolAttr attr = odsAttrs.get("Truncate").dyn_cast_or_null<::mlir::BoolAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getBoolAttr(false);
  return attr;
}

::mlir::LogicalResult CastOpAdaptor::verify(::mlir::Location loc) {
  {
  auto tblgen_Truncate = odsAttrs.get("Truncate");
  if (tblgen_Truncate) {
    if (!((tblgen_Truncate.isa<::mlir::BoolAttr>()))) return emitError(loc, "'tf.Cast' op ""attribute 'Truncate' failed to satisfy constraint: bool attribute");
  }
  }
  return ::mlir::success();
}

::llvm::StringRef CastOp::getOperationName() {
  return "tf.Cast";
}

std::pair<unsigned, unsigned> CastOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range CastOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value CastOp::x() {
  return *getODSOperands(0).begin();
}

::mlir::MutableOperandRange CastOp::xMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> CastOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range CastOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value CastOp::y() {
  return *getODSResults(0).begin();
}

::mlir::BoolAttr CastOp::TruncateAttr() {
  return this->getAttr("Truncate").dyn_cast_or_null<::mlir::BoolAttr>();
}

bool CastOp::Truncate() {
  auto attr = TruncateAttr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getBoolAttr(false).getValue();
  return attr.getValue();
}

Type CastOp::SrcT() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

Type CastOp::DstT() {
  return mlir::getElementTypeOrSelf(*getODSResults(0).begin());
}

bool CastOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "SrcT") return true;
  if (name == "DstT") return true;
 return false;
}

::mlir::DictionaryAttr CastOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("SrcT", ctx),
::mlir::TypeAttr::get(SrcT())},
    {::mlir::Identifier::get("DstT", ctx),
::mlir::TypeAttr::get(DstT())}
    }, ctx);
}

void CastOp::TruncateAttr(::mlir::BoolAttr attr) {
  this->getOperation()->setAttr("Truncate", attr);
}

void CastOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type y, ::mlir::Value x, ::mlir::BoolAttr Truncate) {
  odsState.addOperands(x);
  odsState.addAttribute("Truncate", Truncate);
  odsState.addTypes(y);
}

void CastOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value x, ::mlir::BoolAttr Truncate) {
  odsState.addOperands(x);
  odsState.addAttribute("Truncate", Truncate);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void CastOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type y, ::mlir::Value x, bool Truncate) {
  odsState.addOperands(x);
  odsState.addAttribute("Truncate", odsBuilder.getBoolAttr(Truncate));
  odsState.addTypes(y);
}

void CastOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value x, bool Truncate) {
  odsState.addOperands(x);
  odsState.addAttribute("Truncate", odsBuilder.getBoolAttr(Truncate));
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void CastOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult CastOp::verify() {
  if (failed(CastOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>())))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::TensorFlowType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of tf.dtype values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>())))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::TensorFlowType>()))))) {
        return emitOpError("result #") << index << " must be tensor of tf.dtype values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}



void CastOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::CeilOp definitions
//===----------------------------------------------------------------------===//

CeilOpAdaptor::CeilOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

CeilOpAdaptor::CeilOpAdaptor(CeilOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> CeilOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange CeilOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value CeilOpAdaptor::x() {
  return *getODSOperands(0).begin();
}

::mlir::LogicalResult CeilOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

::llvm::StringRef CeilOp::getOperationName() {
  return "tf.Ceil";
}

std::pair<unsigned, unsigned> CeilOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range CeilOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value CeilOp::x() {
  return *getODSOperands(0).begin();
}

::mlir::MutableOperandRange CeilOp::xMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> CeilOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range CeilOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value CeilOp::y() {
  return *getODSResults(0).begin();
}

Type CeilOp::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

bool CeilOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "T") return true;
 return false;
}

::mlir::DictionaryAttr CeilOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())}
    }, ctx);
}

void CeilOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type y, ::mlir::Value x) {
  odsState.addOperands(x);
  odsState.addTypes(y);
}

void CeilOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value x) {
  odsState.addOperands(x);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void CeilOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

void CeilOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value x) {
  odsState.addOperands(x);
  odsState.addTypes({x.getType()});

}

void CeilOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  odsState.addTypes({operands[0].getType()});

}

::mlir::LogicalResult CeilOp::verify() {
  if (failed(CeilOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of floating-point values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))))) {
        return emitOpError("result #") << index << " must be tensor of floating-point values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void CeilOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::CheckNumericsOp definitions
//===----------------------------------------------------------------------===//

CheckNumericsOpAdaptor::CheckNumericsOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

CheckNumericsOpAdaptor::CheckNumericsOpAdaptor(CheckNumericsOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> CheckNumericsOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange CheckNumericsOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value CheckNumericsOpAdaptor::tensor() {
  return *getODSOperands(0).begin();
}

::mlir::StringAttr CheckNumericsOpAdaptor::message() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::StringAttr attr = odsAttrs.get("message").cast<::mlir::StringAttr>();
  return attr;
}

::mlir::LogicalResult CheckNumericsOpAdaptor::verify(::mlir::Location loc) {
  {
  auto tblgen_message = odsAttrs.get("message");
  if (!tblgen_message) return emitError(loc, "'tf.CheckNumerics' op ""requires attribute 'message'");
    if (!((tblgen_message.isa<::mlir::StringAttr>()))) return emitError(loc, "'tf.CheckNumerics' op ""attribute 'message' failed to satisfy constraint: string attribute");
  }
  return ::mlir::success();
}

::llvm::StringRef CheckNumericsOp::getOperationName() {
  return "tf.CheckNumerics";
}

std::pair<unsigned, unsigned> CheckNumericsOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range CheckNumericsOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value CheckNumericsOp::tensor() {
  return *getODSOperands(0).begin();
}

::mlir::MutableOperandRange CheckNumericsOp::tensorMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> CheckNumericsOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range CheckNumericsOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value CheckNumericsOp::output() {
  return *getODSResults(0).begin();
}

::mlir::StringAttr CheckNumericsOp::messageAttr() {
  return this->getAttr("message").cast<::mlir::StringAttr>();
}

::llvm::StringRef CheckNumericsOp::message() {
  auto attr = messageAttr();
  return attr.getValue();
}

Type CheckNumericsOp::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

bool CheckNumericsOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "T") return true;
 return false;
}

::mlir::DictionaryAttr CheckNumericsOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())}
    }, ctx);
}

void CheckNumericsOp::messageAttr(::mlir::StringAttr attr) {
  this->getOperation()->setAttr("message", attr);
}

void CheckNumericsOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value tensor, ::mlir::StringAttr message) {
  odsState.addOperands(tensor);
  odsState.addAttribute("message", message);
  odsState.addTypes(output);
}

void CheckNumericsOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value tensor, ::mlir::StringAttr message) {
  odsState.addOperands(tensor);
  odsState.addAttribute("message", message);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void CheckNumericsOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value tensor, ::llvm::StringRef message) {
  odsState.addOperands(tensor);
  odsState.addAttribute("message", odsBuilder.getStringAttr(message));
  odsState.addTypes(output);
}

void CheckNumericsOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value tensor, ::llvm::StringRef message) {
  odsState.addOperands(tensor);
  odsState.addAttribute("message", odsBuilder.getStringAttr(message));
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void CheckNumericsOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

void CheckNumericsOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value tensor, ::mlir::StringAttr message) {
  odsState.addOperands(tensor);
  odsState.addAttribute("message", message);
  odsState.addTypes({tensor.getType()});

}

void CheckNumericsOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  odsState.addTypes({operands[0].getType()});

}

::mlir::LogicalResult CheckNumericsOp::verify() {
  if (failed(CheckNumericsOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of floating-point values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))))) {
        return emitOpError("result #") << index << " must be tensor of floating-point values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::CholeskyOp definitions
//===----------------------------------------------------------------------===//

CholeskyOpAdaptor::CholeskyOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

CholeskyOpAdaptor::CholeskyOpAdaptor(CholeskyOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> CholeskyOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange CholeskyOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value CholeskyOpAdaptor::input() {
  return *getODSOperands(0).begin();
}

::mlir::LogicalResult CholeskyOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

::llvm::StringRef CholeskyOp::getOperationName() {
  return "tf.Cholesky";
}

std::pair<unsigned, unsigned> CholeskyOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range CholeskyOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value CholeskyOp::input() {
  return *getODSOperands(0).begin();
}

::mlir::MutableOperandRange CholeskyOp::inputMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> CholeskyOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range CholeskyOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value CholeskyOp::output() {
  return *getODSResults(0).begin();
}

Type CholeskyOp::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

bool CholeskyOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "T") return true;
 return false;
}

::mlir::DictionaryAttr CholeskyOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())}
    }, ctx);
}

void CholeskyOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value input) {
  odsState.addOperands(input);
  odsState.addTypes(output);
}

void CholeskyOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input) {
  odsState.addOperands(input);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void CholeskyOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult CholeskyOp::verify() {
  if (failed(CholeskyOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of 128-bit complex or 64-bit complex or 16-bit float or 32-bit float or 64-bit float values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())))))) {
        return emitOpError("result #") << index << " must be tensor of 128-bit complex or 64-bit complex or 16-bit float or 32-bit float or 64-bit float values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void CholeskyOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::ClipByValueOp definitions
//===----------------------------------------------------------------------===//

ClipByValueOpAdaptor::ClipByValueOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

ClipByValueOpAdaptor::ClipByValueOpAdaptor(ClipByValueOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> ClipByValueOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange ClipByValueOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value ClipByValueOpAdaptor::t() {
  return *getODSOperands(0).begin();
}

::mlir::Value ClipByValueOpAdaptor::clip_value_min() {
  return *getODSOperands(1).begin();
}

::mlir::Value ClipByValueOpAdaptor::clip_value_max() {
  return *getODSOperands(2).begin();
}

::mlir::LogicalResult ClipByValueOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

::llvm::StringRef ClipByValueOp::getOperationName() {
  return "tf.ClipByValue";
}

std::pair<unsigned, unsigned> ClipByValueOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range ClipByValueOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value ClipByValueOp::t() {
  return *getODSOperands(0).begin();
}

::mlir::Value ClipByValueOp::clip_value_min() {
  return *getODSOperands(1).begin();
}

::mlir::Value ClipByValueOp::clip_value_max() {
  return *getODSOperands(2).begin();
}

::mlir::MutableOperandRange ClipByValueOp::tMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange ClipByValueOp::clip_value_minMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange ClipByValueOp::clip_value_maxMutable() {
  auto range = getODSOperandIndexAndLength(2);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> ClipByValueOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range ClipByValueOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value ClipByValueOp::output() {
  return *getODSResults(0).begin();
}

Type ClipByValueOp::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

bool ClipByValueOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "T") return true;
 return false;
}

::mlir::DictionaryAttr ClipByValueOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())}
    }, ctx);
}

void ClipByValueOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value t, ::mlir::Value clip_value_min, ::mlir::Value clip_value_max) {
  odsState.addOperands(t);
  odsState.addOperands(clip_value_min);
  odsState.addOperands(clip_value_max);
  odsState.addTypes(output);
}

void ClipByValueOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value t, ::mlir::Value clip_value_min, ::mlir::Value clip_value_max) {
  odsState.addOperands(t);
  odsState.addOperands(clip_value_min);
  odsState.addOperands(clip_value_max);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void ClipByValueOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 3u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult ClipByValueOp::verify() {
  if (failed(ClipByValueOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of bfloat16 or 128-bit complex or 64-bit complex or 16-bit float or 32-bit float or 64-bit float or 16-bit integer or 32-bit integer or 64-bit integer or 8-bit integer or 32-bit quantized integer or 8-bit quantized integer or 8-bit quantized unsigned integer or 16-bit unsigned integer or 32-bit unsigned integer or 64-bit unsigned integer or 8-bit unsigned integer values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of bfloat16 or 128-bit complex or 64-bit complex or 16-bit float or 32-bit float or 64-bit float or 16-bit integer or 32-bit integer or 64-bit integer or 8-bit integer or 32-bit quantized integer or 8-bit quantized integer or 8-bit quantized unsigned integer or 16-bit unsigned integer or 32-bit unsigned integer or 64-bit unsigned integer or 8-bit unsigned integer values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup2 = getODSOperands(2);
    for (::mlir::Value v : valueGroup2) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of bfloat16 or 128-bit complex or 64-bit complex or 16-bit float or 32-bit float or 64-bit float or 16-bit integer or 32-bit integer or 64-bit integer or 8-bit integer or 32-bit quantized integer or 8-bit quantized integer or 8-bit quantized unsigned integer or 16-bit unsigned integer or 32-bit unsigned integer or 64-bit unsigned integer or 8-bit unsigned integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>())))))) {
        return emitOpError("result #") << index << " must be tensor of bfloat16 or 128-bit complex or 64-bit complex or 16-bit float or 32-bit float or 64-bit float or 16-bit integer or 32-bit integer or 64-bit integer or 8-bit integer or 32-bit quantized integer or 8-bit quantized integer or 8-bit quantized unsigned integer or 16-bit unsigned integer or 32-bit unsigned integer or 64-bit unsigned integer or 8-bit unsigned integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void ClipByValueOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::CloseSummaryWriterOp definitions
//===----------------------------------------------------------------------===//

CloseSummaryWriterOpAdaptor::CloseSummaryWriterOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

CloseSummaryWriterOpAdaptor::CloseSummaryWriterOpAdaptor(CloseSummaryWriterOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> CloseSummaryWriterOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange CloseSummaryWriterOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value CloseSummaryWriterOpAdaptor::writer() {
  return *getODSOperands(0).begin();
}

::mlir::LogicalResult CloseSummaryWriterOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

::llvm::StringRef CloseSummaryWriterOp::getOperationName() {
  return "tf.CloseSummaryWriter";
}

std::pair<unsigned, unsigned> CloseSummaryWriterOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range CloseSummaryWriterOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value CloseSummaryWriterOp::writer() {
  return *getODSOperands(0).begin();
}

::mlir::MutableOperandRange CloseSummaryWriterOp::writerMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> CloseSummaryWriterOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range CloseSummaryWriterOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

void CloseSummaryWriterOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value writer) {
  odsState.addOperands(writer);
}

void CloseSummaryWriterOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value writer) {
  odsState.addOperands(writer);
  assert(resultTypes.size() == 0u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void CloseSummaryWriterOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 0u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult CloseSummaryWriterOp::verify() {
  if (failed(CloseSummaryWriterOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::ResourceType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::ResourceRefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of resource values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
  }
  return ::mlir::success();
}

void CloseSummaryWriterOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
  for (::mlir::Value value : getODSOperands(0))
    effects.emplace_back(MemoryEffects::Free::get(), value, ::mlir::TF::ResourceEffects::Summary::get());
}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::CollectiveBcastRecvOp definitions
//===----------------------------------------------------------------------===//

CollectiveBcastRecvOpAdaptor::CollectiveBcastRecvOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

CollectiveBcastRecvOpAdaptor::CollectiveBcastRecvOpAdaptor(CollectiveBcastRecvOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> CollectiveBcastRecvOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange CollectiveBcastRecvOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::IntegerAttr CollectiveBcastRecvOpAdaptor::group_size() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::IntegerAttr attr = odsAttrs.get("group_size").cast<::mlir::IntegerAttr>();
  return attr;
}

::mlir::IntegerAttr CollectiveBcastRecvOpAdaptor::group_key() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::IntegerAttr attr = odsAttrs.get("group_key").cast<::mlir::IntegerAttr>();
  return attr;
}

::mlir::IntegerAttr CollectiveBcastRecvOpAdaptor::instance_key() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::IntegerAttr attr = odsAttrs.get("instance_key").cast<::mlir::IntegerAttr>();
  return attr;
}

Attribute CollectiveBcastRecvOpAdaptor::shape() {
  assert(odsAttrs && "no attributes when constructing adapter");
  Attribute attr = odsAttrs.get("shape").cast<Attribute>();
  return attr;
}

::mlir::StringAttr CollectiveBcastRecvOpAdaptor::communication_hint() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::StringAttr attr = odsAttrs.get("communication_hint").dyn_cast_or_null<::mlir::StringAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getStringAttr("auto");
  return attr;
}

::mlir::FloatAttr CollectiveBcastRecvOpAdaptor::timeout_seconds() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::FloatAttr attr = odsAttrs.get("timeout_seconds").dyn_cast_or_null<::mlir::FloatAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getFloatAttr(::mlir::Builder(odsAttrs.getContext()).getF32Type(), 0.0f);
  return attr;
}

::mlir::LogicalResult CollectiveBcastRecvOpAdaptor::verify(::mlir::Location loc) {
  {
  auto tblgen_group_size = odsAttrs.get("group_size");
  if (!tblgen_group_size) return emitError(loc, "'tf.CollectiveBcastRecv' op ""requires attribute 'group_size'");
    if (!(((tblgen_group_size.isa<::mlir::IntegerAttr>())) && ((tblgen_group_size.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(64))))) return emitError(loc, "'tf.CollectiveBcastRecv' op ""attribute 'group_size' failed to satisfy constraint: 64-bit signless integer attribute");
  }
  {
  auto tblgen_group_key = odsAttrs.get("group_key");
  if (!tblgen_group_key) return emitError(loc, "'tf.CollectiveBcastRecv' op ""requires attribute 'group_key'");
    if (!(((tblgen_group_key.isa<::mlir::IntegerAttr>())) && ((tblgen_group_key.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(64))))) return emitError(loc, "'tf.CollectiveBcastRecv' op ""attribute 'group_key' failed to satisfy constraint: 64-bit signless integer attribute");
  }
  {
  auto tblgen_instance_key = odsAttrs.get("instance_key");
  if (!tblgen_instance_key) return emitError(loc, "'tf.CollectiveBcastRecv' op ""requires attribute 'instance_key'");
    if (!(((tblgen_instance_key.isa<::mlir::IntegerAttr>())) && ((tblgen_instance_key.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(64))))) return emitError(loc, "'tf.CollectiveBcastRecv' op ""attribute 'instance_key' failed to satisfy constraint: 64-bit signless integer attribute");
  }
  {
  auto tblgen_shape = odsAttrs.get("shape");
  if (!tblgen_shape) return emitError(loc, "'tf.CollectiveBcastRecv' op ""requires attribute 'shape'");
    if (!((tblgen_shape.isa<mlir::TF::ShapeAttr>()))) return emitError(loc, "'tf.CollectiveBcastRecv' op ""attribute 'shape' failed to satisfy constraint: TensorFlow shape attribute");
  }
  {
  auto tblgen_communication_hint = odsAttrs.get("communication_hint");
  if (tblgen_communication_hint) {
    if (!((tblgen_communication_hint.isa<::mlir::StringAttr>()))) return emitError(loc, "'tf.CollectiveBcastRecv' op ""attribute 'communication_hint' failed to satisfy constraint: string attribute");
  }
  }
  {
  auto tblgen_timeout_seconds = odsAttrs.get("timeout_seconds");
  if (tblgen_timeout_seconds) {
    if (!(((tblgen_timeout_seconds.isa<::mlir::FloatAttr>())) && ((tblgen_timeout_seconds.cast<::mlir::FloatAttr>().getType().isF32())))) return emitError(loc, "'tf.CollectiveBcastRecv' op ""attribute 'timeout_seconds' failed to satisfy constraint: 32-bit float attribute");
  }
  }
  return ::mlir::success();
}

::llvm::StringRef CollectiveBcastRecvOp::getOperationName() {
  return "tf.CollectiveBcastRecv";
}

std::pair<unsigned, unsigned> CollectiveBcastRecvOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range CollectiveBcastRecvOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

std::pair<unsigned, unsigned> CollectiveBcastRecvOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range CollectiveBcastRecvOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value CollectiveBcastRecvOp::data() {
  return *getODSResults(0).begin();
}

::mlir::IntegerAttr CollectiveBcastRecvOp::group_sizeAttr() {
  return this->getAttr("group_size").cast<::mlir::IntegerAttr>();
}

uint64_t CollectiveBcastRecvOp::group_size() {
  auto attr = group_sizeAttr();
  return attr.getValue().getZExtValue();
}

::mlir::IntegerAttr CollectiveBcastRecvOp::group_keyAttr() {
  return this->getAttr("group_key").cast<::mlir::IntegerAttr>();
}

uint64_t CollectiveBcastRecvOp::group_key() {
  auto attr = group_keyAttr();
  return attr.getValue().getZExtValue();
}

::mlir::IntegerAttr CollectiveBcastRecvOp::instance_keyAttr() {
  return this->getAttr("instance_key").cast<::mlir::IntegerAttr>();
}

uint64_t CollectiveBcastRecvOp::instance_key() {
  auto attr = instance_keyAttr();
  return attr.getValue().getZExtValue();
}

Attribute CollectiveBcastRecvOp::shapeAttr() {
  return this->getAttr("shape").cast<Attribute>();
}

llvm::Optional<llvm::ArrayRef<int64_t>> CollectiveBcastRecvOp::shape() {
  auto attr = shapeAttr();
  return attr.cast<mlir::TF::ShapeAttr>().getValue();
}

::mlir::StringAttr CollectiveBcastRecvOp::communication_hintAttr() {
  return this->getAttr("communication_hint").dyn_cast_or_null<::mlir::StringAttr>();
}

::llvm::StringRef CollectiveBcastRecvOp::communication_hint() {
  auto attr = communication_hintAttr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getStringAttr("auto").getValue();
  return attr.getValue();
}

::mlir::FloatAttr CollectiveBcastRecvOp::timeout_secondsAttr() {
  return this->getAttr("timeout_seconds").dyn_cast_or_null<::mlir::FloatAttr>();
}

::llvm::APFloat CollectiveBcastRecvOp::timeout_seconds() {
  auto attr = timeout_secondsAttr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getFloatAttr(::mlir::Builder(this->getContext()).getF32Type(), 0.0f).getValue();
  return attr.getValue();
}

Type CollectiveBcastRecvOp::T() {
  return mlir::getElementTypeOrSelf(*getODSResults(0).begin());
}

bool CollectiveBcastRecvOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "T") return true;
 return false;
}

::mlir::DictionaryAttr CollectiveBcastRecvOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())}
    }, ctx);
}

void CollectiveBcastRecvOp::group_sizeAttr(::mlir::IntegerAttr attr) {
  this->getOperation()->setAttr("group_size", attr);
}

void CollectiveBcastRecvOp::group_keyAttr(::mlir::IntegerAttr attr) {
  this->getOperation()->setAttr("group_key", attr);
}

void CollectiveBcastRecvOp::instance_keyAttr(::mlir::IntegerAttr attr) {
  this->getOperation()->setAttr("instance_key", attr);
}

void CollectiveBcastRecvOp::shapeAttr(Attribute attr) {
  this->getOperation()->setAttr("shape", attr);
}

void CollectiveBcastRecvOp::communication_hintAttr(::mlir::StringAttr attr) {
  this->getOperation()->setAttr("communication_hint", attr);
}

void CollectiveBcastRecvOp::timeout_secondsAttr(::mlir::FloatAttr attr) {
  this->getOperation()->setAttr("timeout_seconds", attr);
}

void CollectiveBcastRecvOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type data, ::mlir::IntegerAttr group_size, ::mlir::IntegerAttr group_key, ::mlir::IntegerAttr instance_key, Attribute shape, ::mlir::StringAttr communication_hint, ::mlir::FloatAttr timeout_seconds) {
  odsState.addAttribute("group_size", group_size);
  odsState.addAttribute("group_key", group_key);
  odsState.addAttribute("instance_key", instance_key);
  odsState.addAttribute("shape", shape);
  odsState.addAttribute("communication_hint", communication_hint);
  odsState.addAttribute("timeout_seconds", timeout_seconds);
  odsState.addTypes(data);
}

void CollectiveBcastRecvOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::IntegerAttr group_size, ::mlir::IntegerAttr group_key, ::mlir::IntegerAttr instance_key, Attribute shape, ::mlir::StringAttr communication_hint, ::mlir::FloatAttr timeout_seconds) {
  odsState.addAttribute("group_size", group_size);
  odsState.addAttribute("group_key", group_key);
  odsState.addAttribute("instance_key", instance_key);
  odsState.addAttribute("shape", shape);
  odsState.addAttribute("communication_hint", communication_hint);
  odsState.addAttribute("timeout_seconds", timeout_seconds);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void CollectiveBcastRecvOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type data, uint64_t group_size, uint64_t group_key, uint64_t instance_key, llvm::Optional<llvm::ArrayRef<int64_t>> shape, ::llvm::StringRef communication_hint, ::llvm::APFloat timeout_seconds) {
  odsState.addAttribute("group_size", odsBuilder.getIntegerAttr(odsBuilder.getIntegerType(64), group_size));
  odsState.addAttribute("group_key", odsBuilder.getIntegerAttr(odsBuilder.getIntegerType(64), group_key));
  odsState.addAttribute("instance_key", odsBuilder.getIntegerAttr(odsBuilder.getIntegerType(64), instance_key));
  odsState.addAttribute("shape", mlir::TF::ShapeAttr::get(odsBuilder.getContext(), shape));
  odsState.addAttribute("communication_hint", odsBuilder.getStringAttr(communication_hint));
  odsState.addAttribute("timeout_seconds", odsBuilder.getFloatAttr(odsBuilder.getF32Type(), timeout_seconds));
  odsState.addTypes(data);
}

void CollectiveBcastRecvOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, uint64_t group_size, uint64_t group_key, uint64_t instance_key, llvm::Optional<llvm::ArrayRef<int64_t>> shape, ::llvm::StringRef communication_hint, ::llvm::APFloat timeout_seconds) {
  odsState.addAttribute("group_size", odsBuilder.getIntegerAttr(odsBuilder.getIntegerType(64), group_size));
  odsState.addAttribute("group_key", odsBuilder.getIntegerAttr(odsBuilder.getIntegerType(64), group_key));
  odsState.addAttribute("instance_key", odsBuilder.getIntegerAttr(odsBuilder.getIntegerType(64), instance_key));
  odsState.addAttribute("shape", mlir::TF::ShapeAttr::get(odsBuilder.getContext(), shape));
  odsState.addAttribute("communication_hint", odsBuilder.getStringAttr(communication_hint));
  odsState.addAttribute("timeout_seconds", odsBuilder.getFloatAttr(odsBuilder.getF32Type(), timeout_seconds));
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void CollectiveBcastRecvOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 0u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult CollectiveBcastRecvOp::verify() {
  if (failed(CollectiveBcastRecvOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))))) {
        return emitOpError("result #") << index << " must be tensor of bool or 16-bit float or 32-bit float or 64-bit float or 32-bit integer or 64-bit integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::CollectiveBcastSendOp definitions
//===----------------------------------------------------------------------===//

CollectiveBcastSendOpAdaptor::CollectiveBcastSendOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

CollectiveBcastSendOpAdaptor::CollectiveBcastSendOpAdaptor(CollectiveBcastSendOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> CollectiveBcastSendOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange CollectiveBcastSendOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value CollectiveBcastSendOpAdaptor::input() {
  return *getODSOperands(0).begin();
}

::mlir::IntegerAttr CollectiveBcastSendOpAdaptor::group_size() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::IntegerAttr attr = odsAttrs.get("group_size").cast<::mlir::IntegerAttr>();
  return attr;
}

::mlir::IntegerAttr CollectiveBcastSendOpAdaptor::group_key() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::IntegerAttr attr = odsAttrs.get("group_key").cast<::mlir::IntegerAttr>();
  return attr;
}

::mlir::IntegerAttr CollectiveBcastSendOpAdaptor::instance_key() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::IntegerAttr attr = odsAttrs.get("instance_key").cast<::mlir::IntegerAttr>();
  return attr;
}

Attribute CollectiveBcastSendOpAdaptor::shape() {
  assert(odsAttrs && "no attributes when constructing adapter");
  Attribute attr = odsAttrs.get("shape").cast<Attribute>();
  return attr;
}

::mlir::StringAttr CollectiveBcastSendOpAdaptor::communication_hint() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::StringAttr attr = odsAttrs.get("communication_hint").dyn_cast_or_null<::mlir::StringAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getStringAttr("auto");
  return attr;
}

::mlir::FloatAttr CollectiveBcastSendOpAdaptor::timeout_seconds() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::FloatAttr attr = odsAttrs.get("timeout_seconds").dyn_cast_or_null<::mlir::FloatAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getFloatAttr(::mlir::Builder(odsAttrs.getContext()).getF32Type(), 0.0f);
  return attr;
}

::mlir::LogicalResult CollectiveBcastSendOpAdaptor::verify(::mlir::Location loc) {
  {
  auto tblgen_group_size = odsAttrs.get("group_size");
  if (!tblgen_group_size) return emitError(loc, "'tf.CollectiveBcastSend' op ""requires attribute 'group_size'");
    if (!(((tblgen_group_size.isa<::mlir::IntegerAttr>())) && ((tblgen_group_size.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(64))))) return emitError(loc, "'tf.CollectiveBcastSend' op ""attribute 'group_size' failed to satisfy constraint: 64-bit signless integer attribute");
  }
  {
  auto tblgen_group_key = odsAttrs.get("group_key");
  if (!tblgen_group_key) return emitError(loc, "'tf.CollectiveBcastSend' op ""requires attribute 'group_key'");
    if (!(((tblgen_group_key.isa<::mlir::IntegerAttr>())) && ((tblgen_group_key.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(64))))) return emitError(loc, "'tf.CollectiveBcastSend' op ""attribute 'group_key' failed to satisfy constraint: 64-bit signless integer attribute");
  }
  {
  auto tblgen_instance_key = odsAttrs.get("instance_key");
  if (!tblgen_instance_key) return emitError(loc, "'tf.CollectiveBcastSend' op ""requires attribute 'instance_key'");
    if (!(((tblgen_instance_key.isa<::mlir::IntegerAttr>())) && ((tblgen_instance_key.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(64))))) return emitError(loc, "'tf.CollectiveBcastSend' op ""attribute 'instance_key' failed to satisfy constraint: 64-bit signless integer attribute");
  }
  {
  auto tblgen_shape = odsAttrs.get("shape");
  if (!tblgen_shape) return emitError(loc, "'tf.CollectiveBcastSend' op ""requires attribute 'shape'");
    if (!((tblgen_shape.isa<mlir::TF::ShapeAttr>()))) return emitError(loc, "'tf.CollectiveBcastSend' op ""attribute 'shape' failed to satisfy constraint: TensorFlow shape attribute");
  }
  {
  auto tblgen_communication_hint = odsAttrs.get("communication_hint");
  if (tblgen_communication_hint) {
    if (!((tblgen_communication_hint.isa<::mlir::StringAttr>()))) return emitError(loc, "'tf.CollectiveBcastSend' op ""attribute 'communication_hint' failed to satisfy constraint: string attribute");
  }
  }
  {
  auto tblgen_timeout_seconds = odsAttrs.get("timeout_seconds");
  if (tblgen_timeout_seconds) {
    if (!(((tblgen_timeout_seconds.isa<::mlir::FloatAttr>())) && ((tblgen_timeout_seconds.cast<::mlir::FloatAttr>().getType().isF32())))) return emitError(loc, "'tf.CollectiveBcastSend' op ""attribute 'timeout_seconds' failed to satisfy constraint: 32-bit float attribute");
  }
  }
  return ::mlir::success();
}

::llvm::StringRef CollectiveBcastSendOp::getOperationName() {
  return "tf.CollectiveBcastSend";
}

std::pair<unsigned, unsigned> CollectiveBcastSendOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range CollectiveBcastSendOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value CollectiveBcastSendOp::input() {
  return *getODSOperands(0).begin();
}

::mlir::MutableOperandRange CollectiveBcastSendOp::inputMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> CollectiveBcastSendOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range CollectiveBcastSendOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value CollectiveBcastSendOp::data() {
  return *getODSResults(0).begin();
}

::mlir::IntegerAttr CollectiveBcastSendOp::group_sizeAttr() {
  return this->getAttr("group_size").cast<::mlir::IntegerAttr>();
}

uint64_t CollectiveBcastSendOp::group_size() {
  auto attr = group_sizeAttr();
  return attr.getValue().getZExtValue();
}

::mlir::IntegerAttr CollectiveBcastSendOp::group_keyAttr() {
  return this->getAttr("group_key").cast<::mlir::IntegerAttr>();
}

uint64_t CollectiveBcastSendOp::group_key() {
  auto attr = group_keyAttr();
  return attr.getValue().getZExtValue();
}

::mlir::IntegerAttr CollectiveBcastSendOp::instance_keyAttr() {
  return this->getAttr("instance_key").cast<::mlir::IntegerAttr>();
}

uint64_t CollectiveBcastSendOp::instance_key() {
  auto attr = instance_keyAttr();
  return attr.getValue().getZExtValue();
}

Attribute CollectiveBcastSendOp::shapeAttr() {
  return this->getAttr("shape").cast<Attribute>();
}

llvm::Optional<llvm::ArrayRef<int64_t>> CollectiveBcastSendOp::shape() {
  auto attr = shapeAttr();
  return attr.cast<mlir::TF::ShapeAttr>().getValue();
}

::mlir::StringAttr CollectiveBcastSendOp::communication_hintAttr() {
  return this->getAttr("communication_hint").dyn_cast_or_null<::mlir::StringAttr>();
}

::llvm::StringRef CollectiveBcastSendOp::communication_hint() {
  auto attr = communication_hintAttr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getStringAttr("auto").getValue();
  return attr.getValue();
}

::mlir::FloatAttr CollectiveBcastSendOp::timeout_secondsAttr() {
  return this->getAttr("timeout_seconds").dyn_cast_or_null<::mlir::FloatAttr>();
}

::llvm::APFloat CollectiveBcastSendOp::timeout_seconds() {
  auto attr = timeout_secondsAttr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getFloatAttr(::mlir::Builder(this->getContext()).getF32Type(), 0.0f).getValue();
  return attr.getValue();
}

Type CollectiveBcastSendOp::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

bool CollectiveBcastSendOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "T") return true;
 return false;
}

::mlir::DictionaryAttr CollectiveBcastSendOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())}
    }, ctx);
}

void CollectiveBcastSendOp::group_sizeAttr(::mlir::IntegerAttr attr) {
  this->getOperation()->setAttr("group_size", attr);
}

void CollectiveBcastSendOp::group_keyAttr(::mlir::IntegerAttr attr) {
  this->getOperation()->setAttr("group_key", attr);
}

void CollectiveBcastSendOp::instance_keyAttr(::mlir::IntegerAttr attr) {
  this->getOperation()->setAttr("instance_key", attr);
}

void CollectiveBcastSendOp::shapeAttr(Attribute attr) {
  this->getOperation()->setAttr("shape", attr);
}

void CollectiveBcastSendOp::communication_hintAttr(::mlir::StringAttr attr) {
  this->getOperation()->setAttr("communication_hint", attr);
}

void CollectiveBcastSendOp::timeout_secondsAttr(::mlir::FloatAttr attr) {
  this->getOperation()->setAttr("timeout_seconds", attr);
}

void CollectiveBcastSendOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type data, ::mlir::Value input, ::mlir::IntegerAttr group_size, ::mlir::IntegerAttr group_key, ::mlir::IntegerAttr instance_key, Attribute shape, ::mlir::StringAttr communication_hint, ::mlir::FloatAttr timeout_seconds) {
  odsState.addOperands(input);
  odsState.addAttribute("group_size", group_size);
  odsState.addAttribute("group_key", group_key);
  odsState.addAttribute("instance_key", instance_key);
  odsState.addAttribute("shape", shape);
  odsState.addAttribute("communication_hint", communication_hint);
  odsState.addAttribute("timeout_seconds", timeout_seconds);
  odsState.addTypes(data);
}

void CollectiveBcastSendOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input, ::mlir::IntegerAttr group_size, ::mlir::IntegerAttr group_key, ::mlir::IntegerAttr instance_key, Attribute shape, ::mlir::StringAttr communication_hint, ::mlir::FloatAttr timeout_seconds) {
  odsState.addOperands(input);
  odsState.addAttribute("group_size", group_size);
  odsState.addAttribute("group_key", group_key);
  odsState.addAttribute("instance_key", instance_key);
  odsState.addAttribute("shape", shape);
  odsState.addAttribute("communication_hint", communication_hint);
  odsState.addAttribute("timeout_seconds", timeout_seconds);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void CollectiveBcastSendOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type data, ::mlir::Value input, uint64_t group_size, uint64_t group_key, uint64_t instance_key, llvm::Optional<llvm::ArrayRef<int64_t>> shape, ::llvm::StringRef communication_hint, ::llvm::APFloat timeout_seconds) {
  odsState.addOperands(input);
  odsState.addAttribute("group_size", odsBuilder.getIntegerAttr(odsBuilder.getIntegerType(64), group_size));
  odsState.addAttribute("group_key", odsBuilder.getIntegerAttr(odsBuilder.getIntegerType(64), group_key));
  odsState.addAttribute("instance_key", odsBuilder.getIntegerAttr(odsBuilder.getIntegerType(64), instance_key));
  odsState.addAttribute("shape", mlir::TF::ShapeAttr::get(odsBuilder.getContext(), shape));
  odsState.addAttribute("communication_hint", odsBuilder.getStringAttr(communication_hint));
  odsState.addAttribute("timeout_seconds", odsBuilder.getFloatAttr(odsBuilder.getF32Type(), timeout_seconds));
  odsState.addTypes(data);
}

void CollectiveBcastSendOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input, uint64_t group_size, uint64_t group_key, uint64_t instance_key, llvm::Optional<llvm::ArrayRef<int64_t>> shape, ::llvm::StringRef communication_hint, ::llvm::APFloat timeout_seconds) {
  odsState.addOperands(input);
  odsState.addAttribute("group_size", odsBuilder.getIntegerAttr(odsBuilder.getIntegerType(64), group_size));
  odsState.addAttribute("group_key", odsBuilder.getIntegerAttr(odsBuilder.getIntegerType(64), group_key));
  odsState.addAttribute("instance_key", odsBuilder.getIntegerAttr(odsBuilder.getIntegerType(64), instance_key));
  odsState.addAttribute("shape", mlir::TF::ShapeAttr::get(odsBuilder.getContext(), shape));
  odsState.addAttribute("communication_hint", odsBuilder.getStringAttr(communication_hint));
  odsState.addAttribute("timeout_seconds", odsBuilder.getFloatAttr(odsBuilder.getF32Type(), timeout_seconds));
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void CollectiveBcastSendOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult CollectiveBcastSendOp::verify() {
  if (failed(CollectiveBcastSendOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of bool or 16-bit float or 32-bit float or 64-bit float or 32-bit integer or 64-bit integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))))) {
        return emitOpError("result #") << index << " must be tensor of bool or 16-bit float or 32-bit float or 64-bit float or 32-bit integer or 64-bit integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::CollectiveGatherOp definitions
//===----------------------------------------------------------------------===//

CollectiveGatherOpAdaptor::CollectiveGatherOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

CollectiveGatherOpAdaptor::CollectiveGatherOpAdaptor(CollectiveGatherOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> CollectiveGatherOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange CollectiveGatherOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value CollectiveGatherOpAdaptor::input() {
  return *getODSOperands(0).begin();
}

::mlir::IntegerAttr CollectiveGatherOpAdaptor::group_size() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::IntegerAttr attr = odsAttrs.get("group_size").cast<::mlir::IntegerAttr>();
  return attr;
}

::mlir::IntegerAttr CollectiveGatherOpAdaptor::group_key() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::IntegerAttr attr = odsAttrs.get("group_key").cast<::mlir::IntegerAttr>();
  return attr;
}

::mlir::IntegerAttr CollectiveGatherOpAdaptor::instance_key() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::IntegerAttr attr = odsAttrs.get("instance_key").cast<::mlir::IntegerAttr>();
  return attr;
}

Attribute CollectiveGatherOpAdaptor::shape() {
  assert(odsAttrs && "no attributes when constructing adapter");
  Attribute attr = odsAttrs.get("shape").cast<Attribute>();
  return attr;
}

::mlir::StringAttr CollectiveGatherOpAdaptor::communication_hint() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::StringAttr attr = odsAttrs.get("communication_hint").dyn_cast_or_null<::mlir::StringAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getStringAttr("auto");
  return attr;
}

::mlir::FloatAttr CollectiveGatherOpAdaptor::timeout_seconds() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::FloatAttr attr = odsAttrs.get("timeout_seconds").dyn_cast_or_null<::mlir::FloatAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getFloatAttr(::mlir::Builder(odsAttrs.getContext()).getF32Type(), 0.0f);
  return attr;
}

::mlir::LogicalResult CollectiveGatherOpAdaptor::verify(::mlir::Location loc) {
  {
  auto tblgen_group_size = odsAttrs.get("group_size");
  if (!tblgen_group_size) return emitError(loc, "'tf.CollectiveGather' op ""requires attribute 'group_size'");
    if (!(((tblgen_group_size.isa<::mlir::IntegerAttr>())) && ((tblgen_group_size.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(64))))) return emitError(loc, "'tf.CollectiveGather' op ""attribute 'group_size' failed to satisfy constraint: 64-bit signless integer attribute");
  }
  {
  auto tblgen_group_key = odsAttrs.get("group_key");
  if (!tblgen_group_key) return emitError(loc, "'tf.CollectiveGather' op ""requires attribute 'group_key'");
    if (!(((tblgen_group_key.isa<::mlir::IntegerAttr>())) && ((tblgen_group_key.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(64))))) return emitError(loc, "'tf.CollectiveGather' op ""attribute 'group_key' failed to satisfy constraint: 64-bit signless integer attribute");
  }
  {
  auto tblgen_instance_key = odsAttrs.get("instance_key");
  if (!tblgen_instance_key) return emitError(loc, "'tf.CollectiveGather' op ""requires attribute 'instance_key'");
    if (!(((tblgen_instance_key.isa<::mlir::IntegerAttr>())) && ((tblgen_instance_key.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(64))))) return emitError(loc, "'tf.CollectiveGather' op ""attribute 'instance_key' failed to satisfy constraint: 64-bit signless integer attribute");
  }
  {
  auto tblgen_shape = odsAttrs.get("shape");
  if (!tblgen_shape) return emitError(loc, "'tf.CollectiveGather' op ""requires attribute 'shape'");
    if (!((tblgen_shape.isa<mlir::TF::ShapeAttr>()))) return emitError(loc, "'tf.CollectiveGather' op ""attribute 'shape' failed to satisfy constraint: TensorFlow shape attribute");
  }
  {
  auto tblgen_communication_hint = odsAttrs.get("communication_hint");
  if (tblgen_communication_hint) {
    if (!((tblgen_communication_hint.isa<::mlir::StringAttr>()))) return emitError(loc, "'tf.CollectiveGather' op ""attribute 'communication_hint' failed to satisfy constraint: string attribute");
  }
  }
  {
  auto tblgen_timeout_seconds = odsAttrs.get("timeout_seconds");
  if (tblgen_timeout_seconds) {
    if (!(((tblgen_timeout_seconds.isa<::mlir::FloatAttr>())) && ((tblgen_timeout_seconds.cast<::mlir::FloatAttr>().getType().isF32())))) return emitError(loc, "'tf.CollectiveGather' op ""attribute 'timeout_seconds' failed to satisfy constraint: 32-bit float attribute");
  }
  }
  return ::mlir::success();
}

::llvm::StringRef CollectiveGatherOp::getOperationName() {
  return "tf.CollectiveGather";
}

std::pair<unsigned, unsigned> CollectiveGatherOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range CollectiveGatherOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value CollectiveGatherOp::input() {
  return *getODSOperands(0).begin();
}

::mlir::MutableOperandRange CollectiveGatherOp::inputMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> CollectiveGatherOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range CollectiveGatherOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value CollectiveGatherOp::data() {
  return *getODSResults(0).begin();
}

::mlir::IntegerAttr CollectiveGatherOp::group_sizeAttr() {
  return this->getAttr("group_size").cast<::mlir::IntegerAttr>();
}

uint64_t CollectiveGatherOp::group_size() {
  auto attr = group_sizeAttr();
  return attr.getValue().getZExtValue();
}

::mlir::IntegerAttr CollectiveGatherOp::group_keyAttr() {
  return this->getAttr("group_key").cast<::mlir::IntegerAttr>();
}

uint64_t CollectiveGatherOp::group_key() {
  auto attr = group_keyAttr();
  return attr.getValue().getZExtValue();
}

::mlir::IntegerAttr CollectiveGatherOp::instance_keyAttr() {
  return this->getAttr("instance_key").cast<::mlir::IntegerAttr>();
}

uint64_t CollectiveGatherOp::instance_key() {
  auto attr = instance_keyAttr();
  return attr.getValue().getZExtValue();
}

Attribute CollectiveGatherOp::shapeAttr() {
  return this->getAttr("shape").cast<Attribute>();
}

llvm::Optional<llvm::ArrayRef<int64_t>> CollectiveGatherOp::shape() {
  auto attr = shapeAttr();
  return attr.cast<mlir::TF::ShapeAttr>().getValue();
}

::mlir::StringAttr CollectiveGatherOp::communication_hintAttr() {
  return this->getAttr("communication_hint").dyn_cast_or_null<::mlir::StringAttr>();
}

::llvm::StringRef CollectiveGatherOp::communication_hint() {
  auto attr = communication_hintAttr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getStringAttr("auto").getValue();
  return attr.getValue();
}

::mlir::FloatAttr CollectiveGatherOp::timeout_secondsAttr() {
  return this->getAttr("timeout_seconds").dyn_cast_or_null<::mlir::FloatAttr>();
}

::llvm::APFloat CollectiveGatherOp::timeout_seconds() {
  auto attr = timeout_secondsAttr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getFloatAttr(::mlir::Builder(this->getContext()).getF32Type(), 0.0f).getValue();
  return attr.getValue();
}

Type CollectiveGatherOp::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

bool CollectiveGatherOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "T") return true;
 return false;
}

::mlir::DictionaryAttr CollectiveGatherOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())}
    }, ctx);
}

void CollectiveGatherOp::group_sizeAttr(::mlir::IntegerAttr attr) {
  this->getOperation()->setAttr("group_size", attr);
}

void CollectiveGatherOp::group_keyAttr(::mlir::IntegerAttr attr) {
  this->getOperation()->setAttr("group_key", attr);
}

void CollectiveGatherOp::instance_keyAttr(::mlir::IntegerAttr attr) {
  this->getOperation()->setAttr("instance_key", attr);
}

void CollectiveGatherOp::shapeAttr(Attribute attr) {
  this->getOperation()->setAttr("shape", attr);
}

void CollectiveGatherOp::communication_hintAttr(::mlir::StringAttr attr) {
  this->getOperation()->setAttr("communication_hint", attr);
}

void CollectiveGatherOp::timeout_secondsAttr(::mlir::FloatAttr attr) {
  this->getOperation()->setAttr("timeout_seconds", attr);
}

void CollectiveGatherOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type data, ::mlir::Value input, ::mlir::IntegerAttr group_size, ::mlir::IntegerAttr group_key, ::mlir::IntegerAttr instance_key, Attribute shape, ::mlir::StringAttr communication_hint, ::mlir::FloatAttr timeout_seconds) {
  odsState.addOperands(input);
  odsState.addAttribute("group_size", group_size);
  odsState.addAttribute("group_key", group_key);
  odsState.addAttribute("instance_key", instance_key);
  odsState.addAttribute("shape", shape);
  odsState.addAttribute("communication_hint", communication_hint);
  odsState.addAttribute("timeout_seconds", timeout_seconds);
  odsState.addTypes(data);
}

void CollectiveGatherOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input, ::mlir::IntegerAttr group_size, ::mlir::IntegerAttr group_key, ::mlir::IntegerAttr instance_key, Attribute shape, ::mlir::StringAttr communication_hint, ::mlir::FloatAttr timeout_seconds) {
  odsState.addOperands(input);
  odsState.addAttribute("group_size", group_size);
  odsState.addAttribute("group_key", group_key);
  odsState.addAttribute("instance_key", instance_key);
  odsState.addAttribute("shape", shape);
  odsState.addAttribute("communication_hint", communication_hint);
  odsState.addAttribute("timeout_seconds", timeout_seconds);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void CollectiveGatherOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type data, ::mlir::Value input, uint64_t group_size, uint64_t group_key, uint64_t instance_key, llvm::Optional<llvm::ArrayRef<int64_t>> shape, ::llvm::StringRef communication_hint, ::llvm::APFloat timeout_seconds) {
  odsState.addOperands(input);
  odsState.addAttribute("group_size", odsBuilder.getIntegerAttr(odsBuilder.getIntegerType(64), group_size));
  odsState.addAttribute("group_key", odsBuilder.getIntegerAttr(odsBuilder.getIntegerType(64), group_key));
  odsState.addAttribute("instance_key", odsBuilder.getIntegerAttr(odsBuilder.getIntegerType(64), instance_key));
  odsState.addAttribute("shape", mlir::TF::ShapeAttr::get(odsBuilder.getContext(), shape));
  odsState.addAttribute("communication_hint", odsBuilder.getStringAttr(communication_hint));
  odsState.addAttribute("timeout_seconds", odsBuilder.getFloatAttr(odsBuilder.getF32Type(), timeout_seconds));
  odsState.addTypes(data);
}

void CollectiveGatherOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input, uint64_t group_size, uint64_t group_key, uint64_t instance_key, llvm::Optional<llvm::ArrayRef<int64_t>> shape, ::llvm::StringRef communication_hint, ::llvm::APFloat timeout_seconds) {
  odsState.addOperands(input);
  odsState.addAttribute("group_size", odsBuilder.getIntegerAttr(odsBuilder.getIntegerType(64), group_size));
  odsState.addAttribute("group_key", odsBuilder.getIntegerAttr(odsBuilder.getIntegerType(64), group_key));
  odsState.addAttribute("instance_key", odsBuilder.getIntegerAttr(odsBuilder.getIntegerType(64), instance_key));
  odsState.addAttribute("shape", mlir::TF::ShapeAttr::get(odsBuilder.getContext(), shape));
  odsState.addAttribute("communication_hint", odsBuilder.getStringAttr(communication_hint));
  odsState.addAttribute("timeout_seconds", odsBuilder.getFloatAttr(odsBuilder.getF32Type(), timeout_seconds));
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void CollectiveGatherOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult CollectiveGatherOp::verify() {
  if (failed(CollectiveGatherOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of 16-bit float or 32-bit float or 64-bit float or 32-bit integer or 64-bit integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))))) {
        return emitOpError("result #") << index << " must be tensor of 16-bit float or 32-bit float or 64-bit float or 32-bit integer or 64-bit integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::CollectivePermuteOp definitions
//===----------------------------------------------------------------------===//

CollectivePermuteOpAdaptor::CollectivePermuteOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

CollectivePermuteOpAdaptor::CollectivePermuteOpAdaptor(CollectivePermuteOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> CollectivePermuteOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange CollectivePermuteOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value CollectivePermuteOpAdaptor::input() {
  return *getODSOperands(0).begin();
}

::mlir::Value CollectivePermuteOpAdaptor::source_target_pairs() {
  return *getODSOperands(1).begin();
}

::mlir::LogicalResult CollectivePermuteOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

::llvm::StringRef CollectivePermuteOp::getOperationName() {
  return "tf.CollectivePermute";
}

std::pair<unsigned, unsigned> CollectivePermuteOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range CollectivePermuteOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value CollectivePermuteOp::input() {
  return *getODSOperands(0).begin();
}

::mlir::Value CollectivePermuteOp::source_target_pairs() {
  return *getODSOperands(1).begin();
}

::mlir::MutableOperandRange CollectivePermuteOp::inputMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange CollectivePermuteOp::source_target_pairsMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> CollectivePermuteOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range CollectivePermuteOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value CollectivePermuteOp::output() {
  return *getODSResults(0).begin();
}

Type CollectivePermuteOp::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

bool CollectivePermuteOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "T") return true;
 return false;
}

::mlir::DictionaryAttr CollectivePermuteOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())}
    }, ctx);
}

void CollectivePermuteOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value input, ::mlir::Value source_target_pairs) {
  odsState.addOperands(input);
  odsState.addOperands(source_target_pairs);
  odsState.addTypes(output);
}

void CollectivePermuteOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input, ::mlir::Value source_target_pairs) {
  odsState.addOperands(input);
  odsState.addOperands(source_target_pairs);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void CollectivePermuteOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult CollectivePermuteOp::verify() {
  if (failed(CollectivePermuteOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of bfloat16 or 16-bit float or 32-bit float or 64-bit float or 16-bit integer or 32-bit integer or 64-bit integer or 8-bit integer or 128-bit complex or 64-bit complex or 32-bit quantized integer or 8-bit quantized integer or 8-bit quantized unsigned integer or 16-bit unsigned integer or 32-bit unsigned integer or 64-bit unsigned integer or 8-bit unsigned integer values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))))) {
        return emitOpError("operand #") << index << " must be tensor of 32-bit signless integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>())))))) {
        return emitOpError("result #") << index << " must be tensor of bfloat16 or 16-bit float or 32-bit float or 64-bit float or 16-bit integer or 32-bit integer or 64-bit integer or 8-bit integer or 128-bit complex or 64-bit complex or 32-bit quantized integer or 8-bit quantized integer or 8-bit quantized unsigned integer or 16-bit unsigned integer or 32-bit unsigned integer or 64-bit unsigned integer or 8-bit unsigned integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::CollectiveReduceOp definitions
//===----------------------------------------------------------------------===//

CollectiveReduceOpAdaptor::CollectiveReduceOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

CollectiveReduceOpAdaptor::CollectiveReduceOpAdaptor(CollectiveReduceOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> CollectiveReduceOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange CollectiveReduceOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value CollectiveReduceOpAdaptor::input() {
  return *getODSOperands(0).begin();
}

::mlir::IntegerAttr CollectiveReduceOpAdaptor::group_size() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::IntegerAttr attr = odsAttrs.get("group_size").cast<::mlir::IntegerAttr>();
  return attr;
}

::mlir::IntegerAttr CollectiveReduceOpAdaptor::group_key() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::IntegerAttr attr = odsAttrs.get("group_key").cast<::mlir::IntegerAttr>();
  return attr;
}

::mlir::IntegerAttr CollectiveReduceOpAdaptor::instance_key() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::IntegerAttr attr = odsAttrs.get("instance_key").cast<::mlir::IntegerAttr>();
  return attr;
}

::mlir::StringAttr CollectiveReduceOpAdaptor::merge_op() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::StringAttr attr = odsAttrs.get("merge_op").cast<::mlir::StringAttr>();
  return attr;
}

::mlir::StringAttr CollectiveReduceOpAdaptor::final_op() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::StringAttr attr = odsAttrs.get("final_op").cast<::mlir::StringAttr>();
  return attr;
}

::mlir::ArrayAttr CollectiveReduceOpAdaptor::subdiv_offsets() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::ArrayAttr attr = odsAttrs.get("subdiv_offsets").cast<::mlir::ArrayAttr>();
  return attr;
}

::mlir::ArrayAttr CollectiveReduceOpAdaptor::wait_for() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::ArrayAttr attr = odsAttrs.get("wait_for").dyn_cast_or_null<::mlir::ArrayAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getI64ArrayAttr({});
  return attr;
}

::mlir::StringAttr CollectiveReduceOpAdaptor::communication_hint() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::StringAttr attr = odsAttrs.get("communication_hint").dyn_cast_or_null<::mlir::StringAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getStringAttr("auto");
  return attr;
}

::mlir::FloatAttr CollectiveReduceOpAdaptor::timeout_seconds() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::FloatAttr attr = odsAttrs.get("timeout_seconds").dyn_cast_or_null<::mlir::FloatAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getFloatAttr(::mlir::Builder(odsAttrs.getContext()).getF32Type(), 0.0f);
  return attr;
}

::mlir::LogicalResult CollectiveReduceOpAdaptor::verify(::mlir::Location loc) {
  {
  auto tblgen_group_size = odsAttrs.get("group_size");
  if (!tblgen_group_size) return emitError(loc, "'tf.CollectiveReduce' op ""requires attribute 'group_size'");
    if (!(((tblgen_group_size.isa<::mlir::IntegerAttr>())) && ((tblgen_group_size.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(64))))) return emitError(loc, "'tf.CollectiveReduce' op ""attribute 'group_size' failed to satisfy constraint: 64-bit signless integer attribute");
  }
  {
  auto tblgen_group_key = odsAttrs.get("group_key");
  if (!tblgen_group_key) return emitError(loc, "'tf.CollectiveReduce' op ""requires attribute 'group_key'");
    if (!(((tblgen_group_key.isa<::mlir::IntegerAttr>())) && ((tblgen_group_key.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(64))))) return emitError(loc, "'tf.CollectiveReduce' op ""attribute 'group_key' failed to satisfy constraint: 64-bit signless integer attribute");
  }
  {
  auto tblgen_instance_key = odsAttrs.get("instance_key");
  if (!tblgen_instance_key) return emitError(loc, "'tf.CollectiveReduce' op ""requires attribute 'instance_key'");
    if (!(((tblgen_instance_key.isa<::mlir::IntegerAttr>())) && ((tblgen_instance_key.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(64))))) return emitError(loc, "'tf.CollectiveReduce' op ""attribute 'instance_key' failed to satisfy constraint: 64-bit signless integer attribute");
  }
  {
  auto tblgen_merge_op = odsAttrs.get("merge_op");
  if (!tblgen_merge_op) return emitError(loc, "'tf.CollectiveReduce' op ""requires attribute 'merge_op'");
    if (!((tblgen_merge_op.cast<StringAttr>().getValue() == "Min" || tblgen_merge_op.cast<StringAttr>().getValue() == "Max" || tblgen_merge_op.cast<StringAttr>().getValue() == "Mul" || tblgen_merge_op.cast<StringAttr>().getValue() == "Add"))) return emitError(loc, "'tf.CollectiveReduce' op ""attribute 'merge_op' failed to satisfy constraint: string attribute whose value is Min, or Max, or Mul, or Add");
  }
  {
  auto tblgen_final_op = odsAttrs.get("final_op");
  if (!tblgen_final_op) return emitError(loc, "'tf.CollectiveReduce' op ""requires attribute 'final_op'");
    if (!((tblgen_final_op.cast<StringAttr>().getValue() == "Id" || tblgen_final_op.cast<StringAttr>().getValue() == "Div"))) return emitError(loc, "'tf.CollectiveReduce' op ""attribute 'final_op' failed to satisfy constraint: string attribute whose value is Id, or Div");
  }
  {
  auto tblgen_subdiv_offsets = odsAttrs.get("subdiv_offsets");
  if (!tblgen_subdiv_offsets) return emitError(loc, "'tf.CollectiveReduce' op ""requires attribute 'subdiv_offsets'");
    if (!(((tblgen_subdiv_offsets.isa<::mlir::ArrayAttr>())) && (::llvm::all_of(tblgen_subdiv_offsets.cast<::mlir::ArrayAttr>(), [](::mlir::Attribute attr) { return ((attr.isa<::mlir::IntegerAttr>())) && ((attr.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(64))); })))) return emitError(loc, "'tf.CollectiveReduce' op ""attribute 'subdiv_offsets' failed to satisfy constraint: 64-bit integer array attribute");
  }
  {
  auto tblgen_wait_for = odsAttrs.get("wait_for");
  if (tblgen_wait_for) {
    if (!(((tblgen_wait_for.isa<::mlir::ArrayAttr>())) && (::llvm::all_of(tblgen_wait_for.cast<::mlir::ArrayAttr>(), [](::mlir::Attribute attr) { return ((attr.isa<::mlir::IntegerAttr>())) && ((attr.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(64))); })))) return emitError(loc, "'tf.CollectiveReduce' op ""attribute 'wait_for' failed to satisfy constraint: 64-bit integer array attribute");
  }
  }
  {
  auto tblgen_communication_hint = odsAttrs.get("communication_hint");
  if (tblgen_communication_hint) {
    if (!((tblgen_communication_hint.isa<::mlir::StringAttr>()))) return emitError(loc, "'tf.CollectiveReduce' op ""attribute 'communication_hint' failed to satisfy constraint: string attribute");
  }
  }
  {
  auto tblgen_timeout_seconds = odsAttrs.get("timeout_seconds");
  if (tblgen_timeout_seconds) {
    if (!(((tblgen_timeout_seconds.isa<::mlir::FloatAttr>())) && ((tblgen_timeout_seconds.cast<::mlir::FloatAttr>().getType().isF32())))) return emitError(loc, "'tf.CollectiveReduce' op ""attribute 'timeout_seconds' failed to satisfy constraint: 32-bit float attribute");
  }
  }
  return ::mlir::success();
}

::llvm::StringRef CollectiveReduceOp::getOperationName() {
  return "tf.CollectiveReduce";
}

std::pair<unsigned, unsigned> CollectiveReduceOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range CollectiveReduceOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value CollectiveReduceOp::input() {
  return *getODSOperands(0).begin();
}

::mlir::MutableOperandRange CollectiveReduceOp::inputMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> CollectiveReduceOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range CollectiveReduceOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value CollectiveReduceOp::data() {
  return *getODSResults(0).begin();
}

::mlir::IntegerAttr CollectiveReduceOp::group_sizeAttr() {
  return this->getAttr("group_size").cast<::mlir::IntegerAttr>();
}

uint64_t CollectiveReduceOp::group_size() {
  auto attr = group_sizeAttr();
  return attr.getValue().getZExtValue();
}

::mlir::IntegerAttr CollectiveReduceOp::group_keyAttr() {
  return this->getAttr("group_key").cast<::mlir::IntegerAttr>();
}

uint64_t CollectiveReduceOp::group_key() {
  auto attr = group_keyAttr();
  return attr.getValue().getZExtValue();
}

::mlir::IntegerAttr CollectiveReduceOp::instance_keyAttr() {
  return this->getAttr("instance_key").cast<::mlir::IntegerAttr>();
}

uint64_t CollectiveReduceOp::instance_key() {
  auto attr = instance_keyAttr();
  return attr.getValue().getZExtValue();
}

::mlir::StringAttr CollectiveReduceOp::merge_opAttr() {
  return this->getAttr("merge_op").cast<::mlir::StringAttr>();
}

::llvm::StringRef CollectiveReduceOp::merge_op() {
  auto attr = merge_opAttr();
  return attr.getValue();
}

::mlir::StringAttr CollectiveReduceOp::final_opAttr() {
  return this->getAttr("final_op").cast<::mlir::StringAttr>();
}

::llvm::StringRef CollectiveReduceOp::final_op() {
  auto attr = final_opAttr();
  return attr.getValue();
}

::mlir::ArrayAttr CollectiveReduceOp::subdiv_offsetsAttr() {
  return this->getAttr("subdiv_offsets").cast<::mlir::ArrayAttr>();
}

::mlir::ArrayAttr CollectiveReduceOp::subdiv_offsets() {
  auto attr = subdiv_offsetsAttr();
  return attr;
}

::mlir::ArrayAttr CollectiveReduceOp::wait_forAttr() {
  return this->getAttr("wait_for").dyn_cast_or_null<::mlir::ArrayAttr>();
}

::mlir::ArrayAttr CollectiveReduceOp::wait_for() {
  auto attr = wait_forAttr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getI64ArrayAttr({});
  return attr;
}

::mlir::StringAttr CollectiveReduceOp::communication_hintAttr() {
  return this->getAttr("communication_hint").dyn_cast_or_null<::mlir::StringAttr>();
}

::llvm::StringRef CollectiveReduceOp::communication_hint() {
  auto attr = communication_hintAttr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getStringAttr("auto").getValue();
  return attr.getValue();
}

::mlir::FloatAttr CollectiveReduceOp::timeout_secondsAttr() {
  return this->getAttr("timeout_seconds").dyn_cast_or_null<::mlir::FloatAttr>();
}

::llvm::APFloat CollectiveReduceOp::timeout_seconds() {
  auto attr = timeout_secondsAttr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getFloatAttr(::mlir::Builder(this->getContext()).getF32Type(), 0.0f).getValue();
  return attr.getValue();
}

Type CollectiveReduceOp::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

bool CollectiveReduceOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "T") return true;
 return false;
}

::mlir::DictionaryAttr CollectiveReduceOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())}
    }, ctx);
}

void CollectiveReduceOp::group_sizeAttr(::mlir::IntegerAttr attr) {
  this->getOperation()->setAttr("group_size", attr);
}

void CollectiveReduceOp::group_keyAttr(::mlir::IntegerAttr attr) {
  this->getOperation()->setAttr("group_key", attr);
}

void CollectiveReduceOp::instance_keyAttr(::mlir::IntegerAttr attr) {
  this->getOperation()->setAttr("instance_key", attr);
}

void CollectiveReduceOp::merge_opAttr(::mlir::StringAttr attr) {
  this->getOperation()->setAttr("merge_op", attr);
}

void CollectiveReduceOp::final_opAttr(::mlir::StringAttr attr) {
  this->getOperation()->setAttr("final_op", attr);
}

void CollectiveReduceOp::subdiv_offsetsAttr(::mlir::ArrayAttr attr) {
  this->getOperation()->setAttr("subdiv_offsets", attr);
}

void CollectiveReduceOp::wait_forAttr(::mlir::ArrayAttr attr) {
  this->getOperation()->setAttr("wait_for", attr);
}

void CollectiveReduceOp::communication_hintAttr(::mlir::StringAttr attr) {
  this->getOperation()->setAttr("communication_hint", attr);
}

void CollectiveReduceOp::timeout_secondsAttr(::mlir::FloatAttr attr) {
  this->getOperation()->setAttr("timeout_seconds", attr);
}

void CollectiveReduceOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type data, ::mlir::Value input, ::mlir::IntegerAttr group_size, ::mlir::IntegerAttr group_key, ::mlir::IntegerAttr instance_key, ::mlir::StringAttr merge_op, ::mlir::StringAttr final_op, ::mlir::ArrayAttr subdiv_offsets, ::mlir::ArrayAttr wait_for, ::mlir::StringAttr communication_hint, ::mlir::FloatAttr timeout_seconds) {
  odsState.addOperands(input);
  odsState.addAttribute("group_size", group_size);
  odsState.addAttribute("group_key", group_key);
  odsState.addAttribute("instance_key", instance_key);
  odsState.addAttribute("merge_op", merge_op);
  odsState.addAttribute("final_op", final_op);
  odsState.addAttribute("subdiv_offsets", subdiv_offsets);
  odsState.addAttribute("wait_for", wait_for);
  odsState.addAttribute("communication_hint", communication_hint);
  odsState.addAttribute("timeout_seconds", timeout_seconds);
  odsState.addTypes(data);
}

void CollectiveReduceOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input, ::mlir::IntegerAttr group_size, ::mlir::IntegerAttr group_key, ::mlir::IntegerAttr instance_key, ::mlir::StringAttr merge_op, ::mlir::StringAttr final_op, ::mlir::ArrayAttr subdiv_offsets, ::mlir::ArrayAttr wait_for, ::mlir::StringAttr communication_hint, ::mlir::FloatAttr timeout_seconds) {
  odsState.addOperands(input);
  odsState.addAttribute("group_size", group_size);
  odsState.addAttribute("group_key", group_key);
  odsState.addAttribute("instance_key", instance_key);
  odsState.addAttribute("merge_op", merge_op);
  odsState.addAttribute("final_op", final_op);
  odsState.addAttribute("subdiv_offsets", subdiv_offsets);
  odsState.addAttribute("wait_for", wait_for);
  odsState.addAttribute("communication_hint", communication_hint);
  odsState.addAttribute("timeout_seconds", timeout_seconds);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void CollectiveReduceOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type data, ::mlir::Value input, uint64_t group_size, uint64_t group_key, uint64_t instance_key, ::llvm::StringRef merge_op, ::llvm::StringRef final_op, ::mlir::ArrayAttr subdiv_offsets, ::mlir::ArrayAttr wait_for, ::llvm::StringRef communication_hint, ::llvm::APFloat timeout_seconds) {
  odsState.addOperands(input);
  odsState.addAttribute("group_size", odsBuilder.getIntegerAttr(odsBuilder.getIntegerType(64), group_size));
  odsState.addAttribute("group_key", odsBuilder.getIntegerAttr(odsBuilder.getIntegerType(64), group_key));
  odsState.addAttribute("instance_key", odsBuilder.getIntegerAttr(odsBuilder.getIntegerType(64), instance_key));
  odsState.addAttribute("merge_op", odsBuilder.getStringAttr(merge_op));
  odsState.addAttribute("final_op", odsBuilder.getStringAttr(final_op));
  odsState.addAttribute("subdiv_offsets", subdiv_offsets);
  odsState.addAttribute("wait_for", wait_for);
  odsState.addAttribute("communication_hint", odsBuilder.getStringAttr(communication_hint));
  odsState.addAttribute("timeout_seconds", odsBuilder.getFloatAttr(odsBuilder.getF32Type(), timeout_seconds));
  odsState.addTypes(data);
}

void CollectiveReduceOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input, uint64_t group_size, uint64_t group_key, uint64_t instance_key, ::llvm::StringRef merge_op, ::llvm::StringRef final_op, ::mlir::ArrayAttr subdiv_offsets, ::mlir::ArrayAttr wait_for, ::llvm::StringRef communication_hint, ::llvm::APFloat timeout_seconds) {
  odsState.addOperands(input);
  odsState.addAttribute("group_size", odsBuilder.getIntegerAttr(odsBuilder.getIntegerType(64), group_size));
  odsState.addAttribute("group_key", odsBuilder.getIntegerAttr(odsBuilder.getIntegerType(64), group_key));
  odsState.addAttribute("instance_key", odsBuilder.getIntegerAttr(odsBuilder.getIntegerType(64), instance_key));
  odsState.addAttribute("merge_op", odsBuilder.getStringAttr(merge_op));
  odsState.addAttribute("final_op", odsBuilder.getStringAttr(final_op));
  odsState.addAttribute("subdiv_offsets", subdiv_offsets);
  odsState.addAttribute("wait_for", wait_for);
  odsState.addAttribute("communication_hint", odsBuilder.getStringAttr(communication_hint));
  odsState.addAttribute("timeout_seconds", odsBuilder.getFloatAttr(odsBuilder.getF32Type(), timeout_seconds));
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void CollectiveReduceOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

void CollectiveReduceOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value input, ::mlir::IntegerAttr group_size, ::mlir::IntegerAttr group_key, ::mlir::IntegerAttr instance_key, ::mlir::StringAttr merge_op, ::mlir::StringAttr final_op, ::mlir::ArrayAttr subdiv_offsets, ::mlir::ArrayAttr wait_for, ::mlir::StringAttr communication_hint, ::mlir::FloatAttr timeout_seconds) {
  odsState.addOperands(input);
  odsState.addAttribute("group_size", group_size);
  odsState.addAttribute("group_key", group_key);
  odsState.addAttribute("instance_key", instance_key);
  odsState.addAttribute("merge_op", merge_op);
  odsState.addAttribute("final_op", final_op);
  odsState.addAttribute("subdiv_offsets", subdiv_offsets);
  odsState.addAttribute("wait_for", wait_for);
  odsState.addAttribute("communication_hint", communication_hint);
  odsState.addAttribute("timeout_seconds", timeout_seconds);
  odsState.addTypes({input.getType()});

}

void CollectiveReduceOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  odsState.addTypes({operands[0].getType()});

}

::mlir::LogicalResult CollectiveReduceOp::verify() {
  if (failed(CollectiveReduceOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of 16-bit float or 32-bit float or 64-bit float or 32-bit integer or 64-bit integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))))) {
        return emitOpError("result #") << index << " must be tensor of 16-bit float or 32-bit float or 64-bit float or 32-bit integer or 64-bit integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::CollectiveReduceV2Op definitions
//===----------------------------------------------------------------------===//

CollectiveReduceV2OpAdaptor::CollectiveReduceV2OpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

CollectiveReduceV2OpAdaptor::CollectiveReduceV2OpAdaptor(CollectiveReduceV2Op&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> CollectiveReduceV2OpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange CollectiveReduceV2OpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value CollectiveReduceV2OpAdaptor::input() {
  return *getODSOperands(0).begin();
}

::mlir::Value CollectiveReduceV2OpAdaptor::group_size() {
  return *getODSOperands(1).begin();
}

::mlir::Value CollectiveReduceV2OpAdaptor::group_key() {
  return *getODSOperands(2).begin();
}

::mlir::Value CollectiveReduceV2OpAdaptor::instance_key() {
  return *getODSOperands(3).begin();
}

::mlir::StringAttr CollectiveReduceV2OpAdaptor::merge_op() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::StringAttr attr = odsAttrs.get("merge_op").cast<::mlir::StringAttr>();
  return attr;
}

::mlir::StringAttr CollectiveReduceV2OpAdaptor::final_op() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::StringAttr attr = odsAttrs.get("final_op").cast<::mlir::StringAttr>();
  return attr;
}

::mlir::StringAttr CollectiveReduceV2OpAdaptor::communication_hint() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::StringAttr attr = odsAttrs.get("communication_hint").dyn_cast_or_null<::mlir::StringAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getStringAttr("auto");
  return attr;
}

::mlir::LogicalResult CollectiveReduceV2OpAdaptor::verify(::mlir::Location loc) {
  {
  auto tblgen_merge_op = odsAttrs.get("merge_op");
  if (!tblgen_merge_op) return emitError(loc, "'tf.CollectiveReduceV2' op ""requires attribute 'merge_op'");
    if (!((tblgen_merge_op.cast<StringAttr>().getValue() == "Min" || tblgen_merge_op.cast<StringAttr>().getValue() == "Max" || tblgen_merge_op.cast<StringAttr>().getValue() == "Mul" || tblgen_merge_op.cast<StringAttr>().getValue() == "Add"))) return emitError(loc, "'tf.CollectiveReduceV2' op ""attribute 'merge_op' failed to satisfy constraint: string attribute whose value is Min, or Max, or Mul, or Add");
  }
  {
  auto tblgen_final_op = odsAttrs.get("final_op");
  if (!tblgen_final_op) return emitError(loc, "'tf.CollectiveReduceV2' op ""requires attribute 'final_op'");
    if (!((tblgen_final_op.cast<StringAttr>().getValue() == "Id" || tblgen_final_op.cast<StringAttr>().getValue() == "Div"))) return emitError(loc, "'tf.CollectiveReduceV2' op ""attribute 'final_op' failed to satisfy constraint: string attribute whose value is Id, or Div");
  }
  {
  auto tblgen_communication_hint = odsAttrs.get("communication_hint");
  if (tblgen_communication_hint) {
    if (!((tblgen_communication_hint.isa<::mlir::StringAttr>()))) return emitError(loc, "'tf.CollectiveReduceV2' op ""attribute 'communication_hint' failed to satisfy constraint: string attribute");
  }
  }
  return ::mlir::success();
}

::llvm::StringRef CollectiveReduceV2Op::getOperationName() {
  return "tf.CollectiveReduceV2";
}

std::pair<unsigned, unsigned> CollectiveReduceV2Op::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range CollectiveReduceV2Op::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value CollectiveReduceV2Op::input() {
  return *getODSOperands(0).begin();
}

::mlir::Value CollectiveReduceV2Op::group_size() {
  return *getODSOperands(1).begin();
}

::mlir::Value CollectiveReduceV2Op::group_key() {
  return *getODSOperands(2).begin();
}

::mlir::Value CollectiveReduceV2Op::instance_key() {
  return *getODSOperands(3).begin();
}

::mlir::MutableOperandRange CollectiveReduceV2Op::inputMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange CollectiveReduceV2Op::group_sizeMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange CollectiveReduceV2Op::group_keyMutable() {
  auto range = getODSOperandIndexAndLength(2);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange CollectiveReduceV2Op::instance_keyMutable() {
  auto range = getODSOperandIndexAndLength(3);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> CollectiveReduceV2Op::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range CollectiveReduceV2Op::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value CollectiveReduceV2Op::data() {
  return *getODSResults(0).begin();
}

::mlir::StringAttr CollectiveReduceV2Op::merge_opAttr() {
  return this->getAttr("merge_op").cast<::mlir::StringAttr>();
}

::llvm::StringRef CollectiveReduceV2Op::merge_op() {
  auto attr = merge_opAttr();
  return attr.getValue();
}

::mlir::StringAttr CollectiveReduceV2Op::final_opAttr() {
  return this->getAttr("final_op").cast<::mlir::StringAttr>();
}

::llvm::StringRef CollectiveReduceV2Op::final_op() {
  auto attr = final_opAttr();
  return attr.getValue();
}

::mlir::StringAttr CollectiveReduceV2Op::communication_hintAttr() {
  return this->getAttr("communication_hint").dyn_cast_or_null<::mlir::StringAttr>();
}

::llvm::StringRef CollectiveReduceV2Op::communication_hint() {
  auto attr = communication_hintAttr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getStringAttr("auto").getValue();
  return attr.getValue();
}

Type CollectiveReduceV2Op::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

bool CollectiveReduceV2Op::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "T") return true;
 return false;
}

::mlir::DictionaryAttr CollectiveReduceV2Op::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())}
    }, ctx);
}

void CollectiveReduceV2Op::merge_opAttr(::mlir::StringAttr attr) {
  this->getOperation()->setAttr("merge_op", attr);
}

void CollectiveReduceV2Op::final_opAttr(::mlir::StringAttr attr) {
  this->getOperation()->setAttr("final_op", attr);
}

void CollectiveReduceV2Op::communication_hintAttr(::mlir::StringAttr attr) {
  this->getOperation()->setAttr("communication_hint", attr);
}

void CollectiveReduceV2Op::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type data, ::mlir::Value input, ::mlir::Value group_size, ::mlir::Value group_key, ::mlir::Value instance_key, ::mlir::StringAttr merge_op, ::mlir::StringAttr final_op, ::mlir::StringAttr communication_hint) {
  odsState.addOperands(input);
  odsState.addOperands(group_size);
  odsState.addOperands(group_key);
  odsState.addOperands(instance_key);
  odsState.addAttribute("merge_op", merge_op);
  odsState.addAttribute("final_op", final_op);
  odsState.addAttribute("communication_hint", communication_hint);
  odsState.addTypes(data);
}

void CollectiveReduceV2Op::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input, ::mlir::Value group_size, ::mlir::Value group_key, ::mlir::Value instance_key, ::mlir::StringAttr merge_op, ::mlir::StringAttr final_op, ::mlir::StringAttr communication_hint) {
  odsState.addOperands(input);
  odsState.addOperands(group_size);
  odsState.addOperands(group_key);
  odsState.addOperands(instance_key);
  odsState.addAttribute("merge_op", merge_op);
  odsState.addAttribute("final_op", final_op);
  odsState.addAttribute("communication_hint", communication_hint);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void CollectiveReduceV2Op::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type data, ::mlir::Value input, ::mlir::Value group_size, ::mlir::Value group_key, ::mlir::Value instance_key, ::llvm::StringRef merge_op, ::llvm::StringRef final_op, ::llvm::StringRef communication_hint) {
  odsState.addOperands(input);
  odsState.addOperands(group_size);
  odsState.addOperands(group_key);
  odsState.addOperands(instance_key);
  odsState.addAttribute("merge_op", odsBuilder.getStringAttr(merge_op));
  odsState.addAttribute("final_op", odsBuilder.getStringAttr(final_op));
  odsState.addAttribute("communication_hint", odsBuilder.getStringAttr(communication_hint));
  odsState.addTypes(data);
}

void CollectiveReduceV2Op::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input, ::mlir::Value group_size, ::mlir::Value group_key, ::mlir::Value instance_key, ::llvm::StringRef merge_op, ::llvm::StringRef final_op, ::llvm::StringRef communication_hint) {
  odsState.addOperands(input);
  odsState.addOperands(group_size);
  odsState.addOperands(group_key);
  odsState.addOperands(instance_key);
  odsState.addAttribute("merge_op", odsBuilder.getStringAttr(merge_op));
  odsState.addAttribute("final_op", odsBuilder.getStringAttr(final_op));
  odsState.addAttribute("communication_hint", odsBuilder.getStringAttr(communication_hint));
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void CollectiveReduceV2Op::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 4u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult CollectiveReduceV2Op::verify() {
  if (failed(CollectiveReduceV2OpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of 16-bit float or 32-bit float or 64-bit float or 32-bit integer or 64-bit integer values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of 32-bit integer values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup2 = getODSOperands(2);
    for (::mlir::Value v : valueGroup2) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of 32-bit integer values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup3 = getODSOperands(3);
    for (::mlir::Value v : valueGroup3) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of 32-bit integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))))) {
        return emitOpError("result #") << index << " must be tensor of 16-bit float or 32-bit float or 64-bit float or 32-bit integer or 64-bit integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::ComplexAbsOp definitions
//===----------------------------------------------------------------------===//

ComplexAbsOpAdaptor::ComplexAbsOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

ComplexAbsOpAdaptor::ComplexAbsOpAdaptor(ComplexAbsOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> ComplexAbsOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange ComplexAbsOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value ComplexAbsOpAdaptor::x() {
  return *getODSOperands(0).begin();
}

::mlir::LogicalResult ComplexAbsOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

::llvm::StringRef ComplexAbsOp::getOperationName() {
  return "tf.ComplexAbs";
}

std::pair<unsigned, unsigned> ComplexAbsOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range ComplexAbsOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value ComplexAbsOp::x() {
  return *getODSOperands(0).begin();
}

::mlir::MutableOperandRange ComplexAbsOp::xMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> ComplexAbsOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range ComplexAbsOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value ComplexAbsOp::y() {
  return *getODSResults(0).begin();
}

Type ComplexAbsOp::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

Type ComplexAbsOp::Tout() {
  return mlir::getElementTypeOrSelf(*getODSResults(0).begin());
}

bool ComplexAbsOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "T") return true;
  if (name == "Tout") return true;
 return false;
}

::mlir::DictionaryAttr ComplexAbsOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())},
    {::mlir::Identifier::get("Tout", ctx),
::mlir::TypeAttr::get(Tout())}
    }, ctx);
}

void ComplexAbsOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type y, ::mlir::Value x) {
  odsState.addOperands(x);
  odsState.addTypes(y);
}

void ComplexAbsOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value x) {
  odsState.addOperands(x);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void ComplexAbsOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult ComplexAbsOp::verify() {
  if (failed(ComplexAbsOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of 128-bit complex or 64-bit complex values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())))))) {
        return emitOpError("result #") << index << " must be tensor of 32/64-bit float values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void ComplexAbsOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::ComplexOp definitions
//===----------------------------------------------------------------------===//

ComplexOpAdaptor::ComplexOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

ComplexOpAdaptor::ComplexOpAdaptor(ComplexOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> ComplexOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange ComplexOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value ComplexOpAdaptor::real() {
  return *getODSOperands(0).begin();
}

::mlir::Value ComplexOpAdaptor::imag() {
  return *getODSOperands(1).begin();
}

::mlir::LogicalResult ComplexOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

::llvm::StringRef ComplexOp::getOperationName() {
  return "tf.Complex";
}

std::pair<unsigned, unsigned> ComplexOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range ComplexOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value ComplexOp::real() {
  return *getODSOperands(0).begin();
}

::mlir::Value ComplexOp::imag() {
  return *getODSOperands(1).begin();
}

::mlir::MutableOperandRange ComplexOp::realMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange ComplexOp::imagMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> ComplexOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range ComplexOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value ComplexOp::out() {
  return *getODSResults(0).begin();
}

Type ComplexOp::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

Type ComplexOp::Tout() {
  return mlir::getElementTypeOrSelf(*getODSResults(0).begin());
}

bool ComplexOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "T") return true;
  if (name == "Tout") return true;
 return false;
}

::mlir::DictionaryAttr ComplexOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())},
    {::mlir::Identifier::get("Tout", ctx),
::mlir::TypeAttr::get(Tout())}
    }, ctx);
}

void ComplexOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type out, ::mlir::Value real, ::mlir::Value imag) {
  odsState.addOperands(real);
  odsState.addOperands(imag);
  odsState.addTypes(out);
}

void ComplexOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value real, ::mlir::Value imag) {
  odsState.addOperands(real);
  odsState.addOperands(imag);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void ComplexOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult ComplexOp::verify() {
  if (failed(ComplexOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of 32/64-bit float values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of 32/64-bit float values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>())))))) {
        return emitOpError("result #") << index << " must be tensor of 128-bit complex or 64-bit complex values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void ComplexOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::ConcatOffsetOp definitions
//===----------------------------------------------------------------------===//

ConcatOffsetOpAdaptor::ConcatOffsetOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

ConcatOffsetOpAdaptor::ConcatOffsetOpAdaptor(ConcatOffsetOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> ConcatOffsetOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  bool isVariadic[] = {false, true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (odsOperands.size() - 1) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::mlir::ValueRange ConcatOffsetOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value ConcatOffsetOpAdaptor::concat_dim() {
  return *getODSOperands(0).begin();
}

::mlir::ValueRange ConcatOffsetOpAdaptor::shape() {
  return getODSOperands(1);
}

::mlir::LogicalResult ConcatOffsetOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

::llvm::StringRef ConcatOffsetOp::getOperationName() {
  return "tf.ConcatOffset";
}

std::pair<unsigned, unsigned> ConcatOffsetOp::getODSOperandIndexAndLength(unsigned index) {
  bool isVariadic[] = {false, true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (getOperation()->getNumOperands() - 1) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::mlir::Operation::operand_range ConcatOffsetOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value ConcatOffsetOp::concat_dim() {
  return *getODSOperands(0).begin();
}

::mlir::Operation::operand_range ConcatOffsetOp::shape() {
  return getODSOperands(1);
}

::mlir::MutableOperandRange ConcatOffsetOp::concat_dimMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange ConcatOffsetOp::shapeMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> ConcatOffsetOp::getODSResultIndexAndLength(unsigned index) {
  bool isVariadic[] = {true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (getOperation()->getNumResults() - 0) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::mlir::Operation::result_range ConcatOffsetOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Operation::result_range ConcatOffsetOp::offset() {
  return getODSResults(0);
}

size_t ConcatOffsetOp::N() {
  auto range = getODSOperands(1);
return std::distance(range.begin(), range.end());
}

bool ConcatOffsetOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "N") return true;
 return false;
}

::mlir::DictionaryAttr ConcatOffsetOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("N", ctx),
odsBuilder.getI64IntegerAttr(N())}
    }, ctx);
}

void ConcatOffsetOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange offset, ::mlir::Value concat_dim, ::mlir::ValueRange shape) {
  odsState.addOperands(concat_dim);
  odsState.addOperands(shape);
  odsState.addTypes(offset);
}

void ConcatOffsetOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() >= 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult ConcatOffsetOp::verify() {
  if (failed(ConcatOffsetOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of 32-bit integer values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of 32-bit integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))))) {
        return emitOpError("result #") << index << " must be tensor of 32-bit integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  return Verify(*this);
}



void ConcatOffsetOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::ConcatOp definitions
//===----------------------------------------------------------------------===//

ConcatOpAdaptor::ConcatOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

ConcatOpAdaptor::ConcatOpAdaptor(ConcatOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> ConcatOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  bool isVariadic[] = {false, true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (odsOperands.size() - 1) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::mlir::ValueRange ConcatOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value ConcatOpAdaptor::concat_dim() {
  return *getODSOperands(0).begin();
}

::mlir::ValueRange ConcatOpAdaptor::values() {
  return getODSOperands(1);
}

::mlir::LogicalResult ConcatOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

::llvm::StringRef ConcatOp::getOperationName() {
  return "tf.Concat";
}

std::pair<unsigned, unsigned> ConcatOp::getODSOperandIndexAndLength(unsigned index) {
  bool isVariadic[] = {false, true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (getOperation()->getNumOperands() - 1) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::mlir::Operation::operand_range ConcatOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value ConcatOp::concat_dim() {
  return *getODSOperands(0).begin();
}

::mlir::Operation::operand_range ConcatOp::values() {
  return getODSOperands(1);
}

::mlir::MutableOperandRange ConcatOp::concat_dimMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange ConcatOp::valuesMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> ConcatOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range ConcatOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value ConcatOp::output() {
  return *getODSResults(0).begin();
}

Type ConcatOp::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(1).begin());
}

size_t ConcatOp::N() {
  auto range = getODSOperands(1);
return std::distance(range.begin(), range.end());
}

bool ConcatOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "T") return true;
  if (name == "N") return true;
 return false;
}

::mlir::DictionaryAttr ConcatOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())},
    {::mlir::Identifier::get("N", ctx),
odsBuilder.getI64IntegerAttr(N())}
    }, ctx);
}

void ConcatOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value concat_dim, ::mlir::ValueRange values) {
  odsState.addOperands(concat_dim);
  odsState.addOperands(values);
  odsState.addTypes(output);
}

void ConcatOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value concat_dim, ::mlir::ValueRange values) {
  odsState.addOperands(concat_dim);
  odsState.addOperands(values);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void ConcatOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() >= 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult ConcatOp::verify() {
  if (failed(ConcatOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of 32-bit integer values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>())))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::TensorFlowType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of tf.dtype values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>())))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::TensorFlowType>()))))) {
        return emitOpError("result #") << index << " must be tensor of tf.dtype values, but got " << v.getType();
      }
      ++index;
    }
  }
  return Verify(*this);
}



void ConcatOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::ConcatV2Op definitions
//===----------------------------------------------------------------------===//

ConcatV2OpAdaptor::ConcatV2OpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

ConcatV2OpAdaptor::ConcatV2OpAdaptor(ConcatV2Op&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> ConcatV2OpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  bool isVariadic[] = {true, false};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (odsOperands.size() - 1) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::mlir::ValueRange ConcatV2OpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::ValueRange ConcatV2OpAdaptor::values() {
  return getODSOperands(0);
}

::mlir::Value ConcatV2OpAdaptor::axis() {
  return *getODSOperands(1).begin();
}

::mlir::LogicalResult ConcatV2OpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

::llvm::StringRef ConcatV2Op::getOperationName() {
  return "tf.ConcatV2";
}

std::pair<unsigned, unsigned> ConcatV2Op::getODSOperandIndexAndLength(unsigned index) {
  bool isVariadic[] = {true, false};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (getOperation()->getNumOperands() - 1) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::mlir::Operation::operand_range ConcatV2Op::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Operation::operand_range ConcatV2Op::values() {
  return getODSOperands(0);
}

::mlir::Value ConcatV2Op::axis() {
  return *getODSOperands(1).begin();
}

::mlir::MutableOperandRange ConcatV2Op::valuesMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange ConcatV2Op::axisMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> ConcatV2Op::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range ConcatV2Op::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value ConcatV2Op::output() {
  return *getODSResults(0).begin();
}

Type ConcatV2Op::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

Type ConcatV2Op::Tidx() {
  return mlir::getElementTypeOrSelf(*getODSOperands(1).begin());
}

size_t ConcatV2Op::N() {
  auto range = getODSOperands(0);
return std::distance(range.begin(), range.end());
}

bool ConcatV2Op::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "T") return true;
  if (name == "Tidx") return true;
  if (name == "N") return true;
 return false;
}

::mlir::DictionaryAttr ConcatV2Op::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())},
    {::mlir::Identifier::get("Tidx", ctx),
::mlir::TypeAttr::get(Tidx())},
    {::mlir::Identifier::get("N", ctx),
odsBuilder.getI64IntegerAttr(N())}
    }, ctx);
}

void ConcatV2Op::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::ValueRange values, ::mlir::Value axis) {
  odsState.addOperands(values);
  odsState.addOperands(axis);
  odsState.addTypes(output);
}

void ConcatV2Op::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange values, ::mlir::Value axis) {
  odsState.addOperands(values);
  odsState.addOperands(axis);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void ConcatV2Op::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() >= 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult ConcatV2Op::verify() {
  if (failed(ConcatV2OpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>())))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::TensorFlowType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of tf.dtype values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of 32/64-bit signed integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>())))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::TensorFlowType>()))))) {
        return emitOpError("result #") << index << " must be tensor of tf.dtype values, but got " << v.getType();
      }
      ++index;
    }
  }
  return Verify(*this);
}



void ConcatV2Op::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::ConfigureDistributedTPUOp definitions
//===----------------------------------------------------------------------===//

ConfigureDistributedTPUOpAdaptor::ConfigureDistributedTPUOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

ConfigureDistributedTPUOpAdaptor::ConfigureDistributedTPUOpAdaptor(ConfigureDistributedTPUOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> ConfigureDistributedTPUOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange ConfigureDistributedTPUOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::StringAttr ConfigureDistributedTPUOpAdaptor::embedding_config() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::StringAttr attr = odsAttrs.get("embedding_config").cast<::mlir::StringAttr>();
  return attr;
}

::mlir::StringAttr ConfigureDistributedTPUOpAdaptor::tpu_embedding_config() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::StringAttr attr = odsAttrs.get("tpu_embedding_config").cast<::mlir::StringAttr>();
  return attr;
}

::mlir::BoolAttr ConfigureDistributedTPUOpAdaptor::is_global_init() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::BoolAttr attr = odsAttrs.get("is_global_init").dyn_cast_or_null<::mlir::BoolAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getBoolAttr(false);
  return attr;
}

::mlir::BoolAttr ConfigureDistributedTPUOpAdaptor::enable_whole_mesh_compilations() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::BoolAttr attr = odsAttrs.get("enable_whole_mesh_compilations").dyn_cast_or_null<::mlir::BoolAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getBoolAttr(false);
  return attr;
}

::mlir::BoolAttr ConfigureDistributedTPUOpAdaptor::compilation_failure_closes_chips() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::BoolAttr attr = odsAttrs.get("compilation_failure_closes_chips").dyn_cast_or_null<::mlir::BoolAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getBoolAttr(true);
  return attr;
}

::mlir::LogicalResult ConfigureDistributedTPUOpAdaptor::verify(::mlir::Location loc) {
  {
  auto tblgen_embedding_config = odsAttrs.get("embedding_config");
  if (!tblgen_embedding_config) return emitError(loc, "'tf.ConfigureDistributedTPU' op ""requires attribute 'embedding_config'");
    if (!((tblgen_embedding_config.isa<::mlir::StringAttr>()))) return emitError(loc, "'tf.ConfigureDistributedTPU' op ""attribute 'embedding_config' failed to satisfy constraint: string attribute");
  }
  {
  auto tblgen_tpu_embedding_config = odsAttrs.get("tpu_embedding_config");
  if (!tblgen_tpu_embedding_config) return emitError(loc, "'tf.ConfigureDistributedTPU' op ""requires attribute 'tpu_embedding_config'");
    if (!((tblgen_tpu_embedding_config.isa<::mlir::StringAttr>()))) return emitError(loc, "'tf.ConfigureDistributedTPU' op ""attribute 'tpu_embedding_config' failed to satisfy constraint: string attribute");
  }
  {
  auto tblgen_is_global_init = odsAttrs.get("is_global_init");
  if (tblgen_is_global_init) {
    if (!((tblgen_is_global_init.isa<::mlir::BoolAttr>()))) return emitError(loc, "'tf.ConfigureDistributedTPU' op ""attribute 'is_global_init' failed to satisfy constraint: bool attribute");
  }
  }
  {
  auto tblgen_enable_whole_mesh_compilations = odsAttrs.get("enable_whole_mesh_compilations");
  if (tblgen_enable_whole_mesh_compilations) {
    if (!((tblgen_enable_whole_mesh_compilations.isa<::mlir::BoolAttr>()))) return emitError(loc, "'tf.ConfigureDistributedTPU' op ""attribute 'enable_whole_mesh_compilations' failed to satisfy constraint: bool attribute");
  }
  }
  {
  auto tblgen_compilation_failure_closes_chips = odsAttrs.get("compilation_failure_closes_chips");
  if (tblgen_compilation_failure_closes_chips) {
    if (!((tblgen_compilation_failure_closes_chips.isa<::mlir::BoolAttr>()))) return emitError(loc, "'tf.ConfigureDistributedTPU' op ""attribute 'compilation_failure_closes_chips' failed to satisfy constraint: bool attribute");
  }
  }
  return ::mlir::success();
}

::llvm::StringRef ConfigureDistributedTPUOp::getOperationName() {
  return "tf.ConfigureDistributedTPU";
}

std::pair<unsigned, unsigned> ConfigureDistributedTPUOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range ConfigureDistributedTPUOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

std::pair<unsigned, unsigned> ConfigureDistributedTPUOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range ConfigureDistributedTPUOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value ConfigureDistributedTPUOp::topology() {
  return *getODSResults(0).begin();
}

::mlir::StringAttr ConfigureDistributedTPUOp::embedding_configAttr() {
  return this->getAttr("embedding_config").cast<::mlir::StringAttr>();
}

::llvm::StringRef ConfigureDistributedTPUOp::embedding_config() {
  auto attr = embedding_configAttr();
  return attr.getValue();
}

::mlir::StringAttr ConfigureDistributedTPUOp::tpu_embedding_configAttr() {
  return this->getAttr("tpu_embedding_config").cast<::mlir::StringAttr>();
}

::llvm::StringRef ConfigureDistributedTPUOp::tpu_embedding_config() {
  auto attr = tpu_embedding_configAttr();
  return attr.getValue();
}

::mlir::BoolAttr ConfigureDistributedTPUOp::is_global_initAttr() {
  return this->getAttr("is_global_init").dyn_cast_or_null<::mlir::BoolAttr>();
}

bool ConfigureDistributedTPUOp::is_global_init() {
  auto attr = is_global_initAttr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getBoolAttr(false).getValue();
  return attr.getValue();
}

::mlir::BoolAttr ConfigureDistributedTPUOp::enable_whole_mesh_compilationsAttr() {
  return this->getAttr("enable_whole_mesh_compilations").dyn_cast_or_null<::mlir::BoolAttr>();
}

bool ConfigureDistributedTPUOp::enable_whole_mesh_compilations() {
  auto attr = enable_whole_mesh_compilationsAttr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getBoolAttr(false).getValue();
  return attr.getValue();
}

::mlir::BoolAttr ConfigureDistributedTPUOp::compilation_failure_closes_chipsAttr() {
  return this->getAttr("compilation_failure_closes_chips").dyn_cast_or_null<::mlir::BoolAttr>();
}

bool ConfigureDistributedTPUOp::compilation_failure_closes_chips() {
  auto attr = compilation_failure_closes_chipsAttr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getBoolAttr(true).getValue();
  return attr.getValue();
}

void ConfigureDistributedTPUOp::embedding_configAttr(::mlir::StringAttr attr) {
  this->getOperation()->setAttr("embedding_config", attr);
}

void ConfigureDistributedTPUOp::tpu_embedding_configAttr(::mlir::StringAttr attr) {
  this->getOperation()->setAttr("tpu_embedding_config", attr);
}

void ConfigureDistributedTPUOp::is_global_initAttr(::mlir::BoolAttr attr) {
  this->getOperation()->setAttr("is_global_init", attr);
}

void ConfigureDistributedTPUOp::enable_whole_mesh_compilationsAttr(::mlir::BoolAttr attr) {
  this->getOperation()->setAttr("enable_whole_mesh_compilations", attr);
}

void ConfigureDistributedTPUOp::compilation_failure_closes_chipsAttr(::mlir::BoolAttr attr) {
  this->getOperation()->setAttr("compilation_failure_closes_chips", attr);
}

void ConfigureDistributedTPUOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type topology, ::mlir::StringAttr embedding_config, ::mlir::StringAttr tpu_embedding_config, ::mlir::BoolAttr is_global_init, ::mlir::BoolAttr enable_whole_mesh_compilations, ::mlir::BoolAttr compilation_failure_closes_chips) {
  odsState.addAttribute("embedding_config", embedding_config);
  odsState.addAttribute("tpu_embedding_config", tpu_embedding_config);
  odsState.addAttribute("is_global_init", is_global_init);
  odsState.addAttribute("enable_whole_mesh_compilations", enable_whole_mesh_compilations);
  odsState.addAttribute("compilation_failure_closes_chips", compilation_failure_closes_chips);
  odsState.addTypes(topology);
}

void ConfigureDistributedTPUOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::StringAttr embedding_config, ::mlir::StringAttr tpu_embedding_config, ::mlir::BoolAttr is_global_init, ::mlir::BoolAttr enable_whole_mesh_compilations, ::mlir::BoolAttr compilation_failure_closes_chips) {
  odsState.addAttribute("embedding_config", embedding_config);
  odsState.addAttribute("tpu_embedding_config", tpu_embedding_config);
  odsState.addAttribute("is_global_init", is_global_init);
  odsState.addAttribute("enable_whole_mesh_compilations", enable_whole_mesh_compilations);
  odsState.addAttribute("compilation_failure_closes_chips", compilation_failure_closes_chips);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void ConfigureDistributedTPUOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type topology, ::llvm::StringRef embedding_config, ::llvm::StringRef tpu_embedding_config, bool is_global_init, bool enable_whole_mesh_compilations, bool compilation_failure_closes_chips) {
  odsState.addAttribute("embedding_config", odsBuilder.getStringAttr(embedding_config));
  odsState.addAttribute("tpu_embedding_config", odsBuilder.getStringAttr(tpu_embedding_config));
  odsState.addAttribute("is_global_init", odsBuilder.getBoolAttr(is_global_init));
  odsState.addAttribute("enable_whole_mesh_compilations", odsBuilder.getBoolAttr(enable_whole_mesh_compilations));
  odsState.addAttribute("compilation_failure_closes_chips", odsBuilder.getBoolAttr(compilation_failure_closes_chips));
  odsState.addTypes(topology);
}

void ConfigureDistributedTPUOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::llvm::StringRef embedding_config, ::llvm::StringRef tpu_embedding_config, bool is_global_init, bool enable_whole_mesh_compilations, bool compilation_failure_closes_chips) {
  odsState.addAttribute("embedding_config", odsBuilder.getStringAttr(embedding_config));
  odsState.addAttribute("tpu_embedding_config", odsBuilder.getStringAttr(tpu_embedding_config));
  odsState.addAttribute("is_global_init", odsBuilder.getBoolAttr(is_global_init));
  odsState.addAttribute("enable_whole_mesh_compilations", odsBuilder.getBoolAttr(enable_whole_mesh_compilations));
  odsState.addAttribute("compilation_failure_closes_chips", odsBuilder.getBoolAttr(compilation_failure_closes_chips));
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void ConfigureDistributedTPUOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 0u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult ConfigureDistributedTPUOp::verify() {
  if (failed(ConfigureDistributedTPUOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::StringType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::StringRefType>()))))) {
        return emitOpError("result #") << index << " must be tensor of string values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::ConfigureTPUEmbeddingOp definitions
//===----------------------------------------------------------------------===//

ConfigureTPUEmbeddingOpAdaptor::ConfigureTPUEmbeddingOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

ConfigureTPUEmbeddingOpAdaptor::ConfigureTPUEmbeddingOpAdaptor(ConfigureTPUEmbeddingOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> ConfigureTPUEmbeddingOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange ConfigureTPUEmbeddingOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::StringAttr ConfigureTPUEmbeddingOpAdaptor::config() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::StringAttr attr = odsAttrs.get("config").cast<::mlir::StringAttr>();
  return attr;
}

::mlir::LogicalResult ConfigureTPUEmbeddingOpAdaptor::verify(::mlir::Location loc) {
  {
  auto tblgen_config = odsAttrs.get("config");
  if (!tblgen_config) return emitError(loc, "'tf.ConfigureTPUEmbedding' op ""requires attribute 'config'");
    if (!((tblgen_config.isa<::mlir::StringAttr>()))) return emitError(loc, "'tf.ConfigureTPUEmbedding' op ""attribute 'config' failed to satisfy constraint: string attribute");
  }
  return ::mlir::success();
}

::llvm::StringRef ConfigureTPUEmbeddingOp::getOperationName() {
  return "tf.ConfigureTPUEmbedding";
}

std::pair<unsigned, unsigned> ConfigureTPUEmbeddingOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range ConfigureTPUEmbeddingOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

std::pair<unsigned, unsigned> ConfigureTPUEmbeddingOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range ConfigureTPUEmbeddingOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::StringAttr ConfigureTPUEmbeddingOp::configAttr() {
  return this->getAttr("config").cast<::mlir::StringAttr>();
}

::llvm::StringRef ConfigureTPUEmbeddingOp::config() {
  auto attr = configAttr();
  return attr.getValue();
}

void ConfigureTPUEmbeddingOp::configAttr(::mlir::StringAttr attr) {
  this->getOperation()->setAttr("config", attr);
}

void ConfigureTPUEmbeddingOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::StringAttr config) {
  odsState.addAttribute("config", config);
}

void ConfigureTPUEmbeddingOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::StringAttr config) {
  odsState.addAttribute("config", config);
  assert(resultTypes.size() == 0u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void ConfigureTPUEmbeddingOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::llvm::StringRef config) {
  odsState.addAttribute("config", odsBuilder.getStringAttr(config));
}

void ConfigureTPUEmbeddingOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::llvm::StringRef config) {
  odsState.addAttribute("config", odsBuilder.getStringAttr(config));
  assert(resultTypes.size() == 0u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void ConfigureTPUEmbeddingOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 0u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 0u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult ConfigureTPUEmbeddingOp::verify() {
  if (failed(ConfigureTPUEmbeddingOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
  }
  {
    unsigned index = 0; (void)index;
  }
  return ::mlir::success();
}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::ConjOp definitions
//===----------------------------------------------------------------------===//

ConjOpAdaptor::ConjOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

ConjOpAdaptor::ConjOpAdaptor(ConjOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> ConjOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange ConjOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value ConjOpAdaptor::input() {
  return *getODSOperands(0).begin();
}

::mlir::LogicalResult ConjOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

::llvm::StringRef ConjOp::getOperationName() {
  return "tf.Conj";
}

std::pair<unsigned, unsigned> ConjOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range ConjOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value ConjOp::input() {
  return *getODSOperands(0).begin();
}

::mlir::MutableOperandRange ConjOp::inputMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> ConjOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range ConjOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value ConjOp::output() {
  return *getODSResults(0).begin();
}

Type ConjOp::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

bool ConjOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "T") return true;
 return false;
}

::mlir::DictionaryAttr ConjOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())}
    }, ctx);
}

void ConjOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value input) {
  odsState.addOperands(input);
  odsState.addTypes(output);
}

void ConjOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input) {
  odsState.addOperands(input);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void ConjOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

void ConjOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value input) {
  odsState.addOperands(input);
  odsState.addTypes({input.getType()});

}

void ConjOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  odsState.addTypes({operands[0].getType()});

}

::mlir::LogicalResult ConjOp::verify() {
  if (failed(ConjOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::VariantType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::VariantRefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of 128-bit complex or 64-bit complex or variant values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::VariantType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::VariantRefType>())))))) {
        return emitOpError("result #") << index << " must be tensor of 128-bit complex or 64-bit complex or variant values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}



void ConjOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::ConjugateTransposeOp definitions
//===----------------------------------------------------------------------===//

ConjugateTransposeOpAdaptor::ConjugateTransposeOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

ConjugateTransposeOpAdaptor::ConjugateTransposeOpAdaptor(ConjugateTransposeOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> ConjugateTransposeOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange ConjugateTransposeOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value ConjugateTransposeOpAdaptor::x() {
  return *getODSOperands(0).begin();
}

::mlir::Value ConjugateTransposeOpAdaptor::perm() {
  return *getODSOperands(1).begin();
}

::mlir::LogicalResult ConjugateTransposeOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

::llvm::StringRef ConjugateTransposeOp::getOperationName() {
  return "tf.ConjugateTranspose";
}

std::pair<unsigned, unsigned> ConjugateTransposeOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range ConjugateTransposeOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value ConjugateTransposeOp::x() {
  return *getODSOperands(0).begin();
}

::mlir::Value ConjugateTransposeOp::perm() {
  return *getODSOperands(1).begin();
}

::mlir::MutableOperandRange ConjugateTransposeOp::xMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange ConjugateTransposeOp::permMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> ConjugateTransposeOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range ConjugateTransposeOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value ConjugateTransposeOp::y() {
  return *getODSResults(0).begin();
}

Type ConjugateTransposeOp::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

Type ConjugateTransposeOp::Tperm() {
  return mlir::getElementTypeOrSelf(*getODSOperands(1).begin());
}

bool ConjugateTransposeOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "T") return true;
  if (name == "Tperm") return true;
 return false;
}

::mlir::DictionaryAttr ConjugateTransposeOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())},
    {::mlir::Identifier::get("Tperm", ctx),
::mlir::TypeAttr::get(Tperm())}
    }, ctx);
}

void ConjugateTransposeOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type y, ::mlir::Value x, ::mlir::Value perm) {
  odsState.addOperands(x);
  odsState.addOperands(perm);
  odsState.addTypes(y);
}

void ConjugateTransposeOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value x, ::mlir::Value perm) {
  odsState.addOperands(x);
  odsState.addOperands(perm);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void ConjugateTransposeOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult ConjugateTransposeOp::verify() {
  if (failed(ConjugateTransposeOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>())))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::TensorFlowType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of tf.dtype values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of 32/64-bit signed integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>())))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::TensorFlowType>()))))) {
        return emitOpError("result #") << index << " must be tensor of tf.dtype values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void ConjugateTransposeOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::ConstOp definitions
//===----------------------------------------------------------------------===//

ConstOpAdaptor::ConstOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

ConstOpAdaptor::ConstOpAdaptor(ConstOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> ConstOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange ConstOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::ElementsAttr ConstOpAdaptor::value() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::ElementsAttr attr = odsAttrs.get("value").cast<::mlir::ElementsAttr>();
  return attr;
}

::mlir::LogicalResult ConstOpAdaptor::verify(::mlir::Location loc) {
  {
  auto tblgen_value = odsAttrs.get("value");
  if (!tblgen_value) return emitError(loc, "'tf.Const' op ""requires attribute 'value'");
    if (!((tblgen_value.isa<::mlir::ElementsAttr>()))) return emitError(loc, "'tf.Const' op ""attribute 'value' failed to satisfy constraint: constant vector/tensor attribute");
  }
  return ::mlir::success();
}

::llvm::StringRef ConstOp::getOperationName() {
  return "tf.Const";
}

std::pair<unsigned, unsigned> ConstOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range ConstOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

std::pair<unsigned, unsigned> ConstOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range ConstOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value ConstOp::output() {
  return *getODSResults(0).begin();
}

::mlir::ElementsAttr ConstOp::valueAttr() {
  return this->getAttr("value").cast<::mlir::ElementsAttr>();
}

::mlir::ElementsAttr ConstOp::value() {
  auto attr = valueAttr();
  return attr;
}

Type ConstOp::dtype() {
  return mlir::getElementTypeOrSelf(*getODSResults(0).begin());
}

bool ConstOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "dtype") return true;
 return false;
}

::mlir::DictionaryAttr ConstOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("dtype", ctx),
::mlir::TypeAttr::get(dtype())}
    }, ctx);
}

void ConstOp::valueAttr(::mlir::ElementsAttr attr) {
  this->getOperation()->setAttr("value", attr);
}





void ConstOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::ElementsAttr value) {
  odsState.addAttribute("value", value);
  odsState.addTypes(output);
}

void ConstOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ElementsAttr value) {
  odsState.addAttribute("value", value);

        ::llvm::SmallVector<::mlir::Type, 2> inferredReturnTypes;
        if (succeeded(ConstOp::inferReturnTypes(odsBuilder.getContext(),
                      odsState.location, odsState.operands,
                      odsState.attributes.getDictionary(odsState.getContext()),
                      /*regions=*/{}, inferredReturnTypes)))
          odsState.addTypes(inferredReturnTypes);
        else
          ::llvm::report_fatal_error("Failed to infer result type(s).");
}

void ConstOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ElementsAttr value) {
  odsState.addAttribute("value", value);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void ConstOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 0u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

void ConstOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 0u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);

    ::mlir::SmallVector<::mlir::Type, 2> inferredReturnTypes;
    if (succeeded(ConstOp::inferReturnTypes(odsBuilder.getContext(),
                  odsState.location, operands,
                  odsState.attributes.getDictionary(odsState.getContext()),
                  /*regions=*/{}, inferredReturnTypes))) {  assert(inferredReturnTypes.size() == 1u && "mismatched number of return types");
      odsState.addTypes(inferredReturnTypes);
    } else
      ::llvm::report_fatal_error("Failed to infer result type(s).");
}

::mlir::LogicalResult ConstOp::verify() {
  if (failed(ConstOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>())))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::TensorFlowType>()))))) {
        return emitOpError("result #") << index << " must be tensor of tf.dtype values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}





void ConstOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::Conv2DBackpropFilterOp definitions
//===----------------------------------------------------------------------===//

Conv2DBackpropFilterOpAdaptor::Conv2DBackpropFilterOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

Conv2DBackpropFilterOpAdaptor::Conv2DBackpropFilterOpAdaptor(Conv2DBackpropFilterOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> Conv2DBackpropFilterOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange Conv2DBackpropFilterOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value Conv2DBackpropFilterOpAdaptor::input() {
  return *getODSOperands(0).begin();
}

::mlir::Value Conv2DBackpropFilterOpAdaptor::filter_sizes() {
  return *getODSOperands(1).begin();
}

::mlir::Value Conv2DBackpropFilterOpAdaptor::out_backprop() {
  return *getODSOperands(2).begin();
}

::mlir::ArrayAttr Conv2DBackpropFilterOpAdaptor::strides() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::ArrayAttr attr = odsAttrs.get("strides").cast<::mlir::ArrayAttr>();
  return attr;
}

::mlir::BoolAttr Conv2DBackpropFilterOpAdaptor::use_cudnn_on_gpu() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::BoolAttr attr = odsAttrs.get("use_cudnn_on_gpu").dyn_cast_or_null<::mlir::BoolAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getBoolAttr(true);
  return attr;
}

::mlir::StringAttr Conv2DBackpropFilterOpAdaptor::padding() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::StringAttr attr = odsAttrs.get("padding").cast<::mlir::StringAttr>();
  return attr;
}

::mlir::ArrayAttr Conv2DBackpropFilterOpAdaptor::explicit_paddings() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::ArrayAttr attr = odsAttrs.get("explicit_paddings").dyn_cast_or_null<::mlir::ArrayAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getI64ArrayAttr({});
  return attr;
}

::mlir::StringAttr Conv2DBackpropFilterOpAdaptor::data_format() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::StringAttr attr = odsAttrs.get("data_format").dyn_cast_or_null<::mlir::StringAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getStringAttr("NHWC");
  return attr;
}

::mlir::ArrayAttr Conv2DBackpropFilterOpAdaptor::dilations() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::ArrayAttr attr = odsAttrs.get("dilations").dyn_cast_or_null<::mlir::ArrayAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getI64ArrayAttr({1, 1, 1, 1});
  return attr;
}

::mlir::LogicalResult Conv2DBackpropFilterOpAdaptor::verify(::mlir::Location loc) {
  {
  auto tblgen_strides = odsAttrs.get("strides");
  if (!tblgen_strides) return emitError(loc, "'tf.Conv2DBackpropFilter' op ""requires attribute 'strides'");
    if (!(((tblgen_strides.isa<::mlir::ArrayAttr>())) && (::llvm::all_of(tblgen_strides.cast<::mlir::ArrayAttr>(), [](::mlir::Attribute attr) { return ((attr.isa<::mlir::IntegerAttr>())) && ((attr.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(64))); })))) return emitError(loc, "'tf.Conv2DBackpropFilter' op ""attribute 'strides' failed to satisfy constraint: 64-bit integer array attribute");
  }
  {
  auto tblgen_use_cudnn_on_gpu = odsAttrs.get("use_cudnn_on_gpu");
  if (tblgen_use_cudnn_on_gpu) {
    if (!((tblgen_use_cudnn_on_gpu.isa<::mlir::BoolAttr>()))) return emitError(loc, "'tf.Conv2DBackpropFilter' op ""attribute 'use_cudnn_on_gpu' failed to satisfy constraint: bool attribute");
  }
  }
  {
  auto tblgen_padding = odsAttrs.get("padding");
  if (!tblgen_padding) return emitError(loc, "'tf.Conv2DBackpropFilter' op ""requires attribute 'padding'");
    if (!((tblgen_padding.cast<StringAttr>().getValue() == "SAME" || tblgen_padding.cast<StringAttr>().getValue() == "VALID" || tblgen_padding.cast<StringAttr>().getValue() == "EXPLICIT"))) return emitError(loc, "'tf.Conv2DBackpropFilter' op ""attribute 'padding' failed to satisfy constraint: string attribute whose value is SAME, or VALID, or EXPLICIT");
  }
  {
  auto tblgen_explicit_paddings = odsAttrs.get("explicit_paddings");
  if (tblgen_explicit_paddings) {
    if (!(((tblgen_explicit_paddings.isa<::mlir::ArrayAttr>())) && (::llvm::all_of(tblgen_explicit_paddings.cast<::mlir::ArrayAttr>(), [](::mlir::Attribute attr) { return ((attr.isa<::mlir::IntegerAttr>())) && ((attr.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(64))); })))) return emitError(loc, "'tf.Conv2DBackpropFilter' op ""attribute 'explicit_paddings' failed to satisfy constraint: 64-bit integer array attribute");
  }
  }
  {
  auto tblgen_data_format = odsAttrs.get("data_format");
  if (tblgen_data_format) {
    if (!((tblgen_data_format.cast<StringAttr>().getValue() == "NHWC" || tblgen_data_format.cast<StringAttr>().getValue() == "NCHW"))) return emitError(loc, "'tf.Conv2DBackpropFilter' op ""attribute 'data_format' failed to satisfy constraint: 'NHWC' or 'NCHW' convnet data format");
  }
  }
  {
  auto tblgen_dilations = odsAttrs.get("dilations");
  if (tblgen_dilations) {
    if (!(((tblgen_dilations.isa<::mlir::ArrayAttr>())) && (::llvm::all_of(tblgen_dilations.cast<::mlir::ArrayAttr>(), [](::mlir::Attribute attr) { return ((attr.isa<::mlir::IntegerAttr>())) && ((attr.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(64))); })))) return emitError(loc, "'tf.Conv2DBackpropFilter' op ""attribute 'dilations' failed to satisfy constraint: 64-bit integer array attribute");
  }
  }
  return ::mlir::success();
}

::llvm::StringRef Conv2DBackpropFilterOp::getOperationName() {
  return "tf.Conv2DBackpropFilter";
}

std::pair<unsigned, unsigned> Conv2DBackpropFilterOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range Conv2DBackpropFilterOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value Conv2DBackpropFilterOp::input() {
  return *getODSOperands(0).begin();
}

::mlir::Value Conv2DBackpropFilterOp::filter_sizes() {
  return *getODSOperands(1).begin();
}

::mlir::Value Conv2DBackpropFilterOp::out_backprop() {
  return *getODSOperands(2).begin();
}

::mlir::MutableOperandRange Conv2DBackpropFilterOp::inputMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange Conv2DBackpropFilterOp::filter_sizesMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange Conv2DBackpropFilterOp::out_backpropMutable() {
  auto range = getODSOperandIndexAndLength(2);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> Conv2DBackpropFilterOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range Conv2DBackpropFilterOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value Conv2DBackpropFilterOp::output() {
  return *getODSResults(0).begin();
}

::mlir::ArrayAttr Conv2DBackpropFilterOp::stridesAttr() {
  return this->getAttr("strides").cast<::mlir::ArrayAttr>();
}

::mlir::ArrayAttr Conv2DBackpropFilterOp::strides() {
  auto attr = stridesAttr();
  return attr;
}

::mlir::BoolAttr Conv2DBackpropFilterOp::use_cudnn_on_gpuAttr() {
  return this->getAttr("use_cudnn_on_gpu").dyn_cast_or_null<::mlir::BoolAttr>();
}

bool Conv2DBackpropFilterOp::use_cudnn_on_gpu() {
  auto attr = use_cudnn_on_gpuAttr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getBoolAttr(true).getValue();
  return attr.getValue();
}

::mlir::StringAttr Conv2DBackpropFilterOp::paddingAttr() {
  return this->getAttr("padding").cast<::mlir::StringAttr>();
}

::llvm::StringRef Conv2DBackpropFilterOp::padding() {
  auto attr = paddingAttr();
  return attr.getValue();
}

::mlir::ArrayAttr Conv2DBackpropFilterOp::explicit_paddingsAttr() {
  return this->getAttr("explicit_paddings").dyn_cast_or_null<::mlir::ArrayAttr>();
}

::mlir::ArrayAttr Conv2DBackpropFilterOp::explicit_paddings() {
  auto attr = explicit_paddingsAttr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getI64ArrayAttr({});
  return attr;
}

::mlir::StringAttr Conv2DBackpropFilterOp::data_formatAttr() {
  return this->getAttr("data_format").dyn_cast_or_null<::mlir::StringAttr>();
}

::llvm::StringRef Conv2DBackpropFilterOp::data_format() {
  auto attr = data_formatAttr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getStringAttr("NHWC").getValue();
  return attr.getValue();
}

::mlir::ArrayAttr Conv2DBackpropFilterOp::dilationsAttr() {
  return this->getAttr("dilations").dyn_cast_or_null<::mlir::ArrayAttr>();
}

::mlir::ArrayAttr Conv2DBackpropFilterOp::dilations() {
  auto attr = dilationsAttr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getI64ArrayAttr({1, 1, 1, 1});
  return attr;
}

Type Conv2DBackpropFilterOp::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

bool Conv2DBackpropFilterOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "T") return true;
 return false;
}

::mlir::DictionaryAttr Conv2DBackpropFilterOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())}
    }, ctx);
}

void Conv2DBackpropFilterOp::stridesAttr(::mlir::ArrayAttr attr) {
  this->getOperation()->setAttr("strides", attr);
}

void Conv2DBackpropFilterOp::use_cudnn_on_gpuAttr(::mlir::BoolAttr attr) {
  this->getOperation()->setAttr("use_cudnn_on_gpu", attr);
}

void Conv2DBackpropFilterOp::paddingAttr(::mlir::StringAttr attr) {
  this->getOperation()->setAttr("padding", attr);
}

void Conv2DBackpropFilterOp::explicit_paddingsAttr(::mlir::ArrayAttr attr) {
  this->getOperation()->setAttr("explicit_paddings", attr);
}

void Conv2DBackpropFilterOp::data_formatAttr(::mlir::StringAttr attr) {
  this->getOperation()->setAttr("data_format", attr);
}

void Conv2DBackpropFilterOp::dilationsAttr(::mlir::ArrayAttr attr) {
  this->getOperation()->setAttr("dilations", attr);
}

void Conv2DBackpropFilterOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value input, ::mlir::Value filter_sizes, ::mlir::Value out_backprop, ::mlir::ArrayAttr strides, ::mlir::BoolAttr use_cudnn_on_gpu, ::mlir::StringAttr padding, ::mlir::ArrayAttr explicit_paddings, ::mlir::StringAttr data_format, ::mlir::ArrayAttr dilations) {
  odsState.addOperands(input);
  odsState.addOperands(filter_sizes);
  odsState.addOperands(out_backprop);
  odsState.addAttribute("strides", strides);
  odsState.addAttribute("use_cudnn_on_gpu", use_cudnn_on_gpu);
  odsState.addAttribute("padding", padding);
  odsState.addAttribute("explicit_paddings", explicit_paddings);
  odsState.addAttribute("data_format", data_format);
  odsState.addAttribute("dilations", dilations);
  odsState.addTypes(output);
}

void Conv2DBackpropFilterOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input, ::mlir::Value filter_sizes, ::mlir::Value out_backprop, ::mlir::ArrayAttr strides, ::mlir::BoolAttr use_cudnn_on_gpu, ::mlir::StringAttr padding, ::mlir::ArrayAttr explicit_paddings, ::mlir::StringAttr data_format, ::mlir::ArrayAttr dilations) {
  odsState.addOperands(input);
  odsState.addOperands(filter_sizes);
  odsState.addOperands(out_backprop);
  odsState.addAttribute("strides", strides);
  odsState.addAttribute("use_cudnn_on_gpu", use_cudnn_on_gpu);
  odsState.addAttribute("padding", padding);
  odsState.addAttribute("explicit_paddings", explicit_paddings);
  odsState.addAttribute("data_format", data_format);
  odsState.addAttribute("dilations", dilations);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void Conv2DBackpropFilterOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value input, ::mlir::Value filter_sizes, ::mlir::Value out_backprop, ::mlir::ArrayAttr strides, bool use_cudnn_on_gpu, ::llvm::StringRef padding, ::mlir::ArrayAttr explicit_paddings, ::llvm::StringRef data_format, ::mlir::ArrayAttr dilations) {
  odsState.addOperands(input);
  odsState.addOperands(filter_sizes);
  odsState.addOperands(out_backprop);
  odsState.addAttribute("strides", strides);
  odsState.addAttribute("use_cudnn_on_gpu", odsBuilder.getBoolAttr(use_cudnn_on_gpu));
  odsState.addAttribute("padding", odsBuilder.getStringAttr(padding));
  odsState.addAttribute("explicit_paddings", explicit_paddings);
  odsState.addAttribute("data_format", odsBuilder.getStringAttr(data_format));
  odsState.addAttribute("dilations", dilations);
  odsState.addTypes(output);
}

void Conv2DBackpropFilterOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input, ::mlir::Value filter_sizes, ::mlir::Value out_backprop, ::mlir::ArrayAttr strides, bool use_cudnn_on_gpu, ::llvm::StringRef padding, ::mlir::ArrayAttr explicit_paddings, ::llvm::StringRef data_format, ::mlir::ArrayAttr dilations) {
  odsState.addOperands(input);
  odsState.addOperands(filter_sizes);
  odsState.addOperands(out_backprop);
  odsState.addAttribute("strides", strides);
  odsState.addAttribute("use_cudnn_on_gpu", odsBuilder.getBoolAttr(use_cudnn_on_gpu));
  odsState.addAttribute("padding", odsBuilder.getStringAttr(padding));
  odsState.addAttribute("explicit_paddings", explicit_paddings);
  odsState.addAttribute("data_format", odsBuilder.getStringAttr(data_format));
  odsState.addAttribute("dilations", dilations);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void Conv2DBackpropFilterOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 3u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult Conv2DBackpropFilterOp::verify() {
  if (failed(Conv2DBackpropFilterOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of floating-point values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of 32-bit integer values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup2 = getODSOperands(2);
    for (::mlir::Value v : valueGroup2) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of floating-point values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))))) {
        return emitOpError("result #") << index << " must be tensor of floating-point values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void Conv2DBackpropFilterOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::Conv2DBackpropInputOp definitions
//===----------------------------------------------------------------------===//

Conv2DBackpropInputOpAdaptor::Conv2DBackpropInputOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

Conv2DBackpropInputOpAdaptor::Conv2DBackpropInputOpAdaptor(Conv2DBackpropInputOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> Conv2DBackpropInputOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange Conv2DBackpropInputOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value Conv2DBackpropInputOpAdaptor::input_sizes() {
  return *getODSOperands(0).begin();
}

::mlir::Value Conv2DBackpropInputOpAdaptor::filter() {
  return *getODSOperands(1).begin();
}

::mlir::Value Conv2DBackpropInputOpAdaptor::out_backprop() {
  return *getODSOperands(2).begin();
}

::mlir::ArrayAttr Conv2DBackpropInputOpAdaptor::strides() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::ArrayAttr attr = odsAttrs.get("strides").cast<::mlir::ArrayAttr>();
  return attr;
}

::mlir::BoolAttr Conv2DBackpropInputOpAdaptor::use_cudnn_on_gpu() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::BoolAttr attr = odsAttrs.get("use_cudnn_on_gpu").dyn_cast_or_null<::mlir::BoolAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getBoolAttr(true);
  return attr;
}

::mlir::StringAttr Conv2DBackpropInputOpAdaptor::padding() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::StringAttr attr = odsAttrs.get("padding").cast<::mlir::StringAttr>();
  return attr;
}

::mlir::ArrayAttr Conv2DBackpropInputOpAdaptor::explicit_paddings() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::ArrayAttr attr = odsAttrs.get("explicit_paddings").dyn_cast_or_null<::mlir::ArrayAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getI64ArrayAttr({});
  return attr;
}

::mlir::StringAttr Conv2DBackpropInputOpAdaptor::data_format() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::StringAttr attr = odsAttrs.get("data_format").dyn_cast_or_null<::mlir::StringAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getStringAttr("NHWC");
  return attr;
}

::mlir::ArrayAttr Conv2DBackpropInputOpAdaptor::dilations() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::ArrayAttr attr = odsAttrs.get("dilations").dyn_cast_or_null<::mlir::ArrayAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getI64ArrayAttr({1, 1, 1, 1});
  return attr;
}

::mlir::LogicalResult Conv2DBackpropInputOpAdaptor::verify(::mlir::Location loc) {
  {
  auto tblgen_strides = odsAttrs.get("strides");
  if (!tblgen_strides) return emitError(loc, "'tf.Conv2DBackpropInput' op ""requires attribute 'strides'");
    if (!(((tblgen_strides.isa<::mlir::ArrayAttr>())) && (::llvm::all_of(tblgen_strides.cast<::mlir::ArrayAttr>(), [](::mlir::Attribute attr) { return ((attr.isa<::mlir::IntegerAttr>())) && ((attr.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(64))); })))) return emitError(loc, "'tf.Conv2DBackpropInput' op ""attribute 'strides' failed to satisfy constraint: 64-bit integer array attribute");
  }
  {
  auto tblgen_use_cudnn_on_gpu = odsAttrs.get("use_cudnn_on_gpu");
  if (tblgen_use_cudnn_on_gpu) {
    if (!((tblgen_use_cudnn_on_gpu.isa<::mlir::BoolAttr>()))) return emitError(loc, "'tf.Conv2DBackpropInput' op ""attribute 'use_cudnn_on_gpu' failed to satisfy constraint: bool attribute");
  }
  }
  {
  auto tblgen_padding = odsAttrs.get("padding");
  if (!tblgen_padding) return emitError(loc, "'tf.Conv2DBackpropInput' op ""requires attribute 'padding'");
    if (!((tblgen_padding.cast<StringAttr>().getValue() == "SAME" || tblgen_padding.cast<StringAttr>().getValue() == "VALID" || tblgen_padding.cast<StringAttr>().getValue() == "EXPLICIT"))) return emitError(loc, "'tf.Conv2DBackpropInput' op ""attribute 'padding' failed to satisfy constraint: string attribute whose value is SAME, or VALID, or EXPLICIT");
  }
  {
  auto tblgen_explicit_paddings = odsAttrs.get("explicit_paddings");
  if (tblgen_explicit_paddings) {
    if (!(((tblgen_explicit_paddings.isa<::mlir::ArrayAttr>())) && (::llvm::all_of(tblgen_explicit_paddings.cast<::mlir::ArrayAttr>(), [](::mlir::Attribute attr) { return ((attr.isa<::mlir::IntegerAttr>())) && ((attr.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(64))); })))) return emitError(loc, "'tf.Conv2DBackpropInput' op ""attribute 'explicit_paddings' failed to satisfy constraint: 64-bit integer array attribute");
  }
  }
  {
  auto tblgen_data_format = odsAttrs.get("data_format");
  if (tblgen_data_format) {
    if (!((tblgen_data_format.cast<StringAttr>().getValue() == "NHWC" || tblgen_data_format.cast<StringAttr>().getValue() == "NCHW"))) return emitError(loc, "'tf.Conv2DBackpropInput' op ""attribute 'data_format' failed to satisfy constraint: 'NHWC' or 'NCHW' convnet data format");
  }
  }
  {
  auto tblgen_dilations = odsAttrs.get("dilations");
  if (tblgen_dilations) {
    if (!(((tblgen_dilations.isa<::mlir::ArrayAttr>())) && (::llvm::all_of(tblgen_dilations.cast<::mlir::ArrayAttr>(), [](::mlir::Attribute attr) { return ((attr.isa<::mlir::IntegerAttr>())) && ((attr.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(64))); })))) return emitError(loc, "'tf.Conv2DBackpropInput' op ""attribute 'dilations' failed to satisfy constraint: 64-bit integer array attribute");
  }
  }
  return ::mlir::success();
}

::llvm::StringRef Conv2DBackpropInputOp::getOperationName() {
  return "tf.Conv2DBackpropInput";
}

std::pair<unsigned, unsigned> Conv2DBackpropInputOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range Conv2DBackpropInputOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value Conv2DBackpropInputOp::input_sizes() {
  return *getODSOperands(0).begin();
}

::mlir::Value Conv2DBackpropInputOp::filter() {
  return *getODSOperands(1).begin();
}

::mlir::Value Conv2DBackpropInputOp::out_backprop() {
  return *getODSOperands(2).begin();
}

::mlir::MutableOperandRange Conv2DBackpropInputOp::input_sizesMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange Conv2DBackpropInputOp::filterMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange Conv2DBackpropInputOp::out_backpropMutable() {
  auto range = getODSOperandIndexAndLength(2);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> Conv2DBackpropInputOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range Conv2DBackpropInputOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value Conv2DBackpropInputOp::output() {
  return *getODSResults(0).begin();
}

::mlir::ArrayAttr Conv2DBackpropInputOp::stridesAttr() {
  return this->getAttr("strides").cast<::mlir::ArrayAttr>();
}

::mlir::ArrayAttr Conv2DBackpropInputOp::strides() {
  auto attr = stridesAttr();
  return attr;
}

::mlir::BoolAttr Conv2DBackpropInputOp::use_cudnn_on_gpuAttr() {
  return this->getAttr("use_cudnn_on_gpu").dyn_cast_or_null<::mlir::BoolAttr>();
}

bool Conv2DBackpropInputOp::use_cudnn_on_gpu() {
  auto attr = use_cudnn_on_gpuAttr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getBoolAttr(true).getValue();
  return attr.getValue();
}

::mlir::StringAttr Conv2DBackpropInputOp::paddingAttr() {
  return this->getAttr("padding").cast<::mlir::StringAttr>();
}

::llvm::StringRef Conv2DBackpropInputOp::padding() {
  auto attr = paddingAttr();
  return attr.getValue();
}

::mlir::ArrayAttr Conv2DBackpropInputOp::explicit_paddingsAttr() {
  return this->getAttr("explicit_paddings").dyn_cast_or_null<::mlir::ArrayAttr>();
}

::mlir::ArrayAttr Conv2DBackpropInputOp::explicit_paddings() {
  auto attr = explicit_paddingsAttr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getI64ArrayAttr({});
  return attr;
}

::mlir::StringAttr Conv2DBackpropInputOp::data_formatAttr() {
  return this->getAttr("data_format").dyn_cast_or_null<::mlir::StringAttr>();
}

::llvm::StringRef Conv2DBackpropInputOp::data_format() {
  auto attr = data_formatAttr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getStringAttr("NHWC").getValue();
  return attr.getValue();
}

::mlir::ArrayAttr Conv2DBackpropInputOp::dilationsAttr() {
  return this->getAttr("dilations").dyn_cast_or_null<::mlir::ArrayAttr>();
}

::mlir::ArrayAttr Conv2DBackpropInputOp::dilations() {
  auto attr = dilationsAttr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getI64ArrayAttr({1, 1, 1, 1});
  return attr;
}

Type Conv2DBackpropInputOp::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(1).begin());
}

bool Conv2DBackpropInputOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "T") return true;
 return false;
}

::mlir::DictionaryAttr Conv2DBackpropInputOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())}
    }, ctx);
}

void Conv2DBackpropInputOp::stridesAttr(::mlir::ArrayAttr attr) {
  this->getOperation()->setAttr("strides", attr);
}

void Conv2DBackpropInputOp::use_cudnn_on_gpuAttr(::mlir::BoolAttr attr) {
  this->getOperation()->setAttr("use_cudnn_on_gpu", attr);
}

void Conv2DBackpropInputOp::paddingAttr(::mlir::StringAttr attr) {
  this->getOperation()->setAttr("padding", attr);
}

void Conv2DBackpropInputOp::explicit_paddingsAttr(::mlir::ArrayAttr attr) {
  this->getOperation()->setAttr("explicit_paddings", attr);
}

void Conv2DBackpropInputOp::data_formatAttr(::mlir::StringAttr attr) {
  this->getOperation()->setAttr("data_format", attr);
}

void Conv2DBackpropInputOp::dilationsAttr(::mlir::ArrayAttr attr) {
  this->getOperation()->setAttr("dilations", attr);
}

void Conv2DBackpropInputOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value input_sizes, ::mlir::Value filter, ::mlir::Value out_backprop, ::mlir::ArrayAttr strides, ::mlir::BoolAttr use_cudnn_on_gpu, ::mlir::StringAttr padding, ::mlir::ArrayAttr explicit_paddings, ::mlir::StringAttr data_format, ::mlir::ArrayAttr dilations) {
  odsState.addOperands(input_sizes);
  odsState.addOperands(filter);
  odsState.addOperands(out_backprop);
  odsState.addAttribute("strides", strides);
  odsState.addAttribute("use_cudnn_on_gpu", use_cudnn_on_gpu);
  odsState.addAttribute("padding", padding);
  odsState.addAttribute("explicit_paddings", explicit_paddings);
  odsState.addAttribute("data_format", data_format);
  odsState.addAttribute("dilations", dilations);
  odsState.addTypes(output);
}

void Conv2DBackpropInputOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input_sizes, ::mlir::Value filter, ::mlir::Value out_backprop, ::mlir::ArrayAttr strides, ::mlir::BoolAttr use_cudnn_on_gpu, ::mlir::StringAttr padding, ::mlir::ArrayAttr explicit_paddings, ::mlir::StringAttr data_format, ::mlir::ArrayAttr dilations) {
  odsState.addOperands(input_sizes);
  odsState.addOperands(filter);
  odsState.addOperands(out_backprop);
  odsState.addAttribute("strides", strides);
  odsState.addAttribute("use_cudnn_on_gpu", use_cudnn_on_gpu);
  odsState.addAttribute("padding", padding);
  odsState.addAttribute("explicit_paddings", explicit_paddings);
  odsState.addAttribute("data_format", data_format);
  odsState.addAttribute("dilations", dilations);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void Conv2DBackpropInputOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value input_sizes, ::mlir::Value filter, ::mlir::Value out_backprop, ::mlir::ArrayAttr strides, bool use_cudnn_on_gpu, ::llvm::StringRef padding, ::mlir::ArrayAttr explicit_paddings, ::llvm::StringRef data_format, ::mlir::ArrayAttr dilations) {
  odsState.addOperands(input_sizes);
  odsState.addOperands(filter);
  odsState.addOperands(out_backprop);
  odsState.addAttribute("strides", strides);
  odsState.addAttribute("use_cudnn_on_gpu", odsBuilder.getBoolAttr(use_cudnn_on_gpu));
  odsState.addAttribute("padding", odsBuilder.getStringAttr(padding));
  odsState.addAttribute("explicit_paddings", explicit_paddings);
  odsState.addAttribute("data_format", odsBuilder.getStringAttr(data_format));
  odsState.addAttribute("dilations", dilations);
  odsState.addTypes(output);
}

void Conv2DBackpropInputOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input_sizes, ::mlir::Value filter, ::mlir::Value out_backprop, ::mlir::ArrayAttr strides, bool use_cudnn_on_gpu, ::llvm::StringRef padding, ::mlir::ArrayAttr explicit_paddings, ::llvm::StringRef data_format, ::mlir::ArrayAttr dilations) {
  odsState.addOperands(input_sizes);
  odsState.addOperands(filter);
  odsState.addOperands(out_backprop);
  odsState.addAttribute("strides", strides);
  odsState.addAttribute("use_cudnn_on_gpu", odsBuilder.getBoolAttr(use_cudnn_on_gpu));
  odsState.addAttribute("padding", odsBuilder.getStringAttr(padding));
  odsState.addAttribute("explicit_paddings", explicit_paddings);
  odsState.addAttribute("data_format", odsBuilder.getStringAttr(data_format));
  odsState.addAttribute("dilations", dilations);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void Conv2DBackpropInputOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 3u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult Conv2DBackpropInputOp::verify() {
  if (failed(Conv2DBackpropInputOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of 32-bit integer values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of bfloat16 or 16-bit float or 32-bit float or 64-bit float or 32-bit integer values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup2 = getODSOperands(2);
    for (::mlir::Value v : valueGroup2) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of bfloat16 or 16-bit float or 32-bit float or 64-bit float or 32-bit integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>())))))) {
        return emitOpError("result #") << index << " must be tensor of bfloat16 or 16-bit float or 32-bit float or 64-bit float or 32-bit integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  return Verify(*this);
}

void Conv2DBackpropInputOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::Conv2DOp definitions
//===----------------------------------------------------------------------===//

Conv2DOpAdaptor::Conv2DOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

Conv2DOpAdaptor::Conv2DOpAdaptor(Conv2DOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> Conv2DOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange Conv2DOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value Conv2DOpAdaptor::input() {
  return *getODSOperands(0).begin();
}

::mlir::Value Conv2DOpAdaptor::filter() {
  return *getODSOperands(1).begin();
}

::mlir::ArrayAttr Conv2DOpAdaptor::strides() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::ArrayAttr attr = odsAttrs.get("strides").cast<::mlir::ArrayAttr>();
  return attr;
}

::mlir::BoolAttr Conv2DOpAdaptor::use_cudnn_on_gpu() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::BoolAttr attr = odsAttrs.get("use_cudnn_on_gpu").dyn_cast_or_null<::mlir::BoolAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getBoolAttr(true);
  return attr;
}

::mlir::StringAttr Conv2DOpAdaptor::padding() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::StringAttr attr = odsAttrs.get("padding").cast<::mlir::StringAttr>();
  return attr;
}

::mlir::ArrayAttr Conv2DOpAdaptor::explicit_paddings() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::ArrayAttr attr = odsAttrs.get("explicit_paddings").dyn_cast_or_null<::mlir::ArrayAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getI64ArrayAttr({});
  return attr;
}

::mlir::StringAttr Conv2DOpAdaptor::data_format() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::StringAttr attr = odsAttrs.get("data_format").dyn_cast_or_null<::mlir::StringAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getStringAttr("NHWC");
  return attr;
}

::mlir::ArrayAttr Conv2DOpAdaptor::dilations() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::ArrayAttr attr = odsAttrs.get("dilations").dyn_cast_or_null<::mlir::ArrayAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getI64ArrayAttr({1, 1, 1, 1});
  return attr;
}

::mlir::LogicalResult Conv2DOpAdaptor::verify(::mlir::Location loc) {
  {
  auto tblgen_strides = odsAttrs.get("strides");
  if (!tblgen_strides) return emitError(loc, "'tf.Conv2D' op ""requires attribute 'strides'");
    if (!(((tblgen_strides.isa<::mlir::ArrayAttr>())) && (::llvm::all_of(tblgen_strides.cast<::mlir::ArrayAttr>(), [](::mlir::Attribute attr) { return ((attr.isa<::mlir::IntegerAttr>())) && ((attr.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(64))); })))) return emitError(loc, "'tf.Conv2D' op ""attribute 'strides' failed to satisfy constraint: 64-bit integer array attribute");
  }
  {
  auto tblgen_use_cudnn_on_gpu = odsAttrs.get("use_cudnn_on_gpu");
  if (tblgen_use_cudnn_on_gpu) {
    if (!((tblgen_use_cudnn_on_gpu.isa<::mlir::BoolAttr>()))) return emitError(loc, "'tf.Conv2D' op ""attribute 'use_cudnn_on_gpu' failed to satisfy constraint: bool attribute");
  }
  }
  {
  auto tblgen_padding = odsAttrs.get("padding");
  if (!tblgen_padding) return emitError(loc, "'tf.Conv2D' op ""requires attribute 'padding'");
    if (!((tblgen_padding.cast<StringAttr>().getValue() == "SAME" || tblgen_padding.cast<StringAttr>().getValue() == "VALID" || tblgen_padding.cast<StringAttr>().getValue() == "EXPLICIT"))) return emitError(loc, "'tf.Conv2D' op ""attribute 'padding' failed to satisfy constraint: string attribute whose value is SAME, or VALID, or EXPLICIT");
  }
  {
  auto tblgen_explicit_paddings = odsAttrs.get("explicit_paddings");
  if (tblgen_explicit_paddings) {
    if (!(((tblgen_explicit_paddings.isa<::mlir::ArrayAttr>())) && (::llvm::all_of(tblgen_explicit_paddings.cast<::mlir::ArrayAttr>(), [](::mlir::Attribute attr) { return ((attr.isa<::mlir::IntegerAttr>())) && ((attr.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(64))); })))) return emitError(loc, "'tf.Conv2D' op ""attribute 'explicit_paddings' failed to satisfy constraint: 64-bit integer array attribute");
  }
  }
  {
  auto tblgen_data_format = odsAttrs.get("data_format");
  if (tblgen_data_format) {
    if (!((tblgen_data_format.cast<StringAttr>().getValue() == "NHWC" || tblgen_data_format.cast<StringAttr>().getValue() == "NCHW"))) return emitError(loc, "'tf.Conv2D' op ""attribute 'data_format' failed to satisfy constraint: 'NHWC' or 'NCHW' convnet data format");
  }
  }
  {
  auto tblgen_dilations = odsAttrs.get("dilations");
  if (tblgen_dilations) {
    if (!(((tblgen_dilations.isa<::mlir::ArrayAttr>())) && (::llvm::all_of(tblgen_dilations.cast<::mlir::ArrayAttr>(), [](::mlir::Attribute attr) { return ((attr.isa<::mlir::IntegerAttr>())) && ((attr.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(64))); })))) return emitError(loc, "'tf.Conv2D' op ""attribute 'dilations' failed to satisfy constraint: 64-bit integer array attribute");
  }
  }
  return ::mlir::success();
}

::llvm::StringRef Conv2DOp::getOperationName() {
  return "tf.Conv2D";
}

std::pair<unsigned, unsigned> Conv2DOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range Conv2DOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value Conv2DOp::input() {
  return *getODSOperands(0).begin();
}

::mlir::Value Conv2DOp::filter() {
  return *getODSOperands(1).begin();
}

::mlir::MutableOperandRange Conv2DOp::inputMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange Conv2DOp::filterMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> Conv2DOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range Conv2DOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value Conv2DOp::output() {
  return *getODSResults(0).begin();
}

::mlir::ArrayAttr Conv2DOp::stridesAttr() {
  return this->getAttr("strides").cast<::mlir::ArrayAttr>();
}

::mlir::ArrayAttr Conv2DOp::strides() {
  auto attr = stridesAttr();
  return attr;
}

::mlir::BoolAttr Conv2DOp::use_cudnn_on_gpuAttr() {
  return this->getAttr("use_cudnn_on_gpu").dyn_cast_or_null<::mlir::BoolAttr>();
}

bool Conv2DOp::use_cudnn_on_gpu() {
  auto attr = use_cudnn_on_gpuAttr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getBoolAttr(true).getValue();
  return attr.getValue();
}

::mlir::StringAttr Conv2DOp::paddingAttr() {
  return this->getAttr("padding").cast<::mlir::StringAttr>();
}

::llvm::StringRef Conv2DOp::padding() {
  auto attr = paddingAttr();
  return attr.getValue();
}

::mlir::ArrayAttr Conv2DOp::explicit_paddingsAttr() {
  return this->getAttr("explicit_paddings").dyn_cast_or_null<::mlir::ArrayAttr>();
}

::mlir::ArrayAttr Conv2DOp::explicit_paddings() {
  auto attr = explicit_paddingsAttr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getI64ArrayAttr({});
  return attr;
}

::mlir::StringAttr Conv2DOp::data_formatAttr() {
  return this->getAttr("data_format").dyn_cast_or_null<::mlir::StringAttr>();
}

::llvm::StringRef Conv2DOp::data_format() {
  auto attr = data_formatAttr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getStringAttr("NHWC").getValue();
  return attr.getValue();
}

::mlir::ArrayAttr Conv2DOp::dilationsAttr() {
  return this->getAttr("dilations").dyn_cast_or_null<::mlir::ArrayAttr>();
}

::mlir::ArrayAttr Conv2DOp::dilations() {
  auto attr = dilationsAttr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getI64ArrayAttr({1, 1, 1, 1});
  return attr;
}

Type Conv2DOp::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

bool Conv2DOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "T") return true;
 return false;
}

::mlir::DictionaryAttr Conv2DOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())}
    }, ctx);
}

void Conv2DOp::stridesAttr(::mlir::ArrayAttr attr) {
  this->getOperation()->setAttr("strides", attr);
}

void Conv2DOp::use_cudnn_on_gpuAttr(::mlir::BoolAttr attr) {
  this->getOperation()->setAttr("use_cudnn_on_gpu", attr);
}

void Conv2DOp::paddingAttr(::mlir::StringAttr attr) {
  this->getOperation()->setAttr("padding", attr);
}

void Conv2DOp::explicit_paddingsAttr(::mlir::ArrayAttr attr) {
  this->getOperation()->setAttr("explicit_paddings", attr);
}

void Conv2DOp::data_formatAttr(::mlir::StringAttr attr) {
  this->getOperation()->setAttr("data_format", attr);
}

void Conv2DOp::dilationsAttr(::mlir::ArrayAttr attr) {
  this->getOperation()->setAttr("dilations", attr);
}

void Conv2DOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value input, ::mlir::Value filter, ::mlir::ArrayAttr strides, ::mlir::BoolAttr use_cudnn_on_gpu, ::mlir::StringAttr padding, ::mlir::ArrayAttr explicit_paddings, ::mlir::StringAttr data_format, ::mlir::ArrayAttr dilations) {
  odsState.addOperands(input);
  odsState.addOperands(filter);
  odsState.addAttribute("strides", strides);
  odsState.addAttribute("use_cudnn_on_gpu", use_cudnn_on_gpu);
  odsState.addAttribute("padding", padding);
  odsState.addAttribute("explicit_paddings", explicit_paddings);
  odsState.addAttribute("data_format", data_format);
  odsState.addAttribute("dilations", dilations);
  odsState.addTypes(output);
}

void Conv2DOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input, ::mlir::Value filter, ::mlir::ArrayAttr strides, ::mlir::BoolAttr use_cudnn_on_gpu, ::mlir::StringAttr padding, ::mlir::ArrayAttr explicit_paddings, ::mlir::StringAttr data_format, ::mlir::ArrayAttr dilations) {
  odsState.addOperands(input);
  odsState.addOperands(filter);
  odsState.addAttribute("strides", strides);
  odsState.addAttribute("use_cudnn_on_gpu", use_cudnn_on_gpu);
  odsState.addAttribute("padding", padding);
  odsState.addAttribute("explicit_paddings", explicit_paddings);
  odsState.addAttribute("data_format", data_format);
  odsState.addAttribute("dilations", dilations);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void Conv2DOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value input, ::mlir::Value filter, ::mlir::ArrayAttr strides, bool use_cudnn_on_gpu, ::llvm::StringRef padding, ::mlir::ArrayAttr explicit_paddings, ::llvm::StringRef data_format, ::mlir::ArrayAttr dilations) {
  odsState.addOperands(input);
  odsState.addOperands(filter);
  odsState.addAttribute("strides", strides);
  odsState.addAttribute("use_cudnn_on_gpu", odsBuilder.getBoolAttr(use_cudnn_on_gpu));
  odsState.addAttribute("padding", odsBuilder.getStringAttr(padding));
  odsState.addAttribute("explicit_paddings", explicit_paddings);
  odsState.addAttribute("data_format", odsBuilder.getStringAttr(data_format));
  odsState.addAttribute("dilations", dilations);
  odsState.addTypes(output);
}

void Conv2DOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input, ::mlir::Value filter, ::mlir::ArrayAttr strides, bool use_cudnn_on_gpu, ::llvm::StringRef padding, ::mlir::ArrayAttr explicit_paddings, ::llvm::StringRef data_format, ::mlir::ArrayAttr dilations) {
  odsState.addOperands(input);
  odsState.addOperands(filter);
  odsState.addAttribute("strides", strides);
  odsState.addAttribute("use_cudnn_on_gpu", odsBuilder.getBoolAttr(use_cudnn_on_gpu));
  odsState.addAttribute("padding", odsBuilder.getStringAttr(padding));
  odsState.addAttribute("explicit_paddings", explicit_paddings);
  odsState.addAttribute("data_format", odsBuilder.getStringAttr(data_format));
  odsState.addAttribute("dilations", dilations);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void Conv2DOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult Conv2DOp::verify() {
  if (failed(Conv2DOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of bfloat16 or 16-bit float or 32-bit float or 64-bit float or 32-bit integer values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of bfloat16 or 16-bit float or 32-bit float or 64-bit float or 32-bit integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>())))))) {
        return emitOpError("result #") << index << " must be tensor of bfloat16 or 16-bit float or 32-bit float or 64-bit float or 32-bit integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  return Verify(*this);
}

void Conv2DOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::Conv3DBackpropFilterV2Op definitions
//===----------------------------------------------------------------------===//

Conv3DBackpropFilterV2OpAdaptor::Conv3DBackpropFilterV2OpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

Conv3DBackpropFilterV2OpAdaptor::Conv3DBackpropFilterV2OpAdaptor(Conv3DBackpropFilterV2Op&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> Conv3DBackpropFilterV2OpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange Conv3DBackpropFilterV2OpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value Conv3DBackpropFilterV2OpAdaptor::input() {
  return *getODSOperands(0).begin();
}

::mlir::Value Conv3DBackpropFilterV2OpAdaptor::filter_sizes() {
  return *getODSOperands(1).begin();
}

::mlir::Value Conv3DBackpropFilterV2OpAdaptor::out_backprop() {
  return *getODSOperands(2).begin();
}

::mlir::ArrayAttr Conv3DBackpropFilterV2OpAdaptor::strides() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::ArrayAttr attr = odsAttrs.get("strides").cast<::mlir::ArrayAttr>();
  return attr;
}

::mlir::StringAttr Conv3DBackpropFilterV2OpAdaptor::padding() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::StringAttr attr = odsAttrs.get("padding").cast<::mlir::StringAttr>();
  return attr;
}

::mlir::StringAttr Conv3DBackpropFilterV2OpAdaptor::data_format() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::StringAttr attr = odsAttrs.get("data_format").dyn_cast_or_null<::mlir::StringAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getStringAttr("NDHWC");
  return attr;
}

::mlir::ArrayAttr Conv3DBackpropFilterV2OpAdaptor::dilations() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::ArrayAttr attr = odsAttrs.get("dilations").dyn_cast_or_null<::mlir::ArrayAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getI64ArrayAttr({1, 1, 1, 1, 1});
  return attr;
}

::mlir::LogicalResult Conv3DBackpropFilterV2OpAdaptor::verify(::mlir::Location loc) {
  {
  auto tblgen_strides = odsAttrs.get("strides");
  if (!tblgen_strides) return emitError(loc, "'tf.Conv3DBackpropFilterV2' op ""requires attribute 'strides'");
    if (!((((tblgen_strides.isa<::mlir::ArrayAttr>())) && (::llvm::all_of(tblgen_strides.cast<::mlir::ArrayAttr>(), [](::mlir::Attribute attr) { return ((attr.isa<::mlir::IntegerAttr>())) && ((attr.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(64))); }))) && ((tblgen_strides.cast<::mlir::ArrayAttr>().size() >= 5)))) return emitError(loc, "'tf.Conv3DBackpropFilterV2' op ""attribute 'strides' failed to satisfy constraint: 64-bit integer array attribute with at least 5 elements");
  }
  {
  auto tblgen_padding = odsAttrs.get("padding");
  if (!tblgen_padding) return emitError(loc, "'tf.Conv3DBackpropFilterV2' op ""requires attribute 'padding'");
    if (!((tblgen_padding.cast<StringAttr>().getValue() == "SAME" || tblgen_padding.cast<StringAttr>().getValue() == "VALID"))) return emitError(loc, "'tf.Conv3DBackpropFilterV2' op ""attribute 'padding' failed to satisfy constraint: string attribute whose value is SAME, or VALID");
  }
  {
  auto tblgen_data_format = odsAttrs.get("data_format");
  if (tblgen_data_format) {
    if (!((tblgen_data_format.cast<StringAttr>().getValue() == "NDHWC" || tblgen_data_format.cast<StringAttr>().getValue() == "NCDHW"))) return emitError(loc, "'tf.Conv3DBackpropFilterV2' op ""attribute 'data_format' failed to satisfy constraint: string attribute whose value is NDHWC, or NCDHW");
  }
  }
  {
  auto tblgen_dilations = odsAttrs.get("dilations");
  if (tblgen_dilations) {
    if (!(((tblgen_dilations.isa<::mlir::ArrayAttr>())) && (::llvm::all_of(tblgen_dilations.cast<::mlir::ArrayAttr>(), [](::mlir::Attribute attr) { return ((attr.isa<::mlir::IntegerAttr>())) && ((attr.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(64))); })))) return emitError(loc, "'tf.Conv3DBackpropFilterV2' op ""attribute 'dilations' failed to satisfy constraint: 64-bit integer array attribute");
  }
  }
  return ::mlir::success();
}

::llvm::StringRef Conv3DBackpropFilterV2Op::getOperationName() {
  return "tf.Conv3DBackpropFilterV2";
}

std::pair<unsigned, unsigned> Conv3DBackpropFilterV2Op::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range Conv3DBackpropFilterV2Op::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value Conv3DBackpropFilterV2Op::input() {
  return *getODSOperands(0).begin();
}

::mlir::Value Conv3DBackpropFilterV2Op::filter_sizes() {
  return *getODSOperands(1).begin();
}

::mlir::Value Conv3DBackpropFilterV2Op::out_backprop() {
  return *getODSOperands(2).begin();
}

::mlir::MutableOperandRange Conv3DBackpropFilterV2Op::inputMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange Conv3DBackpropFilterV2Op::filter_sizesMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange Conv3DBackpropFilterV2Op::out_backpropMutable() {
  auto range = getODSOperandIndexAndLength(2);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> Conv3DBackpropFilterV2Op::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range Conv3DBackpropFilterV2Op::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value Conv3DBackpropFilterV2Op::output() {
  return *getODSResults(0).begin();
}

::mlir::ArrayAttr Conv3DBackpropFilterV2Op::stridesAttr() {
  return this->getAttr("strides").cast<::mlir::ArrayAttr>();
}

::mlir::ArrayAttr Conv3DBackpropFilterV2Op::strides() {
  auto attr = stridesAttr();
  return attr;
}

::mlir::StringAttr Conv3DBackpropFilterV2Op::paddingAttr() {
  return this->getAttr("padding").cast<::mlir::StringAttr>();
}

::llvm::StringRef Conv3DBackpropFilterV2Op::padding() {
  auto attr = paddingAttr();
  return attr.getValue();
}

::mlir::StringAttr Conv3DBackpropFilterV2Op::data_formatAttr() {
  return this->getAttr("data_format").dyn_cast_or_null<::mlir::StringAttr>();
}

::llvm::StringRef Conv3DBackpropFilterV2Op::data_format() {
  auto attr = data_formatAttr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getStringAttr("NDHWC").getValue();
  return attr.getValue();
}

::mlir::ArrayAttr Conv3DBackpropFilterV2Op::dilationsAttr() {
  return this->getAttr("dilations").dyn_cast_or_null<::mlir::ArrayAttr>();
}

::mlir::ArrayAttr Conv3DBackpropFilterV2Op::dilations() {
  auto attr = dilationsAttr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getI64ArrayAttr({1, 1, 1, 1, 1});
  return attr;
}

Type Conv3DBackpropFilterV2Op::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

bool Conv3DBackpropFilterV2Op::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "T") return true;
 return false;
}

::mlir::DictionaryAttr Conv3DBackpropFilterV2Op::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())}
    }, ctx);
}

void Conv3DBackpropFilterV2Op::stridesAttr(::mlir::ArrayAttr attr) {
  this->getOperation()->setAttr("strides", attr);
}

void Conv3DBackpropFilterV2Op::paddingAttr(::mlir::StringAttr attr) {
  this->getOperation()->setAttr("padding", attr);
}

void Conv3DBackpropFilterV2Op::data_formatAttr(::mlir::StringAttr attr) {
  this->getOperation()->setAttr("data_format", attr);
}

void Conv3DBackpropFilterV2Op::dilationsAttr(::mlir::ArrayAttr attr) {
  this->getOperation()->setAttr("dilations", attr);
}

void Conv3DBackpropFilterV2Op::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value input, ::mlir::Value filter_sizes, ::mlir::Value out_backprop, ::mlir::ArrayAttr strides, ::mlir::StringAttr padding, ::mlir::StringAttr data_format, ::mlir::ArrayAttr dilations) {
  odsState.addOperands(input);
  odsState.addOperands(filter_sizes);
  odsState.addOperands(out_backprop);
  odsState.addAttribute("strides", strides);
  odsState.addAttribute("padding", padding);
  odsState.addAttribute("data_format", data_format);
  odsState.addAttribute("dilations", dilations);
  odsState.addTypes(output);
}

void Conv3DBackpropFilterV2Op::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input, ::mlir::Value filter_sizes, ::mlir::Value out_backprop, ::mlir::ArrayAttr strides, ::mlir::StringAttr padding, ::mlir::StringAttr data_format, ::mlir::ArrayAttr dilations) {
  odsState.addOperands(input);
  odsState.addOperands(filter_sizes);
  odsState.addOperands(out_backprop);
  odsState.addAttribute("strides", strides);
  odsState.addAttribute("padding", padding);
  odsState.addAttribute("data_format", data_format);
  odsState.addAttribute("dilations", dilations);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void Conv3DBackpropFilterV2Op::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value input, ::mlir::Value filter_sizes, ::mlir::Value out_backprop, ::mlir::ArrayAttr strides, ::llvm::StringRef padding, ::llvm::StringRef data_format, ::mlir::ArrayAttr dilations) {
  odsState.addOperands(input);
  odsState.addOperands(filter_sizes);
  odsState.addOperands(out_backprop);
  odsState.addAttribute("strides", strides);
  odsState.addAttribute("padding", odsBuilder.getStringAttr(padding));
  odsState.addAttribute("data_format", odsBuilder.getStringAttr(data_format));
  odsState.addAttribute("dilations", dilations);
  odsState.addTypes(output);
}

void Conv3DBackpropFilterV2Op::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input, ::mlir::Value filter_sizes, ::mlir::Value out_backprop, ::mlir::ArrayAttr strides, ::llvm::StringRef padding, ::llvm::StringRef data_format, ::mlir::ArrayAttr dilations) {
  odsState.addOperands(input);
  odsState.addOperands(filter_sizes);
  odsState.addOperands(out_backprop);
  odsState.addAttribute("strides", strides);
  odsState.addAttribute("padding", odsBuilder.getStringAttr(padding));
  odsState.addAttribute("data_format", odsBuilder.getStringAttr(data_format));
  odsState.addAttribute("dilations", dilations);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void Conv3DBackpropFilterV2Op::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 3u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult Conv3DBackpropFilterV2Op::verify() {
  if (failed(Conv3DBackpropFilterV2OpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of floating-point values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of 32-bit integer values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup2 = getODSOperands(2);
    for (::mlir::Value v : valueGroup2) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of floating-point values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))))) {
        return emitOpError("result #") << index << " must be tensor of floating-point values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void Conv3DBackpropFilterV2Op::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::Conv3DBackpropInputV2Op definitions
//===----------------------------------------------------------------------===//

Conv3DBackpropInputV2OpAdaptor::Conv3DBackpropInputV2OpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

Conv3DBackpropInputV2OpAdaptor::Conv3DBackpropInputV2OpAdaptor(Conv3DBackpropInputV2Op&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> Conv3DBackpropInputV2OpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange Conv3DBackpropInputV2OpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value Conv3DBackpropInputV2OpAdaptor::input_sizes() {
  return *getODSOperands(0).begin();
}

::mlir::Value Conv3DBackpropInputV2OpAdaptor::filter() {
  return *getODSOperands(1).begin();
}

::mlir::Value Conv3DBackpropInputV2OpAdaptor::out_backprop() {
  return *getODSOperands(2).begin();
}

::mlir::ArrayAttr Conv3DBackpropInputV2OpAdaptor::strides() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::ArrayAttr attr = odsAttrs.get("strides").cast<::mlir::ArrayAttr>();
  return attr;
}

::mlir::StringAttr Conv3DBackpropInputV2OpAdaptor::padding() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::StringAttr attr = odsAttrs.get("padding").cast<::mlir::StringAttr>();
  return attr;
}

::mlir::StringAttr Conv3DBackpropInputV2OpAdaptor::data_format() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::StringAttr attr = odsAttrs.get("data_format").dyn_cast_or_null<::mlir::StringAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getStringAttr("NDHWC");
  return attr;
}

::mlir::ArrayAttr Conv3DBackpropInputV2OpAdaptor::dilations() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::ArrayAttr attr = odsAttrs.get("dilations").dyn_cast_or_null<::mlir::ArrayAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getI64ArrayAttr({1, 1, 1, 1, 1});
  return attr;
}

::mlir::LogicalResult Conv3DBackpropInputV2OpAdaptor::verify(::mlir::Location loc) {
  {
  auto tblgen_strides = odsAttrs.get("strides");
  if (!tblgen_strides) return emitError(loc, "'tf.Conv3DBackpropInputV2' op ""requires attribute 'strides'");
    if (!((((tblgen_strides.isa<::mlir::ArrayAttr>())) && (::llvm::all_of(tblgen_strides.cast<::mlir::ArrayAttr>(), [](::mlir::Attribute attr) { return ((attr.isa<::mlir::IntegerAttr>())) && ((attr.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(64))); }))) && ((tblgen_strides.cast<::mlir::ArrayAttr>().size() >= 5)))) return emitError(loc, "'tf.Conv3DBackpropInputV2' op ""attribute 'strides' failed to satisfy constraint: 64-bit integer array attribute with at least 5 elements");
  }
  {
  auto tblgen_padding = odsAttrs.get("padding");
  if (!tblgen_padding) return emitError(loc, "'tf.Conv3DBackpropInputV2' op ""requires attribute 'padding'");
    if (!((tblgen_padding.cast<StringAttr>().getValue() == "SAME" || tblgen_padding.cast<StringAttr>().getValue() == "VALID"))) return emitError(loc, "'tf.Conv3DBackpropInputV2' op ""attribute 'padding' failed to satisfy constraint: string attribute whose value is SAME, or VALID");
  }
  {
  auto tblgen_data_format = odsAttrs.get("data_format");
  if (tblgen_data_format) {
    if (!((tblgen_data_format.cast<StringAttr>().getValue() == "NDHWC" || tblgen_data_format.cast<StringAttr>().getValue() == "NCDHW"))) return emitError(loc, "'tf.Conv3DBackpropInputV2' op ""attribute 'data_format' failed to satisfy constraint: string attribute whose value is NDHWC, or NCDHW");
  }
  }
  {
  auto tblgen_dilations = odsAttrs.get("dilations");
  if (tblgen_dilations) {
    if (!(((tblgen_dilations.isa<::mlir::ArrayAttr>())) && (::llvm::all_of(tblgen_dilations.cast<::mlir::ArrayAttr>(), [](::mlir::Attribute attr) { return ((attr.isa<::mlir::IntegerAttr>())) && ((attr.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(64))); })))) return emitError(loc, "'tf.Conv3DBackpropInputV2' op ""attribute 'dilations' failed to satisfy constraint: 64-bit integer array attribute");
  }
  }
  return ::mlir::success();
}

::llvm::StringRef Conv3DBackpropInputV2Op::getOperationName() {
  return "tf.Conv3DBackpropInputV2";
}

std::pair<unsigned, unsigned> Conv3DBackpropInputV2Op::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range Conv3DBackpropInputV2Op::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value Conv3DBackpropInputV2Op::input_sizes() {
  return *getODSOperands(0).begin();
}

::mlir::Value Conv3DBackpropInputV2Op::filter() {
  return *getODSOperands(1).begin();
}

::mlir::Value Conv3DBackpropInputV2Op::out_backprop() {
  return *getODSOperands(2).begin();
}

::mlir::MutableOperandRange Conv3DBackpropInputV2Op::input_sizesMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange Conv3DBackpropInputV2Op::filterMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange Conv3DBackpropInputV2Op::out_backpropMutable() {
  auto range = getODSOperandIndexAndLength(2);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> Conv3DBackpropInputV2Op::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range Conv3DBackpropInputV2Op::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value Conv3DBackpropInputV2Op::output() {
  return *getODSResults(0).begin();
}

::mlir::ArrayAttr Conv3DBackpropInputV2Op::stridesAttr() {
  return this->getAttr("strides").cast<::mlir::ArrayAttr>();
}

::mlir::ArrayAttr Conv3DBackpropInputV2Op::strides() {
  auto attr = stridesAttr();
  return attr;
}

::mlir::StringAttr Conv3DBackpropInputV2Op::paddingAttr() {
  return this->getAttr("padding").cast<::mlir::StringAttr>();
}

::llvm::StringRef Conv3DBackpropInputV2Op::padding() {
  auto attr = paddingAttr();
  return attr.getValue();
}

::mlir::StringAttr Conv3DBackpropInputV2Op::data_formatAttr() {
  return this->getAttr("data_format").dyn_cast_or_null<::mlir::StringAttr>();
}

::llvm::StringRef Conv3DBackpropInputV2Op::data_format() {
  auto attr = data_formatAttr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getStringAttr("NDHWC").getValue();
  return attr.getValue();
}

::mlir::ArrayAttr Conv3DBackpropInputV2Op::dilationsAttr() {
  return this->getAttr("dilations").dyn_cast_or_null<::mlir::ArrayAttr>();
}

::mlir::ArrayAttr Conv3DBackpropInputV2Op::dilations() {
  auto attr = dilationsAttr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getI64ArrayAttr({1, 1, 1, 1, 1});
  return attr;
}

Type Conv3DBackpropInputV2Op::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(1).begin());
}

Type Conv3DBackpropInputV2Op::Tshape() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

bool Conv3DBackpropInputV2Op::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "T") return true;
  if (name == "Tshape") return true;
 return false;
}

::mlir::DictionaryAttr Conv3DBackpropInputV2Op::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())},
    {::mlir::Identifier::get("Tshape", ctx),
::mlir::TypeAttr::get(Tshape())}
    }, ctx);
}

void Conv3DBackpropInputV2Op::stridesAttr(::mlir::ArrayAttr attr) {
  this->getOperation()->setAttr("strides", attr);
}

void Conv3DBackpropInputV2Op::paddingAttr(::mlir::StringAttr attr) {
  this->getOperation()->setAttr("padding", attr);
}

void Conv3DBackpropInputV2Op::data_formatAttr(::mlir::StringAttr attr) {
  this->getOperation()->setAttr("data_format", attr);
}

void Conv3DBackpropInputV2Op::dilationsAttr(::mlir::ArrayAttr attr) {
  this->getOperation()->setAttr("dilations", attr);
}

void Conv3DBackpropInputV2Op::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value input_sizes, ::mlir::Value filter, ::mlir::Value out_backprop, ::mlir::ArrayAttr strides, ::mlir::StringAttr padding, ::mlir::StringAttr data_format, ::mlir::ArrayAttr dilations) {
  odsState.addOperands(input_sizes);
  odsState.addOperands(filter);
  odsState.addOperands(out_backprop);
  odsState.addAttribute("strides", strides);
  odsState.addAttribute("padding", padding);
  odsState.addAttribute("data_format", data_format);
  odsState.addAttribute("dilations", dilations);
  odsState.addTypes(output);
}

void Conv3DBackpropInputV2Op::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input_sizes, ::mlir::Value filter, ::mlir::Value out_backprop, ::mlir::ArrayAttr strides, ::mlir::StringAttr padding, ::mlir::StringAttr data_format, ::mlir::ArrayAttr dilations) {
  odsState.addOperands(input_sizes);
  odsState.addOperands(filter);
  odsState.addOperands(out_backprop);
  odsState.addAttribute("strides", strides);
  odsState.addAttribute("padding", padding);
  odsState.addAttribute("data_format", data_format);
  odsState.addAttribute("dilations", dilations);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void Conv3DBackpropInputV2Op::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value input_sizes, ::mlir::Value filter, ::mlir::Value out_backprop, ::mlir::ArrayAttr strides, ::llvm::StringRef padding, ::llvm::StringRef data_format, ::mlir::ArrayAttr dilations) {
  odsState.addOperands(input_sizes);
  odsState.addOperands(filter);
  odsState.addOperands(out_backprop);
  odsState.addAttribute("strides", strides);
  odsState.addAttribute("padding", odsBuilder.getStringAttr(padding));
  odsState.addAttribute("data_format", odsBuilder.getStringAttr(data_format));
  odsState.addAttribute("dilations", dilations);
  odsState.addTypes(output);
}

void Conv3DBackpropInputV2Op::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input_sizes, ::mlir::Value filter, ::mlir::Value out_backprop, ::mlir::ArrayAttr strides, ::llvm::StringRef padding, ::llvm::StringRef data_format, ::mlir::ArrayAttr dilations) {
  odsState.addOperands(input_sizes);
  odsState.addOperands(filter);
  odsState.addOperands(out_backprop);
  odsState.addAttribute("strides", strides);
  odsState.addAttribute("padding", odsBuilder.getStringAttr(padding));
  odsState.addAttribute("data_format", odsBuilder.getStringAttr(data_format));
  odsState.addAttribute("dilations", dilations);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void Conv3DBackpropInputV2Op::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 3u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult Conv3DBackpropInputV2Op::verify() {
  if (failed(Conv3DBackpropInputV2OpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of 32/64-bit signed integer values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of floating-point values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup2 = getODSOperands(2);
    for (::mlir::Value v : valueGroup2) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of floating-point values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))))) {
        return emitOpError("result #") << index << " must be tensor of floating-point values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void Conv3DBackpropInputV2Op::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::Conv3DOp definitions
//===----------------------------------------------------------------------===//

Conv3DOpAdaptor::Conv3DOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

Conv3DOpAdaptor::Conv3DOpAdaptor(Conv3DOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> Conv3DOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange Conv3DOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value Conv3DOpAdaptor::input() {
  return *getODSOperands(0).begin();
}

::mlir::Value Conv3DOpAdaptor::filter() {
  return *getODSOperands(1).begin();
}

::mlir::ArrayAttr Conv3DOpAdaptor::strides() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::ArrayAttr attr = odsAttrs.get("strides").cast<::mlir::ArrayAttr>();
  return attr;
}

::mlir::StringAttr Conv3DOpAdaptor::padding() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::StringAttr attr = odsAttrs.get("padding").cast<::mlir::StringAttr>();
  return attr;
}

::mlir::StringAttr Conv3DOpAdaptor::data_format() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::StringAttr attr = odsAttrs.get("data_format").dyn_cast_or_null<::mlir::StringAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getStringAttr("NDHWC");
  return attr;
}

::mlir::ArrayAttr Conv3DOpAdaptor::dilations() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::ArrayAttr attr = odsAttrs.get("dilations").dyn_cast_or_null<::mlir::ArrayAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getI64ArrayAttr({1, 1, 1, 1, 1});
  return attr;
}

::mlir::LogicalResult Conv3DOpAdaptor::verify(::mlir::Location loc) {
  {
  auto tblgen_strides = odsAttrs.get("strides");
  if (!tblgen_strides) return emitError(loc, "'tf.Conv3D' op ""requires attribute 'strides'");
    if (!((((tblgen_strides.isa<::mlir::ArrayAttr>())) && (::llvm::all_of(tblgen_strides.cast<::mlir::ArrayAttr>(), [](::mlir::Attribute attr) { return ((attr.isa<::mlir::IntegerAttr>())) && ((attr.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(64))); }))) && ((tblgen_strides.cast<::mlir::ArrayAttr>().size() >= 5)))) return emitError(loc, "'tf.Conv3D' op ""attribute 'strides' failed to satisfy constraint: 64-bit integer array attribute with at least 5 elements");
  }
  {
  auto tblgen_padding = odsAttrs.get("padding");
  if (!tblgen_padding) return emitError(loc, "'tf.Conv3D' op ""requires attribute 'padding'");
    if (!((tblgen_padding.cast<StringAttr>().getValue() == "SAME" || tblgen_padding.cast<StringAttr>().getValue() == "VALID"))) return emitError(loc, "'tf.Conv3D' op ""attribute 'padding' failed to satisfy constraint: string attribute whose value is SAME, or VALID");
  }
  {
  auto tblgen_data_format = odsAttrs.get("data_format");
  if (tblgen_data_format) {
    if (!((tblgen_data_format.cast<StringAttr>().getValue() == "NDHWC" || tblgen_data_format.cast<StringAttr>().getValue() == "NCDHW"))) return emitError(loc, "'tf.Conv3D' op ""attribute 'data_format' failed to satisfy constraint: string attribute whose value is NDHWC, or NCDHW");
  }
  }
  {
  auto tblgen_dilations = odsAttrs.get("dilations");
  if (tblgen_dilations) {
    if (!(((tblgen_dilations.isa<::mlir::ArrayAttr>())) && (::llvm::all_of(tblgen_dilations.cast<::mlir::ArrayAttr>(), [](::mlir::Attribute attr) { return ((attr.isa<::mlir::IntegerAttr>())) && ((attr.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(64))); })))) return emitError(loc, "'tf.Conv3D' op ""attribute 'dilations' failed to satisfy constraint: 64-bit integer array attribute");
  }
  }
  return ::mlir::success();
}

::llvm::StringRef Conv3DOp::getOperationName() {
  return "tf.Conv3D";
}

std::pair<unsigned, unsigned> Conv3DOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range Conv3DOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value Conv3DOp::input() {
  return *getODSOperands(0).begin();
}

::mlir::Value Conv3DOp::filter() {
  return *getODSOperands(1).begin();
}

::mlir::MutableOperandRange Conv3DOp::inputMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange Conv3DOp::filterMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> Conv3DOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range Conv3DOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value Conv3DOp::output() {
  return *getODSResults(0).begin();
}

::mlir::ArrayAttr Conv3DOp::stridesAttr() {
  return this->getAttr("strides").cast<::mlir::ArrayAttr>();
}

::mlir::ArrayAttr Conv3DOp::strides() {
  auto attr = stridesAttr();
  return attr;
}

::mlir::StringAttr Conv3DOp::paddingAttr() {
  return this->getAttr("padding").cast<::mlir::StringAttr>();
}

::llvm::StringRef Conv3DOp::padding() {
  auto attr = paddingAttr();
  return attr.getValue();
}

::mlir::StringAttr Conv3DOp::data_formatAttr() {
  return this->getAttr("data_format").dyn_cast_or_null<::mlir::StringAttr>();
}

::llvm::StringRef Conv3DOp::data_format() {
  auto attr = data_formatAttr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getStringAttr("NDHWC").getValue();
  return attr.getValue();
}

::mlir::ArrayAttr Conv3DOp::dilationsAttr() {
  return this->getAttr("dilations").dyn_cast_or_null<::mlir::ArrayAttr>();
}

::mlir::ArrayAttr Conv3DOp::dilations() {
  auto attr = dilationsAttr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getI64ArrayAttr({1, 1, 1, 1, 1});
  return attr;
}

Type Conv3DOp::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

bool Conv3DOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "T") return true;
 return false;
}

::mlir::DictionaryAttr Conv3DOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())}
    }, ctx);
}

void Conv3DOp::stridesAttr(::mlir::ArrayAttr attr) {
  this->getOperation()->setAttr("strides", attr);
}

void Conv3DOp::paddingAttr(::mlir::StringAttr attr) {
  this->getOperation()->setAttr("padding", attr);
}

void Conv3DOp::data_formatAttr(::mlir::StringAttr attr) {
  this->getOperation()->setAttr("data_format", attr);
}

void Conv3DOp::dilationsAttr(::mlir::ArrayAttr attr) {
  this->getOperation()->setAttr("dilations", attr);
}

void Conv3DOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value input, ::mlir::Value filter, ::mlir::ArrayAttr strides, ::mlir::StringAttr padding, ::mlir::StringAttr data_format, ::mlir::ArrayAttr dilations) {
  odsState.addOperands(input);
  odsState.addOperands(filter);
  odsState.addAttribute("strides", strides);
  odsState.addAttribute("padding", padding);
  odsState.addAttribute("data_format", data_format);
  odsState.addAttribute("dilations", dilations);
  odsState.addTypes(output);
}

void Conv3DOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input, ::mlir::Value filter, ::mlir::ArrayAttr strides, ::mlir::StringAttr padding, ::mlir::StringAttr data_format, ::mlir::ArrayAttr dilations) {
  odsState.addOperands(input);
  odsState.addOperands(filter);
  odsState.addAttribute("strides", strides);
  odsState.addAttribute("padding", padding);
  odsState.addAttribute("data_format", data_format);
  odsState.addAttribute("dilations", dilations);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void Conv3DOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value input, ::mlir::Value filter, ::mlir::ArrayAttr strides, ::llvm::StringRef padding, ::llvm::StringRef data_format, ::mlir::ArrayAttr dilations) {
  odsState.addOperands(input);
  odsState.addOperands(filter);
  odsState.addAttribute("strides", strides);
  odsState.addAttribute("padding", odsBuilder.getStringAttr(padding));
  odsState.addAttribute("data_format", odsBuilder.getStringAttr(data_format));
  odsState.addAttribute("dilations", dilations);
  odsState.addTypes(output);
}

void Conv3DOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input, ::mlir::Value filter, ::mlir::ArrayAttr strides, ::llvm::StringRef padding, ::llvm::StringRef data_format, ::mlir::ArrayAttr dilations) {
  odsState.addOperands(input);
  odsState.addOperands(filter);
  odsState.addAttribute("strides", strides);
  odsState.addAttribute("padding", odsBuilder.getStringAttr(padding));
  odsState.addAttribute("data_format", odsBuilder.getStringAttr(data_format));
  odsState.addAttribute("dilations", dilations);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void Conv3DOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult Conv3DOp::verify() {
  if (failed(Conv3DOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of floating-point values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of floating-point values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))))) {
        return emitOpError("result #") << index << " must be tensor of floating-point values, but got " << v.getType();
      }
      ++index;
    }
  }
  return Verify(*this);
}

void Conv3DOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::CosOp definitions
//===----------------------------------------------------------------------===//

CosOpAdaptor::CosOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

CosOpAdaptor::CosOpAdaptor(CosOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> CosOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange CosOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value CosOpAdaptor::x() {
  return *getODSOperands(0).begin();
}

::mlir::LogicalResult CosOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

::llvm::StringRef CosOp::getOperationName() {
  return "tf.Cos";
}

std::pair<unsigned, unsigned> CosOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range CosOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value CosOp::x() {
  return *getODSOperands(0).begin();
}

::mlir::MutableOperandRange CosOp::xMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> CosOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range CosOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value CosOp::y() {
  return *getODSResults(0).begin();
}

Type CosOp::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

bool CosOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "T") return true;
 return false;
}

::mlir::DictionaryAttr CosOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())}
    }, ctx);
}

void CosOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type y, ::mlir::Value x) {
  odsState.addOperands(x);
  odsState.addTypes(y);
}

void CosOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value x) {
  odsState.addOperands(x);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void CosOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

void CosOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value x) {
  odsState.addOperands(x);
  odsState.addTypes({x.getType()});

}

void CosOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  odsState.addTypes({operands[0].getType()});

}

::mlir::LogicalResult CosOp::verify() {
  if (failed(CosOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))))))) {
        return emitOpError("operand #") << index << " must be tensor of floating-point or complex values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))))))) {
        return emitOpError("result #") << index << " must be tensor of floating-point or complex values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void CosOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::CoshOp definitions
//===----------------------------------------------------------------------===//

CoshOpAdaptor::CoshOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

CoshOpAdaptor::CoshOpAdaptor(CoshOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> CoshOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange CoshOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value CoshOpAdaptor::x() {
  return *getODSOperands(0).begin();
}

::mlir::LogicalResult CoshOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

::llvm::StringRef CoshOp::getOperationName() {
  return "tf.Cosh";
}

std::pair<unsigned, unsigned> CoshOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range CoshOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value CoshOp::x() {
  return *getODSOperands(0).begin();
}

::mlir::MutableOperandRange CoshOp::xMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> CoshOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range CoshOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value CoshOp::y() {
  return *getODSResults(0).begin();
}

Type CoshOp::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

bool CoshOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "T") return true;
 return false;
}

::mlir::DictionaryAttr CoshOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())}
    }, ctx);
}

void CoshOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type y, ::mlir::Value x) {
  odsState.addOperands(x);
  odsState.addTypes(y);
}

void CoshOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value x) {
  odsState.addOperands(x);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void CoshOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

void CoshOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value x) {
  odsState.addOperands(x);
  odsState.addTypes({x.getType()});

}

void CoshOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  odsState.addTypes({operands[0].getType()});

}

::mlir::LogicalResult CoshOp::verify() {
  if (failed(CoshOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))))))) {
        return emitOpError("operand #") << index << " must be tensor of floating-point or complex values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))))))) {
        return emitOpError("result #") << index << " must be tensor of floating-point or complex values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void CoshOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::CreateSummaryDbWriterOp definitions
//===----------------------------------------------------------------------===//

CreateSummaryDbWriterOpAdaptor::CreateSummaryDbWriterOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

CreateSummaryDbWriterOpAdaptor::CreateSummaryDbWriterOpAdaptor(CreateSummaryDbWriterOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> CreateSummaryDbWriterOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange CreateSummaryDbWriterOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value CreateSummaryDbWriterOpAdaptor::writer() {
  return *getODSOperands(0).begin();
}

::mlir::Value CreateSummaryDbWriterOpAdaptor::db_uri() {
  return *getODSOperands(1).begin();
}

::mlir::Value CreateSummaryDbWriterOpAdaptor::experiment_name() {
  return *getODSOperands(2).begin();
}

::mlir::Value CreateSummaryDbWriterOpAdaptor::run_name() {
  return *getODSOperands(3).begin();
}

::mlir::Value CreateSummaryDbWriterOpAdaptor::user_name() {
  return *getODSOperands(4).begin();
}

::mlir::LogicalResult CreateSummaryDbWriterOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

::llvm::StringRef CreateSummaryDbWriterOp::getOperationName() {
  return "tf.CreateSummaryDbWriter";
}

std::pair<unsigned, unsigned> CreateSummaryDbWriterOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range CreateSummaryDbWriterOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value CreateSummaryDbWriterOp::writer() {
  return *getODSOperands(0).begin();
}

::mlir::Value CreateSummaryDbWriterOp::db_uri() {
  return *getODSOperands(1).begin();
}

::mlir::Value CreateSummaryDbWriterOp::experiment_name() {
  return *getODSOperands(2).begin();
}

::mlir::Value CreateSummaryDbWriterOp::run_name() {
  return *getODSOperands(3).begin();
}

::mlir::Value CreateSummaryDbWriterOp::user_name() {
  return *getODSOperands(4).begin();
}

::mlir::MutableOperandRange CreateSummaryDbWriterOp::writerMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange CreateSummaryDbWriterOp::db_uriMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange CreateSummaryDbWriterOp::experiment_nameMutable() {
  auto range = getODSOperandIndexAndLength(2);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange CreateSummaryDbWriterOp::run_nameMutable() {
  auto range = getODSOperandIndexAndLength(3);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange CreateSummaryDbWriterOp::user_nameMutable() {
  auto range = getODSOperandIndexAndLength(4);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> CreateSummaryDbWriterOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range CreateSummaryDbWriterOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

void CreateSummaryDbWriterOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value writer, ::mlir::Value db_uri, ::mlir::Value experiment_name, ::mlir::Value run_name, ::mlir::Value user_name) {
  odsState.addOperands(writer);
  odsState.addOperands(db_uri);
  odsState.addOperands(experiment_name);
  odsState.addOperands(run_name);
  odsState.addOperands(user_name);
}

void CreateSummaryDbWriterOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value writer, ::mlir::Value db_uri, ::mlir::Value experiment_name, ::mlir::Value run_name, ::mlir::Value user_name) {
  odsState.addOperands(writer);
  odsState.addOperands(db_uri);
  odsState.addOperands(experiment_name);
  odsState.addOperands(run_name);
  odsState.addOperands(user_name);
  assert(resultTypes.size() == 0u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void CreateSummaryDbWriterOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 5u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 0u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult CreateSummaryDbWriterOp::verify() {
  if (failed(CreateSummaryDbWriterOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::ResourceType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::ResourceRefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of resource values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::StringType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::StringRefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of string values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup2 = getODSOperands(2);
    for (::mlir::Value v : valueGroup2) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::StringType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::StringRefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of string values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup3 = getODSOperands(3);
    for (::mlir::Value v : valueGroup3) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::StringType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::StringRefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of string values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup4 = getODSOperands(4);
    for (::mlir::Value v : valueGroup4) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::StringType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::StringRefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of string values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
  }
  return ::mlir::success();
}

void CreateSummaryDbWriterOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
  for (::mlir::Value value : getODSOperands(0))
    effects.emplace_back(MemoryEffects::Write::get(), value, ::mlir::TF::ResourceEffects::Summary::get());
}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::CreateSummaryFileWriterOp definitions
//===----------------------------------------------------------------------===//

CreateSummaryFileWriterOpAdaptor::CreateSummaryFileWriterOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

CreateSummaryFileWriterOpAdaptor::CreateSummaryFileWriterOpAdaptor(CreateSummaryFileWriterOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> CreateSummaryFileWriterOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange CreateSummaryFileWriterOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value CreateSummaryFileWriterOpAdaptor::writer() {
  return *getODSOperands(0).begin();
}

::mlir::Value CreateSummaryFileWriterOpAdaptor::logdir() {
  return *getODSOperands(1).begin();
}

::mlir::Value CreateSummaryFileWriterOpAdaptor::max_queue() {
  return *getODSOperands(2).begin();
}

::mlir::Value CreateSummaryFileWriterOpAdaptor::flush_millis() {
  return *getODSOperands(3).begin();
}

::mlir::Value CreateSummaryFileWriterOpAdaptor::filename_suffix() {
  return *getODSOperands(4).begin();
}

::mlir::LogicalResult CreateSummaryFileWriterOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

::llvm::StringRef CreateSummaryFileWriterOp::getOperationName() {
  return "tf.CreateSummaryFileWriter";
}

std::pair<unsigned, unsigned> CreateSummaryFileWriterOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range CreateSummaryFileWriterOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value CreateSummaryFileWriterOp::writer() {
  return *getODSOperands(0).begin();
}

::mlir::Value CreateSummaryFileWriterOp::logdir() {
  return *getODSOperands(1).begin();
}

::mlir::Value CreateSummaryFileWriterOp::max_queue() {
  return *getODSOperands(2).begin();
}

::mlir::Value CreateSummaryFileWriterOp::flush_millis() {
  return *getODSOperands(3).begin();
}

::mlir::Value CreateSummaryFileWriterOp::filename_suffix() {
  return *getODSOperands(4).begin();
}

::mlir::MutableOperandRange CreateSummaryFileWriterOp::writerMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange CreateSummaryFileWriterOp::logdirMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange CreateSummaryFileWriterOp::max_queueMutable() {
  auto range = getODSOperandIndexAndLength(2);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange CreateSummaryFileWriterOp::flush_millisMutable() {
  auto range = getODSOperandIndexAndLength(3);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange CreateSummaryFileWriterOp::filename_suffixMutable() {
  auto range = getODSOperandIndexAndLength(4);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> CreateSummaryFileWriterOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range CreateSummaryFileWriterOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

void CreateSummaryFileWriterOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value writer, ::mlir::Value logdir, ::mlir::Value max_queue, ::mlir::Value flush_millis, ::mlir::Value filename_suffix) {
  odsState.addOperands(writer);
  odsState.addOperands(logdir);
  odsState.addOperands(max_queue);
  odsState.addOperands(flush_millis);
  odsState.addOperands(filename_suffix);
}

void CreateSummaryFileWriterOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value writer, ::mlir::Value logdir, ::mlir::Value max_queue, ::mlir::Value flush_millis, ::mlir::Value filename_suffix) {
  odsState.addOperands(writer);
  odsState.addOperands(logdir);
  odsState.addOperands(max_queue);
  odsState.addOperands(flush_millis);
  odsState.addOperands(filename_suffix);
  assert(resultTypes.size() == 0u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void CreateSummaryFileWriterOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 5u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 0u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult CreateSummaryFileWriterOp::verify() {
  if (failed(CreateSummaryFileWriterOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::ResourceType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::ResourceRefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of resource values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::StringType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::StringRefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of string values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup2 = getODSOperands(2);
    for (::mlir::Value v : valueGroup2) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of 32-bit integer values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup3 = getODSOperands(3);
    for (::mlir::Value v : valueGroup3) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of 32-bit integer values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup4 = getODSOperands(4);
    for (::mlir::Value v : valueGroup4) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::StringType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::StringRefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of string values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
  }
  return ::mlir::success();
}

void CreateSummaryFileWriterOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
  for (::mlir::Value value : getODSOperands(0))
    effects.emplace_back(MemoryEffects::Write::get(), value, ::mlir::TF::ResourceEffects::Summary::get());
}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::CrossOp definitions
//===----------------------------------------------------------------------===//

CrossOpAdaptor::CrossOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

CrossOpAdaptor::CrossOpAdaptor(CrossOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> CrossOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange CrossOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value CrossOpAdaptor::a() {
  return *getODSOperands(0).begin();
}

::mlir::Value CrossOpAdaptor::b() {
  return *getODSOperands(1).begin();
}

::mlir::LogicalResult CrossOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

::llvm::StringRef CrossOp::getOperationName() {
  return "tf.Cross";
}

std::pair<unsigned, unsigned> CrossOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range CrossOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value CrossOp::a() {
  return *getODSOperands(0).begin();
}

::mlir::Value CrossOp::b() {
  return *getODSOperands(1).begin();
}

::mlir::MutableOperandRange CrossOp::aMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange CrossOp::bMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> CrossOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range CrossOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value CrossOp::product() {
  return *getODSResults(0).begin();
}

Type CrossOp::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

bool CrossOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "T") return true;
 return false;
}

::mlir::DictionaryAttr CrossOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())}
    }, ctx);
}

void CrossOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type product, ::mlir::Value a, ::mlir::Value b) {
  odsState.addOperands(a);
  odsState.addOperands(b);
  odsState.addTypes(product);
}

void CrossOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value a, ::mlir::Value b) {
  odsState.addOperands(a);
  odsState.addOperands(b);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void CrossOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

void CrossOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value a, ::mlir::Value b) {
  odsState.addOperands(a);
  odsState.addOperands(b);
  odsState.addTypes({a.getType()});

}

void CrossOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  odsState.addTypes({operands[0].getType()});

}

::mlir::LogicalResult CrossOp::verify() {
  if (failed(CrossOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of integer or floating-point values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of integer or floating-point values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>())))))) {
        return emitOpError("result #") << index << " must be tensor of integer or floating-point values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void CrossOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::CrossReplicaSumOp definitions
//===----------------------------------------------------------------------===//

CrossReplicaSumOpAdaptor::CrossReplicaSumOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

CrossReplicaSumOpAdaptor::CrossReplicaSumOpAdaptor(CrossReplicaSumOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> CrossReplicaSumOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange CrossReplicaSumOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value CrossReplicaSumOpAdaptor::input() {
  return *getODSOperands(0).begin();
}

::mlir::Value CrossReplicaSumOpAdaptor::group_assignment() {
  return *getODSOperands(1).begin();
}

::mlir::LogicalResult CrossReplicaSumOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

::llvm::StringRef CrossReplicaSumOp::getOperationName() {
  return "tf.CrossReplicaSum";
}

std::pair<unsigned, unsigned> CrossReplicaSumOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range CrossReplicaSumOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value CrossReplicaSumOp::input() {
  return *getODSOperands(0).begin();
}

::mlir::Value CrossReplicaSumOp::group_assignment() {
  return *getODSOperands(1).begin();
}

::mlir::MutableOperandRange CrossReplicaSumOp::inputMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange CrossReplicaSumOp::group_assignmentMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> CrossReplicaSumOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range CrossReplicaSumOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value CrossReplicaSumOp::output() {
  return *getODSResults(0).begin();
}

Type CrossReplicaSumOp::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

bool CrossReplicaSumOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "T") return true;
 return false;
}

::mlir::DictionaryAttr CrossReplicaSumOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())}
    }, ctx);
}

void CrossReplicaSumOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value input, ::mlir::Value group_assignment) {
  odsState.addOperands(input);
  odsState.addOperands(group_assignment);
  odsState.addTypes(output);
}

void CrossReplicaSumOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input, ::mlir::Value group_assignment) {
  odsState.addOperands(input);
  odsState.addOperands(group_assignment);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void CrossReplicaSumOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult CrossReplicaSumOp::verify() {
  if (failed(CrossReplicaSumOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of bfloat16 or 16-bit float or 32-bit float or 32-bit integer or 32-bit unsigned integer values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of 32-bit integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>())))))) {
        return emitOpError("result #") << index << " must be tensor of bfloat16 or 16-bit float or 32-bit float or 32-bit integer or 32-bit unsigned integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  if (!((TF::AreCastCompatible(llvm::makeArrayRef({(*this->getODSOperands(0).begin()).getType(), (*this->getODSResults(0).begin()).getType()})))))
    return emitOpError("failed to verify that all of {input, output} have dynamically equal types ");
  return ::mlir::success();
}

void CrossReplicaSumOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::CumprodOp definitions
//===----------------------------------------------------------------------===//

CumprodOpAdaptor::CumprodOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

CumprodOpAdaptor::CumprodOpAdaptor(CumprodOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> CumprodOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange CumprodOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value CumprodOpAdaptor::x() {
  return *getODSOperands(0).begin();
}

::mlir::Value CumprodOpAdaptor::axis() {
  return *getODSOperands(1).begin();
}

::mlir::BoolAttr CumprodOpAdaptor::exclusive() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::BoolAttr attr = odsAttrs.get("exclusive").dyn_cast_or_null<::mlir::BoolAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getBoolAttr(false);
  return attr;
}

::mlir::BoolAttr CumprodOpAdaptor::reverse() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::BoolAttr attr = odsAttrs.get("reverse").dyn_cast_or_null<::mlir::BoolAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getBoolAttr(false);
  return attr;
}

::mlir::LogicalResult CumprodOpAdaptor::verify(::mlir::Location loc) {
  {
  auto tblgen_exclusive = odsAttrs.get("exclusive");
  if (tblgen_exclusive) {
    if (!((tblgen_exclusive.isa<::mlir::BoolAttr>()))) return emitError(loc, "'tf.Cumprod' op ""attribute 'exclusive' failed to satisfy constraint: bool attribute");
  }
  }
  {
  auto tblgen_reverse = odsAttrs.get("reverse");
  if (tblgen_reverse) {
    if (!((tblgen_reverse.isa<::mlir::BoolAttr>()))) return emitError(loc, "'tf.Cumprod' op ""attribute 'reverse' failed to satisfy constraint: bool attribute");
  }
  }
  return ::mlir::success();
}

::llvm::StringRef CumprodOp::getOperationName() {
  return "tf.Cumprod";
}

std::pair<unsigned, unsigned> CumprodOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range CumprodOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value CumprodOp::x() {
  return *getODSOperands(0).begin();
}

::mlir::Value CumprodOp::axis() {
  return *getODSOperands(1).begin();
}

::mlir::MutableOperandRange CumprodOp::xMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange CumprodOp::axisMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> CumprodOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range CumprodOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value CumprodOp::out() {
  return *getODSResults(0).begin();
}

::mlir::BoolAttr CumprodOp::exclusiveAttr() {
  return this->getAttr("exclusive").dyn_cast_or_null<::mlir::BoolAttr>();
}

bool CumprodOp::exclusive() {
  auto attr = exclusiveAttr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getBoolAttr(false).getValue();
  return attr.getValue();
}

::mlir::BoolAttr CumprodOp::reverseAttr() {
  return this->getAttr("reverse").dyn_cast_or_null<::mlir::BoolAttr>();
}

bool CumprodOp::reverse() {
  auto attr = reverseAttr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getBoolAttr(false).getValue();
  return attr.getValue();
}

Type CumprodOp::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

Type CumprodOp::Tidx() {
  return mlir::getElementTypeOrSelf(*getODSOperands(1).begin());
}

bool CumprodOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "T") return true;
  if (name == "Tidx") return true;
 return false;
}

::mlir::DictionaryAttr CumprodOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())},
    {::mlir::Identifier::get("Tidx", ctx),
::mlir::TypeAttr::get(Tidx())}
    }, ctx);
}

void CumprodOp::exclusiveAttr(::mlir::BoolAttr attr) {
  this->getOperation()->setAttr("exclusive", attr);
}

void CumprodOp::reverseAttr(::mlir::BoolAttr attr) {
  this->getOperation()->setAttr("reverse", attr);
}

void CumprodOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type out, ::mlir::Value x, ::mlir::Value axis, ::mlir::BoolAttr exclusive, ::mlir::BoolAttr reverse) {
  odsState.addOperands(x);
  odsState.addOperands(axis);
  odsState.addAttribute("exclusive", exclusive);
  odsState.addAttribute("reverse", reverse);
  odsState.addTypes(out);
}

void CumprodOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value x, ::mlir::Value axis, ::mlir::BoolAttr exclusive, ::mlir::BoolAttr reverse) {
  odsState.addOperands(x);
  odsState.addOperands(axis);
  odsState.addAttribute("exclusive", exclusive);
  odsState.addAttribute("reverse", reverse);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void CumprodOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type out, ::mlir::Value x, ::mlir::Value axis, bool exclusive, bool reverse) {
  odsState.addOperands(x);
  odsState.addOperands(axis);
  odsState.addAttribute("exclusive", odsBuilder.getBoolAttr(exclusive));
  odsState.addAttribute("reverse", odsBuilder.getBoolAttr(reverse));
  odsState.addTypes(out);
}

void CumprodOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value x, ::mlir::Value axis, bool exclusive, bool reverse) {
  odsState.addOperands(x);
  odsState.addOperands(axis);
  odsState.addAttribute("exclusive", odsBuilder.getBoolAttr(exclusive));
  odsState.addAttribute("reverse", odsBuilder.getBoolAttr(reverse));
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void CumprodOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult CumprodOp::verify() {
  if (failed(CumprodOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of bfloat16 or 128-bit complex or 64-bit complex or 16-bit float or 32-bit float or 64-bit float or 16-bit integer or 32-bit integer or 64-bit integer or 8-bit integer or 32-bit quantized integer or 8-bit quantized integer or 8-bit quantized unsigned integer or 16-bit unsigned integer or 32-bit unsigned integer or 64-bit unsigned integer or 8-bit unsigned integer values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of 32/64-bit signed integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>())))))) {
        return emitOpError("result #") << index << " must be tensor of bfloat16 or 128-bit complex or 64-bit complex or 16-bit float or 32-bit float or 64-bit float or 16-bit integer or 32-bit integer or 64-bit integer or 8-bit integer or 32-bit quantized integer or 8-bit quantized integer or 8-bit quantized unsigned integer or 16-bit unsigned integer or 32-bit unsigned integer or 64-bit unsigned integer or 8-bit unsigned integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  if (!((TF::AreCastCompatible(llvm::makeArrayRef({(*this->getODSOperands(0).begin()).getType(), (*this->getODSResults(0).begin()).getType()})))))
    return emitOpError("failed to verify that all of {x, out} have dynamically equal types ");
  return Verify(*this);
}

void CumprodOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::CumsumOp definitions
//===----------------------------------------------------------------------===//

CumsumOpAdaptor::CumsumOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

CumsumOpAdaptor::CumsumOpAdaptor(CumsumOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> CumsumOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange CumsumOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value CumsumOpAdaptor::x() {
  return *getODSOperands(0).begin();
}

::mlir::Value CumsumOpAdaptor::axis() {
  return *getODSOperands(1).begin();
}

::mlir::BoolAttr CumsumOpAdaptor::exclusive() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::BoolAttr attr = odsAttrs.get("exclusive").dyn_cast_or_null<::mlir::BoolAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getBoolAttr(false);
  return attr;
}

::mlir::BoolAttr CumsumOpAdaptor::reverse() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::BoolAttr attr = odsAttrs.get("reverse").dyn_cast_or_null<::mlir::BoolAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getBoolAttr(false);
  return attr;
}

::mlir::LogicalResult CumsumOpAdaptor::verify(::mlir::Location loc) {
  {
  auto tblgen_exclusive = odsAttrs.get("exclusive");
  if (tblgen_exclusive) {
    if (!((tblgen_exclusive.isa<::mlir::BoolAttr>()))) return emitError(loc, "'tf.Cumsum' op ""attribute 'exclusive' failed to satisfy constraint: bool attribute");
  }
  }
  {
  auto tblgen_reverse = odsAttrs.get("reverse");
  if (tblgen_reverse) {
    if (!((tblgen_reverse.isa<::mlir::BoolAttr>()))) return emitError(loc, "'tf.Cumsum' op ""attribute 'reverse' failed to satisfy constraint: bool attribute");
  }
  }
  return ::mlir::success();
}

::llvm::StringRef CumsumOp::getOperationName() {
  return "tf.Cumsum";
}

std::pair<unsigned, unsigned> CumsumOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range CumsumOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value CumsumOp::x() {
  return *getODSOperands(0).begin();
}

::mlir::Value CumsumOp::axis() {
  return *getODSOperands(1).begin();
}

::mlir::MutableOperandRange CumsumOp::xMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange CumsumOp::axisMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> CumsumOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range CumsumOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value CumsumOp::out() {
  return *getODSResults(0).begin();
}

::mlir::BoolAttr CumsumOp::exclusiveAttr() {
  return this->getAttr("exclusive").dyn_cast_or_null<::mlir::BoolAttr>();
}

bool CumsumOp::exclusive() {
  auto attr = exclusiveAttr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getBoolAttr(false).getValue();
  return attr.getValue();
}

::mlir::BoolAttr CumsumOp::reverseAttr() {
  return this->getAttr("reverse").dyn_cast_or_null<::mlir::BoolAttr>();
}

bool CumsumOp::reverse() {
  auto attr = reverseAttr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getBoolAttr(false).getValue();
  return attr.getValue();
}

Type CumsumOp::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

Type CumsumOp::Tidx() {
  return mlir::getElementTypeOrSelf(*getODSOperands(1).begin());
}

bool CumsumOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "T") return true;
  if (name == "Tidx") return true;
 return false;
}

::mlir::DictionaryAttr CumsumOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())},
    {::mlir::Identifier::get("Tidx", ctx),
::mlir::TypeAttr::get(Tidx())}
    }, ctx);
}

void CumsumOp::exclusiveAttr(::mlir::BoolAttr attr) {
  this->getOperation()->setAttr("exclusive", attr);
}

void CumsumOp::reverseAttr(::mlir::BoolAttr attr) {
  this->getOperation()->setAttr("reverse", attr);
}

void CumsumOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type out, ::mlir::Value x, ::mlir::Value axis, ::mlir::BoolAttr exclusive, ::mlir::BoolAttr reverse) {
  odsState.addOperands(x);
  odsState.addOperands(axis);
  odsState.addAttribute("exclusive", exclusive);
  odsState.addAttribute("reverse", reverse);
  odsState.addTypes(out);
}

void CumsumOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value x, ::mlir::Value axis, ::mlir::BoolAttr exclusive, ::mlir::BoolAttr reverse) {
  odsState.addOperands(x);
  odsState.addOperands(axis);
  odsState.addAttribute("exclusive", exclusive);
  odsState.addAttribute("reverse", reverse);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void CumsumOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type out, ::mlir::Value x, ::mlir::Value axis, bool exclusive, bool reverse) {
  odsState.addOperands(x);
  odsState.addOperands(axis);
  odsState.addAttribute("exclusive", odsBuilder.getBoolAttr(exclusive));
  odsState.addAttribute("reverse", odsBuilder.getBoolAttr(reverse));
  odsState.addTypes(out);
}

void CumsumOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value x, ::mlir::Value axis, bool exclusive, bool reverse) {
  odsState.addOperands(x);
  odsState.addOperands(axis);
  odsState.addAttribute("exclusive", odsBuilder.getBoolAttr(exclusive));
  odsState.addAttribute("reverse", odsBuilder.getBoolAttr(reverse));
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void CumsumOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult CumsumOp::verify() {
  if (failed(CumsumOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of bfloat16 or 128-bit complex or 64-bit complex or 16-bit float or 32-bit float or 64-bit float or 16-bit integer or 32-bit integer or 64-bit integer or 8-bit integer or 32-bit quantized integer or 8-bit quantized integer or 8-bit quantized unsigned integer or 16-bit unsigned integer or 32-bit unsigned integer or 64-bit unsigned integer or 8-bit unsigned integer values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of 32/64-bit signed integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>())))))) {
        return emitOpError("result #") << index << " must be tensor of bfloat16 or 128-bit complex or 64-bit complex or 16-bit float or 32-bit float or 64-bit float or 16-bit integer or 32-bit integer or 64-bit integer or 8-bit integer or 32-bit quantized integer or 8-bit quantized integer or 8-bit quantized unsigned integer or 16-bit unsigned integer or 32-bit unsigned integer or 64-bit unsigned integer or 8-bit unsigned integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  if (!((TF::AreCastCompatible(llvm::makeArrayRef({(*this->getODSOperands(0).begin()).getType(), (*this->getODSResults(0).begin()).getType()})))))
    return emitOpError("failed to verify that all of {x, out} have dynamically equal types ");
  return Verify(*this);
}

void CumsumOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::DataFormatDimMapOp definitions
//===----------------------------------------------------------------------===//

DataFormatDimMapOpAdaptor::DataFormatDimMapOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

DataFormatDimMapOpAdaptor::DataFormatDimMapOpAdaptor(DataFormatDimMapOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> DataFormatDimMapOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange DataFormatDimMapOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value DataFormatDimMapOpAdaptor::x() {
  return *getODSOperands(0).begin();
}

::mlir::StringAttr DataFormatDimMapOpAdaptor::src_format() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::StringAttr attr = odsAttrs.get("src_format").dyn_cast_or_null<::mlir::StringAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getStringAttr("NHWC");
  return attr;
}

::mlir::StringAttr DataFormatDimMapOpAdaptor::dst_format() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::StringAttr attr = odsAttrs.get("dst_format").dyn_cast_or_null<::mlir::StringAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getStringAttr("NCHW");
  return attr;
}

::mlir::LogicalResult DataFormatDimMapOpAdaptor::verify(::mlir::Location loc) {
  {
  auto tblgen_src_format = odsAttrs.get("src_format");
  if (tblgen_src_format) {
    if (!((tblgen_src_format.isa<::mlir::StringAttr>()))) return emitError(loc, "'tf.DataFormatDimMap' op ""attribute 'src_format' failed to satisfy constraint: string attribute");
  }
  }
  {
  auto tblgen_dst_format = odsAttrs.get("dst_format");
  if (tblgen_dst_format) {
    if (!((tblgen_dst_format.isa<::mlir::StringAttr>()))) return emitError(loc, "'tf.DataFormatDimMap' op ""attribute 'dst_format' failed to satisfy constraint: string attribute");
  }
  }
  return ::mlir::success();
}

::llvm::StringRef DataFormatDimMapOp::getOperationName() {
  return "tf.DataFormatDimMap";
}

std::pair<unsigned, unsigned> DataFormatDimMapOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range DataFormatDimMapOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value DataFormatDimMapOp::x() {
  return *getODSOperands(0).begin();
}

::mlir::MutableOperandRange DataFormatDimMapOp::xMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> DataFormatDimMapOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range DataFormatDimMapOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value DataFormatDimMapOp::y() {
  return *getODSResults(0).begin();
}

::mlir::StringAttr DataFormatDimMapOp::src_formatAttr() {
  return this->getAttr("src_format").dyn_cast_or_null<::mlir::StringAttr>();
}

::llvm::StringRef DataFormatDimMapOp::src_format() {
  auto attr = src_formatAttr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getStringAttr("NHWC").getValue();
  return attr.getValue();
}

::mlir::StringAttr DataFormatDimMapOp::dst_formatAttr() {
  return this->getAttr("dst_format").dyn_cast_or_null<::mlir::StringAttr>();
}

::llvm::StringRef DataFormatDimMapOp::dst_format() {
  auto attr = dst_formatAttr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getStringAttr("NCHW").getValue();
  return attr.getValue();
}

Type DataFormatDimMapOp::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

bool DataFormatDimMapOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "T") return true;
 return false;
}

::mlir::DictionaryAttr DataFormatDimMapOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())}
    }, ctx);
}

void DataFormatDimMapOp::src_formatAttr(::mlir::StringAttr attr) {
  this->getOperation()->setAttr("src_format", attr);
}

void DataFormatDimMapOp::dst_formatAttr(::mlir::StringAttr attr) {
  this->getOperation()->setAttr("dst_format", attr);
}

void DataFormatDimMapOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type y, ::mlir::Value x, ::mlir::StringAttr src_format, ::mlir::StringAttr dst_format) {
  odsState.addOperands(x);
  odsState.addAttribute("src_format", src_format);
  odsState.addAttribute("dst_format", dst_format);
  odsState.addTypes(y);
}

void DataFormatDimMapOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value x, ::mlir::StringAttr src_format, ::mlir::StringAttr dst_format) {
  odsState.addOperands(x);
  odsState.addAttribute("src_format", src_format);
  odsState.addAttribute("dst_format", dst_format);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void DataFormatDimMapOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type y, ::mlir::Value x, ::llvm::StringRef src_format, ::llvm::StringRef dst_format) {
  odsState.addOperands(x);
  odsState.addAttribute("src_format", odsBuilder.getStringAttr(src_format));
  odsState.addAttribute("dst_format", odsBuilder.getStringAttr(dst_format));
  odsState.addTypes(y);
}

void DataFormatDimMapOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value x, ::llvm::StringRef src_format, ::llvm::StringRef dst_format) {
  odsState.addOperands(x);
  odsState.addAttribute("src_format", odsBuilder.getStringAttr(src_format));
  odsState.addAttribute("dst_format", odsBuilder.getStringAttr(dst_format));
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void DataFormatDimMapOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

void DataFormatDimMapOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value x, ::mlir::StringAttr src_format, ::mlir::StringAttr dst_format) {
  odsState.addOperands(x);
  odsState.addAttribute("src_format", src_format);
  odsState.addAttribute("dst_format", dst_format);
  odsState.addTypes({x.getType()});

}

void DataFormatDimMapOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  odsState.addTypes({operands[0].getType()});

}

::mlir::LogicalResult DataFormatDimMapOp::verify() {
  if (failed(DataFormatDimMapOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of 32/64-bit signed integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))))) {
        return emitOpError("result #") << index << " must be tensor of 32/64-bit signed integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void DataFormatDimMapOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::DataFormatVecPermuteOp definitions
//===----------------------------------------------------------------------===//

DataFormatVecPermuteOpAdaptor::DataFormatVecPermuteOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

DataFormatVecPermuteOpAdaptor::DataFormatVecPermuteOpAdaptor(DataFormatVecPermuteOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> DataFormatVecPermuteOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange DataFormatVecPermuteOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value DataFormatVecPermuteOpAdaptor::x() {
  return *getODSOperands(0).begin();
}

::mlir::StringAttr DataFormatVecPermuteOpAdaptor::src_format() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::StringAttr attr = odsAttrs.get("src_format").dyn_cast_or_null<::mlir::StringAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getStringAttr("NHWC");
  return attr;
}

::mlir::StringAttr DataFormatVecPermuteOpAdaptor::dst_format() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::StringAttr attr = odsAttrs.get("dst_format").dyn_cast_or_null<::mlir::StringAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getStringAttr("NCHW");
  return attr;
}

::mlir::LogicalResult DataFormatVecPermuteOpAdaptor::verify(::mlir::Location loc) {
  {
  auto tblgen_src_format = odsAttrs.get("src_format");
  if (tblgen_src_format) {
    if (!((tblgen_src_format.isa<::mlir::StringAttr>()))) return emitError(loc, "'tf.DataFormatVecPermute' op ""attribute 'src_format' failed to satisfy constraint: string attribute");
  }
  }
  {
  auto tblgen_dst_format = odsAttrs.get("dst_format");
  if (tblgen_dst_format) {
    if (!((tblgen_dst_format.isa<::mlir::StringAttr>()))) return emitError(loc, "'tf.DataFormatVecPermute' op ""attribute 'dst_format' failed to satisfy constraint: string attribute");
  }
  }
  return ::mlir::success();
}

::llvm::StringRef DataFormatVecPermuteOp::getOperationName() {
  return "tf.DataFormatVecPermute";
}

std::pair<unsigned, unsigned> DataFormatVecPermuteOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range DataFormatVecPermuteOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value DataFormatVecPermuteOp::x() {
  return *getODSOperands(0).begin();
}

::mlir::MutableOperandRange DataFormatVecPermuteOp::xMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> DataFormatVecPermuteOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range DataFormatVecPermuteOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value DataFormatVecPermuteOp::y() {
  return *getODSResults(0).begin();
}

::mlir::StringAttr DataFormatVecPermuteOp::src_formatAttr() {
  return this->getAttr("src_format").dyn_cast_or_null<::mlir::StringAttr>();
}

::llvm::StringRef DataFormatVecPermuteOp::src_format() {
  auto attr = src_formatAttr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getStringAttr("NHWC").getValue();
  return attr.getValue();
}

::mlir::StringAttr DataFormatVecPermuteOp::dst_formatAttr() {
  return this->getAttr("dst_format").dyn_cast_or_null<::mlir::StringAttr>();
}

::llvm::StringRef DataFormatVecPermuteOp::dst_format() {
  auto attr = dst_formatAttr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getStringAttr("NCHW").getValue();
  return attr.getValue();
}

Type DataFormatVecPermuteOp::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

bool DataFormatVecPermuteOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "T") return true;
 return false;
}

::mlir::DictionaryAttr DataFormatVecPermuteOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())}
    }, ctx);
}

void DataFormatVecPermuteOp::src_formatAttr(::mlir::StringAttr attr) {
  this->getOperation()->setAttr("src_format", attr);
}

void DataFormatVecPermuteOp::dst_formatAttr(::mlir::StringAttr attr) {
  this->getOperation()->setAttr("dst_format", attr);
}

void DataFormatVecPermuteOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type y, ::mlir::Value x, ::mlir::StringAttr src_format, ::mlir::StringAttr dst_format) {
  odsState.addOperands(x);
  odsState.addAttribute("src_format", src_format);
  odsState.addAttribute("dst_format", dst_format);
  odsState.addTypes(y);
}

void DataFormatVecPermuteOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value x, ::mlir::StringAttr src_format, ::mlir::StringAttr dst_format) {
  odsState.addOperands(x);
  odsState.addAttribute("src_format", src_format);
  odsState.addAttribute("dst_format", dst_format);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void DataFormatVecPermuteOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type y, ::mlir::Value x, ::llvm::StringRef src_format, ::llvm::StringRef dst_format) {
  odsState.addOperands(x);
  odsState.addAttribute("src_format", odsBuilder.getStringAttr(src_format));
  odsState.addAttribute("dst_format", odsBuilder.getStringAttr(dst_format));
  odsState.addTypes(y);
}

void DataFormatVecPermuteOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value x, ::llvm::StringRef src_format, ::llvm::StringRef dst_format) {
  odsState.addOperands(x);
  odsState.addAttribute("src_format", odsBuilder.getStringAttr(src_format));
  odsState.addAttribute("dst_format", odsBuilder.getStringAttr(dst_format));
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void DataFormatVecPermuteOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

void DataFormatVecPermuteOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value x, ::mlir::StringAttr src_format, ::mlir::StringAttr dst_format) {
  odsState.addOperands(x);
  odsState.addAttribute("src_format", src_format);
  odsState.addAttribute("dst_format", dst_format);
  odsState.addTypes({x.getType()});

}

void DataFormatVecPermuteOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  odsState.addTypes({operands[0].getType()});

}

::mlir::LogicalResult DataFormatVecPermuteOp::verify() {
  if (failed(DataFormatVecPermuteOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of 32/64-bit signed integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))))) {
        return emitOpError("result #") << index << " must be tensor of 32/64-bit signed integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  return Verify(*this);
}

void DataFormatVecPermuteOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::DebugIdentityV2Op definitions
//===----------------------------------------------------------------------===//

DebugIdentityV2OpAdaptor::DebugIdentityV2OpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

DebugIdentityV2OpAdaptor::DebugIdentityV2OpAdaptor(DebugIdentityV2Op&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> DebugIdentityV2OpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange DebugIdentityV2OpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value DebugIdentityV2OpAdaptor::input() {
  return *getODSOperands(0).begin();
}

::mlir::StringAttr DebugIdentityV2OpAdaptor::tfdbg_context_id() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::StringAttr attr = odsAttrs.get("tfdbg_context_id").cast<::mlir::StringAttr>();
  return attr;
}

::mlir::StringAttr DebugIdentityV2OpAdaptor::op_name() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::StringAttr attr = odsAttrs.get("op_name").cast<::mlir::StringAttr>();
  return attr;
}

::mlir::IntegerAttr DebugIdentityV2OpAdaptor::output_slot() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::IntegerAttr attr = odsAttrs.get("output_slot").dyn_cast_or_null<::mlir::IntegerAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getIntegerAttr(::mlir::Builder(odsAttrs.getContext()).getIntegerType(64), -1);
  return attr;
}

::mlir::IntegerAttr DebugIdentityV2OpAdaptor::tensor_debug_mode() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::IntegerAttr attr = odsAttrs.get("tensor_debug_mode").dyn_cast_or_null<::mlir::IntegerAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getIntegerAttr(::mlir::Builder(odsAttrs.getContext()).getIntegerType(64), -1);
  return attr;
}

::mlir::ArrayAttr DebugIdentityV2OpAdaptor::debug_urls() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::ArrayAttr attr = odsAttrs.get("debug_urls").dyn_cast_or_null<::mlir::ArrayAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getStrArrayAttr({});
  return attr;
}

::mlir::IntegerAttr DebugIdentityV2OpAdaptor::circular_buffer_size() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::IntegerAttr attr = odsAttrs.get("circular_buffer_size").dyn_cast_or_null<::mlir::IntegerAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getIntegerAttr(::mlir::Builder(odsAttrs.getContext()).getIntegerType(64), 1000);
  return attr;
}

::mlir::StringAttr DebugIdentityV2OpAdaptor::tfdbg_run_id() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::StringAttr attr = odsAttrs.get("tfdbg_run_id").cast<::mlir::StringAttr>();
  return attr;
}

::mlir::LogicalResult DebugIdentityV2OpAdaptor::verify(::mlir::Location loc) {
  {
  auto tblgen_tfdbg_context_id = odsAttrs.get("tfdbg_context_id");
  if (!tblgen_tfdbg_context_id) return emitError(loc, "'tf.DebugIdentityV2' op ""requires attribute 'tfdbg_context_id'");
    if (!((tblgen_tfdbg_context_id.isa<::mlir::StringAttr>()))) return emitError(loc, "'tf.DebugIdentityV2' op ""attribute 'tfdbg_context_id' failed to satisfy constraint: string attribute");
  }
  {
  auto tblgen_op_name = odsAttrs.get("op_name");
  if (!tblgen_op_name) return emitError(loc, "'tf.DebugIdentityV2' op ""requires attribute 'op_name'");
    if (!((tblgen_op_name.isa<::mlir::StringAttr>()))) return emitError(loc, "'tf.DebugIdentityV2' op ""attribute 'op_name' failed to satisfy constraint: string attribute");
  }
  {
  auto tblgen_output_slot = odsAttrs.get("output_slot");
  if (tblgen_output_slot) {
    if (!(((tblgen_output_slot.isa<::mlir::IntegerAttr>())) && ((tblgen_output_slot.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(64))))) return emitError(loc, "'tf.DebugIdentityV2' op ""attribute 'output_slot' failed to satisfy constraint: 64-bit signless integer attribute");
  }
  }
  {
  auto tblgen_tensor_debug_mode = odsAttrs.get("tensor_debug_mode");
  if (tblgen_tensor_debug_mode) {
    if (!(((tblgen_tensor_debug_mode.isa<::mlir::IntegerAttr>())) && ((tblgen_tensor_debug_mode.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(64))))) return emitError(loc, "'tf.DebugIdentityV2' op ""attribute 'tensor_debug_mode' failed to satisfy constraint: 64-bit signless integer attribute");
  }
  }
  {
  auto tblgen_debug_urls = odsAttrs.get("debug_urls");
  if (tblgen_debug_urls) {
    if (!(((tblgen_debug_urls.isa<::mlir::ArrayAttr>())) && (::llvm::all_of(tblgen_debug_urls.cast<::mlir::ArrayAttr>(), [](::mlir::Attribute attr) { return (attr.isa<::mlir::StringAttr>()); })))) return emitError(loc, "'tf.DebugIdentityV2' op ""attribute 'debug_urls' failed to satisfy constraint: string array attribute");
  }
  }
  {
  auto tblgen_circular_buffer_size = odsAttrs.get("circular_buffer_size");
  if (tblgen_circular_buffer_size) {
    if (!(((tblgen_circular_buffer_size.isa<::mlir::IntegerAttr>())) && ((tblgen_circular_buffer_size.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(64))))) return emitError(loc, "'tf.DebugIdentityV2' op ""attribute 'circular_buffer_size' failed to satisfy constraint: 64-bit signless integer attribute");
  }
  }
  {
  auto tblgen_tfdbg_run_id = odsAttrs.get("tfdbg_run_id");
  if (!tblgen_tfdbg_run_id) return emitError(loc, "'tf.DebugIdentityV2' op ""requires attribute 'tfdbg_run_id'");
    if (!((tblgen_tfdbg_run_id.isa<::mlir::StringAttr>()))) return emitError(loc, "'tf.DebugIdentityV2' op ""attribute 'tfdbg_run_id' failed to satisfy constraint: string attribute");
  }
  return ::mlir::success();
}

::llvm::StringRef DebugIdentityV2Op::getOperationName() {
  return "tf.DebugIdentityV2";
}

std::pair<unsigned, unsigned> DebugIdentityV2Op::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range DebugIdentityV2Op::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value DebugIdentityV2Op::input() {
  return *getODSOperands(0).begin();
}

::mlir::MutableOperandRange DebugIdentityV2Op::inputMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> DebugIdentityV2Op::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range DebugIdentityV2Op::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value DebugIdentityV2Op::output() {
  return *getODSResults(0).begin();
}

::mlir::StringAttr DebugIdentityV2Op::tfdbg_context_idAttr() {
  return this->getAttr("tfdbg_context_id").cast<::mlir::StringAttr>();
}

::llvm::StringRef DebugIdentityV2Op::tfdbg_context_id() {
  auto attr = tfdbg_context_idAttr();
  return attr.getValue();
}

::mlir::StringAttr DebugIdentityV2Op::op_nameAttr() {
  return this->getAttr("op_name").cast<::mlir::StringAttr>();
}

::llvm::StringRef DebugIdentityV2Op::op_name() {
  auto attr = op_nameAttr();
  return attr.getValue();
}

::mlir::IntegerAttr DebugIdentityV2Op::output_slotAttr() {
  return this->getAttr("output_slot").dyn_cast_or_null<::mlir::IntegerAttr>();
}

uint64_t DebugIdentityV2Op::output_slot() {
  auto attr = output_slotAttr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getIntegerAttr(::mlir::Builder(this->getContext()).getIntegerType(64), -1).getValue().getZExtValue();
  return attr.getValue().getZExtValue();
}

::mlir::IntegerAttr DebugIdentityV2Op::tensor_debug_modeAttr() {
  return this->getAttr("tensor_debug_mode").dyn_cast_or_null<::mlir::IntegerAttr>();
}

uint64_t DebugIdentityV2Op::tensor_debug_mode() {
  auto attr = tensor_debug_modeAttr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getIntegerAttr(::mlir::Builder(this->getContext()).getIntegerType(64), -1).getValue().getZExtValue();
  return attr.getValue().getZExtValue();
}

::mlir::ArrayAttr DebugIdentityV2Op::debug_urlsAttr() {
  return this->getAttr("debug_urls").dyn_cast_or_null<::mlir::ArrayAttr>();
}

::mlir::ArrayAttr DebugIdentityV2Op::debug_urls() {
  auto attr = debug_urlsAttr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getStrArrayAttr({});
  return attr;
}

::mlir::IntegerAttr DebugIdentityV2Op::circular_buffer_sizeAttr() {
  return this->getAttr("circular_buffer_size").dyn_cast_or_null<::mlir::IntegerAttr>();
}

uint64_t DebugIdentityV2Op::circular_buffer_size() {
  auto attr = circular_buffer_sizeAttr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getIntegerAttr(::mlir::Builder(this->getContext()).getIntegerType(64), 1000).getValue().getZExtValue();
  return attr.getValue().getZExtValue();
}

::mlir::StringAttr DebugIdentityV2Op::tfdbg_run_idAttr() {
  return this->getAttr("tfdbg_run_id").cast<::mlir::StringAttr>();
}

::llvm::StringRef DebugIdentityV2Op::tfdbg_run_id() {
  auto attr = tfdbg_run_idAttr();
  return attr.getValue();
}

Type DebugIdentityV2Op::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

bool DebugIdentityV2Op::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "T") return true;
 return false;
}

::mlir::DictionaryAttr DebugIdentityV2Op::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())}
    }, ctx);
}

void DebugIdentityV2Op::tfdbg_context_idAttr(::mlir::StringAttr attr) {
  this->getOperation()->setAttr("tfdbg_context_id", attr);
}

void DebugIdentityV2Op::op_nameAttr(::mlir::StringAttr attr) {
  this->getOperation()->setAttr("op_name", attr);
}

void DebugIdentityV2Op::output_slotAttr(::mlir::IntegerAttr attr) {
  this->getOperation()->setAttr("output_slot", attr);
}

void DebugIdentityV2Op::tensor_debug_modeAttr(::mlir::IntegerAttr attr) {
  this->getOperation()->setAttr("tensor_debug_mode", attr);
}

void DebugIdentityV2Op::debug_urlsAttr(::mlir::ArrayAttr attr) {
  this->getOperation()->setAttr("debug_urls", attr);
}

void DebugIdentityV2Op::circular_buffer_sizeAttr(::mlir::IntegerAttr attr) {
  this->getOperation()->setAttr("circular_buffer_size", attr);
}

void DebugIdentityV2Op::tfdbg_run_idAttr(::mlir::StringAttr attr) {
  this->getOperation()->setAttr("tfdbg_run_id", attr);
}

void DebugIdentityV2Op::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value input, ::mlir::StringAttr tfdbg_context_id, ::mlir::StringAttr op_name, ::mlir::IntegerAttr output_slot, ::mlir::IntegerAttr tensor_debug_mode, ::mlir::ArrayAttr debug_urls, ::mlir::IntegerAttr circular_buffer_size, ::mlir::StringAttr tfdbg_run_id) {
  odsState.addOperands(input);
  odsState.addAttribute("tfdbg_context_id", tfdbg_context_id);
  odsState.addAttribute("op_name", op_name);
  odsState.addAttribute("output_slot", output_slot);
  odsState.addAttribute("tensor_debug_mode", tensor_debug_mode);
  odsState.addAttribute("debug_urls", debug_urls);
  odsState.addAttribute("circular_buffer_size", circular_buffer_size);
  odsState.addAttribute("tfdbg_run_id", tfdbg_run_id);
  odsState.addTypes(output);
}

void DebugIdentityV2Op::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input, ::mlir::StringAttr tfdbg_context_id, ::mlir::StringAttr op_name, ::mlir::IntegerAttr output_slot, ::mlir::IntegerAttr tensor_debug_mode, ::mlir::ArrayAttr debug_urls, ::mlir::IntegerAttr circular_buffer_size, ::mlir::StringAttr tfdbg_run_id) {
  odsState.addOperands(input);
  odsState.addAttribute("tfdbg_context_id", tfdbg_context_id);
  odsState.addAttribute("op_name", op_name);
  odsState.addAttribute("output_slot", output_slot);
  odsState.addAttribute("tensor_debug_mode", tensor_debug_mode);
  odsState.addAttribute("debug_urls", debug_urls);
  odsState.addAttribute("circular_buffer_size", circular_buffer_size);
  odsState.addAttribute("tfdbg_run_id", tfdbg_run_id);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void DebugIdentityV2Op::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value input, ::llvm::StringRef tfdbg_context_id, ::llvm::StringRef op_name, uint64_t output_slot, uint64_t tensor_debug_mode, ::mlir::ArrayAttr debug_urls, uint64_t circular_buffer_size, ::llvm::StringRef tfdbg_run_id) {
  odsState.addOperands(input);
  odsState.addAttribute("tfdbg_context_id", odsBuilder.getStringAttr(tfdbg_context_id));
  odsState.addAttribute("op_name", odsBuilder.getStringAttr(op_name));
  odsState.addAttribute("output_slot", odsBuilder.getIntegerAttr(odsBuilder.getIntegerType(64), output_slot));
  odsState.addAttribute("tensor_debug_mode", odsBuilder.getIntegerAttr(odsBuilder.getIntegerType(64), tensor_debug_mode));
  odsState.addAttribute("debug_urls", debug_urls);
  odsState.addAttribute("circular_buffer_size", odsBuilder.getIntegerAttr(odsBuilder.getIntegerType(64), circular_buffer_size));
  odsState.addAttribute("tfdbg_run_id", odsBuilder.getStringAttr(tfdbg_run_id));
  odsState.addTypes(output);
}

void DebugIdentityV2Op::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input, ::llvm::StringRef tfdbg_context_id, ::llvm::StringRef op_name, uint64_t output_slot, uint64_t tensor_debug_mode, ::mlir::ArrayAttr debug_urls, uint64_t circular_buffer_size, ::llvm::StringRef tfdbg_run_id) {
  odsState.addOperands(input);
  odsState.addAttribute("tfdbg_context_id", odsBuilder.getStringAttr(tfdbg_context_id));
  odsState.addAttribute("op_name", odsBuilder.getStringAttr(op_name));
  odsState.addAttribute("output_slot", odsBuilder.getIntegerAttr(odsBuilder.getIntegerType(64), output_slot));
  odsState.addAttribute("tensor_debug_mode", odsBuilder.getIntegerAttr(odsBuilder.getIntegerType(64), tensor_debug_mode));
  odsState.addAttribute("debug_urls", debug_urls);
  odsState.addAttribute("circular_buffer_size", odsBuilder.getIntegerAttr(odsBuilder.getIntegerType(64), circular_buffer_size));
  odsState.addAttribute("tfdbg_run_id", odsBuilder.getStringAttr(tfdbg_run_id));
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void DebugIdentityV2Op::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult DebugIdentityV2Op::verify() {
  if (failed(DebugIdentityV2OpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>())))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::TensorFlowType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of tf.dtype values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>())))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::TensorFlowType>()))))) {
        return emitOpError("result #") << index << " must be tensor of tf.dtype values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::DecodeAndCropJpegOp definitions
//===----------------------------------------------------------------------===//

DecodeAndCropJpegOpAdaptor::DecodeAndCropJpegOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

DecodeAndCropJpegOpAdaptor::DecodeAndCropJpegOpAdaptor(DecodeAndCropJpegOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> DecodeAndCropJpegOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange DecodeAndCropJpegOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value DecodeAndCropJpegOpAdaptor::contents() {
  return *getODSOperands(0).begin();
}

::mlir::Value DecodeAndCropJpegOpAdaptor::crop_window() {
  return *getODSOperands(1).begin();
}

::mlir::IntegerAttr DecodeAndCropJpegOpAdaptor::channels() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::IntegerAttr attr = odsAttrs.get("channels").dyn_cast_or_null<::mlir::IntegerAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getIntegerAttr(::mlir::Builder(odsAttrs.getContext()).getIntegerType(64), 0);
  return attr;
}

::mlir::IntegerAttr DecodeAndCropJpegOpAdaptor::ratio() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::IntegerAttr attr = odsAttrs.get("ratio").dyn_cast_or_null<::mlir::IntegerAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getIntegerAttr(::mlir::Builder(odsAttrs.getContext()).getIntegerType(64), 1);
  return attr;
}

::mlir::BoolAttr DecodeAndCropJpegOpAdaptor::fancy_upscaling() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::BoolAttr attr = odsAttrs.get("fancy_upscaling").dyn_cast_or_null<::mlir::BoolAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getBoolAttr(true);
  return attr;
}

::mlir::BoolAttr DecodeAndCropJpegOpAdaptor::try_recover_truncated() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::BoolAttr attr = odsAttrs.get("try_recover_truncated").dyn_cast_or_null<::mlir::BoolAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getBoolAttr(false);
  return attr;
}

::mlir::FloatAttr DecodeAndCropJpegOpAdaptor::acceptable_fraction() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::FloatAttr attr = odsAttrs.get("acceptable_fraction").dyn_cast_or_null<::mlir::FloatAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getFloatAttr(::mlir::Builder(odsAttrs.getContext()).getF32Type(), 1.0f);
  return attr;
}

::mlir::StringAttr DecodeAndCropJpegOpAdaptor::dct_method() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::StringAttr attr = odsAttrs.get("dct_method").cast<::mlir::StringAttr>();
  return attr;
}

::mlir::LogicalResult DecodeAndCropJpegOpAdaptor::verify(::mlir::Location loc) {
  {
  auto tblgen_channels = odsAttrs.get("channels");
  if (tblgen_channels) {
    if (!(((tblgen_channels.isa<::mlir::IntegerAttr>())) && ((tblgen_channels.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(64))))) return emitError(loc, "'tf.DecodeAndCropJpeg' op ""attribute 'channels' failed to satisfy constraint: 64-bit signless integer attribute");
  }
  }
  {
  auto tblgen_ratio = odsAttrs.get("ratio");
  if (tblgen_ratio) {
    if (!(((tblgen_ratio.isa<::mlir::IntegerAttr>())) && ((tblgen_ratio.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(64))))) return emitError(loc, "'tf.DecodeAndCropJpeg' op ""attribute 'ratio' failed to satisfy constraint: 64-bit signless integer attribute");
  }
  }
  {
  auto tblgen_fancy_upscaling = odsAttrs.get("fancy_upscaling");
  if (tblgen_fancy_upscaling) {
    if (!((tblgen_fancy_upscaling.isa<::mlir::BoolAttr>()))) return emitError(loc, "'tf.DecodeAndCropJpeg' op ""attribute 'fancy_upscaling' failed to satisfy constraint: bool attribute");
  }
  }
  {
  auto tblgen_try_recover_truncated = odsAttrs.get("try_recover_truncated");
  if (tblgen_try_recover_truncated) {
    if (!((tblgen_try_recover_truncated.isa<::mlir::BoolAttr>()))) return emitError(loc, "'tf.DecodeAndCropJpeg' op ""attribute 'try_recover_truncated' failed to satisfy constraint: bool attribute");
  }
  }
  {
  auto tblgen_acceptable_fraction = odsAttrs.get("acceptable_fraction");
  if (tblgen_acceptable_fraction) {
    if (!(((tblgen_acceptable_fraction.isa<::mlir::FloatAttr>())) && ((tblgen_acceptable_fraction.cast<::mlir::FloatAttr>().getType().isF32())))) return emitError(loc, "'tf.DecodeAndCropJpeg' op ""attribute 'acceptable_fraction' failed to satisfy constraint: 32-bit float attribute");
  }
  }
  {
  auto tblgen_dct_method = odsAttrs.get("dct_method");
  if (!tblgen_dct_method) return emitError(loc, "'tf.DecodeAndCropJpeg' op ""requires attribute 'dct_method'");
    if (!((tblgen_dct_method.isa<::mlir::StringAttr>()))) return emitError(loc, "'tf.DecodeAndCropJpeg' op ""attribute 'dct_method' failed to satisfy constraint: string attribute");
  }
  return ::mlir::success();
}

::llvm::StringRef DecodeAndCropJpegOp::getOperationName() {
  return "tf.DecodeAndCropJpeg";
}

std::pair<unsigned, unsigned> DecodeAndCropJpegOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range DecodeAndCropJpegOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value DecodeAndCropJpegOp::contents() {
  return *getODSOperands(0).begin();
}

::mlir::Value DecodeAndCropJpegOp::crop_window() {
  return *getODSOperands(1).begin();
}

::mlir::MutableOperandRange DecodeAndCropJpegOp::contentsMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange DecodeAndCropJpegOp::crop_windowMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> DecodeAndCropJpegOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range DecodeAndCropJpegOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value DecodeAndCropJpegOp::image() {
  return *getODSResults(0).begin();
}

::mlir::IntegerAttr DecodeAndCropJpegOp::channelsAttr() {
  return this->getAttr("channels").dyn_cast_or_null<::mlir::IntegerAttr>();
}

uint64_t DecodeAndCropJpegOp::channels() {
  auto attr = channelsAttr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getIntegerAttr(::mlir::Builder(this->getContext()).getIntegerType(64), 0).getValue().getZExtValue();
  return attr.getValue().getZExtValue();
}

::mlir::IntegerAttr DecodeAndCropJpegOp::ratioAttr() {
  return this->getAttr("ratio").dyn_cast_or_null<::mlir::IntegerAttr>();
}

uint64_t DecodeAndCropJpegOp::ratio() {
  auto attr = ratioAttr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getIntegerAttr(::mlir::Builder(this->getContext()).getIntegerType(64), 1).getValue().getZExtValue();
  return attr.getValue().getZExtValue();
}

::mlir::BoolAttr DecodeAndCropJpegOp::fancy_upscalingAttr() {
  return this->getAttr("fancy_upscaling").dyn_cast_or_null<::mlir::BoolAttr>();
}

bool DecodeAndCropJpegOp::fancy_upscaling() {
  auto attr = fancy_upscalingAttr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getBoolAttr(true).getValue();
  return attr.getValue();
}

::mlir::BoolAttr DecodeAndCropJpegOp::try_recover_truncatedAttr() {
  return this->getAttr("try_recover_truncated").dyn_cast_or_null<::mlir::BoolAttr>();
}

bool DecodeAndCropJpegOp::try_recover_truncated() {
  auto attr = try_recover_truncatedAttr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getBoolAttr(false).getValue();
  return attr.getValue();
}

::mlir::FloatAttr DecodeAndCropJpegOp::acceptable_fractionAttr() {
  return this->getAttr("acceptable_fraction").dyn_cast_or_null<::mlir::FloatAttr>();
}

::llvm::APFloat DecodeAndCropJpegOp::acceptable_fraction() {
  auto attr = acceptable_fractionAttr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getFloatAttr(::mlir::Builder(this->getContext()).getF32Type(), 1.0f).getValue();
  return attr.getValue();
}

::mlir::StringAttr DecodeAndCropJpegOp::dct_methodAttr() {
  return this->getAttr("dct_method").cast<::mlir::StringAttr>();
}

::llvm::StringRef DecodeAndCropJpegOp::dct_method() {
  auto attr = dct_methodAttr();
  return attr.getValue();
}

void DecodeAndCropJpegOp::channelsAttr(::mlir::IntegerAttr attr) {
  this->getOperation()->setAttr("channels", attr);
}

void DecodeAndCropJpegOp::ratioAttr(::mlir::IntegerAttr attr) {
  this->getOperation()->setAttr("ratio", attr);
}

void DecodeAndCropJpegOp::fancy_upscalingAttr(::mlir::BoolAttr attr) {
  this->getOperation()->setAttr("fancy_upscaling", attr);
}

void DecodeAndCropJpegOp::try_recover_truncatedAttr(::mlir::BoolAttr attr) {
  this->getOperation()->setAttr("try_recover_truncated", attr);
}

void DecodeAndCropJpegOp::acceptable_fractionAttr(::mlir::FloatAttr attr) {
  this->getOperation()->setAttr("acceptable_fraction", attr);
}

void DecodeAndCropJpegOp::dct_methodAttr(::mlir::StringAttr attr) {
  this->getOperation()->setAttr("dct_method", attr);
}

void DecodeAndCropJpegOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type image, ::mlir::Value contents, ::mlir::Value crop_window, ::mlir::IntegerAttr channels, ::mlir::IntegerAttr ratio, ::mlir::BoolAttr fancy_upscaling, ::mlir::BoolAttr try_recover_truncated, ::mlir::FloatAttr acceptable_fraction, ::mlir::StringAttr dct_method) {
  odsState.addOperands(contents);
  odsState.addOperands(crop_window);
  odsState.addAttribute("channels", channels);
  odsState.addAttribute("ratio", ratio);
  odsState.addAttribute("fancy_upscaling", fancy_upscaling);
  odsState.addAttribute("try_recover_truncated", try_recover_truncated);
  odsState.addAttribute("acceptable_fraction", acceptable_fraction);
  odsState.addAttribute("dct_method", dct_method);
  odsState.addTypes(image);
}

void DecodeAndCropJpegOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value contents, ::mlir::Value crop_window, ::mlir::IntegerAttr channels, ::mlir::IntegerAttr ratio, ::mlir::BoolAttr fancy_upscaling, ::mlir::BoolAttr try_recover_truncated, ::mlir::FloatAttr acceptable_fraction, ::mlir::StringAttr dct_method) {
  odsState.addOperands(contents);
  odsState.addOperands(crop_window);
  odsState.addAttribute("channels", channels);
  odsState.addAttribute("ratio", ratio);
  odsState.addAttribute("fancy_upscaling", fancy_upscaling);
  odsState.addAttribute("try_recover_truncated", try_recover_truncated);
  odsState.addAttribute("acceptable_fraction", acceptable_fraction);
  odsState.addAttribute("dct_method", dct_method);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void DecodeAndCropJpegOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type image, ::mlir::Value contents, ::mlir::Value crop_window, uint64_t channels, uint64_t ratio, bool fancy_upscaling, bool try_recover_truncated, ::llvm::APFloat acceptable_fraction, ::llvm::StringRef dct_method) {
  odsState.addOperands(contents);
  odsState.addOperands(crop_window);
  odsState.addAttribute("channels", odsBuilder.getIntegerAttr(odsBuilder.getIntegerType(64), channels));
  odsState.addAttribute("ratio", odsBuilder.getIntegerAttr(odsBuilder.getIntegerType(64), ratio));
  odsState.addAttribute("fancy_upscaling", odsBuilder.getBoolAttr(fancy_upscaling));
  odsState.addAttribute("try_recover_truncated", odsBuilder.getBoolAttr(try_recover_truncated));
  odsState.addAttribute("acceptable_fraction", odsBuilder.getFloatAttr(odsBuilder.getF32Type(), acceptable_fraction));
  odsState.addAttribute("dct_method", odsBuilder.getStringAttr(dct_method));
  odsState.addTypes(image);
}

void DecodeAndCropJpegOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value contents, ::mlir::Value crop_window, uint64_t channels, uint64_t ratio, bool fancy_upscaling, bool try_recover_truncated, ::llvm::APFloat acceptable_fraction, ::llvm::StringRef dct_method) {
  odsState.addOperands(contents);
  odsState.addOperands(crop_window);
  odsState.addAttribute("channels", odsBuilder.getIntegerAttr(odsBuilder.getIntegerType(64), channels));
  odsState.addAttribute("ratio", odsBuilder.getIntegerAttr(odsBuilder.getIntegerType(64), ratio));
  odsState.addAttribute("fancy_upscaling", odsBuilder.getBoolAttr(fancy_upscaling));
  odsState.addAttribute("try_recover_truncated", odsBuilder.getBoolAttr(try_recover_truncated));
  odsState.addAttribute("acceptable_fraction", odsBuilder.getFloatAttr(odsBuilder.getF32Type(), acceptable_fraction));
  odsState.addAttribute("dct_method", odsBuilder.getStringAttr(dct_method));
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void DecodeAndCropJpegOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult DecodeAndCropJpegOp::verify() {
  if (failed(DecodeAndCropJpegOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::StringType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::StringRefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of string values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of 32-bit integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))))) {
        return emitOpError("result #") << index << " must be tensor of 8-bit unsigned integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void DecodeAndCropJpegOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::DecodeGifOp definitions
//===----------------------------------------------------------------------===//

DecodeGifOpAdaptor::DecodeGifOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

DecodeGifOpAdaptor::DecodeGifOpAdaptor(DecodeGifOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> DecodeGifOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange DecodeGifOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value DecodeGifOpAdaptor::contents() {
  return *getODSOperands(0).begin();
}

::mlir::LogicalResult DecodeGifOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

::llvm::StringRef DecodeGifOp::getOperationName() {
  return "tf.DecodeGif";
}

std::pair<unsigned, unsigned> DecodeGifOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range DecodeGifOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value DecodeGifOp::contents() {
  return *getODSOperands(0).begin();
}

::mlir::MutableOperandRange DecodeGifOp::contentsMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> DecodeGifOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range DecodeGifOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value DecodeGifOp::image() {
  return *getODSResults(0).begin();
}

void DecodeGifOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type image, ::mlir::Value contents) {
  odsState.addOperands(contents);
  odsState.addTypes(image);
}

void DecodeGifOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value contents) {
  odsState.addOperands(contents);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void DecodeGifOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult DecodeGifOp::verify() {
  if (failed(DecodeGifOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::StringType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::StringRefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of string values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))))) {
        return emitOpError("result #") << index << " must be tensor of 8-bit unsigned integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void DecodeGifOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::DecodeJpegOp definitions
//===----------------------------------------------------------------------===//

DecodeJpegOpAdaptor::DecodeJpegOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

DecodeJpegOpAdaptor::DecodeJpegOpAdaptor(DecodeJpegOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> DecodeJpegOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange DecodeJpegOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value DecodeJpegOpAdaptor::contents() {
  return *getODSOperands(0).begin();
}

::mlir::IntegerAttr DecodeJpegOpAdaptor::channels() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::IntegerAttr attr = odsAttrs.get("channels").dyn_cast_or_null<::mlir::IntegerAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getIntegerAttr(::mlir::Builder(odsAttrs.getContext()).getIntegerType(64), 0);
  return attr;
}

::mlir::IntegerAttr DecodeJpegOpAdaptor::ratio() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::IntegerAttr attr = odsAttrs.get("ratio").dyn_cast_or_null<::mlir::IntegerAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getIntegerAttr(::mlir::Builder(odsAttrs.getContext()).getIntegerType(64), 1);
  return attr;
}

::mlir::BoolAttr DecodeJpegOpAdaptor::fancy_upscaling() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::BoolAttr attr = odsAttrs.get("fancy_upscaling").dyn_cast_or_null<::mlir::BoolAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getBoolAttr(true);
  return attr;
}

::mlir::BoolAttr DecodeJpegOpAdaptor::try_recover_truncated() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::BoolAttr attr = odsAttrs.get("try_recover_truncated").dyn_cast_or_null<::mlir::BoolAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getBoolAttr(false);
  return attr;
}

::mlir::FloatAttr DecodeJpegOpAdaptor::acceptable_fraction() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::FloatAttr attr = odsAttrs.get("acceptable_fraction").dyn_cast_or_null<::mlir::FloatAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getFloatAttr(::mlir::Builder(odsAttrs.getContext()).getF32Type(), 1.0f);
  return attr;
}

::mlir::StringAttr DecodeJpegOpAdaptor::dct_method() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::StringAttr attr = odsAttrs.get("dct_method").cast<::mlir::StringAttr>();
  return attr;
}

::mlir::LogicalResult DecodeJpegOpAdaptor::verify(::mlir::Location loc) {
  {
  auto tblgen_channels = odsAttrs.get("channels");
  if (tblgen_channels) {
    if (!(((tblgen_channels.isa<::mlir::IntegerAttr>())) && ((tblgen_channels.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(64))))) return emitError(loc, "'tf.DecodeJpeg' op ""attribute 'channels' failed to satisfy constraint: 64-bit signless integer attribute");
  }
  }
  {
  auto tblgen_ratio = odsAttrs.get("ratio");
  if (tblgen_ratio) {
    if (!(((tblgen_ratio.isa<::mlir::IntegerAttr>())) && ((tblgen_ratio.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(64))))) return emitError(loc, "'tf.DecodeJpeg' op ""attribute 'ratio' failed to satisfy constraint: 64-bit signless integer attribute");
  }
  }
  {
  auto tblgen_fancy_upscaling = odsAttrs.get("fancy_upscaling");
  if (tblgen_fancy_upscaling) {
    if (!((tblgen_fancy_upscaling.isa<::mlir::BoolAttr>()))) return emitError(loc, "'tf.DecodeJpeg' op ""attribute 'fancy_upscaling' failed to satisfy constraint: bool attribute");
  }
  }
  {
  auto tblgen_try_recover_truncated = odsAttrs.get("try_recover_truncated");
  if (tblgen_try_recover_truncated) {
    if (!((tblgen_try_recover_truncated.isa<::mlir::BoolAttr>()))) return emitError(loc, "'tf.DecodeJpeg' op ""attribute 'try_recover_truncated' failed to satisfy constraint: bool attribute");
  }
  }
  {
  auto tblgen_acceptable_fraction = odsAttrs.get("acceptable_fraction");
  if (tblgen_acceptable_fraction) {
    if (!(((tblgen_acceptable_fraction.isa<::mlir::FloatAttr>())) && ((tblgen_acceptable_fraction.cast<::mlir::FloatAttr>().getType().isF32())))) return emitError(loc, "'tf.DecodeJpeg' op ""attribute 'acceptable_fraction' failed to satisfy constraint: 32-bit float attribute");
  }
  }
  {
  auto tblgen_dct_method = odsAttrs.get("dct_method");
  if (!tblgen_dct_method) return emitError(loc, "'tf.DecodeJpeg' op ""requires attribute 'dct_method'");
    if (!((tblgen_dct_method.isa<::mlir::StringAttr>()))) return emitError(loc, "'tf.DecodeJpeg' op ""attribute 'dct_method' failed to satisfy constraint: string attribute");
  }
  return ::mlir::success();
}

::llvm::StringRef DecodeJpegOp::getOperationName() {
  return "tf.DecodeJpeg";
}

std::pair<unsigned, unsigned> DecodeJpegOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range DecodeJpegOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value DecodeJpegOp::contents() {
  return *getODSOperands(0).begin();
}

::mlir::MutableOperandRange DecodeJpegOp::contentsMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> DecodeJpegOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range DecodeJpegOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value DecodeJpegOp::image() {
  return *getODSResults(0).begin();
}

::mlir::IntegerAttr DecodeJpegOp::channelsAttr() {
  return this->getAttr("channels").dyn_cast_or_null<::mlir::IntegerAttr>();
}

uint64_t DecodeJpegOp::channels() {
  auto attr = channelsAttr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getIntegerAttr(::mlir::Builder(this->getContext()).getIntegerType(64), 0).getValue().getZExtValue();
  return attr.getValue().getZExtValue();
}

::mlir::IntegerAttr DecodeJpegOp::ratioAttr() {
  return this->getAttr("ratio").dyn_cast_or_null<::mlir::IntegerAttr>();
}

uint64_t DecodeJpegOp::ratio() {
  auto attr = ratioAttr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getIntegerAttr(::mlir::Builder(this->getContext()).getIntegerType(64), 1).getValue().getZExtValue();
  return attr.getValue().getZExtValue();
}

::mlir::BoolAttr DecodeJpegOp::fancy_upscalingAttr() {
  return this->getAttr("fancy_upscaling").dyn_cast_or_null<::mlir::BoolAttr>();
}

bool DecodeJpegOp::fancy_upscaling() {
  auto attr = fancy_upscalingAttr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getBoolAttr(true).getValue();
  return attr.getValue();
}

::mlir::BoolAttr DecodeJpegOp::try_recover_truncatedAttr() {
  return this->getAttr("try_recover_truncated").dyn_cast_or_null<::mlir::BoolAttr>();
}

bool DecodeJpegOp::try_recover_truncated() {
  auto attr = try_recover_truncatedAttr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getBoolAttr(false).getValue();
  return attr.getValue();
}

::mlir::FloatAttr DecodeJpegOp::acceptable_fractionAttr() {
  return this->getAttr("acceptable_fraction").dyn_cast_or_null<::mlir::FloatAttr>();
}

::llvm::APFloat DecodeJpegOp::acceptable_fraction() {
  auto attr = acceptable_fractionAttr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getFloatAttr(::mlir::Builder(this->getContext()).getF32Type(), 1.0f).getValue();
  return attr.getValue();
}

::mlir::StringAttr DecodeJpegOp::dct_methodAttr() {
  return this->getAttr("dct_method").cast<::mlir::StringAttr>();
}

::llvm::StringRef DecodeJpegOp::dct_method() {
  auto attr = dct_methodAttr();
  return attr.getValue();
}

void DecodeJpegOp::channelsAttr(::mlir::IntegerAttr attr) {
  this->getOperation()->setAttr("channels", attr);
}

void DecodeJpegOp::ratioAttr(::mlir::IntegerAttr attr) {
  this->getOperation()->setAttr("ratio", attr);
}

void DecodeJpegOp::fancy_upscalingAttr(::mlir::BoolAttr attr) {
  this->getOperation()->setAttr("fancy_upscaling", attr);
}

void DecodeJpegOp::try_recover_truncatedAttr(::mlir::BoolAttr attr) {
  this->getOperation()->setAttr("try_recover_truncated", attr);
}

void DecodeJpegOp::acceptable_fractionAttr(::mlir::FloatAttr attr) {
  this->getOperation()->setAttr("acceptable_fraction", attr);
}

void DecodeJpegOp::dct_methodAttr(::mlir::StringAttr attr) {
  this->getOperation()->setAttr("dct_method", attr);
}

void DecodeJpegOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type image, ::mlir::Value contents, ::mlir::IntegerAttr channels, ::mlir::IntegerAttr ratio, ::mlir::BoolAttr fancy_upscaling, ::mlir::BoolAttr try_recover_truncated, ::mlir::FloatAttr acceptable_fraction, ::mlir::StringAttr dct_method) {
  odsState.addOperands(contents);
  odsState.addAttribute("channels", channels);
  odsState.addAttribute("ratio", ratio);
  odsState.addAttribute("fancy_upscaling", fancy_upscaling);
  odsState.addAttribute("try_recover_truncated", try_recover_truncated);
  odsState.addAttribute("acceptable_fraction", acceptable_fraction);
  odsState.addAttribute("dct_method", dct_method);
  odsState.addTypes(image);
}

void DecodeJpegOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value contents, ::mlir::IntegerAttr channels, ::mlir::IntegerAttr ratio, ::mlir::BoolAttr fancy_upscaling, ::mlir::BoolAttr try_recover_truncated, ::mlir::FloatAttr acceptable_fraction, ::mlir::StringAttr dct_method) {
  odsState.addOperands(contents);
  odsState.addAttribute("channels", channels);
  odsState.addAttribute("ratio", ratio);
  odsState.addAttribute("fancy_upscaling", fancy_upscaling);
  odsState.addAttribute("try_recover_truncated", try_recover_truncated);
  odsState.addAttribute("acceptable_fraction", acceptable_fraction);
  odsState.addAttribute("dct_method", dct_method);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void DecodeJpegOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type image, ::mlir::Value contents, uint64_t channels, uint64_t ratio, bool fancy_upscaling, bool try_recover_truncated, ::llvm::APFloat acceptable_fraction, ::llvm::StringRef dct_method) {
  odsState.addOperands(contents);
  odsState.addAttribute("channels", odsBuilder.getIntegerAttr(odsBuilder.getIntegerType(64), channels));
  odsState.addAttribute("ratio", odsBuilder.getIntegerAttr(odsBuilder.getIntegerType(64), ratio));
  odsState.addAttribute("fancy_upscaling", odsBuilder.getBoolAttr(fancy_upscaling));
  odsState.addAttribute("try_recover_truncated", odsBuilder.getBoolAttr(try_recover_truncated));
  odsState.addAttribute("acceptable_fraction", odsBuilder.getFloatAttr(odsBuilder.getF32Type(), acceptable_fraction));
  odsState.addAttribute("dct_method", odsBuilder.getStringAttr(dct_method));
  odsState.addTypes(image);
}

void DecodeJpegOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value contents, uint64_t channels, uint64_t ratio, bool fancy_upscaling, bool try_recover_truncated, ::llvm::APFloat acceptable_fraction, ::llvm::StringRef dct_method) {
  odsState.addOperands(contents);
  odsState.addAttribute("channels", odsBuilder.getIntegerAttr(odsBuilder.getIntegerType(64), channels));
  odsState.addAttribute("ratio", odsBuilder.getIntegerAttr(odsBuilder.getIntegerType(64), ratio));
  odsState.addAttribute("fancy_upscaling", odsBuilder.getBoolAttr(fancy_upscaling));
  odsState.addAttribute("try_recover_truncated", odsBuilder.getBoolAttr(try_recover_truncated));
  odsState.addAttribute("acceptable_fraction", odsBuilder.getFloatAttr(odsBuilder.getF32Type(), acceptable_fraction));
  odsState.addAttribute("dct_method", odsBuilder.getStringAttr(dct_method));
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void DecodeJpegOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult DecodeJpegOp::verify() {
  if (failed(DecodeJpegOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::StringType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::StringRefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of string values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))))) {
        return emitOpError("result #") << index << " must be tensor of 8-bit unsigned integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void DecodeJpegOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::DecodePngOp definitions
//===----------------------------------------------------------------------===//

DecodePngOpAdaptor::DecodePngOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

DecodePngOpAdaptor::DecodePngOpAdaptor(DecodePngOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> DecodePngOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange DecodePngOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value DecodePngOpAdaptor::contents() {
  return *getODSOperands(0).begin();
}

::mlir::IntegerAttr DecodePngOpAdaptor::channels() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::IntegerAttr attr = odsAttrs.get("channels").dyn_cast_or_null<::mlir::IntegerAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getIntegerAttr(::mlir::Builder(odsAttrs.getContext()).getIntegerType(64), 0);
  return attr;
}

::mlir::LogicalResult DecodePngOpAdaptor::verify(::mlir::Location loc) {
  {
  auto tblgen_channels = odsAttrs.get("channels");
  if (tblgen_channels) {
    if (!(((tblgen_channels.isa<::mlir::IntegerAttr>())) && ((tblgen_channels.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(64))))) return emitError(loc, "'tf.DecodePng' op ""attribute 'channels' failed to satisfy constraint: 64-bit signless integer attribute");
  }
  }
  return ::mlir::success();
}

::llvm::StringRef DecodePngOp::getOperationName() {
  return "tf.DecodePng";
}

std::pair<unsigned, unsigned> DecodePngOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range DecodePngOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value DecodePngOp::contents() {
  return *getODSOperands(0).begin();
}

::mlir::MutableOperandRange DecodePngOp::contentsMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> DecodePngOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range DecodePngOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value DecodePngOp::image() {
  return *getODSResults(0).begin();
}

::mlir::IntegerAttr DecodePngOp::channelsAttr() {
  return this->getAttr("channels").dyn_cast_or_null<::mlir::IntegerAttr>();
}

uint64_t DecodePngOp::channels() {
  auto attr = channelsAttr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getIntegerAttr(::mlir::Builder(this->getContext()).getIntegerType(64), 0).getValue().getZExtValue();
  return attr.getValue().getZExtValue();
}

Type DecodePngOp::dtype() {
  return mlir::getElementTypeOrSelf(*getODSResults(0).begin());
}

bool DecodePngOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "dtype") return true;
 return false;
}

::mlir::DictionaryAttr DecodePngOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("dtype", ctx),
::mlir::TypeAttr::get(dtype())}
    }, ctx);
}

void DecodePngOp::channelsAttr(::mlir::IntegerAttr attr) {
  this->getOperation()->setAttr("channels", attr);
}

void DecodePngOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type image, ::mlir::Value contents, ::mlir::IntegerAttr channels) {
  odsState.addOperands(contents);
  odsState.addAttribute("channels", channels);
  odsState.addTypes(image);
}

void DecodePngOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value contents, ::mlir::IntegerAttr channels) {
  odsState.addOperands(contents);
  odsState.addAttribute("channels", channels);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void DecodePngOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type image, ::mlir::Value contents, uint64_t channels) {
  odsState.addOperands(contents);
  odsState.addAttribute("channels", odsBuilder.getIntegerAttr(odsBuilder.getIntegerType(64), channels));
  odsState.addTypes(image);
}

void DecodePngOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value contents, uint64_t channels) {
  odsState.addOperands(contents);
  odsState.addAttribute("channels", odsBuilder.getIntegerAttr(odsBuilder.getIntegerType(64), channels));
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void DecodePngOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult DecodePngOp::verify() {
  if (failed(DecodePngOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::StringType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::StringRefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of string values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>())))))) {
        return emitOpError("result #") << index << " must be tensor of 16-bit unsigned integer or 8-bit unsigned integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void DecodePngOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::DeleteIteratorOp definitions
//===----------------------------------------------------------------------===//

DeleteIteratorOpAdaptor::DeleteIteratorOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

DeleteIteratorOpAdaptor::DeleteIteratorOpAdaptor(DeleteIteratorOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> DeleteIteratorOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange DeleteIteratorOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value DeleteIteratorOpAdaptor::handle() {
  return *getODSOperands(0).begin();
}

::mlir::Value DeleteIteratorOpAdaptor::deleter() {
  return *getODSOperands(1).begin();
}

::mlir::LogicalResult DeleteIteratorOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

::llvm::StringRef DeleteIteratorOp::getOperationName() {
  return "tf.DeleteIterator";
}

std::pair<unsigned, unsigned> DeleteIteratorOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range DeleteIteratorOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value DeleteIteratorOp::handle() {
  return *getODSOperands(0).begin();
}

::mlir::Value DeleteIteratorOp::deleter() {
  return *getODSOperands(1).begin();
}

::mlir::MutableOperandRange DeleteIteratorOp::handleMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange DeleteIteratorOp::deleterMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> DeleteIteratorOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range DeleteIteratorOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

void DeleteIteratorOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value handle, ::mlir::Value deleter) {
  odsState.addOperands(handle);
  odsState.addOperands(deleter);
}

void DeleteIteratorOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value handle, ::mlir::Value deleter) {
  odsState.addOperands(handle);
  odsState.addOperands(deleter);
  assert(resultTypes.size() == 0u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void DeleteIteratorOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 0u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult DeleteIteratorOp::verify() {
  if (failed(DeleteIteratorOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::ResourceType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::ResourceRefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of resource values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::VariantType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::VariantRefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of variant values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
  }
  return ::mlir::success();
}

void DeleteIteratorOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
  for (::mlir::Value value : getODSOperands(0))
    effects.emplace_back(MemoryEffects::Free::get(), value, ::mlir::TF::ResourceEffects::DatasetIterator::get());
}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::DeleteMemoryCacheOp definitions
//===----------------------------------------------------------------------===//

DeleteMemoryCacheOpAdaptor::DeleteMemoryCacheOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

DeleteMemoryCacheOpAdaptor::DeleteMemoryCacheOpAdaptor(DeleteMemoryCacheOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> DeleteMemoryCacheOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange DeleteMemoryCacheOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value DeleteMemoryCacheOpAdaptor::handle() {
  return *getODSOperands(0).begin();
}

::mlir::Value DeleteMemoryCacheOpAdaptor::deleter() {
  return *getODSOperands(1).begin();
}

::mlir::LogicalResult DeleteMemoryCacheOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

::llvm::StringRef DeleteMemoryCacheOp::getOperationName() {
  return "tf.DeleteMemoryCache";
}

std::pair<unsigned, unsigned> DeleteMemoryCacheOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range DeleteMemoryCacheOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value DeleteMemoryCacheOp::handle() {
  return *getODSOperands(0).begin();
}

::mlir::Value DeleteMemoryCacheOp::deleter() {
  return *getODSOperands(1).begin();
}

::mlir::MutableOperandRange DeleteMemoryCacheOp::handleMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange DeleteMemoryCacheOp::deleterMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> DeleteMemoryCacheOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range DeleteMemoryCacheOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

void DeleteMemoryCacheOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value handle, ::mlir::Value deleter) {
  odsState.addOperands(handle);
  odsState.addOperands(deleter);
}

void DeleteMemoryCacheOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value handle, ::mlir::Value deleter) {
  odsState.addOperands(handle);
  odsState.addOperands(deleter);
  assert(resultTypes.size() == 0u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void DeleteMemoryCacheOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 0u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult DeleteMemoryCacheOp::verify() {
  if (failed(DeleteMemoryCacheOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::ResourceType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::ResourceRefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of resource values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::VariantType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::VariantRefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of variant values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
  }
  return ::mlir::success();
}

void DeleteMemoryCacheOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
  for (::mlir::Value value : getODSOperands(0))
    effects.emplace_back(MemoryEffects::Free::get(), value, ::mlir::TF::ResourceEffects::DatasetMemoryCache::get());
}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::DeleteMultiDeviceIteratorOp definitions
//===----------------------------------------------------------------------===//

DeleteMultiDeviceIteratorOpAdaptor::DeleteMultiDeviceIteratorOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

DeleteMultiDeviceIteratorOpAdaptor::DeleteMultiDeviceIteratorOpAdaptor(DeleteMultiDeviceIteratorOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> DeleteMultiDeviceIteratorOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  bool isVariadic[] = {false, true, false};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (odsOperands.size() - 2) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::mlir::ValueRange DeleteMultiDeviceIteratorOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value DeleteMultiDeviceIteratorOpAdaptor::multi_device_iterator() {
  return *getODSOperands(0).begin();
}

::mlir::ValueRange DeleteMultiDeviceIteratorOpAdaptor::iterators() {
  return getODSOperands(1);
}

::mlir::Value DeleteMultiDeviceIteratorOpAdaptor::deleter() {
  return *getODSOperands(2).begin();
}

::mlir::LogicalResult DeleteMultiDeviceIteratorOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

::llvm::StringRef DeleteMultiDeviceIteratorOp::getOperationName() {
  return "tf.DeleteMultiDeviceIterator";
}

std::pair<unsigned, unsigned> DeleteMultiDeviceIteratorOp::getODSOperandIndexAndLength(unsigned index) {
  bool isVariadic[] = {false, true, false};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (getOperation()->getNumOperands() - 2) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::mlir::Operation::operand_range DeleteMultiDeviceIteratorOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value DeleteMultiDeviceIteratorOp::multi_device_iterator() {
  return *getODSOperands(0).begin();
}

::mlir::Operation::operand_range DeleteMultiDeviceIteratorOp::iterators() {
  return getODSOperands(1);
}

::mlir::Value DeleteMultiDeviceIteratorOp::deleter() {
  return *getODSOperands(2).begin();
}

::mlir::MutableOperandRange DeleteMultiDeviceIteratorOp::multi_device_iteratorMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange DeleteMultiDeviceIteratorOp::iteratorsMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange DeleteMultiDeviceIteratorOp::deleterMutable() {
  auto range = getODSOperandIndexAndLength(2);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> DeleteMultiDeviceIteratorOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range DeleteMultiDeviceIteratorOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

size_t DeleteMultiDeviceIteratorOp::N() {
  auto range = getODSOperands(1);
return std::distance(range.begin(), range.end());
}

bool DeleteMultiDeviceIteratorOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "N") return true;
 return false;
}

::mlir::DictionaryAttr DeleteMultiDeviceIteratorOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("N", ctx),
odsBuilder.getI64IntegerAttr(N())}
    }, ctx);
}

void DeleteMultiDeviceIteratorOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value multi_device_iterator, ::mlir::ValueRange iterators, ::mlir::Value deleter) {
  odsState.addOperands(multi_device_iterator);
  odsState.addOperands(iterators);
  odsState.addOperands(deleter);
}

void DeleteMultiDeviceIteratorOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value multi_device_iterator, ::mlir::ValueRange iterators, ::mlir::Value deleter) {
  odsState.addOperands(multi_device_iterator);
  odsState.addOperands(iterators);
  odsState.addOperands(deleter);
  assert(resultTypes.size() == 0u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void DeleteMultiDeviceIteratorOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() >= 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 0u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult DeleteMultiDeviceIteratorOp::verify() {
  if (failed(DeleteMultiDeviceIteratorOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::ResourceType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::ResourceRefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of resource values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::ResourceType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::ResourceRefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of resource values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup2 = getODSOperands(2);
    for (::mlir::Value v : valueGroup2) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::VariantType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::VariantRefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of variant values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
  }
  return ::mlir::success();
}

void DeleteMultiDeviceIteratorOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
  for (::mlir::Value value : getODSOperands(0))
    effects.emplace_back(MemoryEffects::Free::get(), value, ::mlir::TF::ResourceEffects::DatasetIterator::get());
  for (::mlir::Value value : getODSOperands(1))
    effects.emplace_back(MemoryEffects::Read::get(), value, ::mlir::TF::ResourceEffects::DatasetIterator::get());
}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::DeleteRandomSeedGeneratorOp definitions
//===----------------------------------------------------------------------===//

DeleteRandomSeedGeneratorOpAdaptor::DeleteRandomSeedGeneratorOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

DeleteRandomSeedGeneratorOpAdaptor::DeleteRandomSeedGeneratorOpAdaptor(DeleteRandomSeedGeneratorOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> DeleteRandomSeedGeneratorOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange DeleteRandomSeedGeneratorOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value DeleteRandomSeedGeneratorOpAdaptor::handle() {
  return *getODSOperands(0).begin();
}

::mlir::Value DeleteRandomSeedGeneratorOpAdaptor::deleter() {
  return *getODSOperands(1).begin();
}

::mlir::LogicalResult DeleteRandomSeedGeneratorOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

::llvm::StringRef DeleteRandomSeedGeneratorOp::getOperationName() {
  return "tf.DeleteRandomSeedGenerator";
}

std::pair<unsigned, unsigned> DeleteRandomSeedGeneratorOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range DeleteRandomSeedGeneratorOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value DeleteRandomSeedGeneratorOp::handle() {
  return *getODSOperands(0).begin();
}

::mlir::Value DeleteRandomSeedGeneratorOp::deleter() {
  return *getODSOperands(1).begin();
}

::mlir::MutableOperandRange DeleteRandomSeedGeneratorOp::handleMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange DeleteRandomSeedGeneratorOp::deleterMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> DeleteRandomSeedGeneratorOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range DeleteRandomSeedGeneratorOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

void DeleteRandomSeedGeneratorOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value handle, ::mlir::Value deleter) {
  odsState.addOperands(handle);
  odsState.addOperands(deleter);
}

void DeleteRandomSeedGeneratorOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value handle, ::mlir::Value deleter) {
  odsState.addOperands(handle);
  odsState.addOperands(deleter);
  assert(resultTypes.size() == 0u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void DeleteRandomSeedGeneratorOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 0u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult DeleteRandomSeedGeneratorOp::verify() {
  if (failed(DeleteRandomSeedGeneratorOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::ResourceType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::ResourceRefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of resource values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::VariantType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::VariantRefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of variant values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
  }
  return ::mlir::success();
}

void DeleteRandomSeedGeneratorOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
  for (::mlir::Value value : getODSOperands(0))
    effects.emplace_back(MemoryEffects::Free::get(), value, ::mlir::TF::ResourceEffects::DatasetSeedGenerator::get());
}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::DeleteSeedGeneratorOp definitions
//===----------------------------------------------------------------------===//

DeleteSeedGeneratorOpAdaptor::DeleteSeedGeneratorOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

DeleteSeedGeneratorOpAdaptor::DeleteSeedGeneratorOpAdaptor(DeleteSeedGeneratorOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> DeleteSeedGeneratorOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange DeleteSeedGeneratorOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value DeleteSeedGeneratorOpAdaptor::handle() {
  return *getODSOperands(0).begin();
}

::mlir::Value DeleteSeedGeneratorOpAdaptor::deleter() {
  return *getODSOperands(1).begin();
}

::mlir::LogicalResult DeleteSeedGeneratorOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

::llvm::StringRef DeleteSeedGeneratorOp::getOperationName() {
  return "tf.DeleteSeedGenerator";
}

std::pair<unsigned, unsigned> DeleteSeedGeneratorOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range DeleteSeedGeneratorOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value DeleteSeedGeneratorOp::handle() {
  return *getODSOperands(0).begin();
}

::mlir::Value DeleteSeedGeneratorOp::deleter() {
  return *getODSOperands(1).begin();
}

::mlir::MutableOperandRange DeleteSeedGeneratorOp::handleMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange DeleteSeedGeneratorOp::deleterMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> DeleteSeedGeneratorOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range DeleteSeedGeneratorOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

void DeleteSeedGeneratorOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value handle, ::mlir::Value deleter) {
  odsState.addOperands(handle);
  odsState.addOperands(deleter);
}

void DeleteSeedGeneratorOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value handle, ::mlir::Value deleter) {
  odsState.addOperands(handle);
  odsState.addOperands(deleter);
  assert(resultTypes.size() == 0u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void DeleteSeedGeneratorOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 0u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult DeleteSeedGeneratorOp::verify() {
  if (failed(DeleteSeedGeneratorOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::ResourceType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::ResourceRefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of resource values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::VariantType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::VariantRefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of variant values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
  }
  return ::mlir::success();
}

void DeleteSeedGeneratorOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
  for (::mlir::Value value : getODSOperands(0))
    effects.emplace_back(MemoryEffects::Free::get(), value, ::mlir::TF::ResourceEffects::DatasetSeedGenerator::get());
}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::DepthToSpaceOp definitions
//===----------------------------------------------------------------------===//

DepthToSpaceOpAdaptor::DepthToSpaceOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

DepthToSpaceOpAdaptor::DepthToSpaceOpAdaptor(DepthToSpaceOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> DepthToSpaceOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange DepthToSpaceOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value DepthToSpaceOpAdaptor::input() {
  return *getODSOperands(0).begin();
}

::mlir::IntegerAttr DepthToSpaceOpAdaptor::block_size() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::IntegerAttr attr = odsAttrs.get("block_size").cast<::mlir::IntegerAttr>();
  return attr;
}

::mlir::StringAttr DepthToSpaceOpAdaptor::data_format() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::StringAttr attr = odsAttrs.get("data_format").dyn_cast_or_null<::mlir::StringAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getStringAttr("NHWC");
  return attr;
}

::mlir::LogicalResult DepthToSpaceOpAdaptor::verify(::mlir::Location loc) {
  {
  auto tblgen_block_size = odsAttrs.get("block_size");
  if (!tblgen_block_size) return emitError(loc, "'tf.DepthToSpace' op ""requires attribute 'block_size'");
    if (!((((tblgen_block_size.isa<::mlir::IntegerAttr>())) && ((tblgen_block_size.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(64)))) && ((tblgen_block_size.cast<::mlir::IntegerAttr>().getInt() >= 2)))) return emitError(loc, "'tf.DepthToSpace' op ""attribute 'block_size' failed to satisfy constraint: 64-bit signless integer attribute whose minimum value is 2");
  }
  {
  auto tblgen_data_format = odsAttrs.get("data_format");
  if (tblgen_data_format) {
    if (!((tblgen_data_format.cast<StringAttr>().getValue() == "NHWC" || tblgen_data_format.cast<StringAttr>().getValue() == "NCHW" || tblgen_data_format.cast<StringAttr>().getValue() == "NCHW_VECT_C"))) return emitError(loc, "'tf.DepthToSpace' op ""attribute 'data_format' failed to satisfy constraint: string attribute whose value is NHWC, or NCHW, or NCHW_VECT_C");
  }
  }
  return ::mlir::success();
}

::llvm::StringRef DepthToSpaceOp::getOperationName() {
  return "tf.DepthToSpace";
}

std::pair<unsigned, unsigned> DepthToSpaceOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range DepthToSpaceOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value DepthToSpaceOp::input() {
  return *getODSOperands(0).begin();
}

::mlir::MutableOperandRange DepthToSpaceOp::inputMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> DepthToSpaceOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range DepthToSpaceOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value DepthToSpaceOp::output() {
  return *getODSResults(0).begin();
}

::mlir::IntegerAttr DepthToSpaceOp::block_sizeAttr() {
  return this->getAttr("block_size").cast<::mlir::IntegerAttr>();
}

uint64_t DepthToSpaceOp::block_size() {
  auto attr = block_sizeAttr();
  return attr.getValue().getZExtValue();
}

::mlir::StringAttr DepthToSpaceOp::data_formatAttr() {
  return this->getAttr("data_format").dyn_cast_or_null<::mlir::StringAttr>();
}

::llvm::StringRef DepthToSpaceOp::data_format() {
  auto attr = data_formatAttr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getStringAttr("NHWC").getValue();
  return attr.getValue();
}

Type DepthToSpaceOp::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

bool DepthToSpaceOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "T") return true;
 return false;
}

::mlir::DictionaryAttr DepthToSpaceOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())}
    }, ctx);
}

void DepthToSpaceOp::block_sizeAttr(::mlir::IntegerAttr attr) {
  this->getOperation()->setAttr("block_size", attr);
}

void DepthToSpaceOp::data_formatAttr(::mlir::StringAttr attr) {
  this->getOperation()->setAttr("data_format", attr);
}

void DepthToSpaceOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value input, ::mlir::IntegerAttr block_size, ::mlir::StringAttr data_format) {
  odsState.addOperands(input);
  odsState.addAttribute("block_size", block_size);
  odsState.addAttribute("data_format", data_format);
  odsState.addTypes(output);
}

void DepthToSpaceOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input, ::mlir::IntegerAttr block_size, ::mlir::StringAttr data_format) {
  odsState.addOperands(input);
  odsState.addAttribute("block_size", block_size);
  odsState.addAttribute("data_format", data_format);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void DepthToSpaceOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value input, uint64_t block_size, ::llvm::StringRef data_format) {
  odsState.addOperands(input);
  odsState.addAttribute("block_size", odsBuilder.getIntegerAttr(odsBuilder.getIntegerType(64), block_size));
  odsState.addAttribute("data_format", odsBuilder.getStringAttr(data_format));
  odsState.addTypes(output);
}

void DepthToSpaceOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input, uint64_t block_size, ::llvm::StringRef data_format) {
  odsState.addOperands(input);
  odsState.addAttribute("block_size", odsBuilder.getIntegerAttr(odsBuilder.getIntegerType(64), block_size));
  odsState.addAttribute("data_format", odsBuilder.getStringAttr(data_format));
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void DepthToSpaceOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult DepthToSpaceOp::verify() {
  if (failed(DepthToSpaceOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>())))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::TensorFlowType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of tf.dtype values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>())))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::TensorFlowType>()))))) {
        return emitOpError("result #") << index << " must be tensor of tf.dtype values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void DepthToSpaceOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::DepthwiseConv2dNativeBackpropFilterOp definitions
//===----------------------------------------------------------------------===//

DepthwiseConv2dNativeBackpropFilterOpAdaptor::DepthwiseConv2dNativeBackpropFilterOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

DepthwiseConv2dNativeBackpropFilterOpAdaptor::DepthwiseConv2dNativeBackpropFilterOpAdaptor(DepthwiseConv2dNativeBackpropFilterOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> DepthwiseConv2dNativeBackpropFilterOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange DepthwiseConv2dNativeBackpropFilterOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value DepthwiseConv2dNativeBackpropFilterOpAdaptor::input() {
  return *getODSOperands(0).begin();
}

::mlir::Value DepthwiseConv2dNativeBackpropFilterOpAdaptor::filter_sizes() {
  return *getODSOperands(1).begin();
}

::mlir::Value DepthwiseConv2dNativeBackpropFilterOpAdaptor::out_backprop() {
  return *getODSOperands(2).begin();
}

::mlir::ArrayAttr DepthwiseConv2dNativeBackpropFilterOpAdaptor::strides() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::ArrayAttr attr = odsAttrs.get("strides").cast<::mlir::ArrayAttr>();
  return attr;
}

::mlir::StringAttr DepthwiseConv2dNativeBackpropFilterOpAdaptor::padding() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::StringAttr attr = odsAttrs.get("padding").cast<::mlir::StringAttr>();
  return attr;
}

::mlir::ArrayAttr DepthwiseConv2dNativeBackpropFilterOpAdaptor::explicit_paddings() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::ArrayAttr attr = odsAttrs.get("explicit_paddings").dyn_cast_or_null<::mlir::ArrayAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getI64ArrayAttr({});
  return attr;
}

::mlir::StringAttr DepthwiseConv2dNativeBackpropFilterOpAdaptor::data_format() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::StringAttr attr = odsAttrs.get("data_format").dyn_cast_or_null<::mlir::StringAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getStringAttr("NHWC");
  return attr;
}

::mlir::ArrayAttr DepthwiseConv2dNativeBackpropFilterOpAdaptor::dilations() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::ArrayAttr attr = odsAttrs.get("dilations").dyn_cast_or_null<::mlir::ArrayAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getI64ArrayAttr({1, 1, 1, 1});
  return attr;
}

::mlir::LogicalResult DepthwiseConv2dNativeBackpropFilterOpAdaptor::verify(::mlir::Location loc) {
  {
  auto tblgen_strides = odsAttrs.get("strides");
  if (!tblgen_strides) return emitError(loc, "'tf.DepthwiseConv2dNativeBackpropFilter' op ""requires attribute 'strides'");
    if (!(((tblgen_strides.isa<::mlir::ArrayAttr>())) && (::llvm::all_of(tblgen_strides.cast<::mlir::ArrayAttr>(), [](::mlir::Attribute attr) { return ((attr.isa<::mlir::IntegerAttr>())) && ((attr.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(64))); })))) return emitError(loc, "'tf.DepthwiseConv2dNativeBackpropFilter' op ""attribute 'strides' failed to satisfy constraint: 64-bit integer array attribute");
  }
  {
  auto tblgen_padding = odsAttrs.get("padding");
  if (!tblgen_padding) return emitError(loc, "'tf.DepthwiseConv2dNativeBackpropFilter' op ""requires attribute 'padding'");
    if (!((tblgen_padding.cast<StringAttr>().getValue() == "SAME" || tblgen_padding.cast<StringAttr>().getValue() == "VALID" || tblgen_padding.cast<StringAttr>().getValue() == "EXPLICIT"))) return emitError(loc, "'tf.DepthwiseConv2dNativeBackpropFilter' op ""attribute 'padding' failed to satisfy constraint: string attribute whose value is SAME, or VALID, or EXPLICIT");
  }
  {
  auto tblgen_explicit_paddings = odsAttrs.get("explicit_paddings");
  if (tblgen_explicit_paddings) {
    if (!(((tblgen_explicit_paddings.isa<::mlir::ArrayAttr>())) && (::llvm::all_of(tblgen_explicit_paddings.cast<::mlir::ArrayAttr>(), [](::mlir::Attribute attr) { return ((attr.isa<::mlir::IntegerAttr>())) && ((attr.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(64))); })))) return emitError(loc, "'tf.DepthwiseConv2dNativeBackpropFilter' op ""attribute 'explicit_paddings' failed to satisfy constraint: 64-bit integer array attribute");
  }
  }
  {
  auto tblgen_data_format = odsAttrs.get("data_format");
  if (tblgen_data_format) {
    if (!((tblgen_data_format.cast<StringAttr>().getValue() == "NHWC" || tblgen_data_format.cast<StringAttr>().getValue() == "NCHW"))) return emitError(loc, "'tf.DepthwiseConv2dNativeBackpropFilter' op ""attribute 'data_format' failed to satisfy constraint: 'NHWC' or 'NCHW' convnet data format");
  }
  }
  {
  auto tblgen_dilations = odsAttrs.get("dilations");
  if (tblgen_dilations) {
    if (!(((tblgen_dilations.isa<::mlir::ArrayAttr>())) && (::llvm::all_of(tblgen_dilations.cast<::mlir::ArrayAttr>(), [](::mlir::Attribute attr) { return ((attr.isa<::mlir::IntegerAttr>())) && ((attr.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(64))); })))) return emitError(loc, "'tf.DepthwiseConv2dNativeBackpropFilter' op ""attribute 'dilations' failed to satisfy constraint: 64-bit integer array attribute");
  }
  }
  return ::mlir::success();
}

::llvm::StringRef DepthwiseConv2dNativeBackpropFilterOp::getOperationName() {
  return "tf.DepthwiseConv2dNativeBackpropFilter";
}

std::pair<unsigned, unsigned> DepthwiseConv2dNativeBackpropFilterOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range DepthwiseConv2dNativeBackpropFilterOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value DepthwiseConv2dNativeBackpropFilterOp::input() {
  return *getODSOperands(0).begin();
}

::mlir::Value DepthwiseConv2dNativeBackpropFilterOp::filter_sizes() {
  return *getODSOperands(1).begin();
}

::mlir::Value DepthwiseConv2dNativeBackpropFilterOp::out_backprop() {
  return *getODSOperands(2).begin();
}

::mlir::MutableOperandRange DepthwiseConv2dNativeBackpropFilterOp::inputMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange DepthwiseConv2dNativeBackpropFilterOp::filter_sizesMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange DepthwiseConv2dNativeBackpropFilterOp::out_backpropMutable() {
  auto range = getODSOperandIndexAndLength(2);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> DepthwiseConv2dNativeBackpropFilterOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range DepthwiseConv2dNativeBackpropFilterOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value DepthwiseConv2dNativeBackpropFilterOp::output() {
  return *getODSResults(0).begin();
}

::mlir::ArrayAttr DepthwiseConv2dNativeBackpropFilterOp::stridesAttr() {
  return this->getAttr("strides").cast<::mlir::ArrayAttr>();
}

::mlir::ArrayAttr DepthwiseConv2dNativeBackpropFilterOp::strides() {
  auto attr = stridesAttr();
  return attr;
}

::mlir::StringAttr DepthwiseConv2dNativeBackpropFilterOp::paddingAttr() {
  return this->getAttr("padding").cast<::mlir::StringAttr>();
}

::llvm::StringRef DepthwiseConv2dNativeBackpropFilterOp::padding() {
  auto attr = paddingAttr();
  return attr.getValue();
}

::mlir::ArrayAttr DepthwiseConv2dNativeBackpropFilterOp::explicit_paddingsAttr() {
  return this->getAttr("explicit_paddings").dyn_cast_or_null<::mlir::ArrayAttr>();
}

::mlir::ArrayAttr DepthwiseConv2dNativeBackpropFilterOp::explicit_paddings() {
  auto attr = explicit_paddingsAttr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getI64ArrayAttr({});
  return attr;
}

::mlir::StringAttr DepthwiseConv2dNativeBackpropFilterOp::data_formatAttr() {
  return this->getAttr("data_format").dyn_cast_or_null<::mlir::StringAttr>();
}

::llvm::StringRef DepthwiseConv2dNativeBackpropFilterOp::data_format() {
  auto attr = data_formatAttr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getStringAttr("NHWC").getValue();
  return attr.getValue();
}

::mlir::ArrayAttr DepthwiseConv2dNativeBackpropFilterOp::dilationsAttr() {
  return this->getAttr("dilations").dyn_cast_or_null<::mlir::ArrayAttr>();
}

::mlir::ArrayAttr DepthwiseConv2dNativeBackpropFilterOp::dilations() {
  auto attr = dilationsAttr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getI64ArrayAttr({1, 1, 1, 1});
  return attr;
}

Type DepthwiseConv2dNativeBackpropFilterOp::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

bool DepthwiseConv2dNativeBackpropFilterOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "T") return true;
 return false;
}

::mlir::DictionaryAttr DepthwiseConv2dNativeBackpropFilterOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())}
    }, ctx);
}

void DepthwiseConv2dNativeBackpropFilterOp::stridesAttr(::mlir::ArrayAttr attr) {
  this->getOperation()->setAttr("strides", attr);
}

void DepthwiseConv2dNativeBackpropFilterOp::paddingAttr(::mlir::StringAttr attr) {
  this->getOperation()->setAttr("padding", attr);
}

void DepthwiseConv2dNativeBackpropFilterOp::explicit_paddingsAttr(::mlir::ArrayAttr attr) {
  this->getOperation()->setAttr("explicit_paddings", attr);
}

void DepthwiseConv2dNativeBackpropFilterOp::data_formatAttr(::mlir::StringAttr attr) {
  this->getOperation()->setAttr("data_format", attr);
}

void DepthwiseConv2dNativeBackpropFilterOp::dilationsAttr(::mlir::ArrayAttr attr) {
  this->getOperation()->setAttr("dilations", attr);
}

void DepthwiseConv2dNativeBackpropFilterOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value input, ::mlir::Value filter_sizes, ::mlir::Value out_backprop, ::mlir::ArrayAttr strides, ::mlir::StringAttr padding, ::mlir::ArrayAttr explicit_paddings, ::mlir::StringAttr data_format, ::mlir::ArrayAttr dilations) {
  odsState.addOperands(input);
  odsState.addOperands(filter_sizes);
  odsState.addOperands(out_backprop);
  odsState.addAttribute("strides", strides);
  odsState.addAttribute("padding", padding);
  odsState.addAttribute("explicit_paddings", explicit_paddings);
  odsState.addAttribute("data_format", data_format);
  odsState.addAttribute("dilations", dilations);
  odsState.addTypes(output);
}

void DepthwiseConv2dNativeBackpropFilterOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input, ::mlir::Value filter_sizes, ::mlir::Value out_backprop, ::mlir::ArrayAttr strides, ::mlir::StringAttr padding, ::mlir::ArrayAttr explicit_paddings, ::mlir::StringAttr data_format, ::mlir::ArrayAttr dilations) {
  odsState.addOperands(input);
  odsState.addOperands(filter_sizes);
  odsState.addOperands(out_backprop);
  odsState.addAttribute("strides", strides);
  odsState.addAttribute("padding", padding);
  odsState.addAttribute("explicit_paddings", explicit_paddings);
  odsState.addAttribute("data_format", data_format);
  odsState.addAttribute("dilations", dilations);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void DepthwiseConv2dNativeBackpropFilterOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value input, ::mlir::Value filter_sizes, ::mlir::Value out_backprop, ::mlir::ArrayAttr strides, ::llvm::StringRef padding, ::mlir::ArrayAttr explicit_paddings, ::llvm::StringRef data_format, ::mlir::ArrayAttr dilations) {
  odsState.addOperands(input);
  odsState.addOperands(filter_sizes);
  odsState.addOperands(out_backprop);
  odsState.addAttribute("strides", strides);
  odsState.addAttribute("padding", odsBuilder.getStringAttr(padding));
  odsState.addAttribute("explicit_paddings", explicit_paddings);
  odsState.addAttribute("data_format", odsBuilder.getStringAttr(data_format));
  odsState.addAttribute("dilations", dilations);
  odsState.addTypes(output);
}

void DepthwiseConv2dNativeBackpropFilterOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input, ::mlir::Value filter_sizes, ::mlir::Value out_backprop, ::mlir::ArrayAttr strides, ::llvm::StringRef padding, ::mlir::ArrayAttr explicit_paddings, ::llvm::StringRef data_format, ::mlir::ArrayAttr dilations) {
  odsState.addOperands(input);
  odsState.addOperands(filter_sizes);
  odsState.addOperands(out_backprop);
  odsState.addAttribute("strides", strides);
  odsState.addAttribute("padding", odsBuilder.getStringAttr(padding));
  odsState.addAttribute("explicit_paddings", explicit_paddings);
  odsState.addAttribute("data_format", odsBuilder.getStringAttr(data_format));
  odsState.addAttribute("dilations", dilations);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void DepthwiseConv2dNativeBackpropFilterOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 3u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult DepthwiseConv2dNativeBackpropFilterOp::verify() {
  if (failed(DepthwiseConv2dNativeBackpropFilterOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of floating-point values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of 32-bit integer values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup2 = getODSOperands(2);
    for (::mlir::Value v : valueGroup2) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of floating-point values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))))) {
        return emitOpError("result #") << index << " must be tensor of floating-point values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void DepthwiseConv2dNativeBackpropFilterOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::DepthwiseConv2dNativeBackpropInputOp definitions
//===----------------------------------------------------------------------===//

DepthwiseConv2dNativeBackpropInputOpAdaptor::DepthwiseConv2dNativeBackpropInputOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

DepthwiseConv2dNativeBackpropInputOpAdaptor::DepthwiseConv2dNativeBackpropInputOpAdaptor(DepthwiseConv2dNativeBackpropInputOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> DepthwiseConv2dNativeBackpropInputOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange DepthwiseConv2dNativeBackpropInputOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value DepthwiseConv2dNativeBackpropInputOpAdaptor::input_sizes() {
  return *getODSOperands(0).begin();
}

::mlir::Value DepthwiseConv2dNativeBackpropInputOpAdaptor::filter() {
  return *getODSOperands(1).begin();
}

::mlir::Value DepthwiseConv2dNativeBackpropInputOpAdaptor::out_backprop() {
  return *getODSOperands(2).begin();
}

::mlir::ArrayAttr DepthwiseConv2dNativeBackpropInputOpAdaptor::strides() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::ArrayAttr attr = odsAttrs.get("strides").cast<::mlir::ArrayAttr>();
  return attr;
}

::mlir::StringAttr DepthwiseConv2dNativeBackpropInputOpAdaptor::padding() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::StringAttr attr = odsAttrs.get("padding").cast<::mlir::StringAttr>();
  return attr;
}

::mlir::ArrayAttr DepthwiseConv2dNativeBackpropInputOpAdaptor::explicit_paddings() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::ArrayAttr attr = odsAttrs.get("explicit_paddings").dyn_cast_or_null<::mlir::ArrayAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getI64ArrayAttr({});
  return attr;
}

::mlir::StringAttr DepthwiseConv2dNativeBackpropInputOpAdaptor::data_format() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::StringAttr attr = odsAttrs.get("data_format").dyn_cast_or_null<::mlir::StringAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getStringAttr("NHWC");
  return attr;
}

::mlir::ArrayAttr DepthwiseConv2dNativeBackpropInputOpAdaptor::dilations() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::ArrayAttr attr = odsAttrs.get("dilations").dyn_cast_or_null<::mlir::ArrayAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getI64ArrayAttr({1, 1, 1, 1});
  return attr;
}

::mlir::LogicalResult DepthwiseConv2dNativeBackpropInputOpAdaptor::verify(::mlir::Location loc) {
  {
  auto tblgen_strides = odsAttrs.get("strides");
  if (!tblgen_strides) return emitError(loc, "'tf.DepthwiseConv2dNativeBackpropInput' op ""requires attribute 'strides'");
    if (!(((tblgen_strides.isa<::mlir::ArrayAttr>())) && (::llvm::all_of(tblgen_strides.cast<::mlir::ArrayAttr>(), [](::mlir::Attribute attr) { return ((attr.isa<::mlir::IntegerAttr>())) && ((attr.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(64))); })))) return emitError(loc, "'tf.DepthwiseConv2dNativeBackpropInput' op ""attribute 'strides' failed to satisfy constraint: 64-bit integer array attribute");
  }
  {
  auto tblgen_padding = odsAttrs.get("padding");
  if (!tblgen_padding) return emitError(loc, "'tf.DepthwiseConv2dNativeBackpropInput' op ""requires attribute 'padding'");
    if (!((tblgen_padding.cast<StringAttr>().getValue() == "SAME" || tblgen_padding.cast<StringAttr>().getValue() == "VALID" || tblgen_padding.cast<StringAttr>().getValue() == "EXPLICIT"))) return emitError(loc, "'tf.DepthwiseConv2dNativeBackpropInput' op ""attribute 'padding' failed to satisfy constraint: string attribute whose value is SAME, or VALID, or EXPLICIT");
  }
  {
  auto tblgen_explicit_paddings = odsAttrs.get("explicit_paddings");
  if (tblgen_explicit_paddings) {
    if (!(((tblgen_explicit_paddings.isa<::mlir::ArrayAttr>())) && (::llvm::all_of(tblgen_explicit_paddings.cast<::mlir::ArrayAttr>(), [](::mlir::Attribute attr) { return ((attr.isa<::mlir::IntegerAttr>())) && ((attr.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(64))); })))) return emitError(loc, "'tf.DepthwiseConv2dNativeBackpropInput' op ""attribute 'explicit_paddings' failed to satisfy constraint: 64-bit integer array attribute");
  }
  }
  {
  auto tblgen_data_format = odsAttrs.get("data_format");
  if (tblgen_data_format) {
    if (!((tblgen_data_format.cast<StringAttr>().getValue() == "NHWC" || tblgen_data_format.cast<StringAttr>().getValue() == "NCHW"))) return emitError(loc, "'tf.DepthwiseConv2dNativeBackpropInput' op ""attribute 'data_format' failed to satisfy constraint: 'NHWC' or 'NCHW' convnet data format");
  }
  }
  {
  auto tblgen_dilations = odsAttrs.get("dilations");
  if (tblgen_dilations) {
    if (!(((tblgen_dilations.isa<::mlir::ArrayAttr>())) && (::llvm::all_of(tblgen_dilations.cast<::mlir::ArrayAttr>(), [](::mlir::Attribute attr) { return ((attr.isa<::mlir::IntegerAttr>())) && ((attr.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(64))); })))) return emitError(loc, "'tf.DepthwiseConv2dNativeBackpropInput' op ""attribute 'dilations' failed to satisfy constraint: 64-bit integer array attribute");
  }
  }
  return ::mlir::success();
}

::llvm::StringRef DepthwiseConv2dNativeBackpropInputOp::getOperationName() {
  return "tf.DepthwiseConv2dNativeBackpropInput";
}

std::pair<unsigned, unsigned> DepthwiseConv2dNativeBackpropInputOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range DepthwiseConv2dNativeBackpropInputOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value DepthwiseConv2dNativeBackpropInputOp::input_sizes() {
  return *getODSOperands(0).begin();
}

::mlir::Value DepthwiseConv2dNativeBackpropInputOp::filter() {
  return *getODSOperands(1).begin();
}

::mlir::Value DepthwiseConv2dNativeBackpropInputOp::out_backprop() {
  return *getODSOperands(2).begin();
}

::mlir::MutableOperandRange DepthwiseConv2dNativeBackpropInputOp::input_sizesMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange DepthwiseConv2dNativeBackpropInputOp::filterMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange DepthwiseConv2dNativeBackpropInputOp::out_backpropMutable() {
  auto range = getODSOperandIndexAndLength(2);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> DepthwiseConv2dNativeBackpropInputOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range DepthwiseConv2dNativeBackpropInputOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value DepthwiseConv2dNativeBackpropInputOp::output() {
  return *getODSResults(0).begin();
}

::mlir::ArrayAttr DepthwiseConv2dNativeBackpropInputOp::stridesAttr() {
  return this->getAttr("strides").cast<::mlir::ArrayAttr>();
}

::mlir::ArrayAttr DepthwiseConv2dNativeBackpropInputOp::strides() {
  auto attr = stridesAttr();
  return attr;
}

::mlir::StringAttr DepthwiseConv2dNativeBackpropInputOp::paddingAttr() {
  return this->getAttr("padding").cast<::mlir::StringAttr>();
}

::llvm::StringRef DepthwiseConv2dNativeBackpropInputOp::padding() {
  auto attr = paddingAttr();
  return attr.getValue();
}

::mlir::ArrayAttr DepthwiseConv2dNativeBackpropInputOp::explicit_paddingsAttr() {
  return this->getAttr("explicit_paddings").dyn_cast_or_null<::mlir::ArrayAttr>();
}

::mlir::ArrayAttr DepthwiseConv2dNativeBackpropInputOp::explicit_paddings() {
  auto attr = explicit_paddingsAttr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getI64ArrayAttr({});
  return attr;
}

::mlir::StringAttr DepthwiseConv2dNativeBackpropInputOp::data_formatAttr() {
  return this->getAttr("data_format").dyn_cast_or_null<::mlir::StringAttr>();
}

::llvm::StringRef DepthwiseConv2dNativeBackpropInputOp::data_format() {
  auto attr = data_formatAttr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getStringAttr("NHWC").getValue();
  return attr.getValue();
}

::mlir::ArrayAttr DepthwiseConv2dNativeBackpropInputOp::dilationsAttr() {
  return this->getAttr("dilations").dyn_cast_or_null<::mlir::ArrayAttr>();
}

::mlir::ArrayAttr DepthwiseConv2dNativeBackpropInputOp::dilations() {
  auto attr = dilationsAttr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getI64ArrayAttr({1, 1, 1, 1});
  return attr;
}

Type DepthwiseConv2dNativeBackpropInputOp::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(1).begin());
}

bool DepthwiseConv2dNativeBackpropInputOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "T") return true;
 return false;
}

::mlir::DictionaryAttr DepthwiseConv2dNativeBackpropInputOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())}
    }, ctx);
}

void DepthwiseConv2dNativeBackpropInputOp::stridesAttr(::mlir::ArrayAttr attr) {
  this->getOperation()->setAttr("strides", attr);
}

void DepthwiseConv2dNativeBackpropInputOp::paddingAttr(::mlir::StringAttr attr) {
  this->getOperation()->setAttr("padding", attr);
}

void DepthwiseConv2dNativeBackpropInputOp::explicit_paddingsAttr(::mlir::ArrayAttr attr) {
  this->getOperation()->setAttr("explicit_paddings", attr);
}

void DepthwiseConv2dNativeBackpropInputOp::data_formatAttr(::mlir::StringAttr attr) {
  this->getOperation()->setAttr("data_format", attr);
}

void DepthwiseConv2dNativeBackpropInputOp::dilationsAttr(::mlir::ArrayAttr attr) {
  this->getOperation()->setAttr("dilations", attr);
}

void DepthwiseConv2dNativeBackpropInputOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value input_sizes, ::mlir::Value filter, ::mlir::Value out_backprop, ::mlir::ArrayAttr strides, ::mlir::StringAttr padding, ::mlir::ArrayAttr explicit_paddings, ::mlir::StringAttr data_format, ::mlir::ArrayAttr dilations) {
  odsState.addOperands(input_sizes);
  odsState.addOperands(filter);
  odsState.addOperands(out_backprop);
  odsState.addAttribute("strides", strides);
  odsState.addAttribute("padding", padding);
  odsState.addAttribute("explicit_paddings", explicit_paddings);
  odsState.addAttribute("data_format", data_format);
  odsState.addAttribute("dilations", dilations);
  odsState.addTypes(output);
}

void DepthwiseConv2dNativeBackpropInputOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input_sizes, ::mlir::Value filter, ::mlir::Value out_backprop, ::mlir::ArrayAttr strides, ::mlir::StringAttr padding, ::mlir::ArrayAttr explicit_paddings, ::mlir::StringAttr data_format, ::mlir::ArrayAttr dilations) {
  odsState.addOperands(input_sizes);
  odsState.addOperands(filter);
  odsState.addOperands(out_backprop);
  odsState.addAttribute("strides", strides);
  odsState.addAttribute("padding", padding);
  odsState.addAttribute("explicit_paddings", explicit_paddings);
  odsState.addAttribute("data_format", data_format);
  odsState.addAttribute("dilations", dilations);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void DepthwiseConv2dNativeBackpropInputOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value input_sizes, ::mlir::Value filter, ::mlir::Value out_backprop, ::mlir::ArrayAttr strides, ::llvm::StringRef padding, ::mlir::ArrayAttr explicit_paddings, ::llvm::StringRef data_format, ::mlir::ArrayAttr dilations) {
  odsState.addOperands(input_sizes);
  odsState.addOperands(filter);
  odsState.addOperands(out_backprop);
  odsState.addAttribute("strides", strides);
  odsState.addAttribute("padding", odsBuilder.getStringAttr(padding));
  odsState.addAttribute("explicit_paddings", explicit_paddings);
  odsState.addAttribute("data_format", odsBuilder.getStringAttr(data_format));
  odsState.addAttribute("dilations", dilations);
  odsState.addTypes(output);
}

void DepthwiseConv2dNativeBackpropInputOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input_sizes, ::mlir::Value filter, ::mlir::Value out_backprop, ::mlir::ArrayAttr strides, ::llvm::StringRef padding, ::mlir::ArrayAttr explicit_paddings, ::llvm::StringRef data_format, ::mlir::ArrayAttr dilations) {
  odsState.addOperands(input_sizes);
  odsState.addOperands(filter);
  odsState.addOperands(out_backprop);
  odsState.addAttribute("strides", strides);
  odsState.addAttribute("padding", odsBuilder.getStringAttr(padding));
  odsState.addAttribute("explicit_paddings", explicit_paddings);
  odsState.addAttribute("data_format", odsBuilder.getStringAttr(data_format));
  odsState.addAttribute("dilations", dilations);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void DepthwiseConv2dNativeBackpropInputOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 3u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult DepthwiseConv2dNativeBackpropInputOp::verify() {
  if (failed(DepthwiseConv2dNativeBackpropInputOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of 32-bit integer values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of floating-point values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup2 = getODSOperands(2);
    for (::mlir::Value v : valueGroup2) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of floating-point values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))))) {
        return emitOpError("result #") << index << " must be tensor of floating-point values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void DepthwiseConv2dNativeBackpropInputOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::DepthwiseConv2dNativeOp definitions
//===----------------------------------------------------------------------===//

DepthwiseConv2dNativeOpAdaptor::DepthwiseConv2dNativeOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

DepthwiseConv2dNativeOpAdaptor::DepthwiseConv2dNativeOpAdaptor(DepthwiseConv2dNativeOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> DepthwiseConv2dNativeOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange DepthwiseConv2dNativeOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value DepthwiseConv2dNativeOpAdaptor::input() {
  return *getODSOperands(0).begin();
}

::mlir::Value DepthwiseConv2dNativeOpAdaptor::filter() {
  return *getODSOperands(1).begin();
}

::mlir::ArrayAttr DepthwiseConv2dNativeOpAdaptor::strides() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::ArrayAttr attr = odsAttrs.get("strides").cast<::mlir::ArrayAttr>();
  return attr;
}

::mlir::StringAttr DepthwiseConv2dNativeOpAdaptor::padding() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::StringAttr attr = odsAttrs.get("padding").cast<::mlir::StringAttr>();
  return attr;
}

::mlir::ArrayAttr DepthwiseConv2dNativeOpAdaptor::explicit_paddings() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::ArrayAttr attr = odsAttrs.get("explicit_paddings").dyn_cast_or_null<::mlir::ArrayAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getI64ArrayAttr({});
  return attr;
}

::mlir::StringAttr DepthwiseConv2dNativeOpAdaptor::data_format() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::StringAttr attr = odsAttrs.get("data_format").dyn_cast_or_null<::mlir::StringAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getStringAttr("NHWC");
  return attr;
}

::mlir::ArrayAttr DepthwiseConv2dNativeOpAdaptor::dilations() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::ArrayAttr attr = odsAttrs.get("dilations").dyn_cast_or_null<::mlir::ArrayAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getI64ArrayAttr({1, 1, 1, 1});
  return attr;
}

::mlir::LogicalResult DepthwiseConv2dNativeOpAdaptor::verify(::mlir::Location loc) {
  {
  auto tblgen_strides = odsAttrs.get("strides");
  if (!tblgen_strides) return emitError(loc, "'tf.DepthwiseConv2dNative' op ""requires attribute 'strides'");
    if (!(((tblgen_strides.isa<::mlir::ArrayAttr>())) && (::llvm::all_of(tblgen_strides.cast<::mlir::ArrayAttr>(), [](::mlir::Attribute attr) { return ((attr.isa<::mlir::IntegerAttr>())) && ((attr.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(64))); })))) return emitError(loc, "'tf.DepthwiseConv2dNative' op ""attribute 'strides' failed to satisfy constraint: 64-bit integer array attribute");
  }
  {
  auto tblgen_padding = odsAttrs.get("padding");
  if (!tblgen_padding) return emitError(loc, "'tf.DepthwiseConv2dNative' op ""requires attribute 'padding'");
    if (!((tblgen_padding.cast<StringAttr>().getValue() == "SAME" || tblgen_padding.cast<StringAttr>().getValue() == "VALID" || tblgen_padding.cast<StringAttr>().getValue() == "EXPLICIT"))) return emitError(loc, "'tf.DepthwiseConv2dNative' op ""attribute 'padding' failed to satisfy constraint: string attribute whose value is SAME, or VALID, or EXPLICIT");
  }
  {
  auto tblgen_explicit_paddings = odsAttrs.get("explicit_paddings");
  if (tblgen_explicit_paddings) {
    if (!(((tblgen_explicit_paddings.isa<::mlir::ArrayAttr>())) && (::llvm::all_of(tblgen_explicit_paddings.cast<::mlir::ArrayAttr>(), [](::mlir::Attribute attr) { return ((attr.isa<::mlir::IntegerAttr>())) && ((attr.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(64))); })))) return emitError(loc, "'tf.DepthwiseConv2dNative' op ""attribute 'explicit_paddings' failed to satisfy constraint: 64-bit integer array attribute");
  }
  }
  {
  auto tblgen_data_format = odsAttrs.get("data_format");
  if (tblgen_data_format) {
    if (!((tblgen_data_format.cast<StringAttr>().getValue() == "NHWC" || tblgen_data_format.cast<StringAttr>().getValue() == "NCHW"))) return emitError(loc, "'tf.DepthwiseConv2dNative' op ""attribute 'data_format' failed to satisfy constraint: 'NHWC' or 'NCHW' convnet data format");
  }
  }
  {
  auto tblgen_dilations = odsAttrs.get("dilations");
  if (tblgen_dilations) {
    if (!(((tblgen_dilations.isa<::mlir::ArrayAttr>())) && (::llvm::all_of(tblgen_dilations.cast<::mlir::ArrayAttr>(), [](::mlir::Attribute attr) { return ((attr.isa<::mlir::IntegerAttr>())) && ((attr.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(64))); })))) return emitError(loc, "'tf.DepthwiseConv2dNative' op ""attribute 'dilations' failed to satisfy constraint: 64-bit integer array attribute");
  }
  }
  return ::mlir::success();
}

::llvm::StringRef DepthwiseConv2dNativeOp::getOperationName() {
  return "tf.DepthwiseConv2dNative";
}

std::pair<unsigned, unsigned> DepthwiseConv2dNativeOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range DepthwiseConv2dNativeOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value DepthwiseConv2dNativeOp::input() {
  return *getODSOperands(0).begin();
}

::mlir::Value DepthwiseConv2dNativeOp::filter() {
  return *getODSOperands(1).begin();
}

::mlir::MutableOperandRange DepthwiseConv2dNativeOp::inputMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange DepthwiseConv2dNativeOp::filterMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> DepthwiseConv2dNativeOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range DepthwiseConv2dNativeOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value DepthwiseConv2dNativeOp::output() {
  return *getODSResults(0).begin();
}

::mlir::ArrayAttr DepthwiseConv2dNativeOp::stridesAttr() {
  return this->getAttr("strides").cast<::mlir::ArrayAttr>();
}

::mlir::ArrayAttr DepthwiseConv2dNativeOp::strides() {
  auto attr = stridesAttr();
  return attr;
}

::mlir::StringAttr DepthwiseConv2dNativeOp::paddingAttr() {
  return this->getAttr("padding").cast<::mlir::StringAttr>();
}

::llvm::StringRef DepthwiseConv2dNativeOp::padding() {
  auto attr = paddingAttr();
  return attr.getValue();
}

::mlir::ArrayAttr DepthwiseConv2dNativeOp::explicit_paddingsAttr() {
  return this->getAttr("explicit_paddings").dyn_cast_or_null<::mlir::ArrayAttr>();
}

::mlir::ArrayAttr DepthwiseConv2dNativeOp::explicit_paddings() {
  auto attr = explicit_paddingsAttr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getI64ArrayAttr({});
  return attr;
}

::mlir::StringAttr DepthwiseConv2dNativeOp::data_formatAttr() {
  return this->getAttr("data_format").dyn_cast_or_null<::mlir::StringAttr>();
}

::llvm::StringRef DepthwiseConv2dNativeOp::data_format() {
  auto attr = data_formatAttr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getStringAttr("NHWC").getValue();
  return attr.getValue();
}

::mlir::ArrayAttr DepthwiseConv2dNativeOp::dilationsAttr() {
  return this->getAttr("dilations").dyn_cast_or_null<::mlir::ArrayAttr>();
}

::mlir::ArrayAttr DepthwiseConv2dNativeOp::dilations() {
  auto attr = dilationsAttr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getI64ArrayAttr({1, 1, 1, 1});
  return attr;
}

Type DepthwiseConv2dNativeOp::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

bool DepthwiseConv2dNativeOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "T") return true;
 return false;
}

::mlir::DictionaryAttr DepthwiseConv2dNativeOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())}
    }, ctx);
}

void DepthwiseConv2dNativeOp::stridesAttr(::mlir::ArrayAttr attr) {
  this->getOperation()->setAttr("strides", attr);
}

void DepthwiseConv2dNativeOp::paddingAttr(::mlir::StringAttr attr) {
  this->getOperation()->setAttr("padding", attr);
}

void DepthwiseConv2dNativeOp::explicit_paddingsAttr(::mlir::ArrayAttr attr) {
  this->getOperation()->setAttr("explicit_paddings", attr);
}

void DepthwiseConv2dNativeOp::data_formatAttr(::mlir::StringAttr attr) {
  this->getOperation()->setAttr("data_format", attr);
}

void DepthwiseConv2dNativeOp::dilationsAttr(::mlir::ArrayAttr attr) {
  this->getOperation()->setAttr("dilations", attr);
}

void DepthwiseConv2dNativeOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value input, ::mlir::Value filter, ::mlir::ArrayAttr strides, ::mlir::StringAttr padding, ::mlir::ArrayAttr explicit_paddings, ::mlir::StringAttr data_format, ::mlir::ArrayAttr dilations) {
  odsState.addOperands(input);
  odsState.addOperands(filter);
  odsState.addAttribute("strides", strides);
  odsState.addAttribute("padding", padding);
  odsState.addAttribute("explicit_paddings", explicit_paddings);
  odsState.addAttribute("data_format", data_format);
  odsState.addAttribute("dilations", dilations);
  odsState.addTypes(output);
}

void DepthwiseConv2dNativeOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input, ::mlir::Value filter, ::mlir::ArrayAttr strides, ::mlir::StringAttr padding, ::mlir::ArrayAttr explicit_paddings, ::mlir::StringAttr data_format, ::mlir::ArrayAttr dilations) {
  odsState.addOperands(input);
  odsState.addOperands(filter);
  odsState.addAttribute("strides", strides);
  odsState.addAttribute("padding", padding);
  odsState.addAttribute("explicit_paddings", explicit_paddings);
  odsState.addAttribute("data_format", data_format);
  odsState.addAttribute("dilations", dilations);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void DepthwiseConv2dNativeOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value input, ::mlir::Value filter, ::mlir::ArrayAttr strides, ::llvm::StringRef padding, ::mlir::ArrayAttr explicit_paddings, ::llvm::StringRef data_format, ::mlir::ArrayAttr dilations) {
  odsState.addOperands(input);
  odsState.addOperands(filter);
  odsState.addAttribute("strides", strides);
  odsState.addAttribute("padding", odsBuilder.getStringAttr(padding));
  odsState.addAttribute("explicit_paddings", explicit_paddings);
  odsState.addAttribute("data_format", odsBuilder.getStringAttr(data_format));
  odsState.addAttribute("dilations", dilations);
  odsState.addTypes(output);
}

void DepthwiseConv2dNativeOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input, ::mlir::Value filter, ::mlir::ArrayAttr strides, ::llvm::StringRef padding, ::mlir::ArrayAttr explicit_paddings, ::llvm::StringRef data_format, ::mlir::ArrayAttr dilations) {
  odsState.addOperands(input);
  odsState.addOperands(filter);
  odsState.addAttribute("strides", strides);
  odsState.addAttribute("padding", odsBuilder.getStringAttr(padding));
  odsState.addAttribute("explicit_paddings", explicit_paddings);
  odsState.addAttribute("data_format", odsBuilder.getStringAttr(data_format));
  odsState.addAttribute("dilations", dilations);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void DepthwiseConv2dNativeOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult DepthwiseConv2dNativeOp::verify() {
  if (failed(DepthwiseConv2dNativeOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of floating-point values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of floating-point values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))))) {
        return emitOpError("result #") << index << " must be tensor of floating-point values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void DepthwiseConv2dNativeOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::DeserializeIteratorOp definitions
//===----------------------------------------------------------------------===//

DeserializeIteratorOpAdaptor::DeserializeIteratorOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

DeserializeIteratorOpAdaptor::DeserializeIteratorOpAdaptor(DeserializeIteratorOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> DeserializeIteratorOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange DeserializeIteratorOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value DeserializeIteratorOpAdaptor::resource_handle() {
  return *getODSOperands(0).begin();
}

::mlir::Value DeserializeIteratorOpAdaptor::serialized() {
  return *getODSOperands(1).begin();
}

::mlir::LogicalResult DeserializeIteratorOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

::llvm::StringRef DeserializeIteratorOp::getOperationName() {
  return "tf.DeserializeIterator";
}

std::pair<unsigned, unsigned> DeserializeIteratorOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range DeserializeIteratorOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value DeserializeIteratorOp::resource_handle() {
  return *getODSOperands(0).begin();
}

::mlir::Value DeserializeIteratorOp::serialized() {
  return *getODSOperands(1).begin();
}

::mlir::MutableOperandRange DeserializeIteratorOp::resource_handleMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange DeserializeIteratorOp::serializedMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> DeserializeIteratorOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range DeserializeIteratorOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

void DeserializeIteratorOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value resource_handle, ::mlir::Value serialized) {
  odsState.addOperands(resource_handle);
  odsState.addOperands(serialized);
}

void DeserializeIteratorOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value resource_handle, ::mlir::Value serialized) {
  odsState.addOperands(resource_handle);
  odsState.addOperands(serialized);
  assert(resultTypes.size() == 0u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void DeserializeIteratorOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 0u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult DeserializeIteratorOp::verify() {
  if (failed(DeserializeIteratorOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::ResourceType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::ResourceRefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of resource values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::VariantType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::VariantRefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of variant values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
  }
  return ::mlir::success();
}

void DeserializeIteratorOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
  for (::mlir::Value value : getODSOperands(0))
    effects.emplace_back(MemoryEffects::Write::get(), value, ::mlir::TF::ResourceEffects::DatasetIterator::get());
}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::DestroyResourceOp definitions
//===----------------------------------------------------------------------===//

DestroyResourceOpAdaptor::DestroyResourceOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

DestroyResourceOpAdaptor::DestroyResourceOpAdaptor(DestroyResourceOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> DestroyResourceOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange DestroyResourceOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value DestroyResourceOpAdaptor::resource() {
  return *getODSOperands(0).begin();
}

::mlir::BoolAttr DestroyResourceOpAdaptor::ignore_lookup_error() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::BoolAttr attr = odsAttrs.get("ignore_lookup_error").dyn_cast_or_null<::mlir::BoolAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getBoolAttr(true);
  return attr;
}

::mlir::LogicalResult DestroyResourceOpAdaptor::verify(::mlir::Location loc) {
  {
  auto tblgen_ignore_lookup_error = odsAttrs.get("ignore_lookup_error");
  if (tblgen_ignore_lookup_error) {
    if (!((tblgen_ignore_lookup_error.isa<::mlir::BoolAttr>()))) return emitError(loc, "'tf.DestroyResourceOp' op ""attribute 'ignore_lookup_error' failed to satisfy constraint: bool attribute");
  }
  }
  return ::mlir::success();
}

::llvm::StringRef DestroyResourceOp::getOperationName() {
  return "tf.DestroyResourceOp";
}

std::pair<unsigned, unsigned> DestroyResourceOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range DestroyResourceOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value DestroyResourceOp::resource() {
  return *getODSOperands(0).begin();
}

::mlir::MutableOperandRange DestroyResourceOp::resourceMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> DestroyResourceOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range DestroyResourceOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::BoolAttr DestroyResourceOp::ignore_lookup_errorAttr() {
  return this->getAttr("ignore_lookup_error").dyn_cast_or_null<::mlir::BoolAttr>();
}

bool DestroyResourceOp::ignore_lookup_error() {
  auto attr = ignore_lookup_errorAttr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getBoolAttr(true).getValue();
  return attr.getValue();
}

void DestroyResourceOp::ignore_lookup_errorAttr(::mlir::BoolAttr attr) {
  this->getOperation()->setAttr("ignore_lookup_error", attr);
}

void DestroyResourceOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value resource, ::mlir::BoolAttr ignore_lookup_error) {
  odsState.addOperands(resource);
  odsState.addAttribute("ignore_lookup_error", ignore_lookup_error);
}

void DestroyResourceOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value resource, ::mlir::BoolAttr ignore_lookup_error) {
  odsState.addOperands(resource);
  odsState.addAttribute("ignore_lookup_error", ignore_lookup_error);
  assert(resultTypes.size() == 0u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void DestroyResourceOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value resource, bool ignore_lookup_error) {
  odsState.addOperands(resource);
  odsState.addAttribute("ignore_lookup_error", odsBuilder.getBoolAttr(ignore_lookup_error));
}

void DestroyResourceOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value resource, bool ignore_lookup_error) {
  odsState.addOperands(resource);
  odsState.addAttribute("ignore_lookup_error", odsBuilder.getBoolAttr(ignore_lookup_error));
  assert(resultTypes.size() == 0u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void DestroyResourceOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 0u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult DestroyResourceOp::verify() {
  if (failed(DestroyResourceOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::ResourceType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::ResourceRefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of resource values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
  }
  return ::mlir::success();
}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::DeviceIndexOp definitions
//===----------------------------------------------------------------------===//

DeviceIndexOpAdaptor::DeviceIndexOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

DeviceIndexOpAdaptor::DeviceIndexOpAdaptor(DeviceIndexOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> DeviceIndexOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange DeviceIndexOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::ArrayAttr DeviceIndexOpAdaptor::device_names() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::ArrayAttr attr = odsAttrs.get("device_names").cast<::mlir::ArrayAttr>();
  return attr;
}

::mlir::LogicalResult DeviceIndexOpAdaptor::verify(::mlir::Location loc) {
  {
  auto tblgen_device_names = odsAttrs.get("device_names");
  if (!tblgen_device_names) return emitError(loc, "'tf.DeviceIndex' op ""requires attribute 'device_names'");
    if (!(((tblgen_device_names.isa<::mlir::ArrayAttr>())) && (::llvm::all_of(tblgen_device_names.cast<::mlir::ArrayAttr>(), [](::mlir::Attribute attr) { return (attr.isa<::mlir::StringAttr>()); })))) return emitError(loc, "'tf.DeviceIndex' op ""attribute 'device_names' failed to satisfy constraint: string array attribute");
  }
  return ::mlir::success();
}

::llvm::StringRef DeviceIndexOp::getOperationName() {
  return "tf.DeviceIndex";
}

std::pair<unsigned, unsigned> DeviceIndexOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range DeviceIndexOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

std::pair<unsigned, unsigned> DeviceIndexOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range DeviceIndexOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value DeviceIndexOp::index() {
  return *getODSResults(0).begin();
}

::mlir::ArrayAttr DeviceIndexOp::device_namesAttr() {
  return this->getAttr("device_names").cast<::mlir::ArrayAttr>();
}

::mlir::ArrayAttr DeviceIndexOp::device_names() {
  auto attr = device_namesAttr();
  return attr;
}

void DeviceIndexOp::device_namesAttr(::mlir::ArrayAttr attr) {
  this->getOperation()->setAttr("device_names", attr);
}

void DeviceIndexOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type index, ::mlir::ArrayAttr device_names) {
  odsState.addAttribute("device_names", device_names);
  odsState.addTypes(index);
}

void DeviceIndexOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ArrayAttr device_names) {
  odsState.addAttribute("device_names", device_names);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void DeviceIndexOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 0u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult DeviceIndexOp::verify() {
  if (failed(DeviceIndexOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))))) {
        return emitOpError("result #") << index << " must be tensor of 32-bit integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void DeviceIndexOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::DiagOp definitions
//===----------------------------------------------------------------------===//

DiagOpAdaptor::DiagOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

DiagOpAdaptor::DiagOpAdaptor(DiagOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> DiagOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange DiagOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value DiagOpAdaptor::diagonal() {
  return *getODSOperands(0).begin();
}

::mlir::LogicalResult DiagOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

::llvm::StringRef DiagOp::getOperationName() {
  return "tf.Diag";
}

std::pair<unsigned, unsigned> DiagOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range DiagOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value DiagOp::diagonal() {
  return *getODSOperands(0).begin();
}

::mlir::MutableOperandRange DiagOp::diagonalMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> DiagOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range DiagOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value DiagOp::output() {
  return *getODSResults(0).begin();
}

Type DiagOp::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

bool DiagOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "T") return true;
 return false;
}

::mlir::DictionaryAttr DiagOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())}
    }, ctx);
}

void DiagOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value diagonal) {
  odsState.addOperands(diagonal);
  odsState.addTypes(output);
}

void DiagOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value diagonal) {
  odsState.addOperands(diagonal);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void DiagOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult DiagOp::verify() {
  if (failed(DiagOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of bfloat16 or 128-bit complex or 64-bit complex or 16-bit float or 32-bit float or 64-bit float or 32-bit integer or 64-bit integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))))) {
        return emitOpError("result #") << index << " must be tensor of bfloat16 or 128-bit complex or 64-bit complex or 16-bit float or 32-bit float or 64-bit float or 32-bit integer or 64-bit integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void DiagOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::DiagPartOp definitions
//===----------------------------------------------------------------------===//

DiagPartOpAdaptor::DiagPartOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

DiagPartOpAdaptor::DiagPartOpAdaptor(DiagPartOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> DiagPartOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange DiagPartOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value DiagPartOpAdaptor::input() {
  return *getODSOperands(0).begin();
}

::mlir::LogicalResult DiagPartOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

::llvm::StringRef DiagPartOp::getOperationName() {
  return "tf.DiagPart";
}

std::pair<unsigned, unsigned> DiagPartOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range DiagPartOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value DiagPartOp::input() {
  return *getODSOperands(0).begin();
}

::mlir::MutableOperandRange DiagPartOp::inputMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> DiagPartOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range DiagPartOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value DiagPartOp::diagonal() {
  return *getODSResults(0).begin();
}

Type DiagPartOp::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

bool DiagPartOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "T") return true;
 return false;
}

::mlir::DictionaryAttr DiagPartOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())}
    }, ctx);
}

void DiagPartOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type diagonal, ::mlir::Value input) {
  odsState.addOperands(input);
  odsState.addTypes(diagonal);
}

void DiagPartOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input) {
  odsState.addOperands(input);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void DiagPartOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult DiagPartOp::verify() {
  if (failed(DiagPartOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of bfloat16 or 128-bit complex or 64-bit complex or 16-bit float or 32-bit float or 64-bit float or 32-bit integer or 64-bit integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))))) {
        return emitOpError("result #") << index << " must be tensor of bfloat16 or 128-bit complex or 64-bit complex or 16-bit float or 32-bit float or 64-bit float or 32-bit integer or 64-bit integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void DiagPartOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::DigammaOp definitions
//===----------------------------------------------------------------------===//

DigammaOpAdaptor::DigammaOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

DigammaOpAdaptor::DigammaOpAdaptor(DigammaOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> DigammaOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange DigammaOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value DigammaOpAdaptor::x() {
  return *getODSOperands(0).begin();
}

::mlir::LogicalResult DigammaOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

::llvm::StringRef DigammaOp::getOperationName() {
  return "tf.Digamma";
}

std::pair<unsigned, unsigned> DigammaOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range DigammaOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value DigammaOp::x() {
  return *getODSOperands(0).begin();
}

::mlir::MutableOperandRange DigammaOp::xMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> DigammaOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range DigammaOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value DigammaOp::y() {
  return *getODSResults(0).begin();
}

Type DigammaOp::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

bool DigammaOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "T") return true;
 return false;
}

::mlir::DictionaryAttr DigammaOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())}
    }, ctx);
}

void DigammaOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type y, ::mlir::Value x) {
  odsState.addOperands(x);
  odsState.addTypes(y);
}

void DigammaOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value x) {
  odsState.addOperands(x);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void DigammaOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

void DigammaOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value x) {
  odsState.addOperands(x);
  odsState.addTypes({x.getType()});

}

void DigammaOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  odsState.addTypes({operands[0].getType()});

}

::mlir::LogicalResult DigammaOp::verify() {
  if (failed(DigammaOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of floating-point values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))))) {
        return emitOpError("result #") << index << " must be tensor of floating-point values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void DigammaOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::DivNoNanOp definitions
//===----------------------------------------------------------------------===//

DivNoNanOpAdaptor::DivNoNanOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

DivNoNanOpAdaptor::DivNoNanOpAdaptor(DivNoNanOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> DivNoNanOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange DivNoNanOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value DivNoNanOpAdaptor::x() {
  return *getODSOperands(0).begin();
}

::mlir::Value DivNoNanOpAdaptor::y() {
  return *getODSOperands(1).begin();
}

::mlir::LogicalResult DivNoNanOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

::llvm::StringRef DivNoNanOp::getOperationName() {
  return "tf.DivNoNan";
}

std::pair<unsigned, unsigned> DivNoNanOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range DivNoNanOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value DivNoNanOp::x() {
  return *getODSOperands(0).begin();
}

::mlir::Value DivNoNanOp::y() {
  return *getODSOperands(1).begin();
}

::mlir::MutableOperandRange DivNoNanOp::xMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange DivNoNanOp::yMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> DivNoNanOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range DivNoNanOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value DivNoNanOp::z() {
  return *getODSResults(0).begin();
}

Type DivNoNanOp::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

bool DivNoNanOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "T") return true;
 return false;
}

::mlir::DictionaryAttr DivNoNanOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())}
    }, ctx);
}

void DivNoNanOp::build(OpBuilder &builder, OperationState &result, Value  x, Value  y) {
  auto resultType =
      OpTrait::util::getBroadcastedType(x.getType(), y.getType());
  if (!resultType)
    mlir::emitError(result.location, "non-broadcastable operands");
  return build(builder, result, resultType, x, y);
}

void DivNoNanOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type z, ::mlir::Value x, ::mlir::Value y) {
  odsState.addOperands(x);
  odsState.addOperands(y);
  odsState.addTypes(z);
}

void DivNoNanOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value x, ::mlir::Value y) {
  odsState.addOperands(x);
  odsState.addOperands(y);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void DivNoNanOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult DivNoNanOp::verify() {
  if (failed(DivNoNanOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))))))) {
        return emitOpError("operand #") << index << " must be tensor of 16-bit float or 32-bit float or 64-bit float or complex values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))))))) {
        return emitOpError("operand #") << index << " must be tensor of 16-bit float or 32-bit float or 64-bit float or complex values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))))))) {
        return emitOpError("result #") << index << " must be tensor of 16-bit float or 32-bit float or 64-bit float or complex values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void DivNoNanOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::DivOp definitions
//===----------------------------------------------------------------------===//

DivOpAdaptor::DivOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

DivOpAdaptor::DivOpAdaptor(DivOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> DivOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange DivOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value DivOpAdaptor::x() {
  return *getODSOperands(0).begin();
}

::mlir::Value DivOpAdaptor::y() {
  return *getODSOperands(1).begin();
}

::mlir::LogicalResult DivOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

::llvm::StringRef DivOp::getOperationName() {
  return "tf.Div";
}

std::pair<unsigned, unsigned> DivOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range DivOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value DivOp::x() {
  return *getODSOperands(0).begin();
}

::mlir::Value DivOp::y() {
  return *getODSOperands(1).begin();
}

::mlir::MutableOperandRange DivOp::xMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange DivOp::yMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> DivOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range DivOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value DivOp::z() {
  return *getODSResults(0).begin();
}

Type DivOp::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

bool DivOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "T") return true;
 return false;
}

::mlir::DictionaryAttr DivOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())}
    }, ctx);
}

void DivOp::build(OpBuilder &builder, OperationState &result, Value  x, Value  y) {
  auto resultType =
      OpTrait::util::getBroadcastedType(x.getType(), y.getType());
  if (!resultType)
    mlir::emitError(result.location, "non-broadcastable operands");
  return build(builder, result, resultType, x, y);
}

void DivOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type z, ::mlir::Value x, ::mlir::Value y) {
  odsState.addOperands(x);
  odsState.addOperands(y);
  odsState.addTypes(z);
}

void DivOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value x, ::mlir::Value y) {
  odsState.addOperands(x);
  odsState.addOperands(y);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void DivOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult DivOp::verify() {
  if (failed(DivOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of bfloat16 or 128-bit complex or 64-bit complex or 16-bit float or 32-bit float or 64-bit float or 16-bit integer or 32-bit integer or 64-bit integer or 8-bit integer or 16-bit unsigned integer or 8-bit unsigned integer values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of bfloat16 or 128-bit complex or 64-bit complex or 16-bit float or 32-bit float or 64-bit float or 16-bit integer or 32-bit integer or 64-bit integer or 8-bit integer or 16-bit unsigned integer or 8-bit unsigned integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>())))))) {
        return emitOpError("result #") << index << " must be tensor of bfloat16 or 128-bit complex or 64-bit complex or 16-bit float or 32-bit float or 64-bit float or 16-bit integer or 32-bit integer or 64-bit integer or 8-bit integer or 16-bit unsigned integer or 8-bit unsigned integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}





void DivOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::DummyMemoryCacheOp definitions
//===----------------------------------------------------------------------===//

DummyMemoryCacheOpAdaptor::DummyMemoryCacheOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

DummyMemoryCacheOpAdaptor::DummyMemoryCacheOpAdaptor(DummyMemoryCacheOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> DummyMemoryCacheOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange DummyMemoryCacheOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::LogicalResult DummyMemoryCacheOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

::llvm::StringRef DummyMemoryCacheOp::getOperationName() {
  return "tf.DummyMemoryCache";
}

std::pair<unsigned, unsigned> DummyMemoryCacheOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range DummyMemoryCacheOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

std::pair<unsigned, unsigned> DummyMemoryCacheOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range DummyMemoryCacheOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value DummyMemoryCacheOp::handle() {
  return *getODSResults(0).begin();
}

void DummyMemoryCacheOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type handle) {
  odsState.addTypes(handle);
}

void DummyMemoryCacheOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes) {
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void DummyMemoryCacheOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 0u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult DummyMemoryCacheOp::verify() {
  if (failed(DummyMemoryCacheOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::ResourceType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::ResourceRefType>()))))) {
        return emitOpError("result #") << index << " must be tensor of resource values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void DummyMemoryCacheOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
  for (::mlir::Value value : getODSResults(0))
    effects.emplace_back(MemoryEffects::Allocate::get(), value, ::mlir::TF::ResourceEffects::DatasetMemoryCache::get());
}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::DummySeedGeneratorOp definitions
//===----------------------------------------------------------------------===//

DummySeedGeneratorOpAdaptor::DummySeedGeneratorOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

DummySeedGeneratorOpAdaptor::DummySeedGeneratorOpAdaptor(DummySeedGeneratorOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> DummySeedGeneratorOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange DummySeedGeneratorOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::LogicalResult DummySeedGeneratorOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

::llvm::StringRef DummySeedGeneratorOp::getOperationName() {
  return "tf.DummySeedGenerator";
}

std::pair<unsigned, unsigned> DummySeedGeneratorOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range DummySeedGeneratorOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

std::pair<unsigned, unsigned> DummySeedGeneratorOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range DummySeedGeneratorOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value DummySeedGeneratorOp::handle() {
  return *getODSResults(0).begin();
}

void DummySeedGeneratorOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type handle) {
  odsState.addTypes(handle);
}

void DummySeedGeneratorOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes) {
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void DummySeedGeneratorOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 0u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult DummySeedGeneratorOp::verify() {
  if (failed(DummySeedGeneratorOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::ResourceType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::ResourceRefType>()))))) {
        return emitOpError("result #") << index << " must be tensor of resource values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void DummySeedGeneratorOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
  for (::mlir::Value value : getODSResults(0))
    effects.emplace_back(MemoryEffects::Allocate::get(), value, ::mlir::TF::ResourceEffects::DatasetSeedGenerator::get());
}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::DynamicStitchOp definitions
//===----------------------------------------------------------------------===//

DynamicStitchOpAdaptor::DynamicStitchOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

DynamicStitchOpAdaptor::DynamicStitchOpAdaptor(DynamicStitchOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> DynamicStitchOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  bool isVariadic[] = {true, true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (odsOperands.size() - 0) / 2;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::mlir::ValueRange DynamicStitchOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::ValueRange DynamicStitchOpAdaptor::indices() {
  return getODSOperands(0);
}

::mlir::ValueRange DynamicStitchOpAdaptor::data() {
  return getODSOperands(1);
}

::mlir::LogicalResult DynamicStitchOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

::llvm::StringRef DynamicStitchOp::getOperationName() {
  return "tf.DynamicStitch";
}

std::pair<unsigned, unsigned> DynamicStitchOp::getODSOperandIndexAndLength(unsigned index) {
  bool isVariadic[] = {true, true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (getOperation()->getNumOperands() - 0) / 2;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::mlir::Operation::operand_range DynamicStitchOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Operation::operand_range DynamicStitchOp::indices() {
  return getODSOperands(0);
}

::mlir::Operation::operand_range DynamicStitchOp::data() {
  return getODSOperands(1);
}

::mlir::MutableOperandRange DynamicStitchOp::indicesMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange DynamicStitchOp::dataMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> DynamicStitchOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range DynamicStitchOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value DynamicStitchOp::merged() {
  return *getODSResults(0).begin();
}

Type DynamicStitchOp::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(1).begin());
}

size_t DynamicStitchOp::N() {
  auto range = getODSOperands(0);
return std::distance(range.begin(), range.end());
}

bool DynamicStitchOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "T") return true;
  if (name == "N") return true;
 return false;
}

::mlir::DictionaryAttr DynamicStitchOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())},
    {::mlir::Identifier::get("N", ctx),
odsBuilder.getI64IntegerAttr(N())}
    }, ctx);
}

void DynamicStitchOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type merged, ::mlir::ValueRange indices, ::mlir::ValueRange data) {
  odsState.addOperands(indices);
  odsState.addOperands(data);
  odsState.addTypes(merged);
}

void DynamicStitchOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange indices, ::mlir::ValueRange data) {
  odsState.addOperands(indices);
  odsState.addOperands(data);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void DynamicStitchOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult DynamicStitchOp::verify() {
  if (failed(DynamicStitchOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of 32-bit integer values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>())))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::TensorFlowType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of tf.dtype values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>())))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::TensorFlowType>()))))) {
        return emitOpError("result #") << index << " must be tensor of tf.dtype values, but got " << v.getType();
      }
      ++index;
    }
  }
  return Verify(*this);
}

void DynamicStitchOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::EinsumOp definitions
//===----------------------------------------------------------------------===//

EinsumOpAdaptor::EinsumOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

EinsumOpAdaptor::EinsumOpAdaptor(EinsumOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> EinsumOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  bool isVariadic[] = {true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (odsOperands.size() - 0) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::mlir::ValueRange EinsumOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::ValueRange EinsumOpAdaptor::inputs() {
  return getODSOperands(0);
}

::mlir::StringAttr EinsumOpAdaptor::equation() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::StringAttr attr = odsAttrs.get("equation").cast<::mlir::StringAttr>();
  return attr;
}

::mlir::LogicalResult EinsumOpAdaptor::verify(::mlir::Location loc) {
  {
  auto tblgen_equation = odsAttrs.get("equation");
  if (!tblgen_equation) return emitError(loc, "'tf.Einsum' op ""requires attribute 'equation'");
    if (!((tblgen_equation.isa<::mlir::StringAttr>()))) return emitError(loc, "'tf.Einsum' op ""attribute 'equation' failed to satisfy constraint: string attribute");
  }
  return ::mlir::success();
}

::llvm::StringRef EinsumOp::getOperationName() {
  return "tf.Einsum";
}

std::pair<unsigned, unsigned> EinsumOp::getODSOperandIndexAndLength(unsigned index) {
  bool isVariadic[] = {true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (getOperation()->getNumOperands() - 0) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::mlir::Operation::operand_range EinsumOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Operation::operand_range EinsumOp::inputs() {
  return getODSOperands(0);
}

::mlir::MutableOperandRange EinsumOp::inputsMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> EinsumOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range EinsumOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value EinsumOp::output() {
  return *getODSResults(0).begin();
}

::mlir::StringAttr EinsumOp::equationAttr() {
  return this->getAttr("equation").cast<::mlir::StringAttr>();
}

::llvm::StringRef EinsumOp::equation() {
  auto attr = equationAttr();
  return attr.getValue();
}

Type EinsumOp::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

size_t EinsumOp::N() {
  auto range = getODSOperands(0);
return std::distance(range.begin(), range.end());
}

bool EinsumOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "T") return true;
  if (name == "N") return true;
 return false;
}

::mlir::DictionaryAttr EinsumOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())},
    {::mlir::Identifier::get("N", ctx),
odsBuilder.getI64IntegerAttr(N())}
    }, ctx);
}

void EinsumOp::equationAttr(::mlir::StringAttr attr) {
  this->getOperation()->setAttr("equation", attr);
}

void EinsumOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::ValueRange inputs, ::mlir::StringAttr equation) {
  odsState.addOperands(inputs);
  odsState.addAttribute("equation", equation);
  odsState.addTypes(output);
}

void EinsumOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange inputs, ::mlir::StringAttr equation) {
  odsState.addOperands(inputs);
  odsState.addAttribute("equation", equation);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void EinsumOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::ValueRange inputs, ::llvm::StringRef equation) {
  odsState.addOperands(inputs);
  odsState.addAttribute("equation", odsBuilder.getStringAttr(equation));
  odsState.addTypes(output);
}

void EinsumOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange inputs, ::llvm::StringRef equation) {
  odsState.addOperands(inputs);
  odsState.addAttribute("equation", odsBuilder.getStringAttr(equation));
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void EinsumOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult EinsumOp::verify() {
  if (failed(EinsumOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>())))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::TensorFlowType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of tf.dtype values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>())))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::TensorFlowType>()))))) {
        return emitOpError("result #") << index << " must be tensor of tf.dtype values, but got " << v.getType();
      }
      ++index;
    }
  }
  return Verify(*this);
}

void EinsumOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::EluGradOp definitions
//===----------------------------------------------------------------------===//

EluGradOpAdaptor::EluGradOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

EluGradOpAdaptor::EluGradOpAdaptor(EluGradOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> EluGradOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange EluGradOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value EluGradOpAdaptor::gradients() {
  return *getODSOperands(0).begin();
}

::mlir::Value EluGradOpAdaptor::outputs() {
  return *getODSOperands(1).begin();
}

::mlir::LogicalResult EluGradOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

::llvm::StringRef EluGradOp::getOperationName() {
  return "tf.EluGrad";
}

std::pair<unsigned, unsigned> EluGradOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range EluGradOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value EluGradOp::gradients() {
  return *getODSOperands(0).begin();
}

::mlir::Value EluGradOp::outputs() {
  return *getODSOperands(1).begin();
}

::mlir::MutableOperandRange EluGradOp::gradientsMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange EluGradOp::outputsMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> EluGradOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range EluGradOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value EluGradOp::backprops() {
  return *getODSResults(0).begin();
}

Type EluGradOp::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

bool EluGradOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "T") return true;
 return false;
}

::mlir::DictionaryAttr EluGradOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())}
    }, ctx);
}

void EluGradOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type backprops, ::mlir::Value gradients, ::mlir::Value outputs) {
  odsState.addOperands(gradients);
  odsState.addOperands(outputs);
  odsState.addTypes(backprops);
}

void EluGradOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value gradients, ::mlir::Value outputs) {
  odsState.addOperands(gradients);
  odsState.addOperands(outputs);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void EluGradOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

void EluGradOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value gradients, ::mlir::Value outputs) {
  odsState.addOperands(gradients);
  odsState.addOperands(outputs);
  odsState.addTypes({gradients.getType()});

}

void EluGradOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  odsState.addTypes({operands[0].getType()});

}

::mlir::LogicalResult EluGradOp::verify() {
  if (failed(EluGradOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of floating-point values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of floating-point values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))))) {
        return emitOpError("result #") << index << " must be tensor of floating-point values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void EluGradOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::EluOp definitions
//===----------------------------------------------------------------------===//

EluOpAdaptor::EluOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

EluOpAdaptor::EluOpAdaptor(EluOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> EluOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange EluOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value EluOpAdaptor::features() {
  return *getODSOperands(0).begin();
}

::mlir::LogicalResult EluOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

::llvm::StringRef EluOp::getOperationName() {
  return "tf.Elu";
}

std::pair<unsigned, unsigned> EluOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range EluOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value EluOp::features() {
  return *getODSOperands(0).begin();
}

::mlir::MutableOperandRange EluOp::featuresMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> EluOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range EluOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value EluOp::activations() {
  return *getODSResults(0).begin();
}

Type EluOp::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

bool EluOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "T") return true;
 return false;
}

::mlir::DictionaryAttr EluOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())}
    }, ctx);
}

void EluOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type activations, ::mlir::Value features) {
  odsState.addOperands(features);
  odsState.addTypes(activations);
}

void EluOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value features) {
  odsState.addOperands(features);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void EluOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

void EluOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value features) {
  odsState.addOperands(features);
  odsState.addTypes({features.getType()});

}

void EluOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  odsState.addTypes({operands[0].getType()});

}

::mlir::LogicalResult EluOp::verify() {
  if (failed(EluOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of floating-point values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))))) {
        return emitOpError("result #") << index << " must be tensor of floating-point values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void EluOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::EmptyOp definitions
//===----------------------------------------------------------------------===//

EmptyOpAdaptor::EmptyOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

EmptyOpAdaptor::EmptyOpAdaptor(EmptyOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> EmptyOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange EmptyOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value EmptyOpAdaptor::shape() {
  return *getODSOperands(0).begin();
}

::mlir::BoolAttr EmptyOpAdaptor::init() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::BoolAttr attr = odsAttrs.get("init").dyn_cast_or_null<::mlir::BoolAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getBoolAttr(false);
  return attr;
}

::mlir::LogicalResult EmptyOpAdaptor::verify(::mlir::Location loc) {
  {
  auto tblgen_init = odsAttrs.get("init");
  if (tblgen_init) {
    if (!((tblgen_init.isa<::mlir::BoolAttr>()))) return emitError(loc, "'tf.Empty' op ""attribute 'init' failed to satisfy constraint: bool attribute");
  }
  }
  return ::mlir::success();
}

::llvm::StringRef EmptyOp::getOperationName() {
  return "tf.Empty";
}

std::pair<unsigned, unsigned> EmptyOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range EmptyOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value EmptyOp::shape() {
  return *getODSOperands(0).begin();
}

::mlir::MutableOperandRange EmptyOp::shapeMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> EmptyOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range EmptyOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value EmptyOp::output() {
  return *getODSResults(0).begin();
}

::mlir::BoolAttr EmptyOp::initAttr() {
  return this->getAttr("init").dyn_cast_or_null<::mlir::BoolAttr>();
}

bool EmptyOp::init() {
  auto attr = initAttr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getBoolAttr(false).getValue();
  return attr.getValue();
}

Type EmptyOp::dtype() {
  return mlir::getElementTypeOrSelf(*getODSResults(0).begin());
}

bool EmptyOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "dtype") return true;
 return false;
}

::mlir::DictionaryAttr EmptyOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("dtype", ctx),
::mlir::TypeAttr::get(dtype())}
    }, ctx);
}

void EmptyOp::initAttr(::mlir::BoolAttr attr) {
  this->getOperation()->setAttr("init", attr);
}

void EmptyOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value shape, ::mlir::BoolAttr init) {
  odsState.addOperands(shape);
  odsState.addAttribute("init", init);
  odsState.addTypes(output);
}

void EmptyOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value shape, ::mlir::BoolAttr init) {
  odsState.addOperands(shape);
  odsState.addAttribute("init", init);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void EmptyOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value shape, bool init) {
  odsState.addOperands(shape);
  odsState.addAttribute("init", odsBuilder.getBoolAttr(init));
  odsState.addTypes(output);
}

void EmptyOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value shape, bool init) {
  odsState.addOperands(shape);
  odsState.addAttribute("init", odsBuilder.getBoolAttr(init));
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void EmptyOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult EmptyOp::verify() {
  if (failed(EmptyOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of 32-bit integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>())))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::TensorFlowType>()))))) {
        return emitOpError("result #") << index << " must be tensor of tf.dtype values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}



} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::EmptyTensorListOp definitions
//===----------------------------------------------------------------------===//

EmptyTensorListOpAdaptor::EmptyTensorListOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

EmptyTensorListOpAdaptor::EmptyTensorListOpAdaptor(EmptyTensorListOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> EmptyTensorListOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange EmptyTensorListOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value EmptyTensorListOpAdaptor::element_shape() {
  return *getODSOperands(0).begin();
}

::mlir::Value EmptyTensorListOpAdaptor::max_num_elements() {
  return *getODSOperands(1).begin();
}

::mlir::LogicalResult EmptyTensorListOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

::llvm::StringRef EmptyTensorListOp::getOperationName() {
  return "tf.EmptyTensorList";
}

std::pair<unsigned, unsigned> EmptyTensorListOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range EmptyTensorListOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value EmptyTensorListOp::element_shape() {
  return *getODSOperands(0).begin();
}

::mlir::Value EmptyTensorListOp::max_num_elements() {
  return *getODSOperands(1).begin();
}

::mlir::MutableOperandRange EmptyTensorListOp::element_shapeMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange EmptyTensorListOp::max_num_elementsMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> EmptyTensorListOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range EmptyTensorListOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value EmptyTensorListOp::handle() {
  return *getODSResults(0).begin();
}

Type EmptyTensorListOp::shape_type() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

Type EmptyTensorListOp::element_dtype() {
  return getElementTypeOrSelf(element_type());
}

bool EmptyTensorListOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "shape_type") return true;
  if (name == "element_dtype") return true;
 return false;
}

::mlir::DictionaryAttr EmptyTensorListOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("shape_type", ctx),
::mlir::TypeAttr::get(shape_type())},
    {::mlir::Identifier::get("element_dtype", ctx),
::mlir::TypeAttr::get(element_dtype())}
    }, ctx);
}

void EmptyTensorListOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type handle, ::mlir::Value element_shape, ::mlir::Value max_num_elements) {
  odsState.addOperands(element_shape);
  odsState.addOperands(max_num_elements);
  odsState.addTypes(handle);
}

void EmptyTensorListOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value element_shape, ::mlir::Value max_num_elements) {
  odsState.addOperands(element_shape);
  odsState.addOperands(max_num_elements);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void EmptyTensorListOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult EmptyTensorListOp::verify() {
  if (failed(EmptyTensorListOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of 32/64-bit signed integer values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of 32-bit integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::VariantType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::VariantRefType>()))))) {
        return emitOpError("result #") << index << " must be tensor of variant values, but got " << v.getType();
      }
      ++index;
    }
  }
  // This is required to populate derived attributes during export in a
    // meaningful way. Else during export to GraphDef element_type() query
    // will result in out of bounds access/assert.
    if (handle_dtype().getSubtypes().size() != 1) {
      return emitOpError(
          "must have exactly one subtype in the result variant type");
    }

    return Verify(*this);
}

void EmptyTensorListOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::EnqueueTPUEmbeddingRaggedTensorBatchOp definitions
//===----------------------------------------------------------------------===//

EnqueueTPUEmbeddingRaggedTensorBatchOpAdaptor::EnqueueTPUEmbeddingRaggedTensorBatchOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

EnqueueTPUEmbeddingRaggedTensorBatchOpAdaptor::EnqueueTPUEmbeddingRaggedTensorBatchOpAdaptor(EnqueueTPUEmbeddingRaggedTensorBatchOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> EnqueueTPUEmbeddingRaggedTensorBatchOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  bool isVariadic[] = {true, true, true, false};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (odsOperands.size() - 1) / 3;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::mlir::ValueRange EnqueueTPUEmbeddingRaggedTensorBatchOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::ValueRange EnqueueTPUEmbeddingRaggedTensorBatchOpAdaptor::sample_splits() {
  return getODSOperands(0);
}

::mlir::ValueRange EnqueueTPUEmbeddingRaggedTensorBatchOpAdaptor::embedding_indices() {
  return getODSOperands(1);
}

::mlir::ValueRange EnqueueTPUEmbeddingRaggedTensorBatchOpAdaptor::aggregation_weights() {
  return getODSOperands(2);
}

::mlir::Value EnqueueTPUEmbeddingRaggedTensorBatchOpAdaptor::mode_override() {
  return *getODSOperands(3).begin();
}

::mlir::IntegerAttr EnqueueTPUEmbeddingRaggedTensorBatchOpAdaptor::device_ordinal() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::IntegerAttr attr = odsAttrs.get("device_ordinal").dyn_cast_or_null<::mlir::IntegerAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getIntegerAttr(::mlir::Builder(odsAttrs.getContext()).getIntegerType(64), -1);
  return attr;
}

::mlir::ArrayAttr EnqueueTPUEmbeddingRaggedTensorBatchOpAdaptor::combiners() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::ArrayAttr attr = odsAttrs.get("combiners").dyn_cast_or_null<::mlir::ArrayAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getStrArrayAttr({});
  return attr;
}

::mlir::ArrayAttr EnqueueTPUEmbeddingRaggedTensorBatchOpAdaptor::table_ids() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::ArrayAttr attr = odsAttrs.get("table_ids").cast<::mlir::ArrayAttr>();
  return attr;
}

::mlir::ArrayAttr EnqueueTPUEmbeddingRaggedTensorBatchOpAdaptor::max_sequence_lengths() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::ArrayAttr attr = odsAttrs.get("max_sequence_lengths").dyn_cast_or_null<::mlir::ArrayAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getI64ArrayAttr({});
  return attr;
}

::mlir::LogicalResult EnqueueTPUEmbeddingRaggedTensorBatchOpAdaptor::verify(::mlir::Location loc) {
  {
  auto tblgen_device_ordinal = odsAttrs.get("device_ordinal");
  if (tblgen_device_ordinal) {
    if (!(((tblgen_device_ordinal.isa<::mlir::IntegerAttr>())) && ((tblgen_device_ordinal.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(64))))) return emitError(loc, "'tf.EnqueueTPUEmbeddingRaggedTensorBatch' op ""attribute 'device_ordinal' failed to satisfy constraint: 64-bit signless integer attribute");
  }
  }
  {
  auto tblgen_combiners = odsAttrs.get("combiners");
  if (tblgen_combiners) {
    if (!(((tblgen_combiners.isa<::mlir::ArrayAttr>())) && (::llvm::all_of(tblgen_combiners.cast<::mlir::ArrayAttr>(), [](::mlir::Attribute attr) { return (attr.isa<::mlir::StringAttr>()); })))) return emitError(loc, "'tf.EnqueueTPUEmbeddingRaggedTensorBatch' op ""attribute 'combiners' failed to satisfy constraint: string array attribute");
  }
  }
  {
  auto tblgen_table_ids = odsAttrs.get("table_ids");
  if (!tblgen_table_ids) return emitError(loc, "'tf.EnqueueTPUEmbeddingRaggedTensorBatch' op ""requires attribute 'table_ids'");
    if (!(((tblgen_table_ids.isa<::mlir::ArrayAttr>())) && (::llvm::all_of(tblgen_table_ids.cast<::mlir::ArrayAttr>(), [](::mlir::Attribute attr) { return ((attr.isa<::mlir::IntegerAttr>())) && ((attr.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(64))); })))) return emitError(loc, "'tf.EnqueueTPUEmbeddingRaggedTensorBatch' op ""attribute 'table_ids' failed to satisfy constraint: 64-bit integer array attribute");
  }
  {
  auto tblgen_max_sequence_lengths = odsAttrs.get("max_sequence_lengths");
  if (tblgen_max_sequence_lengths) {
    if (!(((tblgen_max_sequence_lengths.isa<::mlir::ArrayAttr>())) && (::llvm::all_of(tblgen_max_sequence_lengths.cast<::mlir::ArrayAttr>(), [](::mlir::Attribute attr) { return ((attr.isa<::mlir::IntegerAttr>())) && ((attr.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(64))); })))) return emitError(loc, "'tf.EnqueueTPUEmbeddingRaggedTensorBatch' op ""attribute 'max_sequence_lengths' failed to satisfy constraint: 64-bit integer array attribute");
  }
  }
  return ::mlir::success();
}

::llvm::StringRef EnqueueTPUEmbeddingRaggedTensorBatchOp::getOperationName() {
  return "tf.EnqueueTPUEmbeddingRaggedTensorBatch";
}

std::pair<unsigned, unsigned> EnqueueTPUEmbeddingRaggedTensorBatchOp::getODSOperandIndexAndLength(unsigned index) {
  bool isVariadic[] = {true, true, true, false};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (getOperation()->getNumOperands() - 1) / 3;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::mlir::Operation::operand_range EnqueueTPUEmbeddingRaggedTensorBatchOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Operation::operand_range EnqueueTPUEmbeddingRaggedTensorBatchOp::sample_splits() {
  return getODSOperands(0);
}

::mlir::Operation::operand_range EnqueueTPUEmbeddingRaggedTensorBatchOp::embedding_indices() {
  return getODSOperands(1);
}

::mlir::Operation::operand_range EnqueueTPUEmbeddingRaggedTensorBatchOp::aggregation_weights() {
  return getODSOperands(2);
}

::mlir::Value EnqueueTPUEmbeddingRaggedTensorBatchOp::mode_override() {
  return *getODSOperands(3).begin();
}

::mlir::MutableOperandRange EnqueueTPUEmbeddingRaggedTensorBatchOp::sample_splitsMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange EnqueueTPUEmbeddingRaggedTensorBatchOp::embedding_indicesMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange EnqueueTPUEmbeddingRaggedTensorBatchOp::aggregation_weightsMutable() {
  auto range = getODSOperandIndexAndLength(2);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange EnqueueTPUEmbeddingRaggedTensorBatchOp::mode_overrideMutable() {
  auto range = getODSOperandIndexAndLength(3);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> EnqueueTPUEmbeddingRaggedTensorBatchOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range EnqueueTPUEmbeddingRaggedTensorBatchOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::IntegerAttr EnqueueTPUEmbeddingRaggedTensorBatchOp::device_ordinalAttr() {
  return this->getAttr("device_ordinal").dyn_cast_or_null<::mlir::IntegerAttr>();
}

uint64_t EnqueueTPUEmbeddingRaggedTensorBatchOp::device_ordinal() {
  auto attr = device_ordinalAttr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getIntegerAttr(::mlir::Builder(this->getContext()).getIntegerType(64), -1).getValue().getZExtValue();
  return attr.getValue().getZExtValue();
}

::mlir::ArrayAttr EnqueueTPUEmbeddingRaggedTensorBatchOp::combinersAttr() {
  return this->getAttr("combiners").dyn_cast_or_null<::mlir::ArrayAttr>();
}

::mlir::ArrayAttr EnqueueTPUEmbeddingRaggedTensorBatchOp::combiners() {
  auto attr = combinersAttr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getStrArrayAttr({});
  return attr;
}

::mlir::ArrayAttr EnqueueTPUEmbeddingRaggedTensorBatchOp::table_idsAttr() {
  return this->getAttr("table_ids").cast<::mlir::ArrayAttr>();
}

::mlir::ArrayAttr EnqueueTPUEmbeddingRaggedTensorBatchOp::table_ids() {
  auto attr = table_idsAttr();
  return attr;
}

::mlir::ArrayAttr EnqueueTPUEmbeddingRaggedTensorBatchOp::max_sequence_lengthsAttr() {
  return this->getAttr("max_sequence_lengths").dyn_cast_or_null<::mlir::ArrayAttr>();
}

::mlir::ArrayAttr EnqueueTPUEmbeddingRaggedTensorBatchOp::max_sequence_lengths() {
  auto attr = max_sequence_lengthsAttr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getI64ArrayAttr({});
  return attr;
}

Type EnqueueTPUEmbeddingRaggedTensorBatchOp::T1() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

Type EnqueueTPUEmbeddingRaggedTensorBatchOp::T2() {
  return mlir::getElementTypeOrSelf(*getODSOperands(1).begin());
}

Type EnqueueTPUEmbeddingRaggedTensorBatchOp::T3() {
  return mlir::getElementTypeOrSelf(*getODSOperands(2).begin());
}

size_t EnqueueTPUEmbeddingRaggedTensorBatchOp::N() {
  auto range = getODSOperands(0);
return std::distance(range.begin(), range.end());
}

bool EnqueueTPUEmbeddingRaggedTensorBatchOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "T1") return true;
  if (name == "T2") return true;
  if (name == "T3") return true;
  if (name == "N") return true;
 return false;
}

::mlir::DictionaryAttr EnqueueTPUEmbeddingRaggedTensorBatchOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("T1", ctx),
::mlir::TypeAttr::get(T1())},
    {::mlir::Identifier::get("T2", ctx),
::mlir::TypeAttr::get(T2())},
    {::mlir::Identifier::get("T3", ctx),
::mlir::TypeAttr::get(T3())},
    {::mlir::Identifier::get("N", ctx),
odsBuilder.getI64IntegerAttr(N())}
    }, ctx);
}

void EnqueueTPUEmbeddingRaggedTensorBatchOp::device_ordinalAttr(::mlir::IntegerAttr attr) {
  this->getOperation()->setAttr("device_ordinal", attr);
}

void EnqueueTPUEmbeddingRaggedTensorBatchOp::combinersAttr(::mlir::ArrayAttr attr) {
  this->getOperation()->setAttr("combiners", attr);
}

void EnqueueTPUEmbeddingRaggedTensorBatchOp::table_idsAttr(::mlir::ArrayAttr attr) {
  this->getOperation()->setAttr("table_ids", attr);
}

void EnqueueTPUEmbeddingRaggedTensorBatchOp::max_sequence_lengthsAttr(::mlir::ArrayAttr attr) {
  this->getOperation()->setAttr("max_sequence_lengths", attr);
}

void EnqueueTPUEmbeddingRaggedTensorBatchOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange sample_splits, ::mlir::ValueRange embedding_indices, ::mlir::ValueRange aggregation_weights, ::mlir::Value mode_override, ::mlir::IntegerAttr device_ordinal, ::mlir::ArrayAttr combiners, ::mlir::ArrayAttr table_ids, ::mlir::ArrayAttr max_sequence_lengths) {
  odsState.addOperands(sample_splits);
  odsState.addOperands(embedding_indices);
  odsState.addOperands(aggregation_weights);
  odsState.addOperands(mode_override);
  odsState.addAttribute("device_ordinal", device_ordinal);
  odsState.addAttribute("combiners", combiners);
  odsState.addAttribute("table_ids", table_ids);
  odsState.addAttribute("max_sequence_lengths", max_sequence_lengths);
}

void EnqueueTPUEmbeddingRaggedTensorBatchOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange sample_splits, ::mlir::ValueRange embedding_indices, ::mlir::ValueRange aggregation_weights, ::mlir::Value mode_override, ::mlir::IntegerAttr device_ordinal, ::mlir::ArrayAttr combiners, ::mlir::ArrayAttr table_ids, ::mlir::ArrayAttr max_sequence_lengths) {
  odsState.addOperands(sample_splits);
  odsState.addOperands(embedding_indices);
  odsState.addOperands(aggregation_weights);
  odsState.addOperands(mode_override);
  odsState.addAttribute("device_ordinal", device_ordinal);
  odsState.addAttribute("combiners", combiners);
  odsState.addAttribute("table_ids", table_ids);
  odsState.addAttribute("max_sequence_lengths", max_sequence_lengths);
  assert(resultTypes.size() == 0u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void EnqueueTPUEmbeddingRaggedTensorBatchOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange sample_splits, ::mlir::ValueRange embedding_indices, ::mlir::ValueRange aggregation_weights, ::mlir::Value mode_override, uint64_t device_ordinal, ::mlir::ArrayAttr combiners, ::mlir::ArrayAttr table_ids, ::mlir::ArrayAttr max_sequence_lengths) {
  odsState.addOperands(sample_splits);
  odsState.addOperands(embedding_indices);
  odsState.addOperands(aggregation_weights);
  odsState.addOperands(mode_override);
  odsState.addAttribute("device_ordinal", odsBuilder.getIntegerAttr(odsBuilder.getIntegerType(64), device_ordinal));
  odsState.addAttribute("combiners", combiners);
  odsState.addAttribute("table_ids", table_ids);
  odsState.addAttribute("max_sequence_lengths", max_sequence_lengths);
}

void EnqueueTPUEmbeddingRaggedTensorBatchOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange sample_splits, ::mlir::ValueRange embedding_indices, ::mlir::ValueRange aggregation_weights, ::mlir::Value mode_override, uint64_t device_ordinal, ::mlir::ArrayAttr combiners, ::mlir::ArrayAttr table_ids, ::mlir::ArrayAttr max_sequence_lengths) {
  odsState.addOperands(sample_splits);
  odsState.addOperands(embedding_indices);
  odsState.addOperands(aggregation_weights);
  odsState.addOperands(mode_override);
  odsState.addAttribute("device_ordinal", odsBuilder.getIntegerAttr(odsBuilder.getIntegerType(64), device_ordinal));
  odsState.addAttribute("combiners", combiners);
  odsState.addAttribute("table_ids", table_ids);
  odsState.addAttribute("max_sequence_lengths", max_sequence_lengths);
  assert(resultTypes.size() == 0u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void EnqueueTPUEmbeddingRaggedTensorBatchOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() >= 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 0u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult EnqueueTPUEmbeddingRaggedTensorBatchOp::verify() {
  if (failed(EnqueueTPUEmbeddingRaggedTensorBatchOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of 32/64-bit signed integer values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of 32/64-bit signed integer values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup2 = getODSOperands(2);
    for (::mlir::Value v : valueGroup2) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of 32/64-bit float values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup3 = getODSOperands(3);
    for (::mlir::Value v : valueGroup3) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::StringType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::StringRefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of string values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
  }
  return ::mlir::success();
}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::EnqueueTPUEmbeddingSparseTensorBatchOp definitions
//===----------------------------------------------------------------------===//

EnqueueTPUEmbeddingSparseTensorBatchOpAdaptor::EnqueueTPUEmbeddingSparseTensorBatchOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

EnqueueTPUEmbeddingSparseTensorBatchOpAdaptor::EnqueueTPUEmbeddingSparseTensorBatchOpAdaptor(EnqueueTPUEmbeddingSparseTensorBatchOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> EnqueueTPUEmbeddingSparseTensorBatchOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  bool isVariadic[] = {true, true, true, false};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (odsOperands.size() - 1) / 3;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::mlir::ValueRange EnqueueTPUEmbeddingSparseTensorBatchOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::ValueRange EnqueueTPUEmbeddingSparseTensorBatchOpAdaptor::sample_indices() {
  return getODSOperands(0);
}

::mlir::ValueRange EnqueueTPUEmbeddingSparseTensorBatchOpAdaptor::embedding_indices() {
  return getODSOperands(1);
}

::mlir::ValueRange EnqueueTPUEmbeddingSparseTensorBatchOpAdaptor::aggregation_weights() {
  return getODSOperands(2);
}

::mlir::Value EnqueueTPUEmbeddingSparseTensorBatchOpAdaptor::mode_override() {
  return *getODSOperands(3).begin();
}

::mlir::IntegerAttr EnqueueTPUEmbeddingSparseTensorBatchOpAdaptor::device_ordinal() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::IntegerAttr attr = odsAttrs.get("device_ordinal").dyn_cast_or_null<::mlir::IntegerAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getIntegerAttr(::mlir::Builder(odsAttrs.getContext()).getIntegerType(64), -1);
  return attr;
}

::mlir::ArrayAttr EnqueueTPUEmbeddingSparseTensorBatchOpAdaptor::combiners() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::ArrayAttr attr = odsAttrs.get("combiners").dyn_cast_or_null<::mlir::ArrayAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getStrArrayAttr({});
  return attr;
}

::mlir::ArrayAttr EnqueueTPUEmbeddingSparseTensorBatchOpAdaptor::table_ids() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::ArrayAttr attr = odsAttrs.get("table_ids").cast<::mlir::ArrayAttr>();
  return attr;
}

::mlir::ArrayAttr EnqueueTPUEmbeddingSparseTensorBatchOpAdaptor::max_sequence_lengths() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::ArrayAttr attr = odsAttrs.get("max_sequence_lengths").dyn_cast_or_null<::mlir::ArrayAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getI64ArrayAttr({});
  return attr;
}

::mlir::LogicalResult EnqueueTPUEmbeddingSparseTensorBatchOpAdaptor::verify(::mlir::Location loc) {
  {
  auto tblgen_device_ordinal = odsAttrs.get("device_ordinal");
  if (tblgen_device_ordinal) {
    if (!(((tblgen_device_ordinal.isa<::mlir::IntegerAttr>())) && ((tblgen_device_ordinal.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(64))))) return emitError(loc, "'tf.EnqueueTPUEmbeddingSparseTensorBatch' op ""attribute 'device_ordinal' failed to satisfy constraint: 64-bit signless integer attribute");
  }
  }
  {
  auto tblgen_combiners = odsAttrs.get("combiners");
  if (tblgen_combiners) {
    if (!(((tblgen_combiners.isa<::mlir::ArrayAttr>())) && (::llvm::all_of(tblgen_combiners.cast<::mlir::ArrayAttr>(), [](::mlir::Attribute attr) { return (attr.isa<::mlir::StringAttr>()); })))) return emitError(loc, "'tf.EnqueueTPUEmbeddingSparseTensorBatch' op ""attribute 'combiners' failed to satisfy constraint: string array attribute");
  }
  }
  {
  auto tblgen_table_ids = odsAttrs.get("table_ids");
  if (!tblgen_table_ids) return emitError(loc, "'tf.EnqueueTPUEmbeddingSparseTensorBatch' op ""requires attribute 'table_ids'");
    if (!(((tblgen_table_ids.isa<::mlir::ArrayAttr>())) && (::llvm::all_of(tblgen_table_ids.cast<::mlir::ArrayAttr>(), [](::mlir::Attribute attr) { return ((attr.isa<::mlir::IntegerAttr>())) && ((attr.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(64))); })))) return emitError(loc, "'tf.EnqueueTPUEmbeddingSparseTensorBatch' op ""attribute 'table_ids' failed to satisfy constraint: 64-bit integer array attribute");
  }
  {
  auto tblgen_max_sequence_lengths = odsAttrs.get("max_sequence_lengths");
  if (tblgen_max_sequence_lengths) {
    if (!(((tblgen_max_sequence_lengths.isa<::mlir::ArrayAttr>())) && (::llvm::all_of(tblgen_max_sequence_lengths.cast<::mlir::ArrayAttr>(), [](::mlir::Attribute attr) { return ((attr.isa<::mlir::IntegerAttr>())) && ((attr.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(64))); })))) return emitError(loc, "'tf.EnqueueTPUEmbeddingSparseTensorBatch' op ""attribute 'max_sequence_lengths' failed to satisfy constraint: 64-bit integer array attribute");
  }
  }
  return ::mlir::success();
}

::llvm::StringRef EnqueueTPUEmbeddingSparseTensorBatchOp::getOperationName() {
  return "tf.EnqueueTPUEmbeddingSparseTensorBatch";
}

std::pair<unsigned, unsigned> EnqueueTPUEmbeddingSparseTensorBatchOp::getODSOperandIndexAndLength(unsigned index) {
  bool isVariadic[] = {true, true, true, false};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (getOperation()->getNumOperands() - 1) / 3;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::mlir::Operation::operand_range EnqueueTPUEmbeddingSparseTensorBatchOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Operation::operand_range EnqueueTPUEmbeddingSparseTensorBatchOp::sample_indices() {
  return getODSOperands(0);
}

::mlir::Operation::operand_range EnqueueTPUEmbeddingSparseTensorBatchOp::embedding_indices() {
  return getODSOperands(1);
}

::mlir::Operation::operand_range EnqueueTPUEmbeddingSparseTensorBatchOp::aggregation_weights() {
  return getODSOperands(2);
}

::mlir::Value EnqueueTPUEmbeddingSparseTensorBatchOp::mode_override() {
  return *getODSOperands(3).begin();
}

::mlir::MutableOperandRange EnqueueTPUEmbeddingSparseTensorBatchOp::sample_indicesMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange EnqueueTPUEmbeddingSparseTensorBatchOp::embedding_indicesMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange EnqueueTPUEmbeddingSparseTensorBatchOp::aggregation_weightsMutable() {
  auto range = getODSOperandIndexAndLength(2);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange EnqueueTPUEmbeddingSparseTensorBatchOp::mode_overrideMutable() {
  auto range = getODSOperandIndexAndLength(3);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> EnqueueTPUEmbeddingSparseTensorBatchOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range EnqueueTPUEmbeddingSparseTensorBatchOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::IntegerAttr EnqueueTPUEmbeddingSparseTensorBatchOp::device_ordinalAttr() {
  return this->getAttr("device_ordinal").dyn_cast_or_null<::mlir::IntegerAttr>();
}

uint64_t EnqueueTPUEmbeddingSparseTensorBatchOp::device_ordinal() {
  auto attr = device_ordinalAttr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getIntegerAttr(::mlir::Builder(this->getContext()).getIntegerType(64), -1).getValue().getZExtValue();
  return attr.getValue().getZExtValue();
}

::mlir::ArrayAttr EnqueueTPUEmbeddingSparseTensorBatchOp::combinersAttr() {
  return this->getAttr("combiners").dyn_cast_or_null<::mlir::ArrayAttr>();
}

::mlir::ArrayAttr EnqueueTPUEmbeddingSparseTensorBatchOp::combiners() {
  auto attr = combinersAttr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getStrArrayAttr({});
  return attr;
}

::mlir::ArrayAttr EnqueueTPUEmbeddingSparseTensorBatchOp::table_idsAttr() {
  return this->getAttr("table_ids").cast<::mlir::ArrayAttr>();
}

::mlir::ArrayAttr EnqueueTPUEmbeddingSparseTensorBatchOp::table_ids() {
  auto attr = table_idsAttr();
  return attr;
}

::mlir::ArrayAttr EnqueueTPUEmbeddingSparseTensorBatchOp::max_sequence_lengthsAttr() {
  return this->getAttr("max_sequence_lengths").dyn_cast_or_null<::mlir::ArrayAttr>();
}

::mlir::ArrayAttr EnqueueTPUEmbeddingSparseTensorBatchOp::max_sequence_lengths() {
  auto attr = max_sequence_lengthsAttr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getI64ArrayAttr({});
  return attr;
}

Type EnqueueTPUEmbeddingSparseTensorBatchOp::T1() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

Type EnqueueTPUEmbeddingSparseTensorBatchOp::T2() {
  return mlir::getElementTypeOrSelf(*getODSOperands(1).begin());
}

Type EnqueueTPUEmbeddingSparseTensorBatchOp::T3() {
  return mlir::getElementTypeOrSelf(*getODSOperands(2).begin());
}

size_t EnqueueTPUEmbeddingSparseTensorBatchOp::N() {
  auto range = getODSOperands(0);
return std::distance(range.begin(), range.end());
}

bool EnqueueTPUEmbeddingSparseTensorBatchOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "T1") return true;
  if (name == "T2") return true;
  if (name == "T3") return true;
  if (name == "N") return true;
 return false;
}

::mlir::DictionaryAttr EnqueueTPUEmbeddingSparseTensorBatchOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("T1", ctx),
::mlir::TypeAttr::get(T1())},
    {::mlir::Identifier::get("T2", ctx),
::mlir::TypeAttr::get(T2())},
    {::mlir::Identifier::get("T3", ctx),
::mlir::TypeAttr::get(T3())},
    {::mlir::Identifier::get("N", ctx),
odsBuilder.getI64IntegerAttr(N())}
    }, ctx);
}

void EnqueueTPUEmbeddingSparseTensorBatchOp::device_ordinalAttr(::mlir::IntegerAttr attr) {
  this->getOperation()->setAttr("device_ordinal", attr);
}

void EnqueueTPUEmbeddingSparseTensorBatchOp::combinersAttr(::mlir::ArrayAttr attr) {
  this->getOperation()->setAttr("combiners", attr);
}

void EnqueueTPUEmbeddingSparseTensorBatchOp::table_idsAttr(::mlir::ArrayAttr attr) {
  this->getOperation()->setAttr("table_ids", attr);
}

void EnqueueTPUEmbeddingSparseTensorBatchOp::max_sequence_lengthsAttr(::mlir::ArrayAttr attr) {
  this->getOperation()->setAttr("max_sequence_lengths", attr);
}

void EnqueueTPUEmbeddingSparseTensorBatchOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange sample_indices, ::mlir::ValueRange embedding_indices, ::mlir::ValueRange aggregation_weights, ::mlir::Value mode_override, ::mlir::IntegerAttr device_ordinal, ::mlir::ArrayAttr combiners, ::mlir::ArrayAttr table_ids, ::mlir::ArrayAttr max_sequence_lengths) {
  odsState.addOperands(sample_indices);
  odsState.addOperands(embedding_indices);
  odsState.addOperands(aggregation_weights);
  odsState.addOperands(mode_override);
  odsState.addAttribute("device_ordinal", device_ordinal);
  odsState.addAttribute("combiners", combiners);
  odsState.addAttribute("table_ids", table_ids);
  odsState.addAttribute("max_sequence_lengths", max_sequence_lengths);
}

void EnqueueTPUEmbeddingSparseTensorBatchOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange sample_indices, ::mlir::ValueRange embedding_indices, ::mlir::ValueRange aggregation_weights, ::mlir::Value mode_override, ::mlir::IntegerAttr device_ordinal, ::mlir::ArrayAttr combiners, ::mlir::ArrayAttr table_ids, ::mlir::ArrayAttr max_sequence_lengths) {
  odsState.addOperands(sample_indices);
  odsState.addOperands(embedding_indices);
  odsState.addOperands(aggregation_weights);
  odsState.addOperands(mode_override);
  odsState.addAttribute("device_ordinal", device_ordinal);
  odsState.addAttribute("combiners", combiners);
  odsState.addAttribute("table_ids", table_ids);
  odsState.addAttribute("max_sequence_lengths", max_sequence_lengths);
  assert(resultTypes.size() == 0u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void EnqueueTPUEmbeddingSparseTensorBatchOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange sample_indices, ::mlir::ValueRange embedding_indices, ::mlir::ValueRange aggregation_weights, ::mlir::Value mode_override, uint64_t device_ordinal, ::mlir::ArrayAttr combiners, ::mlir::ArrayAttr table_ids, ::mlir::ArrayAttr max_sequence_lengths) {
  odsState.addOperands(sample_indices);
  odsState.addOperands(embedding_indices);
  odsState.addOperands(aggregation_weights);
  odsState.addOperands(mode_override);
  odsState.addAttribute("device_ordinal", odsBuilder.getIntegerAttr(odsBuilder.getIntegerType(64), device_ordinal));
  odsState.addAttribute("combiners", combiners);
  odsState.addAttribute("table_ids", table_ids);
  odsState.addAttribute("max_sequence_lengths", max_sequence_lengths);
}

void EnqueueTPUEmbeddingSparseTensorBatchOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange sample_indices, ::mlir::ValueRange embedding_indices, ::mlir::ValueRange aggregation_weights, ::mlir::Value mode_override, uint64_t device_ordinal, ::mlir::ArrayAttr combiners, ::mlir::ArrayAttr table_ids, ::mlir::ArrayAttr max_sequence_lengths) {
  odsState.addOperands(sample_indices);
  odsState.addOperands(embedding_indices);
  odsState.addOperands(aggregation_weights);
  odsState.addOperands(mode_override);
  odsState.addAttribute("device_ordinal", odsBuilder.getIntegerAttr(odsBuilder.getIntegerType(64), device_ordinal));
  odsState.addAttribute("combiners", combiners);
  odsState.addAttribute("table_ids", table_ids);
  odsState.addAttribute("max_sequence_lengths", max_sequence_lengths);
  assert(resultTypes.size() == 0u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void EnqueueTPUEmbeddingSparseTensorBatchOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() >= 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 0u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult EnqueueTPUEmbeddingSparseTensorBatchOp::verify() {
  if (failed(EnqueueTPUEmbeddingSparseTensorBatchOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of 32/64-bit signed integer values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of 32/64-bit signed integer values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup2 = getODSOperands(2);
    for (::mlir::Value v : valueGroup2) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of 32/64-bit float values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup3 = getODSOperands(3);
    for (::mlir::Value v : valueGroup3) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::StringType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::StringRefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of string values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
  }
  return ::mlir::success();
}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::EnsureShapeOp definitions
//===----------------------------------------------------------------------===//

EnsureShapeOpAdaptor::EnsureShapeOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

EnsureShapeOpAdaptor::EnsureShapeOpAdaptor(EnsureShapeOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> EnsureShapeOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange EnsureShapeOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value EnsureShapeOpAdaptor::input() {
  return *getODSOperands(0).begin();
}

Attribute EnsureShapeOpAdaptor::shape() {
  assert(odsAttrs && "no attributes when constructing adapter");
  Attribute attr = odsAttrs.get("shape").cast<Attribute>();
  return attr;
}

::mlir::LogicalResult EnsureShapeOpAdaptor::verify(::mlir::Location loc) {
  {
  auto tblgen_shape = odsAttrs.get("shape");
  if (!tblgen_shape) return emitError(loc, "'tf.EnsureShape' op ""requires attribute 'shape'");
    if (!((tblgen_shape.isa<mlir::TF::ShapeAttr>()))) return emitError(loc, "'tf.EnsureShape' op ""attribute 'shape' failed to satisfy constraint: TensorFlow shape attribute");
  }
  return ::mlir::success();
}

::llvm::StringRef EnsureShapeOp::getOperationName() {
  return "tf.EnsureShape";
}

std::pair<unsigned, unsigned> EnsureShapeOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range EnsureShapeOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value EnsureShapeOp::input() {
  return *getODSOperands(0).begin();
}

::mlir::MutableOperandRange EnsureShapeOp::inputMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> EnsureShapeOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range EnsureShapeOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value EnsureShapeOp::output() {
  return *getODSResults(0).begin();
}

Attribute EnsureShapeOp::shapeAttr() {
  return this->getAttr("shape").cast<Attribute>();
}

llvm::Optional<llvm::ArrayRef<int64_t>> EnsureShapeOp::shape() {
  auto attr = shapeAttr();
  return attr.cast<mlir::TF::ShapeAttr>().getValue();
}

Type EnsureShapeOp::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

bool EnsureShapeOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "T") return true;
 return false;
}

::mlir::DictionaryAttr EnsureShapeOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())}
    }, ctx);
}

void EnsureShapeOp::shapeAttr(Attribute attr) {
  this->getOperation()->setAttr("shape", attr);
}

void EnsureShapeOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value input, Attribute shape) {
  odsState.addOperands(input);
  odsState.addAttribute("shape", shape);
  odsState.addTypes(output);
}

void EnsureShapeOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input, Attribute shape) {
  odsState.addOperands(input);
  odsState.addAttribute("shape", shape);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void EnsureShapeOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value input, llvm::Optional<llvm::ArrayRef<int64_t>> shape) {
  odsState.addOperands(input);
  odsState.addAttribute("shape", mlir::TF::ShapeAttr::get(odsBuilder.getContext(), shape));
  odsState.addTypes(output);
}

void EnsureShapeOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input, llvm::Optional<llvm::ArrayRef<int64_t>> shape) {
  odsState.addOperands(input);
  odsState.addAttribute("shape", mlir::TF::ShapeAttr::get(odsBuilder.getContext(), shape));
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void EnsureShapeOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult EnsureShapeOp::verify() {
  if (failed(EnsureShapeOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>())))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::TensorFlowType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of tf.dtype values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>())))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::TensorFlowType>()))))) {
        return emitOpError("result #") << index << " must be tensor of tf.dtype values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void EnsureShapeOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::EqualOp definitions
//===----------------------------------------------------------------------===//

EqualOpAdaptor::EqualOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

EqualOpAdaptor::EqualOpAdaptor(EqualOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> EqualOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange EqualOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value EqualOpAdaptor::x() {
  return *getODSOperands(0).begin();
}

::mlir::Value EqualOpAdaptor::y() {
  return *getODSOperands(1).begin();
}

::mlir::BoolAttr EqualOpAdaptor::incompatible_shape_error() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::BoolAttr attr = odsAttrs.get("incompatible_shape_error").dyn_cast_or_null<::mlir::BoolAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getBoolAttr(true);
  return attr;
}

::mlir::LogicalResult EqualOpAdaptor::verify(::mlir::Location loc) {
  {
  auto tblgen_incompatible_shape_error = odsAttrs.get("incompatible_shape_error");
  if (tblgen_incompatible_shape_error) {
    if (!((tblgen_incompatible_shape_error.isa<::mlir::BoolAttr>()))) return emitError(loc, "'tf.Equal' op ""attribute 'incompatible_shape_error' failed to satisfy constraint: bool attribute");
  }
  }
  return ::mlir::success();
}

::llvm::StringRef EqualOp::getOperationName() {
  return "tf.Equal";
}

std::pair<unsigned, unsigned> EqualOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range EqualOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value EqualOp::x() {
  return *getODSOperands(0).begin();
}

::mlir::Value EqualOp::y() {
  return *getODSOperands(1).begin();
}

::mlir::MutableOperandRange EqualOp::xMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange EqualOp::yMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> EqualOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range EqualOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value EqualOp::z() {
  return *getODSResults(0).begin();
}

::mlir::BoolAttr EqualOp::incompatible_shape_errorAttr() {
  return this->getAttr("incompatible_shape_error").dyn_cast_or_null<::mlir::BoolAttr>();
}

bool EqualOp::incompatible_shape_error() {
  auto attr = incompatible_shape_errorAttr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getBoolAttr(true).getValue();
  return attr.getValue();
}

Type EqualOp::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

bool EqualOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "T") return true;
 return false;
}

::mlir::DictionaryAttr EqualOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())}
    }, ctx);
}

void EqualOp::incompatible_shape_errorAttr(::mlir::BoolAttr attr) {
  this->getOperation()->setAttr("incompatible_shape_error", attr);
}



void EqualOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type z, ::mlir::Value x, ::mlir::Value y, ::mlir::BoolAttr incompatible_shape_error) {
  odsState.addOperands(x);
  odsState.addOperands(y);
  odsState.addAttribute("incompatible_shape_error", incompatible_shape_error);
  odsState.addTypes(z);
}

void EqualOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value x, ::mlir::Value y, ::mlir::BoolAttr incompatible_shape_error) {
  odsState.addOperands(x);
  odsState.addOperands(y);
  odsState.addAttribute("incompatible_shape_error", incompatible_shape_error);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void EqualOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type z, ::mlir::Value x, ::mlir::Value y, bool incompatible_shape_error) {
  odsState.addOperands(x);
  odsState.addOperands(y);
  odsState.addAttribute("incompatible_shape_error", odsBuilder.getBoolAttr(incompatible_shape_error));
  odsState.addTypes(z);
}

void EqualOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value x, ::mlir::Value y, bool incompatible_shape_error) {
  odsState.addOperands(x);
  odsState.addOperands(y);
  odsState.addAttribute("incompatible_shape_error", odsBuilder.getBoolAttr(incompatible_shape_error));
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void EqualOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult EqualOp::verify() {
  if (failed(EqualOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint16Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint16Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::StringType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::StringRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of bfloat16 or bool or 128-bit complex or 64-bit complex or 16-bit float or 32-bit float or 64-bit float or 16-bit integer or 32-bit integer or 64-bit integer or 8-bit integer or 16-bit quantized integer or 16-bit quantized unsigned integer or 32-bit quantized integer or 8-bit quantized integer or 8-bit quantized unsigned integer or string or 16-bit unsigned integer or 32-bit unsigned integer or 64-bit unsigned integer or 8-bit unsigned integer values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint16Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint16Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::StringType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::StringRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of bfloat16 or bool or 128-bit complex or 64-bit complex or 16-bit float or 32-bit float or 64-bit float or 16-bit integer or 32-bit integer or 64-bit integer or 8-bit integer or 16-bit quantized integer or 16-bit quantized unsigned integer or 32-bit quantized integer or 8-bit quantized integer or 8-bit quantized unsigned integer or string or 16-bit unsigned integer or 32-bit unsigned integer or 64-bit unsigned integer or 8-bit unsigned integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))))) {
        return emitOpError("result #") << index << " must be tensor of bool values, but got " << v.getType();
      }
      ++index;
    }
  }
  return Verify(*this);
}

void EqualOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::ErfOp definitions
//===----------------------------------------------------------------------===//

ErfOpAdaptor::ErfOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

ErfOpAdaptor::ErfOpAdaptor(ErfOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> ErfOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange ErfOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value ErfOpAdaptor::x() {
  return *getODSOperands(0).begin();
}

::mlir::LogicalResult ErfOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

::llvm::StringRef ErfOp::getOperationName() {
  return "tf.Erf";
}

std::pair<unsigned, unsigned> ErfOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range ErfOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value ErfOp::x() {
  return *getODSOperands(0).begin();
}

::mlir::MutableOperandRange ErfOp::xMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> ErfOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range ErfOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value ErfOp::y() {
  return *getODSResults(0).begin();
}

Type ErfOp::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

bool ErfOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "T") return true;
 return false;
}

::mlir::DictionaryAttr ErfOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())}
    }, ctx);
}

void ErfOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type y, ::mlir::Value x) {
  odsState.addOperands(x);
  odsState.addTypes(y);
}

void ErfOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value x) {
  odsState.addOperands(x);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void ErfOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

void ErfOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value x) {
  odsState.addOperands(x);
  odsState.addTypes({x.getType()});

}

void ErfOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  odsState.addTypes({operands[0].getType()});

}

::mlir::LogicalResult ErfOp::verify() {
  if (failed(ErfOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of floating-point values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))))) {
        return emitOpError("result #") << index << " must be tensor of floating-point values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void ErfOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::ErfcOp definitions
//===----------------------------------------------------------------------===//

ErfcOpAdaptor::ErfcOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

ErfcOpAdaptor::ErfcOpAdaptor(ErfcOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> ErfcOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange ErfcOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value ErfcOpAdaptor::x() {
  return *getODSOperands(0).begin();
}

::mlir::LogicalResult ErfcOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

::llvm::StringRef ErfcOp::getOperationName() {
  return "tf.Erfc";
}

std::pair<unsigned, unsigned> ErfcOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range ErfcOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value ErfcOp::x() {
  return *getODSOperands(0).begin();
}

::mlir::MutableOperandRange ErfcOp::xMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> ErfcOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range ErfcOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value ErfcOp::y() {
  return *getODSResults(0).begin();
}

Type ErfcOp::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

bool ErfcOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "T") return true;
 return false;
}

::mlir::DictionaryAttr ErfcOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())}
    }, ctx);
}

void ErfcOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type y, ::mlir::Value x) {
  odsState.addOperands(x);
  odsState.addTypes(y);
}

void ErfcOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value x) {
  odsState.addOperands(x);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void ErfcOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

void ErfcOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value x) {
  odsState.addOperands(x);
  odsState.addTypes({x.getType()});

}

void ErfcOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  odsState.addTypes({operands[0].getType()});

}

::mlir::LogicalResult ErfcOp::verify() {
  if (failed(ErfcOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of floating-point values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))))) {
        return emitOpError("result #") << index << " must be tensor of floating-point values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void ErfcOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::ErfinvOp definitions
//===----------------------------------------------------------------------===//

ErfinvOpAdaptor::ErfinvOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

ErfinvOpAdaptor::ErfinvOpAdaptor(ErfinvOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> ErfinvOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange ErfinvOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value ErfinvOpAdaptor::x() {
  return *getODSOperands(0).begin();
}

::mlir::LogicalResult ErfinvOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

::llvm::StringRef ErfinvOp::getOperationName() {
  return "tf.Erfinv";
}

std::pair<unsigned, unsigned> ErfinvOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range ErfinvOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value ErfinvOp::x() {
  return *getODSOperands(0).begin();
}

::mlir::MutableOperandRange ErfinvOp::xMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> ErfinvOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range ErfinvOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value ErfinvOp::y() {
  return *getODSResults(0).begin();
}

Type ErfinvOp::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

bool ErfinvOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "T") return true;
 return false;
}

::mlir::DictionaryAttr ErfinvOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())}
    }, ctx);
}

void ErfinvOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type y, ::mlir::Value x) {
  odsState.addOperands(x);
  odsState.addTypes(y);
}

void ErfinvOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value x) {
  odsState.addOperands(x);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void ErfinvOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult ErfinvOp::verify() {
  if (failed(ErfinvOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of floating-point values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))))) {
        return emitOpError("result #") << index << " must be tensor of floating-point values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void ErfinvOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::ExpOp definitions
//===----------------------------------------------------------------------===//

ExpOpAdaptor::ExpOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

ExpOpAdaptor::ExpOpAdaptor(ExpOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> ExpOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange ExpOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value ExpOpAdaptor::x() {
  return *getODSOperands(0).begin();
}

::mlir::LogicalResult ExpOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

::llvm::StringRef ExpOp::getOperationName() {
  return "tf.Exp";
}

std::pair<unsigned, unsigned> ExpOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range ExpOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value ExpOp::x() {
  return *getODSOperands(0).begin();
}

::mlir::MutableOperandRange ExpOp::xMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> ExpOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range ExpOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value ExpOp::y() {
  return *getODSResults(0).begin();
}

Type ExpOp::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

bool ExpOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "T") return true;
 return false;
}

::mlir::DictionaryAttr ExpOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())}
    }, ctx);
}

void ExpOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type y, ::mlir::Value x) {
  odsState.addOperands(x);
  odsState.addTypes(y);
}

void ExpOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value x) {
  odsState.addOperands(x);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void ExpOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

void ExpOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value x) {
  odsState.addOperands(x);
  odsState.addTypes({x.getType()});

}

void ExpOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  odsState.addTypes({operands[0].getType()});

}

::mlir::LogicalResult ExpOp::verify() {
  if (failed(ExpOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))))))) {
        return emitOpError("operand #") << index << " must be tensor of floating-point or complex values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))))))) {
        return emitOpError("result #") << index << " must be tensor of floating-point or complex values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void ExpOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::ExpandDimsOp definitions
//===----------------------------------------------------------------------===//

ExpandDimsOpAdaptor::ExpandDimsOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

ExpandDimsOpAdaptor::ExpandDimsOpAdaptor(ExpandDimsOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> ExpandDimsOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange ExpandDimsOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value ExpandDimsOpAdaptor::input() {
  return *getODSOperands(0).begin();
}

::mlir::Value ExpandDimsOpAdaptor::dim() {
  return *getODSOperands(1).begin();
}

::mlir::LogicalResult ExpandDimsOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

::llvm::StringRef ExpandDimsOp::getOperationName() {
  return "tf.ExpandDims";
}

std::pair<unsigned, unsigned> ExpandDimsOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range ExpandDimsOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value ExpandDimsOp::input() {
  return *getODSOperands(0).begin();
}

::mlir::Value ExpandDimsOp::dim() {
  return *getODSOperands(1).begin();
}

::mlir::MutableOperandRange ExpandDimsOp::inputMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange ExpandDimsOp::dimMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> ExpandDimsOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range ExpandDimsOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value ExpandDimsOp::output() {
  return *getODSResults(0).begin();
}

Type ExpandDimsOp::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

Type ExpandDimsOp::Tdim() {
  return mlir::getElementTypeOrSelf(*getODSOperands(1).begin());
}

bool ExpandDimsOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "T") return true;
  if (name == "Tdim") return true;
 return false;
}

::mlir::DictionaryAttr ExpandDimsOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())},
    {::mlir::Identifier::get("Tdim", ctx),
::mlir::TypeAttr::get(Tdim())}
    }, ctx);
}



void ExpandDimsOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value input, ::mlir::Value dim) {
  odsState.addOperands(input);
  odsState.addOperands(dim);
  odsState.addTypes(output);
}

void ExpandDimsOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input, ::mlir::Value dim) {
  odsState.addOperands(input);
  odsState.addOperands(dim);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void ExpandDimsOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult ExpandDimsOp::verify() {
  if (failed(ExpandDimsOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>())))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::TensorFlowType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of tf.dtype values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of 32/64-bit signed integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>())))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::TensorFlowType>()))))) {
        return emitOpError("result #") << index << " must be tensor of tf.dtype values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void ExpandDimsOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::Expm1Op definitions
//===----------------------------------------------------------------------===//

Expm1OpAdaptor::Expm1OpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

Expm1OpAdaptor::Expm1OpAdaptor(Expm1Op&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> Expm1OpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange Expm1OpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value Expm1OpAdaptor::x() {
  return *getODSOperands(0).begin();
}

::mlir::LogicalResult Expm1OpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

::llvm::StringRef Expm1Op::getOperationName() {
  return "tf.Expm1";
}

std::pair<unsigned, unsigned> Expm1Op::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range Expm1Op::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value Expm1Op::x() {
  return *getODSOperands(0).begin();
}

::mlir::MutableOperandRange Expm1Op::xMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> Expm1Op::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range Expm1Op::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value Expm1Op::y() {
  return *getODSResults(0).begin();
}

Type Expm1Op::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

bool Expm1Op::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "T") return true;
 return false;
}

::mlir::DictionaryAttr Expm1Op::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())}
    }, ctx);
}

void Expm1Op::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type y, ::mlir::Value x) {
  odsState.addOperands(x);
  odsState.addTypes(y);
}

void Expm1Op::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value x) {
  odsState.addOperands(x);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void Expm1Op::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

void Expm1Op::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value x) {
  odsState.addOperands(x);
  odsState.addTypes({x.getType()});

}

void Expm1Op::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  odsState.addTypes({operands[0].getType()});

}

::mlir::LogicalResult Expm1Op::verify() {
  if (failed(Expm1OpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))))))) {
        return emitOpError("operand #") << index << " must be tensor of floating-point or complex values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))))))) {
        return emitOpError("result #") << index << " must be tensor of floating-point or complex values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void Expm1Op::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::ExtractImagePatchesOp definitions
//===----------------------------------------------------------------------===//

ExtractImagePatchesOpAdaptor::ExtractImagePatchesOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

ExtractImagePatchesOpAdaptor::ExtractImagePatchesOpAdaptor(ExtractImagePatchesOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> ExtractImagePatchesOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange ExtractImagePatchesOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value ExtractImagePatchesOpAdaptor::images() {
  return *getODSOperands(0).begin();
}

::mlir::ArrayAttr ExtractImagePatchesOpAdaptor::ksizes() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::ArrayAttr attr = odsAttrs.get("ksizes").cast<::mlir::ArrayAttr>();
  return attr;
}

::mlir::ArrayAttr ExtractImagePatchesOpAdaptor::strides() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::ArrayAttr attr = odsAttrs.get("strides").cast<::mlir::ArrayAttr>();
  return attr;
}

::mlir::ArrayAttr ExtractImagePatchesOpAdaptor::rates() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::ArrayAttr attr = odsAttrs.get("rates").cast<::mlir::ArrayAttr>();
  return attr;
}

::mlir::StringAttr ExtractImagePatchesOpAdaptor::padding() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::StringAttr attr = odsAttrs.get("padding").cast<::mlir::StringAttr>();
  return attr;
}

::mlir::LogicalResult ExtractImagePatchesOpAdaptor::verify(::mlir::Location loc) {
  {
  auto tblgen_ksizes = odsAttrs.get("ksizes");
  if (!tblgen_ksizes) return emitError(loc, "'tf.ExtractImagePatches' op ""requires attribute 'ksizes'");
    if (!((((tblgen_ksizes.isa<::mlir::ArrayAttr>())) && (::llvm::all_of(tblgen_ksizes.cast<::mlir::ArrayAttr>(), [](::mlir::Attribute attr) { return ((attr.isa<::mlir::IntegerAttr>())) && ((attr.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(64))); }))) && ((tblgen_ksizes.cast<::mlir::ArrayAttr>().size() >= 4)))) return emitError(loc, "'tf.ExtractImagePatches' op ""attribute 'ksizes' failed to satisfy constraint: 64-bit integer array attribute with at least 4 elements");
  }
  {
  auto tblgen_strides = odsAttrs.get("strides");
  if (!tblgen_strides) return emitError(loc, "'tf.ExtractImagePatches' op ""requires attribute 'strides'");
    if (!((((tblgen_strides.isa<::mlir::ArrayAttr>())) && (::llvm::all_of(tblgen_strides.cast<::mlir::ArrayAttr>(), [](::mlir::Attribute attr) { return ((attr.isa<::mlir::IntegerAttr>())) && ((attr.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(64))); }))) && ((tblgen_strides.cast<::mlir::ArrayAttr>().size() >= 4)))) return emitError(loc, "'tf.ExtractImagePatches' op ""attribute 'strides' failed to satisfy constraint: 64-bit integer array attribute with at least 4 elements");
  }
  {
  auto tblgen_rates = odsAttrs.get("rates");
  if (!tblgen_rates) return emitError(loc, "'tf.ExtractImagePatches' op ""requires attribute 'rates'");
    if (!((((tblgen_rates.isa<::mlir::ArrayAttr>())) && (::llvm::all_of(tblgen_rates.cast<::mlir::ArrayAttr>(), [](::mlir::Attribute attr) { return ((attr.isa<::mlir::IntegerAttr>())) && ((attr.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(64))); }))) && ((tblgen_rates.cast<::mlir::ArrayAttr>().size() >= 4)))) return emitError(loc, "'tf.ExtractImagePatches' op ""attribute 'rates' failed to satisfy constraint: 64-bit integer array attribute with at least 4 elements");
  }
  {
  auto tblgen_padding = odsAttrs.get("padding");
  if (!tblgen_padding) return emitError(loc, "'tf.ExtractImagePatches' op ""requires attribute 'padding'");
    if (!((tblgen_padding.cast<StringAttr>().getValue() == "SAME" || tblgen_padding.cast<StringAttr>().getValue() == "VALID"))) return emitError(loc, "'tf.ExtractImagePatches' op ""attribute 'padding' failed to satisfy constraint: string attribute whose value is SAME, or VALID");
  }
  return ::mlir::success();
}

::llvm::StringRef ExtractImagePatchesOp::getOperationName() {
  return "tf.ExtractImagePatches";
}

std::pair<unsigned, unsigned> ExtractImagePatchesOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range ExtractImagePatchesOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value ExtractImagePatchesOp::images() {
  return *getODSOperands(0).begin();
}

::mlir::MutableOperandRange ExtractImagePatchesOp::imagesMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> ExtractImagePatchesOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range ExtractImagePatchesOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value ExtractImagePatchesOp::patches() {
  return *getODSResults(0).begin();
}

::mlir::ArrayAttr ExtractImagePatchesOp::ksizesAttr() {
  return this->getAttr("ksizes").cast<::mlir::ArrayAttr>();
}

::mlir::ArrayAttr ExtractImagePatchesOp::ksizes() {
  auto attr = ksizesAttr();
  return attr;
}

::mlir::ArrayAttr ExtractImagePatchesOp::stridesAttr() {
  return this->getAttr("strides").cast<::mlir::ArrayAttr>();
}

::mlir::ArrayAttr ExtractImagePatchesOp::strides() {
  auto attr = stridesAttr();
  return attr;
}

::mlir::ArrayAttr ExtractImagePatchesOp::ratesAttr() {
  return this->getAttr("rates").cast<::mlir::ArrayAttr>();
}

::mlir::ArrayAttr ExtractImagePatchesOp::rates() {
  auto attr = ratesAttr();
  return attr;
}

::mlir::StringAttr ExtractImagePatchesOp::paddingAttr() {
  return this->getAttr("padding").cast<::mlir::StringAttr>();
}

::llvm::StringRef ExtractImagePatchesOp::padding() {
  auto attr = paddingAttr();
  return attr.getValue();
}

Type ExtractImagePatchesOp::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

bool ExtractImagePatchesOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "T") return true;
 return false;
}

::mlir::DictionaryAttr ExtractImagePatchesOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())}
    }, ctx);
}

void ExtractImagePatchesOp::ksizesAttr(::mlir::ArrayAttr attr) {
  this->getOperation()->setAttr("ksizes", attr);
}

void ExtractImagePatchesOp::stridesAttr(::mlir::ArrayAttr attr) {
  this->getOperation()->setAttr("strides", attr);
}

void ExtractImagePatchesOp::ratesAttr(::mlir::ArrayAttr attr) {
  this->getOperation()->setAttr("rates", attr);
}

void ExtractImagePatchesOp::paddingAttr(::mlir::StringAttr attr) {
  this->getOperation()->setAttr("padding", attr);
}

void ExtractImagePatchesOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type patches, ::mlir::Value images, ::mlir::ArrayAttr ksizes, ::mlir::ArrayAttr strides, ::mlir::ArrayAttr rates, ::mlir::StringAttr padding) {
  odsState.addOperands(images);
  odsState.addAttribute("ksizes", ksizes);
  odsState.addAttribute("strides", strides);
  odsState.addAttribute("rates", rates);
  odsState.addAttribute("padding", padding);
  odsState.addTypes(patches);
}

void ExtractImagePatchesOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value images, ::mlir::ArrayAttr ksizes, ::mlir::ArrayAttr strides, ::mlir::ArrayAttr rates, ::mlir::StringAttr padding) {
  odsState.addOperands(images);
  odsState.addAttribute("ksizes", ksizes);
  odsState.addAttribute("strides", strides);
  odsState.addAttribute("rates", rates);
  odsState.addAttribute("padding", padding);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void ExtractImagePatchesOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type patches, ::mlir::Value images, ::mlir::ArrayAttr ksizes, ::mlir::ArrayAttr strides, ::mlir::ArrayAttr rates, ::llvm::StringRef padding) {
  odsState.addOperands(images);
  odsState.addAttribute("ksizes", ksizes);
  odsState.addAttribute("strides", strides);
  odsState.addAttribute("rates", rates);
  odsState.addAttribute("padding", odsBuilder.getStringAttr(padding));
  odsState.addTypes(patches);
}

void ExtractImagePatchesOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value images, ::mlir::ArrayAttr ksizes, ::mlir::ArrayAttr strides, ::mlir::ArrayAttr rates, ::llvm::StringRef padding) {
  odsState.addOperands(images);
  odsState.addAttribute("ksizes", ksizes);
  odsState.addAttribute("strides", strides);
  odsState.addAttribute("rates", rates);
  odsState.addAttribute("padding", odsBuilder.getStringAttr(padding));
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void ExtractImagePatchesOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult ExtractImagePatchesOp::verify() {
  if (failed(ExtractImagePatchesOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of bfloat16 or bool or 128-bit complex or 64-bit complex or 16-bit float or 32-bit float or 64-bit float or 16-bit integer or 32-bit integer or 64-bit integer or 8-bit integer or 16-bit unsigned integer or 32-bit unsigned integer or 64-bit unsigned integer or 8-bit unsigned integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>())))))) {
        return emitOpError("result #") << index << " must be tensor of bfloat16 or bool or 128-bit complex or 64-bit complex or 16-bit float or 32-bit float or 64-bit float or 16-bit integer or 32-bit integer or 64-bit integer or 8-bit integer or 16-bit unsigned integer or 32-bit unsigned integer or 64-bit unsigned integer or 8-bit unsigned integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void ExtractImagePatchesOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::FFT2DOp definitions
//===----------------------------------------------------------------------===//

FFT2DOpAdaptor::FFT2DOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

FFT2DOpAdaptor::FFT2DOpAdaptor(FFT2DOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> FFT2DOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange FFT2DOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value FFT2DOpAdaptor::input() {
  return *getODSOperands(0).begin();
}

::mlir::LogicalResult FFT2DOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

::llvm::StringRef FFT2DOp::getOperationName() {
  return "tf.FFT2D";
}

std::pair<unsigned, unsigned> FFT2DOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range FFT2DOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value FFT2DOp::input() {
  return *getODSOperands(0).begin();
}

::mlir::MutableOperandRange FFT2DOp::inputMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> FFT2DOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range FFT2DOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value FFT2DOp::output() {
  return *getODSResults(0).begin();
}

Type FFT2DOp::Tcomplex() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

bool FFT2DOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "Tcomplex") return true;
 return false;
}

::mlir::DictionaryAttr FFT2DOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("Tcomplex", ctx),
::mlir::TypeAttr::get(Tcomplex())}
    }, ctx);
}

void FFT2DOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value input) {
  odsState.addOperands(input);
  odsState.addTypes(output);
}

void FFT2DOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input) {
  odsState.addOperands(input);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void FFT2DOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult FFT2DOp::verify() {
  if (failed(FFT2DOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of 128-bit complex or 64-bit complex values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>())))))) {
        return emitOpError("result #") << index << " must be tensor of 128-bit complex or 64-bit complex values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void FFT2DOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::FFT3DOp definitions
//===----------------------------------------------------------------------===//

FFT3DOpAdaptor::FFT3DOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

FFT3DOpAdaptor::FFT3DOpAdaptor(FFT3DOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> FFT3DOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange FFT3DOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value FFT3DOpAdaptor::input() {
  return *getODSOperands(0).begin();
}

::mlir::LogicalResult FFT3DOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

::llvm::StringRef FFT3DOp::getOperationName() {
  return "tf.FFT3D";
}

std::pair<unsigned, unsigned> FFT3DOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range FFT3DOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value FFT3DOp::input() {
  return *getODSOperands(0).begin();
}

::mlir::MutableOperandRange FFT3DOp::inputMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> FFT3DOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range FFT3DOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value FFT3DOp::output() {
  return *getODSResults(0).begin();
}

Type FFT3DOp::Tcomplex() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

bool FFT3DOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "Tcomplex") return true;
 return false;
}

::mlir::DictionaryAttr FFT3DOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("Tcomplex", ctx),
::mlir::TypeAttr::get(Tcomplex())}
    }, ctx);
}

void FFT3DOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value input) {
  odsState.addOperands(input);
  odsState.addTypes(output);
}

void FFT3DOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input) {
  odsState.addOperands(input);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void FFT3DOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult FFT3DOp::verify() {
  if (failed(FFT3DOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of 128-bit complex or 64-bit complex values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>())))))) {
        return emitOpError("result #") << index << " must be tensor of 128-bit complex or 64-bit complex values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void FFT3DOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::FFTOp definitions
//===----------------------------------------------------------------------===//

FFTOpAdaptor::FFTOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

FFTOpAdaptor::FFTOpAdaptor(FFTOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> FFTOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange FFTOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value FFTOpAdaptor::input() {
  return *getODSOperands(0).begin();
}

::mlir::LogicalResult FFTOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

::llvm::StringRef FFTOp::getOperationName() {
  return "tf.FFT";
}

std::pair<unsigned, unsigned> FFTOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range FFTOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value FFTOp::input() {
  return *getODSOperands(0).begin();
}

::mlir::MutableOperandRange FFTOp::inputMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> FFTOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range FFTOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value FFTOp::output() {
  return *getODSResults(0).begin();
}

Type FFTOp::Tcomplex() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

bool FFTOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "Tcomplex") return true;
 return false;
}

::mlir::DictionaryAttr FFTOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("Tcomplex", ctx),
::mlir::TypeAttr::get(Tcomplex())}
    }, ctx);
}

void FFTOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value input) {
  odsState.addOperands(input);
  odsState.addTypes(output);
}

void FFTOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input) {
  odsState.addOperands(input);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void FFTOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult FFTOp::verify() {
  if (failed(FFTOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of 128-bit complex or 64-bit complex values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>())))))) {
        return emitOpError("result #") << index << " must be tensor of 128-bit complex or 64-bit complex values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void FFTOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::FakeParamOp definitions
//===----------------------------------------------------------------------===//

FakeParamOpAdaptor::FakeParamOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

FakeParamOpAdaptor::FakeParamOpAdaptor(FakeParamOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> FakeParamOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange FakeParamOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

Attribute FakeParamOpAdaptor::shape() {
  assert(odsAttrs && "no attributes when constructing adapter");
  Attribute attr = odsAttrs.get("shape").cast<Attribute>();
  return attr;
}

::mlir::LogicalResult FakeParamOpAdaptor::verify(::mlir::Location loc) {
  {
  auto tblgen_shape = odsAttrs.get("shape");
  if (!tblgen_shape) return emitError(loc, "'tf.FakeParam' op ""requires attribute 'shape'");
    if (!((tblgen_shape.isa<mlir::TF::ShapeAttr>()))) return emitError(loc, "'tf.FakeParam' op ""attribute 'shape' failed to satisfy constraint: TensorFlow shape attribute");
  }
  return ::mlir::success();
}

::llvm::StringRef FakeParamOp::getOperationName() {
  return "tf.FakeParam";
}

std::pair<unsigned, unsigned> FakeParamOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range FakeParamOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

std::pair<unsigned, unsigned> FakeParamOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range FakeParamOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value FakeParamOp::output() {
  return *getODSResults(0).begin();
}

Attribute FakeParamOp::shapeAttr() {
  return this->getAttr("shape").cast<Attribute>();
}

llvm::Optional<llvm::ArrayRef<int64_t>> FakeParamOp::shape() {
  auto attr = shapeAttr();
  return attr.cast<mlir::TF::ShapeAttr>().getValue();
}

Type FakeParamOp::dtype() {
  return mlir::getElementTypeOrSelf(*getODSResults(0).begin());
}

bool FakeParamOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "dtype") return true;
 return false;
}

::mlir::DictionaryAttr FakeParamOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("dtype", ctx),
::mlir::TypeAttr::get(dtype())}
    }, ctx);
}

void FakeParamOp::shapeAttr(Attribute attr) {
  this->getOperation()->setAttr("shape", attr);
}

void FakeParamOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, Attribute shape) {
  odsState.addAttribute("shape", shape);
  odsState.addTypes(output);
}

void FakeParamOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, Attribute shape) {
  odsState.addAttribute("shape", shape);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void FakeParamOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, llvm::Optional<llvm::ArrayRef<int64_t>> shape) {
  odsState.addAttribute("shape", mlir::TF::ShapeAttr::get(odsBuilder.getContext(), shape));
  odsState.addTypes(output);
}

void FakeParamOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, llvm::Optional<llvm::ArrayRef<int64_t>> shape) {
  odsState.addAttribute("shape", mlir::TF::ShapeAttr::get(odsBuilder.getContext(), shape));
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void FakeParamOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 0u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult FakeParamOp::verify() {
  if (failed(FakeParamOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>())))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::TensorFlowType>()))))) {
        return emitOpError("result #") << index << " must be tensor of tf.dtype values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void FakeParamOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::FakeQuantWithMinMaxArgsGradientOp definitions
//===----------------------------------------------------------------------===//

FakeQuantWithMinMaxArgsGradientOpAdaptor::FakeQuantWithMinMaxArgsGradientOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

FakeQuantWithMinMaxArgsGradientOpAdaptor::FakeQuantWithMinMaxArgsGradientOpAdaptor(FakeQuantWithMinMaxArgsGradientOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> FakeQuantWithMinMaxArgsGradientOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange FakeQuantWithMinMaxArgsGradientOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value FakeQuantWithMinMaxArgsGradientOpAdaptor::gradients() {
  return *getODSOperands(0).begin();
}

::mlir::Value FakeQuantWithMinMaxArgsGradientOpAdaptor::inputs() {
  return *getODSOperands(1).begin();
}

::mlir::FloatAttr FakeQuantWithMinMaxArgsGradientOpAdaptor::min() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::FloatAttr attr = odsAttrs.get("min").dyn_cast_or_null<::mlir::FloatAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getFloatAttr(::mlir::Builder(odsAttrs.getContext()).getF32Type(), -6.0f);
  return attr;
}

::mlir::FloatAttr FakeQuantWithMinMaxArgsGradientOpAdaptor::max() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::FloatAttr attr = odsAttrs.get("max").dyn_cast_or_null<::mlir::FloatAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getFloatAttr(::mlir::Builder(odsAttrs.getContext()).getF32Type(), 6.0f);
  return attr;
}

::mlir::IntegerAttr FakeQuantWithMinMaxArgsGradientOpAdaptor::num_bits() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::IntegerAttr attr = odsAttrs.get("num_bits").dyn_cast_or_null<::mlir::IntegerAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getIntegerAttr(::mlir::Builder(odsAttrs.getContext()).getIntegerType(64), 8);
  return attr;
}

::mlir::BoolAttr FakeQuantWithMinMaxArgsGradientOpAdaptor::narrow_range() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::BoolAttr attr = odsAttrs.get("narrow_range").dyn_cast_or_null<::mlir::BoolAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getBoolAttr(false);
  return attr;
}

::mlir::LogicalResult FakeQuantWithMinMaxArgsGradientOpAdaptor::verify(::mlir::Location loc) {
  {
  auto tblgen_min = odsAttrs.get("min");
  if (tblgen_min) {
    if (!(((tblgen_min.isa<::mlir::FloatAttr>())) && ((tblgen_min.cast<::mlir::FloatAttr>().getType().isF32())))) return emitError(loc, "'tf.FakeQuantWithMinMaxArgsGradient' op ""attribute 'min' failed to satisfy constraint: 32-bit float attribute");
  }
  }
  {
  auto tblgen_max = odsAttrs.get("max");
  if (tblgen_max) {
    if (!(((tblgen_max.isa<::mlir::FloatAttr>())) && ((tblgen_max.cast<::mlir::FloatAttr>().getType().isF32())))) return emitError(loc, "'tf.FakeQuantWithMinMaxArgsGradient' op ""attribute 'max' failed to satisfy constraint: 32-bit float attribute");
  }
  }
  {
  auto tblgen_num_bits = odsAttrs.get("num_bits");
  if (tblgen_num_bits) {
    if (!(((tblgen_num_bits.isa<::mlir::IntegerAttr>())) && ((tblgen_num_bits.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(64))))) return emitError(loc, "'tf.FakeQuantWithMinMaxArgsGradient' op ""attribute 'num_bits' failed to satisfy constraint: 64-bit signless integer attribute");
  }
  }
  {
  auto tblgen_narrow_range = odsAttrs.get("narrow_range");
  if (tblgen_narrow_range) {
    if (!((tblgen_narrow_range.isa<::mlir::BoolAttr>()))) return emitError(loc, "'tf.FakeQuantWithMinMaxArgsGradient' op ""attribute 'narrow_range' failed to satisfy constraint: bool attribute");
  }
  }
  return ::mlir::success();
}

::llvm::StringRef FakeQuantWithMinMaxArgsGradientOp::getOperationName() {
  return "tf.FakeQuantWithMinMaxArgsGradient";
}

std::pair<unsigned, unsigned> FakeQuantWithMinMaxArgsGradientOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range FakeQuantWithMinMaxArgsGradientOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value FakeQuantWithMinMaxArgsGradientOp::gradients() {
  return *getODSOperands(0).begin();
}

::mlir::Value FakeQuantWithMinMaxArgsGradientOp::inputs() {
  return *getODSOperands(1).begin();
}

::mlir::MutableOperandRange FakeQuantWithMinMaxArgsGradientOp::gradientsMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange FakeQuantWithMinMaxArgsGradientOp::inputsMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> FakeQuantWithMinMaxArgsGradientOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range FakeQuantWithMinMaxArgsGradientOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value FakeQuantWithMinMaxArgsGradientOp::backprops() {
  return *getODSResults(0).begin();
}

::mlir::FloatAttr FakeQuantWithMinMaxArgsGradientOp::minAttr() {
  return this->getAttr("min").dyn_cast_or_null<::mlir::FloatAttr>();
}

::llvm::APFloat FakeQuantWithMinMaxArgsGradientOp::min() {
  auto attr = minAttr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getFloatAttr(::mlir::Builder(this->getContext()).getF32Type(), -6.0f).getValue();
  return attr.getValue();
}

::mlir::FloatAttr FakeQuantWithMinMaxArgsGradientOp::maxAttr() {
  return this->getAttr("max").dyn_cast_or_null<::mlir::FloatAttr>();
}

::llvm::APFloat FakeQuantWithMinMaxArgsGradientOp::max() {
  auto attr = maxAttr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getFloatAttr(::mlir::Builder(this->getContext()).getF32Type(), 6.0f).getValue();
  return attr.getValue();
}

::mlir::IntegerAttr FakeQuantWithMinMaxArgsGradientOp::num_bitsAttr() {
  return this->getAttr("num_bits").dyn_cast_or_null<::mlir::IntegerAttr>();
}

uint64_t FakeQuantWithMinMaxArgsGradientOp::num_bits() {
  auto attr = num_bitsAttr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getIntegerAttr(::mlir::Builder(this->getContext()).getIntegerType(64), 8).getValue().getZExtValue();
  return attr.getValue().getZExtValue();
}

::mlir::BoolAttr FakeQuantWithMinMaxArgsGradientOp::narrow_rangeAttr() {
  return this->getAttr("narrow_range").dyn_cast_or_null<::mlir::BoolAttr>();
}

bool FakeQuantWithMinMaxArgsGradientOp::narrow_range() {
  auto attr = narrow_rangeAttr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getBoolAttr(false).getValue();
  return attr.getValue();
}

void FakeQuantWithMinMaxArgsGradientOp::minAttr(::mlir::FloatAttr attr) {
  this->getOperation()->setAttr("min", attr);
}

void FakeQuantWithMinMaxArgsGradientOp::maxAttr(::mlir::FloatAttr attr) {
  this->getOperation()->setAttr("max", attr);
}

void FakeQuantWithMinMaxArgsGradientOp::num_bitsAttr(::mlir::IntegerAttr attr) {
  this->getOperation()->setAttr("num_bits", attr);
}

void FakeQuantWithMinMaxArgsGradientOp::narrow_rangeAttr(::mlir::BoolAttr attr) {
  this->getOperation()->setAttr("narrow_range", attr);
}

void FakeQuantWithMinMaxArgsGradientOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type backprops, ::mlir::Value gradients, ::mlir::Value inputs, ::mlir::FloatAttr min, ::mlir::FloatAttr max, ::mlir::IntegerAttr num_bits, ::mlir::BoolAttr narrow_range) {
  odsState.addOperands(gradients);
  odsState.addOperands(inputs);
  odsState.addAttribute("min", min);
  odsState.addAttribute("max", max);
  odsState.addAttribute("num_bits", num_bits);
  odsState.addAttribute("narrow_range", narrow_range);
  odsState.addTypes(backprops);
}

void FakeQuantWithMinMaxArgsGradientOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value gradients, ::mlir::Value inputs, ::mlir::FloatAttr min, ::mlir::FloatAttr max, ::mlir::IntegerAttr num_bits, ::mlir::BoolAttr narrow_range) {
  odsState.addOperands(gradients);
  odsState.addOperands(inputs);
  odsState.addAttribute("min", min);
  odsState.addAttribute("max", max);
  odsState.addAttribute("num_bits", num_bits);
  odsState.addAttribute("narrow_range", narrow_range);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void FakeQuantWithMinMaxArgsGradientOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type backprops, ::mlir::Value gradients, ::mlir::Value inputs, ::llvm::APFloat min, ::llvm::APFloat max, uint64_t num_bits, bool narrow_range) {
  odsState.addOperands(gradients);
  odsState.addOperands(inputs);
  odsState.addAttribute("min", odsBuilder.getFloatAttr(odsBuilder.getF32Type(), min));
  odsState.addAttribute("max", odsBuilder.getFloatAttr(odsBuilder.getF32Type(), max));
  odsState.addAttribute("num_bits", odsBuilder.getIntegerAttr(odsBuilder.getIntegerType(64), num_bits));
  odsState.addAttribute("narrow_range", odsBuilder.getBoolAttr(narrow_range));
  odsState.addTypes(backprops);
}

void FakeQuantWithMinMaxArgsGradientOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value gradients, ::mlir::Value inputs, ::llvm::APFloat min, ::llvm::APFloat max, uint64_t num_bits, bool narrow_range) {
  odsState.addOperands(gradients);
  odsState.addOperands(inputs);
  odsState.addAttribute("min", odsBuilder.getFloatAttr(odsBuilder.getF32Type(), min));
  odsState.addAttribute("max", odsBuilder.getFloatAttr(odsBuilder.getF32Type(), max));
  odsState.addAttribute("num_bits", odsBuilder.getIntegerAttr(odsBuilder.getIntegerType(64), num_bits));
  odsState.addAttribute("narrow_range", odsBuilder.getBoolAttr(narrow_range));
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void FakeQuantWithMinMaxArgsGradientOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

void FakeQuantWithMinMaxArgsGradientOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value gradients, ::mlir::Value inputs, ::mlir::FloatAttr min, ::mlir::FloatAttr max, ::mlir::IntegerAttr num_bits, ::mlir::BoolAttr narrow_range) {
  odsState.addOperands(gradients);
  odsState.addOperands(inputs);
  odsState.addAttribute("min", min);
  odsState.addAttribute("max", max);
  odsState.addAttribute("num_bits", num_bits);
  odsState.addAttribute("narrow_range", narrow_range);
  odsState.addTypes({gradients.getType()});

}

void FakeQuantWithMinMaxArgsGradientOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  odsState.addTypes({operands[0].getType()});

}

::mlir::LogicalResult FakeQuantWithMinMaxArgsGradientOp::verify() {
  if (failed(FakeQuantWithMinMaxArgsGradientOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())))) {
        return emitOpError("operand #") << index << " must be tensor of 32-bit float values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())))) {
        return emitOpError("operand #") << index << " must be tensor of 32-bit float values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())))) {
        return emitOpError("result #") << index << " must be tensor of 32-bit float values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void FakeQuantWithMinMaxArgsGradientOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::FakeQuantWithMinMaxArgsOp definitions
//===----------------------------------------------------------------------===//

FakeQuantWithMinMaxArgsOpAdaptor::FakeQuantWithMinMaxArgsOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

FakeQuantWithMinMaxArgsOpAdaptor::FakeQuantWithMinMaxArgsOpAdaptor(FakeQuantWithMinMaxArgsOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> FakeQuantWithMinMaxArgsOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange FakeQuantWithMinMaxArgsOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value FakeQuantWithMinMaxArgsOpAdaptor::inputs() {
  return *getODSOperands(0).begin();
}

::mlir::FloatAttr FakeQuantWithMinMaxArgsOpAdaptor::min() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::FloatAttr attr = odsAttrs.get("min").dyn_cast_or_null<::mlir::FloatAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getFloatAttr(::mlir::Builder(odsAttrs.getContext()).getF32Type(), -6.0f);
  return attr;
}

::mlir::FloatAttr FakeQuantWithMinMaxArgsOpAdaptor::max() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::FloatAttr attr = odsAttrs.get("max").dyn_cast_or_null<::mlir::FloatAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getFloatAttr(::mlir::Builder(odsAttrs.getContext()).getF32Type(), 6.0f);
  return attr;
}

::mlir::IntegerAttr FakeQuantWithMinMaxArgsOpAdaptor::num_bits() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::IntegerAttr attr = odsAttrs.get("num_bits").dyn_cast_or_null<::mlir::IntegerAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getIntegerAttr(::mlir::Builder(odsAttrs.getContext()).getIntegerType(64), 8);
  return attr;
}

::mlir::BoolAttr FakeQuantWithMinMaxArgsOpAdaptor::narrow_range() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::BoolAttr attr = odsAttrs.get("narrow_range").dyn_cast_or_null<::mlir::BoolAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getBoolAttr(false);
  return attr;
}

::mlir::LogicalResult FakeQuantWithMinMaxArgsOpAdaptor::verify(::mlir::Location loc) {
  {
  auto tblgen_min = odsAttrs.get("min");
  if (tblgen_min) {
    if (!(((tblgen_min.isa<::mlir::FloatAttr>())) && ((tblgen_min.cast<::mlir::FloatAttr>().getType().isF32())))) return emitError(loc, "'tf.FakeQuantWithMinMaxArgs' op ""attribute 'min' failed to satisfy constraint: 32-bit float attribute");
  }
  }
  {
  auto tblgen_max = odsAttrs.get("max");
  if (tblgen_max) {
    if (!(((tblgen_max.isa<::mlir::FloatAttr>())) && ((tblgen_max.cast<::mlir::FloatAttr>().getType().isF32())))) return emitError(loc, "'tf.FakeQuantWithMinMaxArgs' op ""attribute 'max' failed to satisfy constraint: 32-bit float attribute");
  }
  }
  {
  auto tblgen_num_bits = odsAttrs.get("num_bits");
  if (tblgen_num_bits) {
    if (!(((tblgen_num_bits.isa<::mlir::IntegerAttr>())) && ((tblgen_num_bits.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(64))))) return emitError(loc, "'tf.FakeQuantWithMinMaxArgs' op ""attribute 'num_bits' failed to satisfy constraint: 64-bit signless integer attribute");
  }
  }
  {
  auto tblgen_narrow_range = odsAttrs.get("narrow_range");
  if (tblgen_narrow_range) {
    if (!((tblgen_narrow_range.isa<::mlir::BoolAttr>()))) return emitError(loc, "'tf.FakeQuantWithMinMaxArgs' op ""attribute 'narrow_range' failed to satisfy constraint: bool attribute");
  }
  }
  return ::mlir::success();
}

::llvm::StringRef FakeQuantWithMinMaxArgsOp::getOperationName() {
  return "tf.FakeQuantWithMinMaxArgs";
}

std::pair<unsigned, unsigned> FakeQuantWithMinMaxArgsOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range FakeQuantWithMinMaxArgsOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value FakeQuantWithMinMaxArgsOp::inputs() {
  return *getODSOperands(0).begin();
}

::mlir::MutableOperandRange FakeQuantWithMinMaxArgsOp::inputsMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> FakeQuantWithMinMaxArgsOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range FakeQuantWithMinMaxArgsOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value FakeQuantWithMinMaxArgsOp::outputs() {
  return *getODSResults(0).begin();
}

::mlir::FloatAttr FakeQuantWithMinMaxArgsOp::minAttr() {
  return this->getAttr("min").dyn_cast_or_null<::mlir::FloatAttr>();
}

::llvm::APFloat FakeQuantWithMinMaxArgsOp::min() {
  auto attr = minAttr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getFloatAttr(::mlir::Builder(this->getContext()).getF32Type(), -6.0f).getValue();
  return attr.getValue();
}

::mlir::FloatAttr FakeQuantWithMinMaxArgsOp::maxAttr() {
  return this->getAttr("max").dyn_cast_or_null<::mlir::FloatAttr>();
}

::llvm::APFloat FakeQuantWithMinMaxArgsOp::max() {
  auto attr = maxAttr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getFloatAttr(::mlir::Builder(this->getContext()).getF32Type(), 6.0f).getValue();
  return attr.getValue();
}

::mlir::IntegerAttr FakeQuantWithMinMaxArgsOp::num_bitsAttr() {
  return this->getAttr("num_bits").dyn_cast_or_null<::mlir::IntegerAttr>();
}

uint64_t FakeQuantWithMinMaxArgsOp::num_bits() {
  auto attr = num_bitsAttr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getIntegerAttr(::mlir::Builder(this->getContext()).getIntegerType(64), 8).getValue().getZExtValue();
  return attr.getValue().getZExtValue();
}

::mlir::BoolAttr FakeQuantWithMinMaxArgsOp::narrow_rangeAttr() {
  return this->getAttr("narrow_range").dyn_cast_or_null<::mlir::BoolAttr>();
}

bool FakeQuantWithMinMaxArgsOp::narrow_range() {
  auto attr = narrow_rangeAttr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getBoolAttr(false).getValue();
  return attr.getValue();
}

void FakeQuantWithMinMaxArgsOp::minAttr(::mlir::FloatAttr attr) {
  this->getOperation()->setAttr("min", attr);
}

void FakeQuantWithMinMaxArgsOp::maxAttr(::mlir::FloatAttr attr) {
  this->getOperation()->setAttr("max", attr);
}

void FakeQuantWithMinMaxArgsOp::num_bitsAttr(::mlir::IntegerAttr attr) {
  this->getOperation()->setAttr("num_bits", attr);
}

void FakeQuantWithMinMaxArgsOp::narrow_rangeAttr(::mlir::BoolAttr attr) {
  this->getOperation()->setAttr("narrow_range", attr);
}

void FakeQuantWithMinMaxArgsOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type outputs, ::mlir::Value inputs, ::mlir::FloatAttr min, ::mlir::FloatAttr max, ::mlir::IntegerAttr num_bits, ::mlir::BoolAttr narrow_range) {
  odsState.addOperands(inputs);
  odsState.addAttribute("min", min);
  odsState.addAttribute("max", max);
  odsState.addAttribute("num_bits", num_bits);
  odsState.addAttribute("narrow_range", narrow_range);
  odsState.addTypes(outputs);
}

void FakeQuantWithMinMaxArgsOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value inputs, ::mlir::FloatAttr min, ::mlir::FloatAttr max, ::mlir::IntegerAttr num_bits, ::mlir::BoolAttr narrow_range) {
  odsState.addOperands(inputs);
  odsState.addAttribute("min", min);
  odsState.addAttribute("max", max);
  odsState.addAttribute("num_bits", num_bits);
  odsState.addAttribute("narrow_range", narrow_range);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void FakeQuantWithMinMaxArgsOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type outputs, ::mlir::Value inputs, ::llvm::APFloat min, ::llvm::APFloat max, uint64_t num_bits, bool narrow_range) {
  odsState.addOperands(inputs);
  odsState.addAttribute("min", odsBuilder.getFloatAttr(odsBuilder.getF32Type(), min));
  odsState.addAttribute("max", odsBuilder.getFloatAttr(odsBuilder.getF32Type(), max));
  odsState.addAttribute("num_bits", odsBuilder.getIntegerAttr(odsBuilder.getIntegerType(64), num_bits));
  odsState.addAttribute("narrow_range", odsBuilder.getBoolAttr(narrow_range));
  odsState.addTypes(outputs);
}

void FakeQuantWithMinMaxArgsOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value inputs, ::llvm::APFloat min, ::llvm::APFloat max, uint64_t num_bits, bool narrow_range) {
  odsState.addOperands(inputs);
  odsState.addAttribute("min", odsBuilder.getFloatAttr(odsBuilder.getF32Type(), min));
  odsState.addAttribute("max", odsBuilder.getFloatAttr(odsBuilder.getF32Type(), max));
  odsState.addAttribute("num_bits", odsBuilder.getIntegerAttr(odsBuilder.getIntegerType(64), num_bits));
  odsState.addAttribute("narrow_range", odsBuilder.getBoolAttr(narrow_range));
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void FakeQuantWithMinMaxArgsOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

void FakeQuantWithMinMaxArgsOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value inputs, ::mlir::FloatAttr min, ::mlir::FloatAttr max, ::mlir::IntegerAttr num_bits, ::mlir::BoolAttr narrow_range) {
  odsState.addOperands(inputs);
  odsState.addAttribute("min", min);
  odsState.addAttribute("max", max);
  odsState.addAttribute("num_bits", num_bits);
  odsState.addAttribute("narrow_range", narrow_range);
  odsState.addTypes({inputs.getType()});

}

void FakeQuantWithMinMaxArgsOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  odsState.addTypes({operands[0].getType()});

}

::mlir::LogicalResult FakeQuantWithMinMaxArgsOp::verify() {
  if (failed(FakeQuantWithMinMaxArgsOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of 32-bit float values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))))) {
        return emitOpError("result #") << index << " must be tensor of 32-bit float values, but got " << v.getType();
      }
      ++index;
    }
  }
  return Verify(*this);
}

void FakeQuantWithMinMaxArgsOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::FakeQuantWithMinMaxVarsGradientOp definitions
//===----------------------------------------------------------------------===//

FakeQuantWithMinMaxVarsGradientOpAdaptor::FakeQuantWithMinMaxVarsGradientOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

FakeQuantWithMinMaxVarsGradientOpAdaptor::FakeQuantWithMinMaxVarsGradientOpAdaptor(FakeQuantWithMinMaxVarsGradientOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> FakeQuantWithMinMaxVarsGradientOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange FakeQuantWithMinMaxVarsGradientOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value FakeQuantWithMinMaxVarsGradientOpAdaptor::gradients() {
  return *getODSOperands(0).begin();
}

::mlir::Value FakeQuantWithMinMaxVarsGradientOpAdaptor::inputs() {
  return *getODSOperands(1).begin();
}

::mlir::Value FakeQuantWithMinMaxVarsGradientOpAdaptor::min() {
  return *getODSOperands(2).begin();
}

::mlir::Value FakeQuantWithMinMaxVarsGradientOpAdaptor::max() {
  return *getODSOperands(3).begin();
}

::mlir::IntegerAttr FakeQuantWithMinMaxVarsGradientOpAdaptor::num_bits() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::IntegerAttr attr = odsAttrs.get("num_bits").dyn_cast_or_null<::mlir::IntegerAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getIntegerAttr(::mlir::Builder(odsAttrs.getContext()).getIntegerType(64), 8);
  return attr;
}

::mlir::BoolAttr FakeQuantWithMinMaxVarsGradientOpAdaptor::narrow_range() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::BoolAttr attr = odsAttrs.get("narrow_range").dyn_cast_or_null<::mlir::BoolAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getBoolAttr(false);
  return attr;
}

::mlir::LogicalResult FakeQuantWithMinMaxVarsGradientOpAdaptor::verify(::mlir::Location loc) {
  {
  auto tblgen_num_bits = odsAttrs.get("num_bits");
  if (tblgen_num_bits) {
    if (!(((tblgen_num_bits.isa<::mlir::IntegerAttr>())) && ((tblgen_num_bits.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(64))))) return emitError(loc, "'tf.FakeQuantWithMinMaxVarsGradient' op ""attribute 'num_bits' failed to satisfy constraint: 64-bit signless integer attribute");
  }
  }
  {
  auto tblgen_narrow_range = odsAttrs.get("narrow_range");
  if (tblgen_narrow_range) {
    if (!((tblgen_narrow_range.isa<::mlir::BoolAttr>()))) return emitError(loc, "'tf.FakeQuantWithMinMaxVarsGradient' op ""attribute 'narrow_range' failed to satisfy constraint: bool attribute");
  }
  }
  return ::mlir::success();
}

void FakeQuantWithMinMaxVarsGradientOp::getAsmResultNames(::mlir::OpAsmSetValueNameFn setNameFn) {
  auto resultGroup0 = getODSResults(0);
  if (!llvm::empty(resultGroup0))
    setNameFn(*resultGroup0.begin(), "backprops_wrt_input");
  auto resultGroup1 = getODSResults(1);
  if (!llvm::empty(resultGroup1))
    setNameFn(*resultGroup1.begin(), "backprop_wrt_min");
  auto resultGroup2 = getODSResults(2);
  if (!llvm::empty(resultGroup2))
    setNameFn(*resultGroup2.begin(), "backprop_wrt_max");
}

::llvm::StringRef FakeQuantWithMinMaxVarsGradientOp::getOperationName() {
  return "tf.FakeQuantWithMinMaxVarsGradient";
}

std::pair<unsigned, unsigned> FakeQuantWithMinMaxVarsGradientOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range FakeQuantWithMinMaxVarsGradientOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value FakeQuantWithMinMaxVarsGradientOp::gradients() {
  return *getODSOperands(0).begin();
}

::mlir::Value FakeQuantWithMinMaxVarsGradientOp::inputs() {
  return *getODSOperands(1).begin();
}

::mlir::Value FakeQuantWithMinMaxVarsGradientOp::min() {
  return *getODSOperands(2).begin();
}

::mlir::Value FakeQuantWithMinMaxVarsGradientOp::max() {
  return *getODSOperands(3).begin();
}

::mlir::MutableOperandRange FakeQuantWithMinMaxVarsGradientOp::gradientsMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange FakeQuantWithMinMaxVarsGradientOp::inputsMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange FakeQuantWithMinMaxVarsGradientOp::minMutable() {
  auto range = getODSOperandIndexAndLength(2);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange FakeQuantWithMinMaxVarsGradientOp::maxMutable() {
  auto range = getODSOperandIndexAndLength(3);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> FakeQuantWithMinMaxVarsGradientOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range FakeQuantWithMinMaxVarsGradientOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value FakeQuantWithMinMaxVarsGradientOp::backprops_wrt_input() {
  return *getODSResults(0).begin();
}

::mlir::Value FakeQuantWithMinMaxVarsGradientOp::backprop_wrt_min() {
  return *getODSResults(1).begin();
}

::mlir::Value FakeQuantWithMinMaxVarsGradientOp::backprop_wrt_max() {
  return *getODSResults(2).begin();
}

::mlir::IntegerAttr FakeQuantWithMinMaxVarsGradientOp::num_bitsAttr() {
  return this->getAttr("num_bits").dyn_cast_or_null<::mlir::IntegerAttr>();
}

uint64_t FakeQuantWithMinMaxVarsGradientOp::num_bits() {
  auto attr = num_bitsAttr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getIntegerAttr(::mlir::Builder(this->getContext()).getIntegerType(64), 8).getValue().getZExtValue();
  return attr.getValue().getZExtValue();
}

::mlir::BoolAttr FakeQuantWithMinMaxVarsGradientOp::narrow_rangeAttr() {
  return this->getAttr("narrow_range").dyn_cast_or_null<::mlir::BoolAttr>();
}

bool FakeQuantWithMinMaxVarsGradientOp::narrow_range() {
  auto attr = narrow_rangeAttr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getBoolAttr(false).getValue();
  return attr.getValue();
}

void FakeQuantWithMinMaxVarsGradientOp::num_bitsAttr(::mlir::IntegerAttr attr) {
  this->getOperation()->setAttr("num_bits", attr);
}

void FakeQuantWithMinMaxVarsGradientOp::narrow_rangeAttr(::mlir::BoolAttr attr) {
  this->getOperation()->setAttr("narrow_range", attr);
}

void FakeQuantWithMinMaxVarsGradientOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type backprops_wrt_input, ::mlir::Type backprop_wrt_min, ::mlir::Type backprop_wrt_max, ::mlir::Value gradients, ::mlir::Value inputs, ::mlir::Value min, ::mlir::Value max, ::mlir::IntegerAttr num_bits, ::mlir::BoolAttr narrow_range) {
  odsState.addOperands(gradients);
  odsState.addOperands(inputs);
  odsState.addOperands(min);
  odsState.addOperands(max);
  odsState.addAttribute("num_bits", num_bits);
  odsState.addAttribute("narrow_range", narrow_range);
  odsState.addTypes(backprops_wrt_input);
  odsState.addTypes(backprop_wrt_min);
  odsState.addTypes(backprop_wrt_max);
}

void FakeQuantWithMinMaxVarsGradientOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value gradients, ::mlir::Value inputs, ::mlir::Value min, ::mlir::Value max, ::mlir::IntegerAttr num_bits, ::mlir::BoolAttr narrow_range) {
  odsState.addOperands(gradients);
  odsState.addOperands(inputs);
  odsState.addOperands(min);
  odsState.addOperands(max);
  odsState.addAttribute("num_bits", num_bits);
  odsState.addAttribute("narrow_range", narrow_range);
  assert(resultTypes.size() == 3u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void FakeQuantWithMinMaxVarsGradientOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type backprops_wrt_input, ::mlir::Type backprop_wrt_min, ::mlir::Type backprop_wrt_max, ::mlir::Value gradients, ::mlir::Value inputs, ::mlir::Value min, ::mlir::Value max, uint64_t num_bits, bool narrow_range) {
  odsState.addOperands(gradients);
  odsState.addOperands(inputs);
  odsState.addOperands(min);
  odsState.addOperands(max);
  odsState.addAttribute("num_bits", odsBuilder.getIntegerAttr(odsBuilder.getIntegerType(64), num_bits));
  odsState.addAttribute("narrow_range", odsBuilder.getBoolAttr(narrow_range));
  odsState.addTypes(backprops_wrt_input);
  odsState.addTypes(backprop_wrt_min);
  odsState.addTypes(backprop_wrt_max);
}

void FakeQuantWithMinMaxVarsGradientOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value gradients, ::mlir::Value inputs, ::mlir::Value min, ::mlir::Value max, uint64_t num_bits, bool narrow_range) {
  odsState.addOperands(gradients);
  odsState.addOperands(inputs);
  odsState.addOperands(min);
  odsState.addOperands(max);
  odsState.addAttribute("num_bits", odsBuilder.getIntegerAttr(odsBuilder.getIntegerType(64), num_bits));
  odsState.addAttribute("narrow_range", odsBuilder.getBoolAttr(narrow_range));
  assert(resultTypes.size() == 3u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void FakeQuantWithMinMaxVarsGradientOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 4u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 3u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult FakeQuantWithMinMaxVarsGradientOp::verify() {
  if (failed(FakeQuantWithMinMaxVarsGradientOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())))) {
        return emitOpError("operand #") << index << " must be tensor of 32-bit float values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())))) {
        return emitOpError("operand #") << index << " must be tensor of 32-bit float values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup2 = getODSOperands(2);
    for (::mlir::Value v : valueGroup2) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())))) {
        return emitOpError("operand #") << index << " must be tensor of 32-bit float values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup3 = getODSOperands(3);
    for (::mlir::Value v : valueGroup3) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())))) {
        return emitOpError("operand #") << index << " must be tensor of 32-bit float values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())))) {
        return emitOpError("result #") << index << " must be tensor of 32-bit float values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSResults(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())))) {
        return emitOpError("result #") << index << " must be tensor of 32-bit float values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup2 = getODSResults(2);
    for (::mlir::Value v : valueGroup2) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())))) {
        return emitOpError("result #") << index << " must be tensor of 32-bit float values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void FakeQuantWithMinMaxVarsGradientOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::FakeQuantWithMinMaxVarsOp definitions
//===----------------------------------------------------------------------===//

FakeQuantWithMinMaxVarsOpAdaptor::FakeQuantWithMinMaxVarsOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

FakeQuantWithMinMaxVarsOpAdaptor::FakeQuantWithMinMaxVarsOpAdaptor(FakeQuantWithMinMaxVarsOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> FakeQuantWithMinMaxVarsOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange FakeQuantWithMinMaxVarsOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value FakeQuantWithMinMaxVarsOpAdaptor::inputs() {
  return *getODSOperands(0).begin();
}

::mlir::Value FakeQuantWithMinMaxVarsOpAdaptor::min() {
  return *getODSOperands(1).begin();
}

::mlir::Value FakeQuantWithMinMaxVarsOpAdaptor::max() {
  return *getODSOperands(2).begin();
}

::mlir::IntegerAttr FakeQuantWithMinMaxVarsOpAdaptor::num_bits() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::IntegerAttr attr = odsAttrs.get("num_bits").dyn_cast_or_null<::mlir::IntegerAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getIntegerAttr(::mlir::Builder(odsAttrs.getContext()).getIntegerType(64), 8);
  return attr;
}

::mlir::BoolAttr FakeQuantWithMinMaxVarsOpAdaptor::narrow_range() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::BoolAttr attr = odsAttrs.get("narrow_range").dyn_cast_or_null<::mlir::BoolAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getBoolAttr(false);
  return attr;
}

::mlir::LogicalResult FakeQuantWithMinMaxVarsOpAdaptor::verify(::mlir::Location loc) {
  {
  auto tblgen_num_bits = odsAttrs.get("num_bits");
  if (tblgen_num_bits) {
    if (!(((tblgen_num_bits.isa<::mlir::IntegerAttr>())) && ((tblgen_num_bits.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(64))))) return emitError(loc, "'tf.FakeQuantWithMinMaxVars' op ""attribute 'num_bits' failed to satisfy constraint: 64-bit signless integer attribute");
  }
  }
  {
  auto tblgen_narrow_range = odsAttrs.get("narrow_range");
  if (tblgen_narrow_range) {
    if (!((tblgen_narrow_range.isa<::mlir::BoolAttr>()))) return emitError(loc, "'tf.FakeQuantWithMinMaxVars' op ""attribute 'narrow_range' failed to satisfy constraint: bool attribute");
  }
  }
  return ::mlir::success();
}

::llvm::StringRef FakeQuantWithMinMaxVarsOp::getOperationName() {
  return "tf.FakeQuantWithMinMaxVars";
}

std::pair<unsigned, unsigned> FakeQuantWithMinMaxVarsOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range FakeQuantWithMinMaxVarsOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value FakeQuantWithMinMaxVarsOp::inputs() {
  return *getODSOperands(0).begin();
}

::mlir::Value FakeQuantWithMinMaxVarsOp::min() {
  return *getODSOperands(1).begin();
}

::mlir::Value FakeQuantWithMinMaxVarsOp::max() {
  return *getODSOperands(2).begin();
}

::mlir::MutableOperandRange FakeQuantWithMinMaxVarsOp::inputsMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange FakeQuantWithMinMaxVarsOp::minMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange FakeQuantWithMinMaxVarsOp::maxMutable() {
  auto range = getODSOperandIndexAndLength(2);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> FakeQuantWithMinMaxVarsOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range FakeQuantWithMinMaxVarsOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value FakeQuantWithMinMaxVarsOp::outputs() {
  return *getODSResults(0).begin();
}

::mlir::IntegerAttr FakeQuantWithMinMaxVarsOp::num_bitsAttr() {
  return this->getAttr("num_bits").dyn_cast_or_null<::mlir::IntegerAttr>();
}

uint64_t FakeQuantWithMinMaxVarsOp::num_bits() {
  auto attr = num_bitsAttr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getIntegerAttr(::mlir::Builder(this->getContext()).getIntegerType(64), 8).getValue().getZExtValue();
  return attr.getValue().getZExtValue();
}

::mlir::BoolAttr FakeQuantWithMinMaxVarsOp::narrow_rangeAttr() {
  return this->getAttr("narrow_range").dyn_cast_or_null<::mlir::BoolAttr>();
}

bool FakeQuantWithMinMaxVarsOp::narrow_range() {
  auto attr = narrow_rangeAttr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getBoolAttr(false).getValue();
  return attr.getValue();
}

void FakeQuantWithMinMaxVarsOp::num_bitsAttr(::mlir::IntegerAttr attr) {
  this->getOperation()->setAttr("num_bits", attr);
}

void FakeQuantWithMinMaxVarsOp::narrow_rangeAttr(::mlir::BoolAttr attr) {
  this->getOperation()->setAttr("narrow_range", attr);
}

void FakeQuantWithMinMaxVarsOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type outputs, ::mlir::Value inputs, ::mlir::Value min, ::mlir::Value max, ::mlir::IntegerAttr num_bits, ::mlir::BoolAttr narrow_range) {
  odsState.addOperands(inputs);
  odsState.addOperands(min);
  odsState.addOperands(max);
  odsState.addAttribute("num_bits", num_bits);
  odsState.addAttribute("narrow_range", narrow_range);
  odsState.addTypes(outputs);
}

void FakeQuantWithMinMaxVarsOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value inputs, ::mlir::Value min, ::mlir::Value max, ::mlir::IntegerAttr num_bits, ::mlir::BoolAttr narrow_range) {
  odsState.addOperands(inputs);
  odsState.addOperands(min);
  odsState.addOperands(max);
  odsState.addAttribute("num_bits", num_bits);
  odsState.addAttribute("narrow_range", narrow_range);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void FakeQuantWithMinMaxVarsOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type outputs, ::mlir::Value inputs, ::mlir::Value min, ::mlir::Value max, uint64_t num_bits, bool narrow_range) {
  odsState.addOperands(inputs);
  odsState.addOperands(min);
  odsState.addOperands(max);
  odsState.addAttribute("num_bits", odsBuilder.getIntegerAttr(odsBuilder.getIntegerType(64), num_bits));
  odsState.addAttribute("narrow_range", odsBuilder.getBoolAttr(narrow_range));
  odsState.addTypes(outputs);
}

void FakeQuantWithMinMaxVarsOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value inputs, ::mlir::Value min, ::mlir::Value max, uint64_t num_bits, bool narrow_range) {
  odsState.addOperands(inputs);
  odsState.addOperands(min);
  odsState.addOperands(max);
  odsState.addAttribute("num_bits", odsBuilder.getIntegerAttr(odsBuilder.getIntegerType(64), num_bits));
  odsState.addAttribute("narrow_range", odsBuilder.getBoolAttr(narrow_range));
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void FakeQuantWithMinMaxVarsOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 3u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult FakeQuantWithMinMaxVarsOp::verify() {
  if (failed(FakeQuantWithMinMaxVarsOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of 32-bit float values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of 32-bit float values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup2 = getODSOperands(2);
    for (::mlir::Value v : valueGroup2) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of 32-bit float values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))))) {
        return emitOpError("result #") << index << " must be tensor of 32-bit float values, but got " << v.getType();
      }
      ++index;
    }
  }
  return Verify(*this);
}

void FakeQuantWithMinMaxVarsOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::FakeQuantWithMinMaxVarsPerChannelOp definitions
//===----------------------------------------------------------------------===//

FakeQuantWithMinMaxVarsPerChannelOpAdaptor::FakeQuantWithMinMaxVarsPerChannelOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

FakeQuantWithMinMaxVarsPerChannelOpAdaptor::FakeQuantWithMinMaxVarsPerChannelOpAdaptor(FakeQuantWithMinMaxVarsPerChannelOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> FakeQuantWithMinMaxVarsPerChannelOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange FakeQuantWithMinMaxVarsPerChannelOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value FakeQuantWithMinMaxVarsPerChannelOpAdaptor::inputs() {
  return *getODSOperands(0).begin();
}

::mlir::Value FakeQuantWithMinMaxVarsPerChannelOpAdaptor::min() {
  return *getODSOperands(1).begin();
}

::mlir::Value FakeQuantWithMinMaxVarsPerChannelOpAdaptor::max() {
  return *getODSOperands(2).begin();
}

::mlir::IntegerAttr FakeQuantWithMinMaxVarsPerChannelOpAdaptor::num_bits() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::IntegerAttr attr = odsAttrs.get("num_bits").dyn_cast_or_null<::mlir::IntegerAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getIntegerAttr(::mlir::Builder(odsAttrs.getContext()).getIntegerType(64), 8);
  return attr;
}

::mlir::BoolAttr FakeQuantWithMinMaxVarsPerChannelOpAdaptor::narrow_range() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::BoolAttr attr = odsAttrs.get("narrow_range").dyn_cast_or_null<::mlir::BoolAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getBoolAttr(false);
  return attr;
}

::mlir::LogicalResult FakeQuantWithMinMaxVarsPerChannelOpAdaptor::verify(::mlir::Location loc) {
  {
  auto tblgen_num_bits = odsAttrs.get("num_bits");
  if (tblgen_num_bits) {
    if (!(((tblgen_num_bits.isa<::mlir::IntegerAttr>())) && ((tblgen_num_bits.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(64))))) return emitError(loc, "'tf.FakeQuantWithMinMaxVarsPerChannel' op ""attribute 'num_bits' failed to satisfy constraint: 64-bit signless integer attribute");
  }
  }
  {
  auto tblgen_narrow_range = odsAttrs.get("narrow_range");
  if (tblgen_narrow_range) {
    if (!((tblgen_narrow_range.isa<::mlir::BoolAttr>()))) return emitError(loc, "'tf.FakeQuantWithMinMaxVarsPerChannel' op ""attribute 'narrow_range' failed to satisfy constraint: bool attribute");
  }
  }
  return ::mlir::success();
}

::llvm::StringRef FakeQuantWithMinMaxVarsPerChannelOp::getOperationName() {
  return "tf.FakeQuantWithMinMaxVarsPerChannel";
}

std::pair<unsigned, unsigned> FakeQuantWithMinMaxVarsPerChannelOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range FakeQuantWithMinMaxVarsPerChannelOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value FakeQuantWithMinMaxVarsPerChannelOp::inputs() {
  return *getODSOperands(0).begin();
}

::mlir::Value FakeQuantWithMinMaxVarsPerChannelOp::min() {
  return *getODSOperands(1).begin();
}

::mlir::Value FakeQuantWithMinMaxVarsPerChannelOp::max() {
  return *getODSOperands(2).begin();
}

::mlir::MutableOperandRange FakeQuantWithMinMaxVarsPerChannelOp::inputsMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange FakeQuantWithMinMaxVarsPerChannelOp::minMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange FakeQuantWithMinMaxVarsPerChannelOp::maxMutable() {
  auto range = getODSOperandIndexAndLength(2);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> FakeQuantWithMinMaxVarsPerChannelOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range FakeQuantWithMinMaxVarsPerChannelOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value FakeQuantWithMinMaxVarsPerChannelOp::outputs() {
  return *getODSResults(0).begin();
}

::mlir::IntegerAttr FakeQuantWithMinMaxVarsPerChannelOp::num_bitsAttr() {
  return this->getAttr("num_bits").dyn_cast_or_null<::mlir::IntegerAttr>();
}

uint64_t FakeQuantWithMinMaxVarsPerChannelOp::num_bits() {
  auto attr = num_bitsAttr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getIntegerAttr(::mlir::Builder(this->getContext()).getIntegerType(64), 8).getValue().getZExtValue();
  return attr.getValue().getZExtValue();
}

::mlir::BoolAttr FakeQuantWithMinMaxVarsPerChannelOp::narrow_rangeAttr() {
  return this->getAttr("narrow_range").dyn_cast_or_null<::mlir::BoolAttr>();
}

bool FakeQuantWithMinMaxVarsPerChannelOp::narrow_range() {
  auto attr = narrow_rangeAttr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getBoolAttr(false).getValue();
  return attr.getValue();
}

void FakeQuantWithMinMaxVarsPerChannelOp::num_bitsAttr(::mlir::IntegerAttr attr) {
  this->getOperation()->setAttr("num_bits", attr);
}

void FakeQuantWithMinMaxVarsPerChannelOp::narrow_rangeAttr(::mlir::BoolAttr attr) {
  this->getOperation()->setAttr("narrow_range", attr);
}

void FakeQuantWithMinMaxVarsPerChannelOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type outputs, ::mlir::Value inputs, ::mlir::Value min, ::mlir::Value max, ::mlir::IntegerAttr num_bits, ::mlir::BoolAttr narrow_range) {
  odsState.addOperands(inputs);
  odsState.addOperands(min);
  odsState.addOperands(max);
  odsState.addAttribute("num_bits", num_bits);
  odsState.addAttribute("narrow_range", narrow_range);
  odsState.addTypes(outputs);
}

void FakeQuantWithMinMaxVarsPerChannelOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value inputs, ::mlir::Value min, ::mlir::Value max, ::mlir::IntegerAttr num_bits, ::mlir::BoolAttr narrow_range) {
  odsState.addOperands(inputs);
  odsState.addOperands(min);
  odsState.addOperands(max);
  odsState.addAttribute("num_bits", num_bits);
  odsState.addAttribute("narrow_range", narrow_range);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void FakeQuantWithMinMaxVarsPerChannelOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type outputs, ::mlir::Value inputs, ::mlir::Value min, ::mlir::Value max, uint64_t num_bits, bool narrow_range) {
  odsState.addOperands(inputs);
  odsState.addOperands(min);
  odsState.addOperands(max);
  odsState.addAttribute("num_bits", odsBuilder.getIntegerAttr(odsBuilder.getIntegerType(64), num_bits));
  odsState.addAttribute("narrow_range", odsBuilder.getBoolAttr(narrow_range));
  odsState.addTypes(outputs);
}

void FakeQuantWithMinMaxVarsPerChannelOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value inputs, ::mlir::Value min, ::mlir::Value max, uint64_t num_bits, bool narrow_range) {
  odsState.addOperands(inputs);
  odsState.addOperands(min);
  odsState.addOperands(max);
  odsState.addAttribute("num_bits", odsBuilder.getIntegerAttr(odsBuilder.getIntegerType(64), num_bits));
  odsState.addAttribute("narrow_range", odsBuilder.getBoolAttr(narrow_range));
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void FakeQuantWithMinMaxVarsPerChannelOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 3u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult FakeQuantWithMinMaxVarsPerChannelOp::verify() {
  if (failed(FakeQuantWithMinMaxVarsPerChannelOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of 32-bit float values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of 32-bit float values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup2 = getODSOperands(2);
    for (::mlir::Value v : valueGroup2) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of 32-bit float values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))))) {
        return emitOpError("result #") << index << " must be tensor of 32-bit float values, but got " << v.getType();
      }
      ++index;
    }
  }
  return Verify(*this);
}

void FakeQuantWithMinMaxVarsPerChannelOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::FillOp definitions
//===----------------------------------------------------------------------===//

FillOpAdaptor::FillOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

FillOpAdaptor::FillOpAdaptor(FillOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> FillOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange FillOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value FillOpAdaptor::dims() {
  return *getODSOperands(0).begin();
}

::mlir::Value FillOpAdaptor::value() {
  return *getODSOperands(1).begin();
}

::mlir::LogicalResult FillOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

::llvm::StringRef FillOp::getOperationName() {
  return "tf.Fill";
}

std::pair<unsigned, unsigned> FillOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range FillOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value FillOp::dims() {
  return *getODSOperands(0).begin();
}

::mlir::Value FillOp::value() {
  return *getODSOperands(1).begin();
}

::mlir::MutableOperandRange FillOp::dimsMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange FillOp::valueMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> FillOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range FillOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value FillOp::output() {
  return *getODSResults(0).begin();
}

Type FillOp::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(1).begin());
}

Type FillOp::index_type() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

bool FillOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "T") return true;
  if (name == "index_type") return true;
 return false;
}

::mlir::DictionaryAttr FillOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())},
    {::mlir::Identifier::get("index_type", ctx),
::mlir::TypeAttr::get(index_type())}
    }, ctx);
}



void FillOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value dims, ::mlir::Value value) {
  odsState.addOperands(dims);
  odsState.addOperands(value);
  odsState.addTypes(output);
}

void FillOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value dims, ::mlir::Value value) {
  odsState.addOperands(dims);
  odsState.addOperands(value);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void FillOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult FillOp::verify() {
  if (failed(FillOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of 32/64-bit signed integer values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>())))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::TensorFlowType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of tf.dtype values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>())))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::TensorFlowType>()))))) {
        return emitOpError("result #") << index << " must be tensor of tf.dtype values, but got " << v.getType();
      }
      ++index;
    }
  }
  return Verify(*this);
}



void FillOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::FloorDivOp definitions
//===----------------------------------------------------------------------===//

FloorDivOpAdaptor::FloorDivOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

FloorDivOpAdaptor::FloorDivOpAdaptor(FloorDivOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> FloorDivOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange FloorDivOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value FloorDivOpAdaptor::x() {
  return *getODSOperands(0).begin();
}

::mlir::Value FloorDivOpAdaptor::y() {
  return *getODSOperands(1).begin();
}

::mlir::LogicalResult FloorDivOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

::llvm::StringRef FloorDivOp::getOperationName() {
  return "tf.FloorDiv";
}

std::pair<unsigned, unsigned> FloorDivOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range FloorDivOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value FloorDivOp::x() {
  return *getODSOperands(0).begin();
}

::mlir::Value FloorDivOp::y() {
  return *getODSOperands(1).begin();
}

::mlir::MutableOperandRange FloorDivOp::xMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange FloorDivOp::yMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> FloorDivOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range FloorDivOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value FloorDivOp::z() {
  return *getODSResults(0).begin();
}

Type FloorDivOp::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

bool FloorDivOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "T") return true;
 return false;
}

::mlir::DictionaryAttr FloorDivOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())}
    }, ctx);
}

void FloorDivOp::build(OpBuilder &builder, OperationState &result, Value  x, Value  y) {
  auto resultType =
      OpTrait::util::getBroadcastedType(x.getType(), y.getType());
  if (!resultType)
    mlir::emitError(result.location, "non-broadcastable operands");
  return build(builder, result, resultType, x, y);
}

void FloorDivOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type z, ::mlir::Value x, ::mlir::Value y) {
  odsState.addOperands(x);
  odsState.addOperands(y);
  odsState.addTypes(z);
}

void FloorDivOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value x, ::mlir::Value y) {
  odsState.addOperands(x);
  odsState.addOperands(y);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void FloorDivOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult FloorDivOp::verify() {
  if (failed(FloorDivOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of bfloat16 or 128-bit complex or 64-bit complex or 16-bit float or 32-bit float or 64-bit float or 16-bit integer or 32-bit integer or 64-bit integer or 8-bit integer or 16-bit unsigned integer or 8-bit unsigned integer values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of bfloat16 or 128-bit complex or 64-bit complex or 16-bit float or 32-bit float or 64-bit float or 16-bit integer or 32-bit integer or 64-bit integer or 8-bit integer or 16-bit unsigned integer or 8-bit unsigned integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>())))))) {
        return emitOpError("result #") << index << " must be tensor of bfloat16 or 128-bit complex or 64-bit complex or 16-bit float or 32-bit float or 64-bit float or 16-bit integer or 32-bit integer or 64-bit integer or 8-bit integer or 16-bit unsigned integer or 8-bit unsigned integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void FloorDivOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::FloorModOp definitions
//===----------------------------------------------------------------------===//

FloorModOpAdaptor::FloorModOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

FloorModOpAdaptor::FloorModOpAdaptor(FloorModOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> FloorModOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange FloorModOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value FloorModOpAdaptor::x() {
  return *getODSOperands(0).begin();
}

::mlir::Value FloorModOpAdaptor::y() {
  return *getODSOperands(1).begin();
}

::mlir::LogicalResult FloorModOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

::llvm::StringRef FloorModOp::getOperationName() {
  return "tf.FloorMod";
}

std::pair<unsigned, unsigned> FloorModOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range FloorModOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value FloorModOp::x() {
  return *getODSOperands(0).begin();
}

::mlir::Value FloorModOp::y() {
  return *getODSOperands(1).begin();
}

::mlir::MutableOperandRange FloorModOp::xMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange FloorModOp::yMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> FloorModOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range FloorModOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value FloorModOp::z() {
  return *getODSResults(0).begin();
}

Type FloorModOp::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

bool FloorModOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "T") return true;
 return false;
}

::mlir::DictionaryAttr FloorModOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())}
    }, ctx);
}

void FloorModOp::build(OpBuilder &builder, OperationState &result, Value  x, Value  y) {
  auto resultType =
      OpTrait::util::getBroadcastedType(x.getType(), y.getType());
  if (!resultType)
    mlir::emitError(result.location, "non-broadcastable operands");
  return build(builder, result, resultType, x, y);
}

void FloorModOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type z, ::mlir::Value x, ::mlir::Value y) {
  odsState.addOperands(x);
  odsState.addOperands(y);
  odsState.addTypes(z);
}

void FloorModOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value x, ::mlir::Value y) {
  odsState.addOperands(x);
  odsState.addOperands(y);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void FloorModOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult FloorModOp::verify() {
  if (failed(FloorModOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of bfloat16 or 16-bit float or 32-bit float or 64-bit float or 32-bit integer or 64-bit integer or 64-bit unsigned integer values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of bfloat16 or 16-bit float or 32-bit float or 64-bit float or 32-bit integer or 64-bit integer or 64-bit unsigned integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>())))))) {
        return emitOpError("result #") << index << " must be tensor of bfloat16 or 16-bit float or 32-bit float or 64-bit float or 32-bit integer or 64-bit integer or 64-bit unsigned integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void FloorModOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::FloorOp definitions
//===----------------------------------------------------------------------===//

FloorOpAdaptor::FloorOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

FloorOpAdaptor::FloorOpAdaptor(FloorOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> FloorOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange FloorOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value FloorOpAdaptor::x() {
  return *getODSOperands(0).begin();
}

::mlir::LogicalResult FloorOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

::llvm::StringRef FloorOp::getOperationName() {
  return "tf.Floor";
}

std::pair<unsigned, unsigned> FloorOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range FloorOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value FloorOp::x() {
  return *getODSOperands(0).begin();
}

::mlir::MutableOperandRange FloorOp::xMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> FloorOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range FloorOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value FloorOp::y() {
  return *getODSResults(0).begin();
}

Type FloorOp::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

bool FloorOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "T") return true;
 return false;
}

::mlir::DictionaryAttr FloorOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())}
    }, ctx);
}

void FloorOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type y, ::mlir::Value x) {
  odsState.addOperands(x);
  odsState.addTypes(y);
}

void FloorOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value x) {
  odsState.addOperands(x);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void FloorOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

void FloorOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value x) {
  odsState.addOperands(x);
  odsState.addTypes({x.getType()});

}

void FloorOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  odsState.addTypes({operands[0].getType()});

}

::mlir::LogicalResult FloorOp::verify() {
  if (failed(FloorOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of floating-point values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))))) {
        return emitOpError("result #") << index << " must be tensor of floating-point values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void FloorOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::FlushSummaryWriterOp definitions
//===----------------------------------------------------------------------===//

FlushSummaryWriterOpAdaptor::FlushSummaryWriterOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

FlushSummaryWriterOpAdaptor::FlushSummaryWriterOpAdaptor(FlushSummaryWriterOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> FlushSummaryWriterOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange FlushSummaryWriterOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value FlushSummaryWriterOpAdaptor::writer() {
  return *getODSOperands(0).begin();
}

::mlir::LogicalResult FlushSummaryWriterOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

::llvm::StringRef FlushSummaryWriterOp::getOperationName() {
  return "tf.FlushSummaryWriter";
}

std::pair<unsigned, unsigned> FlushSummaryWriterOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range FlushSummaryWriterOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value FlushSummaryWriterOp::writer() {
  return *getODSOperands(0).begin();
}

::mlir::MutableOperandRange FlushSummaryWriterOp::writerMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> FlushSummaryWriterOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range FlushSummaryWriterOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

void FlushSummaryWriterOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value writer) {
  odsState.addOperands(writer);
}

void FlushSummaryWriterOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value writer) {
  odsState.addOperands(writer);
  assert(resultTypes.size() == 0u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void FlushSummaryWriterOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 0u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult FlushSummaryWriterOp::verify() {
  if (failed(FlushSummaryWriterOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::ResourceType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::ResourceRefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of resource values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
  }
  return ::mlir::success();
}

void FlushSummaryWriterOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
  for (::mlir::Value value : getODSOperands(0))
    effects.emplace_back(MemoryEffects::Write::get(), value, ::mlir::TF::ResourceEffects::Summary::get());
}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::FusedBatchNormGradOp definitions
//===----------------------------------------------------------------------===//

FusedBatchNormGradOpAdaptor::FusedBatchNormGradOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

FusedBatchNormGradOpAdaptor::FusedBatchNormGradOpAdaptor(FusedBatchNormGradOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> FusedBatchNormGradOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange FusedBatchNormGradOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value FusedBatchNormGradOpAdaptor::y_backprop() {
  return *getODSOperands(0).begin();
}

::mlir::Value FusedBatchNormGradOpAdaptor::x() {
  return *getODSOperands(1).begin();
}

::mlir::Value FusedBatchNormGradOpAdaptor::scale() {
  return *getODSOperands(2).begin();
}

::mlir::Value FusedBatchNormGradOpAdaptor::reserve_space_1() {
  return *getODSOperands(3).begin();
}

::mlir::Value FusedBatchNormGradOpAdaptor::reserve_space_2() {
  return *getODSOperands(4).begin();
}

::mlir::FloatAttr FusedBatchNormGradOpAdaptor::epsilon() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::FloatAttr attr = odsAttrs.get("epsilon").dyn_cast_or_null<::mlir::FloatAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getFloatAttr(::mlir::Builder(odsAttrs.getContext()).getF32Type(), 0.0001f);
  return attr;
}

::mlir::StringAttr FusedBatchNormGradOpAdaptor::data_format() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::StringAttr attr = odsAttrs.get("data_format").dyn_cast_or_null<::mlir::StringAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getStringAttr("NHWC");
  return attr;
}

::mlir::BoolAttr FusedBatchNormGradOpAdaptor::is_training() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::BoolAttr attr = odsAttrs.get("is_training").dyn_cast_or_null<::mlir::BoolAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getBoolAttr(true);
  return attr;
}

::mlir::LogicalResult FusedBatchNormGradOpAdaptor::verify(::mlir::Location loc) {
  {
  auto tblgen_epsilon = odsAttrs.get("epsilon");
  if (tblgen_epsilon) {
    if (!(((tblgen_epsilon.isa<::mlir::FloatAttr>())) && ((tblgen_epsilon.cast<::mlir::FloatAttr>().getType().isF32())))) return emitError(loc, "'tf.FusedBatchNormGrad' op ""attribute 'epsilon' failed to satisfy constraint: 32-bit float attribute");
  }
  }
  {
  auto tblgen_data_format = odsAttrs.get("data_format");
  if (tblgen_data_format) {
    if (!((tblgen_data_format.cast<StringAttr>().getValue() == "NHWC" || tblgen_data_format.cast<StringAttr>().getValue() == "NCHW"))) return emitError(loc, "'tf.FusedBatchNormGrad' op ""attribute 'data_format' failed to satisfy constraint: 'NHWC' or 'NCHW' convnet data format");
  }
  }
  {
  auto tblgen_is_training = odsAttrs.get("is_training");
  if (tblgen_is_training) {
    if (!((tblgen_is_training.isa<::mlir::BoolAttr>()))) return emitError(loc, "'tf.FusedBatchNormGrad' op ""attribute 'is_training' failed to satisfy constraint: bool attribute");
  }
  }
  return ::mlir::success();
}

void FusedBatchNormGradOp::getAsmResultNames(::mlir::OpAsmSetValueNameFn setNameFn) {
  auto resultGroup0 = getODSResults(0);
  if (!llvm::empty(resultGroup0))
    setNameFn(*resultGroup0.begin(), "x_backprop");
  auto resultGroup1 = getODSResults(1);
  if (!llvm::empty(resultGroup1))
    setNameFn(*resultGroup1.begin(), "scale_backprop");
  auto resultGroup2 = getODSResults(2);
  if (!llvm::empty(resultGroup2))
    setNameFn(*resultGroup2.begin(), "offset_backprop");
  auto resultGroup3 = getODSResults(3);
  if (!llvm::empty(resultGroup3))
    setNameFn(*resultGroup3.begin(), "reserve_space_3");
  auto resultGroup4 = getODSResults(4);
  if (!llvm::empty(resultGroup4))
    setNameFn(*resultGroup4.begin(), "reserve_space_4");
}

::llvm::StringRef FusedBatchNormGradOp::getOperationName() {
  return "tf.FusedBatchNormGrad";
}

std::pair<unsigned, unsigned> FusedBatchNormGradOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range FusedBatchNormGradOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value FusedBatchNormGradOp::y_backprop() {
  return *getODSOperands(0).begin();
}

::mlir::Value FusedBatchNormGradOp::x() {
  return *getODSOperands(1).begin();
}

::mlir::Value FusedBatchNormGradOp::scale() {
  return *getODSOperands(2).begin();
}

::mlir::Value FusedBatchNormGradOp::reserve_space_1() {
  return *getODSOperands(3).begin();
}

::mlir::Value FusedBatchNormGradOp::reserve_space_2() {
  return *getODSOperands(4).begin();
}

::mlir::MutableOperandRange FusedBatchNormGradOp::y_backpropMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange FusedBatchNormGradOp::xMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange FusedBatchNormGradOp::scaleMutable() {
  auto range = getODSOperandIndexAndLength(2);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange FusedBatchNormGradOp::reserve_space_1Mutable() {
  auto range = getODSOperandIndexAndLength(3);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange FusedBatchNormGradOp::reserve_space_2Mutable() {
  auto range = getODSOperandIndexAndLength(4);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> FusedBatchNormGradOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range FusedBatchNormGradOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value FusedBatchNormGradOp::x_backprop() {
  return *getODSResults(0).begin();
}

::mlir::Value FusedBatchNormGradOp::scale_backprop() {
  return *getODSResults(1).begin();
}

::mlir::Value FusedBatchNormGradOp::offset_backprop() {
  return *getODSResults(2).begin();
}

::mlir::Value FusedBatchNormGradOp::reserve_space_3() {
  return *getODSResults(3).begin();
}

::mlir::Value FusedBatchNormGradOp::reserve_space_4() {
  return *getODSResults(4).begin();
}

::mlir::FloatAttr FusedBatchNormGradOp::epsilonAttr() {
  return this->getAttr("epsilon").dyn_cast_or_null<::mlir::FloatAttr>();
}

::llvm::APFloat FusedBatchNormGradOp::epsilon() {
  auto attr = epsilonAttr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getFloatAttr(::mlir::Builder(this->getContext()).getF32Type(), 0.0001f).getValue();
  return attr.getValue();
}

::mlir::StringAttr FusedBatchNormGradOp::data_formatAttr() {
  return this->getAttr("data_format").dyn_cast_or_null<::mlir::StringAttr>();
}

::llvm::StringRef FusedBatchNormGradOp::data_format() {
  auto attr = data_formatAttr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getStringAttr("NHWC").getValue();
  return attr.getValue();
}

::mlir::BoolAttr FusedBatchNormGradOp::is_trainingAttr() {
  return this->getAttr("is_training").dyn_cast_or_null<::mlir::BoolAttr>();
}

bool FusedBatchNormGradOp::is_training() {
  auto attr = is_trainingAttr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getBoolAttr(true).getValue();
  return attr.getValue();
}

Type FusedBatchNormGradOp::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

bool FusedBatchNormGradOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "T") return true;
 return false;
}

::mlir::DictionaryAttr FusedBatchNormGradOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())}
    }, ctx);
}

void FusedBatchNormGradOp::epsilonAttr(::mlir::FloatAttr attr) {
  this->getOperation()->setAttr("epsilon", attr);
}

void FusedBatchNormGradOp::data_formatAttr(::mlir::StringAttr attr) {
  this->getOperation()->setAttr("data_format", attr);
}

void FusedBatchNormGradOp::is_trainingAttr(::mlir::BoolAttr attr) {
  this->getOperation()->setAttr("is_training", attr);
}

void FusedBatchNormGradOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type x_backprop, ::mlir::Type scale_backprop, ::mlir::Type offset_backprop, ::mlir::Type reserve_space_3, ::mlir::Type reserve_space_4, ::mlir::Value y_backprop, ::mlir::Value x, ::mlir::Value scale, ::mlir::Value reserve_space_1, ::mlir::Value reserve_space_2, ::mlir::FloatAttr epsilon, ::mlir::StringAttr data_format, ::mlir::BoolAttr is_training) {
  odsState.addOperands(y_backprop);
  odsState.addOperands(x);
  odsState.addOperands(scale);
  odsState.addOperands(reserve_space_1);
  odsState.addOperands(reserve_space_2);
  odsState.addAttribute("epsilon", epsilon);
  odsState.addAttribute("data_format", data_format);
  odsState.addAttribute("is_training", is_training);
  odsState.addTypes(x_backprop);
  odsState.addTypes(scale_backprop);
  odsState.addTypes(offset_backprop);
  odsState.addTypes(reserve_space_3);
  odsState.addTypes(reserve_space_4);
}

void FusedBatchNormGradOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value y_backprop, ::mlir::Value x, ::mlir::Value scale, ::mlir::Value reserve_space_1, ::mlir::Value reserve_space_2, ::mlir::FloatAttr epsilon, ::mlir::StringAttr data_format, ::mlir::BoolAttr is_training) {
  odsState.addOperands(y_backprop);
  odsState.addOperands(x);
  odsState.addOperands(scale);
  odsState.addOperands(reserve_space_1);
  odsState.addOperands(reserve_space_2);
  odsState.addAttribute("epsilon", epsilon);
  odsState.addAttribute("data_format", data_format);
  odsState.addAttribute("is_training", is_training);
  assert(resultTypes.size() == 5u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void FusedBatchNormGradOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type x_backprop, ::mlir::Type scale_backprop, ::mlir::Type offset_backprop, ::mlir::Type reserve_space_3, ::mlir::Type reserve_space_4, ::mlir::Value y_backprop, ::mlir::Value x, ::mlir::Value scale, ::mlir::Value reserve_space_1, ::mlir::Value reserve_space_2, ::llvm::APFloat epsilon, ::llvm::StringRef data_format, bool is_training) {
  odsState.addOperands(y_backprop);
  odsState.addOperands(x);
  odsState.addOperands(scale);
  odsState.addOperands(reserve_space_1);
  odsState.addOperands(reserve_space_2);
  odsState.addAttribute("epsilon", odsBuilder.getFloatAttr(odsBuilder.getF32Type(), epsilon));
  odsState.addAttribute("data_format", odsBuilder.getStringAttr(data_format));
  odsState.addAttribute("is_training", odsBuilder.getBoolAttr(is_training));
  odsState.addTypes(x_backprop);
  odsState.addTypes(scale_backprop);
  odsState.addTypes(offset_backprop);
  odsState.addTypes(reserve_space_3);
  odsState.addTypes(reserve_space_4);
}

void FusedBatchNormGradOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value y_backprop, ::mlir::Value x, ::mlir::Value scale, ::mlir::Value reserve_space_1, ::mlir::Value reserve_space_2, ::llvm::APFloat epsilon, ::llvm::StringRef data_format, bool is_training) {
  odsState.addOperands(y_backprop);
  odsState.addOperands(x);
  odsState.addOperands(scale);
  odsState.addOperands(reserve_space_1);
  odsState.addOperands(reserve_space_2);
  odsState.addAttribute("epsilon", odsBuilder.getFloatAttr(odsBuilder.getF32Type(), epsilon));
  odsState.addAttribute("data_format", odsBuilder.getStringAttr(data_format));
  odsState.addAttribute("is_training", odsBuilder.getBoolAttr(is_training));
  assert(resultTypes.size() == 5u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void FusedBatchNormGradOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 5u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 5u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult FusedBatchNormGradOp::verify() {
  if (failed(FusedBatchNormGradOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of 32-bit float values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of 32-bit float values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup2 = getODSOperands(2);
    for (::mlir::Value v : valueGroup2) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of 32-bit float values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup3 = getODSOperands(3);
    for (::mlir::Value v : valueGroup3) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of 32-bit float values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup4 = getODSOperands(4);
    for (::mlir::Value v : valueGroup4) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of 32-bit float values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))))) {
        return emitOpError("result #") << index << " must be tensor of 32-bit float values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSResults(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))))) {
        return emitOpError("result #") << index << " must be tensor of 32-bit float values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup2 = getODSResults(2);
    for (::mlir::Value v : valueGroup2) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))))) {
        return emitOpError("result #") << index << " must be tensor of 32-bit float values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup3 = getODSResults(3);
    for (::mlir::Value v : valueGroup3) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))))) {
        return emitOpError("result #") << index << " must be tensor of 32-bit float values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup4 = getODSResults(4);
    for (::mlir::Value v : valueGroup4) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))))) {
        return emitOpError("result #") << index << " must be tensor of 32-bit float values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void FusedBatchNormGradOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::FusedBatchNormGradV2Op definitions
//===----------------------------------------------------------------------===//

FusedBatchNormGradV2OpAdaptor::FusedBatchNormGradV2OpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

FusedBatchNormGradV2OpAdaptor::FusedBatchNormGradV2OpAdaptor(FusedBatchNormGradV2Op&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> FusedBatchNormGradV2OpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange FusedBatchNormGradV2OpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value FusedBatchNormGradV2OpAdaptor::y_backprop() {
  return *getODSOperands(0).begin();
}

::mlir::Value FusedBatchNormGradV2OpAdaptor::x() {
  return *getODSOperands(1).begin();
}

::mlir::Value FusedBatchNormGradV2OpAdaptor::scale() {
  return *getODSOperands(2).begin();
}

::mlir::Value FusedBatchNormGradV2OpAdaptor::reserve_space_1() {
  return *getODSOperands(3).begin();
}

::mlir::Value FusedBatchNormGradV2OpAdaptor::reserve_space_2() {
  return *getODSOperands(4).begin();
}

::mlir::FloatAttr FusedBatchNormGradV2OpAdaptor::epsilon() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::FloatAttr attr = odsAttrs.get("epsilon").dyn_cast_or_null<::mlir::FloatAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getFloatAttr(::mlir::Builder(odsAttrs.getContext()).getF32Type(), 0.0001f);
  return attr;
}

::mlir::StringAttr FusedBatchNormGradV2OpAdaptor::data_format() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::StringAttr attr = odsAttrs.get("data_format").dyn_cast_or_null<::mlir::StringAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getStringAttr("NHWC");
  return attr;
}

::mlir::BoolAttr FusedBatchNormGradV2OpAdaptor::is_training() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::BoolAttr attr = odsAttrs.get("is_training").dyn_cast_or_null<::mlir::BoolAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getBoolAttr(true);
  return attr;
}

::mlir::LogicalResult FusedBatchNormGradV2OpAdaptor::verify(::mlir::Location loc) {
  {
  auto tblgen_epsilon = odsAttrs.get("epsilon");
  if (tblgen_epsilon) {
    if (!(((tblgen_epsilon.isa<::mlir::FloatAttr>())) && ((tblgen_epsilon.cast<::mlir::FloatAttr>().getType().isF32())))) return emitError(loc, "'tf.FusedBatchNormGradV2' op ""attribute 'epsilon' failed to satisfy constraint: 32-bit float attribute");
  }
  }
  {
  auto tblgen_data_format = odsAttrs.get("data_format");
  if (tblgen_data_format) {
    if (!((tblgen_data_format.cast<StringAttr>().getValue() == "NHWC" || tblgen_data_format.cast<StringAttr>().getValue() == "NCHW"))) return emitError(loc, "'tf.FusedBatchNormGradV2' op ""attribute 'data_format' failed to satisfy constraint: 'NHWC' or 'NCHW' convnet data format");
  }
  }
  {
  auto tblgen_is_training = odsAttrs.get("is_training");
  if (tblgen_is_training) {
    if (!((tblgen_is_training.isa<::mlir::BoolAttr>()))) return emitError(loc, "'tf.FusedBatchNormGradV2' op ""attribute 'is_training' failed to satisfy constraint: bool attribute");
  }
  }
  return ::mlir::success();
}

void FusedBatchNormGradV2Op::getAsmResultNames(::mlir::OpAsmSetValueNameFn setNameFn) {
  auto resultGroup0 = getODSResults(0);
  if (!llvm::empty(resultGroup0))
    setNameFn(*resultGroup0.begin(), "x_backprop");
  auto resultGroup1 = getODSResults(1);
  if (!llvm::empty(resultGroup1))
    setNameFn(*resultGroup1.begin(), "scale_backprop");
  auto resultGroup2 = getODSResults(2);
  if (!llvm::empty(resultGroup2))
    setNameFn(*resultGroup2.begin(), "offset_backprop");
  auto resultGroup3 = getODSResults(3);
  if (!llvm::empty(resultGroup3))
    setNameFn(*resultGroup3.begin(), "reserve_space_3");
  auto resultGroup4 = getODSResults(4);
  if (!llvm::empty(resultGroup4))
    setNameFn(*resultGroup4.begin(), "reserve_space_4");
}

::llvm::StringRef FusedBatchNormGradV2Op::getOperationName() {
  return "tf.FusedBatchNormGradV2";
}

std::pair<unsigned, unsigned> FusedBatchNormGradV2Op::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range FusedBatchNormGradV2Op::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value FusedBatchNormGradV2Op::y_backprop() {
  return *getODSOperands(0).begin();
}

::mlir::Value FusedBatchNormGradV2Op::x() {
  return *getODSOperands(1).begin();
}

::mlir::Value FusedBatchNormGradV2Op::scale() {
  return *getODSOperands(2).begin();
}

::mlir::Value FusedBatchNormGradV2Op::reserve_space_1() {
  return *getODSOperands(3).begin();
}

::mlir::Value FusedBatchNormGradV2Op::reserve_space_2() {
  return *getODSOperands(4).begin();
}

::mlir::MutableOperandRange FusedBatchNormGradV2Op::y_backpropMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange FusedBatchNormGradV2Op::xMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange FusedBatchNormGradV2Op::scaleMutable() {
  auto range = getODSOperandIndexAndLength(2);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange FusedBatchNormGradV2Op::reserve_space_1Mutable() {
  auto range = getODSOperandIndexAndLength(3);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange FusedBatchNormGradV2Op::reserve_space_2Mutable() {
  auto range = getODSOperandIndexAndLength(4);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> FusedBatchNormGradV2Op::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range FusedBatchNormGradV2Op::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value FusedBatchNormGradV2Op::x_backprop() {
  return *getODSResults(0).begin();
}

::mlir::Value FusedBatchNormGradV2Op::scale_backprop() {
  return *getODSResults(1).begin();
}

::mlir::Value FusedBatchNormGradV2Op::offset_backprop() {
  return *getODSResults(2).begin();
}

::mlir::Value FusedBatchNormGradV2Op::reserve_space_3() {
  return *getODSResults(3).begin();
}

::mlir::Value FusedBatchNormGradV2Op::reserve_space_4() {
  return *getODSResults(4).begin();
}

::mlir::FloatAttr FusedBatchNormGradV2Op::epsilonAttr() {
  return this->getAttr("epsilon").dyn_cast_or_null<::mlir::FloatAttr>();
}

::llvm::APFloat FusedBatchNormGradV2Op::epsilon() {
  auto attr = epsilonAttr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getFloatAttr(::mlir::Builder(this->getContext()).getF32Type(), 0.0001f).getValue();
  return attr.getValue();
}

::mlir::StringAttr FusedBatchNormGradV2Op::data_formatAttr() {
  return this->getAttr("data_format").dyn_cast_or_null<::mlir::StringAttr>();
}

::llvm::StringRef FusedBatchNormGradV2Op::data_format() {
  auto attr = data_formatAttr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getStringAttr("NHWC").getValue();
  return attr.getValue();
}

::mlir::BoolAttr FusedBatchNormGradV2Op::is_trainingAttr() {
  return this->getAttr("is_training").dyn_cast_or_null<::mlir::BoolAttr>();
}

bool FusedBatchNormGradV2Op::is_training() {
  auto attr = is_trainingAttr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getBoolAttr(true).getValue();
  return attr.getValue();
}

Type FusedBatchNormGradV2Op::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

Type FusedBatchNormGradV2Op::U() {
  return mlir::getElementTypeOrSelf(*getODSOperands(3).begin());
}

bool FusedBatchNormGradV2Op::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "T") return true;
  if (name == "U") return true;
 return false;
}

::mlir::DictionaryAttr FusedBatchNormGradV2Op::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())},
    {::mlir::Identifier::get("U", ctx),
::mlir::TypeAttr::get(U())}
    }, ctx);
}

void FusedBatchNormGradV2Op::epsilonAttr(::mlir::FloatAttr attr) {
  this->getOperation()->setAttr("epsilon", attr);
}

void FusedBatchNormGradV2Op::data_formatAttr(::mlir::StringAttr attr) {
  this->getOperation()->setAttr("data_format", attr);
}

void FusedBatchNormGradV2Op::is_trainingAttr(::mlir::BoolAttr attr) {
  this->getOperation()->setAttr("is_training", attr);
}

void FusedBatchNormGradV2Op::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type x_backprop, ::mlir::Type scale_backprop, ::mlir::Type offset_backprop, ::mlir::Type reserve_space_3, ::mlir::Type reserve_space_4, ::mlir::Value y_backprop, ::mlir::Value x, ::mlir::Value scale, ::mlir::Value reserve_space_1, ::mlir::Value reserve_space_2, ::mlir::FloatAttr epsilon, ::mlir::StringAttr data_format, ::mlir::BoolAttr is_training) {
  odsState.addOperands(y_backprop);
  odsState.addOperands(x);
  odsState.addOperands(scale);
  odsState.addOperands(reserve_space_1);
  odsState.addOperands(reserve_space_2);
  odsState.addAttribute("epsilon", epsilon);
  odsState.addAttribute("data_format", data_format);
  odsState.addAttribute("is_training", is_training);
  odsState.addTypes(x_backprop);
  odsState.addTypes(scale_backprop);
  odsState.addTypes(offset_backprop);
  odsState.addTypes(reserve_space_3);
  odsState.addTypes(reserve_space_4);
}

void FusedBatchNormGradV2Op::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value y_backprop, ::mlir::Value x, ::mlir::Value scale, ::mlir::Value reserve_space_1, ::mlir::Value reserve_space_2, ::mlir::FloatAttr epsilon, ::mlir::StringAttr data_format, ::mlir::BoolAttr is_training) {
  odsState.addOperands(y_backprop);
  odsState.addOperands(x);
  odsState.addOperands(scale);
  odsState.addOperands(reserve_space_1);
  odsState.addOperands(reserve_space_2);
  odsState.addAttribute("epsilon", epsilon);
  odsState.addAttribute("data_format", data_format);
  odsState.addAttribute("is_training", is_training);
  assert(resultTypes.size() == 5u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void FusedBatchNormGradV2Op::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type x_backprop, ::mlir::Type scale_backprop, ::mlir::Type offset_backprop, ::mlir::Type reserve_space_3, ::mlir::Type reserve_space_4, ::mlir::Value y_backprop, ::mlir::Value x, ::mlir::Value scale, ::mlir::Value reserve_space_1, ::mlir::Value reserve_space_2, ::llvm::APFloat epsilon, ::llvm::StringRef data_format, bool is_training) {
  odsState.addOperands(y_backprop);
  odsState.addOperands(x);
  odsState.addOperands(scale);
  odsState.addOperands(reserve_space_1);
  odsState.addOperands(reserve_space_2);
  odsState.addAttribute("epsilon", odsBuilder.getFloatAttr(odsBuilder.getF32Type(), epsilon));
  odsState.addAttribute("data_format", odsBuilder.getStringAttr(data_format));
  odsState.addAttribute("is_training", odsBuilder.getBoolAttr(is_training));
  odsState.addTypes(x_backprop);
  odsState.addTypes(scale_backprop);
  odsState.addTypes(offset_backprop);
  odsState.addTypes(reserve_space_3);
  odsState.addTypes(reserve_space_4);
}

void FusedBatchNormGradV2Op::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value y_backprop, ::mlir::Value x, ::mlir::Value scale, ::mlir::Value reserve_space_1, ::mlir::Value reserve_space_2, ::llvm::APFloat epsilon, ::llvm::StringRef data_format, bool is_training) {
  odsState.addOperands(y_backprop);
  odsState.addOperands(x);
  odsState.addOperands(scale);
  odsState.addOperands(reserve_space_1);
  odsState.addOperands(reserve_space_2);
  odsState.addAttribute("epsilon", odsBuilder.getFloatAttr(odsBuilder.getF32Type(), epsilon));
  odsState.addAttribute("data_format", odsBuilder.getStringAttr(data_format));
  odsState.addAttribute("is_training", odsBuilder.getBoolAttr(is_training));
  assert(resultTypes.size() == 5u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void FusedBatchNormGradV2Op::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 5u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 5u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult FusedBatchNormGradV2Op::verify() {
  if (failed(FusedBatchNormGradV2OpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of bfloat16 or 16-bit float or 32-bit float values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of bfloat16 or 16-bit float or 32-bit float values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup2 = getODSOperands(2);
    for (::mlir::Value v : valueGroup2) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of 32-bit float values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup3 = getODSOperands(3);
    for (::mlir::Value v : valueGroup3) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of 32-bit float values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup4 = getODSOperands(4);
    for (::mlir::Value v : valueGroup4) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of 32-bit float values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())))))) {
        return emitOpError("result #") << index << " must be tensor of bfloat16 or 16-bit float or 32-bit float values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSResults(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))))) {
        return emitOpError("result #") << index << " must be tensor of 32-bit float values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup2 = getODSResults(2);
    for (::mlir::Value v : valueGroup2) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))))) {
        return emitOpError("result #") << index << " must be tensor of 32-bit float values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup3 = getODSResults(3);
    for (::mlir::Value v : valueGroup3) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))))) {
        return emitOpError("result #") << index << " must be tensor of 32-bit float values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup4 = getODSResults(4);
    for (::mlir::Value v : valueGroup4) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))))) {
        return emitOpError("result #") << index << " must be tensor of 32-bit float values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void FusedBatchNormGradV2Op::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::FusedBatchNormGradV3Op definitions
//===----------------------------------------------------------------------===//

FusedBatchNormGradV3OpAdaptor::FusedBatchNormGradV3OpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

FusedBatchNormGradV3OpAdaptor::FusedBatchNormGradV3OpAdaptor(FusedBatchNormGradV3Op&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> FusedBatchNormGradV3OpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange FusedBatchNormGradV3OpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value FusedBatchNormGradV3OpAdaptor::y_backprop() {
  return *getODSOperands(0).begin();
}

::mlir::Value FusedBatchNormGradV3OpAdaptor::x() {
  return *getODSOperands(1).begin();
}

::mlir::Value FusedBatchNormGradV3OpAdaptor::scale() {
  return *getODSOperands(2).begin();
}

::mlir::Value FusedBatchNormGradV3OpAdaptor::reserve_space_1() {
  return *getODSOperands(3).begin();
}

::mlir::Value FusedBatchNormGradV3OpAdaptor::reserve_space_2() {
  return *getODSOperands(4).begin();
}

::mlir::Value FusedBatchNormGradV3OpAdaptor::reserve_space_3() {
  return *getODSOperands(5).begin();
}

::mlir::FloatAttr FusedBatchNormGradV3OpAdaptor::epsilon() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::FloatAttr attr = odsAttrs.get("epsilon").dyn_cast_or_null<::mlir::FloatAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getFloatAttr(::mlir::Builder(odsAttrs.getContext()).getF32Type(), 0.0001f);
  return attr;
}

::mlir::StringAttr FusedBatchNormGradV3OpAdaptor::data_format() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::StringAttr attr = odsAttrs.get("data_format").dyn_cast_or_null<::mlir::StringAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getStringAttr("NHWC");
  return attr;
}

::mlir::BoolAttr FusedBatchNormGradV3OpAdaptor::is_training() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::BoolAttr attr = odsAttrs.get("is_training").dyn_cast_or_null<::mlir::BoolAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getBoolAttr(true);
  return attr;
}

::mlir::LogicalResult FusedBatchNormGradV3OpAdaptor::verify(::mlir::Location loc) {
  {
  auto tblgen_epsilon = odsAttrs.get("epsilon");
  if (tblgen_epsilon) {
    if (!(((tblgen_epsilon.isa<::mlir::FloatAttr>())) && ((tblgen_epsilon.cast<::mlir::FloatAttr>().getType().isF32())))) return emitError(loc, "'tf.FusedBatchNormGradV3' op ""attribute 'epsilon' failed to satisfy constraint: 32-bit float attribute");
  }
  }
  {
  auto tblgen_data_format = odsAttrs.get("data_format");
  if (tblgen_data_format) {
    if (!((tblgen_data_format.cast<StringAttr>().getValue() == "NHWC" || tblgen_data_format.cast<StringAttr>().getValue() == "NCHW" || tblgen_data_format.cast<StringAttr>().getValue() == "NDHWC" || tblgen_data_format.cast<StringAttr>().getValue() == "NCDHW"))) return emitError(loc, "'tf.FusedBatchNormGradV3' op ""attribute 'data_format' failed to satisfy constraint: string attribute whose value is NHWC, or NCHW, or NDHWC, or NCDHW");
  }
  }
  {
  auto tblgen_is_training = odsAttrs.get("is_training");
  if (tblgen_is_training) {
    if (!((tblgen_is_training.isa<::mlir::BoolAttr>()))) return emitError(loc, "'tf.FusedBatchNormGradV3' op ""attribute 'is_training' failed to satisfy constraint: bool attribute");
  }
  }
  return ::mlir::success();
}

void FusedBatchNormGradV3Op::getAsmResultNames(::mlir::OpAsmSetValueNameFn setNameFn) {
  auto resultGroup0 = getODSResults(0);
  if (!llvm::empty(resultGroup0))
    setNameFn(*resultGroup0.begin(), "x_backprop");
  auto resultGroup1 = getODSResults(1);
  if (!llvm::empty(resultGroup1))
    setNameFn(*resultGroup1.begin(), "scale_backprop");
  auto resultGroup2 = getODSResults(2);
  if (!llvm::empty(resultGroup2))
    setNameFn(*resultGroup2.begin(), "offset_backprop");
  auto resultGroup3 = getODSResults(3);
  if (!llvm::empty(resultGroup3))
    setNameFn(*resultGroup3.begin(), "reserve_space_4");
  auto resultGroup4 = getODSResults(4);
  if (!llvm::empty(resultGroup4))
    setNameFn(*resultGroup4.begin(), "reserve_space_5");
}

::llvm::StringRef FusedBatchNormGradV3Op::getOperationName() {
  return "tf.FusedBatchNormGradV3";
}

std::pair<unsigned, unsigned> FusedBatchNormGradV3Op::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range FusedBatchNormGradV3Op::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value FusedBatchNormGradV3Op::y_backprop() {
  return *getODSOperands(0).begin();
}

::mlir::Value FusedBatchNormGradV3Op::x() {
  return *getODSOperands(1).begin();
}

::mlir::Value FusedBatchNormGradV3Op::scale() {
  return *getODSOperands(2).begin();
}

::mlir::Value FusedBatchNormGradV3Op::reserve_space_1() {
  return *getODSOperands(3).begin();
}

::mlir::Value FusedBatchNormGradV3Op::reserve_space_2() {
  return *getODSOperands(4).begin();
}

::mlir::Value FusedBatchNormGradV3Op::reserve_space_3() {
  return *getODSOperands(5).begin();
}

::mlir::MutableOperandRange FusedBatchNormGradV3Op::y_backpropMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange FusedBatchNormGradV3Op::xMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange FusedBatchNormGradV3Op::scaleMutable() {
  auto range = getODSOperandIndexAndLength(2);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange FusedBatchNormGradV3Op::reserve_space_1Mutable() {
  auto range = getODSOperandIndexAndLength(3);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange FusedBatchNormGradV3Op::reserve_space_2Mutable() {
  auto range = getODSOperandIndexAndLength(4);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange FusedBatchNormGradV3Op::reserve_space_3Mutable() {
  auto range = getODSOperandIndexAndLength(5);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> FusedBatchNormGradV3Op::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range FusedBatchNormGradV3Op::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value FusedBatchNormGradV3Op::x_backprop() {
  return *getODSResults(0).begin();
}

::mlir::Value FusedBatchNormGradV3Op::scale_backprop() {
  return *getODSResults(1).begin();
}

::mlir::Value FusedBatchNormGradV3Op::offset_backprop() {
  return *getODSResults(2).begin();
}

::mlir::Value FusedBatchNormGradV3Op::reserve_space_4() {
  return *getODSResults(3).begin();
}

::mlir::Value FusedBatchNormGradV3Op::reserve_space_5() {
  return *getODSResults(4).begin();
}

::mlir::FloatAttr FusedBatchNormGradV3Op::epsilonAttr() {
  return this->getAttr("epsilon").dyn_cast_or_null<::mlir::FloatAttr>();
}

::llvm::APFloat FusedBatchNormGradV3Op::epsilon() {
  auto attr = epsilonAttr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getFloatAttr(::mlir::Builder(this->getContext()).getF32Type(), 0.0001f).getValue();
  return attr.getValue();
}

::mlir::StringAttr FusedBatchNormGradV3Op::data_formatAttr() {
  return this->getAttr("data_format").dyn_cast_or_null<::mlir::StringAttr>();
}

::llvm::StringRef FusedBatchNormGradV3Op::data_format() {
  auto attr = data_formatAttr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getStringAttr("NHWC").getValue();
  return attr.getValue();
}

::mlir::BoolAttr FusedBatchNormGradV3Op::is_trainingAttr() {
  return this->getAttr("is_training").dyn_cast_or_null<::mlir::BoolAttr>();
}

bool FusedBatchNormGradV3Op::is_training() {
  auto attr = is_trainingAttr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getBoolAttr(true).getValue();
  return attr.getValue();
}

Type FusedBatchNormGradV3Op::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

Type FusedBatchNormGradV3Op::U() {
  return mlir::getElementTypeOrSelf(*getODSOperands(3).begin());
}

bool FusedBatchNormGradV3Op::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "T") return true;
  if (name == "U") return true;
 return false;
}

::mlir::DictionaryAttr FusedBatchNormGradV3Op::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())},
    {::mlir::Identifier::get("U", ctx),
::mlir::TypeAttr::get(U())}
    }, ctx);
}

void FusedBatchNormGradV3Op::epsilonAttr(::mlir::FloatAttr attr) {
  this->getOperation()->setAttr("epsilon", attr);
}

void FusedBatchNormGradV3Op::data_formatAttr(::mlir::StringAttr attr) {
  this->getOperation()->setAttr("data_format", attr);
}

void FusedBatchNormGradV3Op::is_trainingAttr(::mlir::BoolAttr attr) {
  this->getOperation()->setAttr("is_training", attr);
}

void FusedBatchNormGradV3Op::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type x_backprop, ::mlir::Type scale_backprop, ::mlir::Type offset_backprop, ::mlir::Type reserve_space_4, ::mlir::Type reserve_space_5, ::mlir::Value y_backprop, ::mlir::Value x, ::mlir::Value scale, ::mlir::Value reserve_space_1, ::mlir::Value reserve_space_2, ::mlir::Value reserve_space_3, ::mlir::FloatAttr epsilon, ::mlir::StringAttr data_format, ::mlir::BoolAttr is_training) {
  odsState.addOperands(y_backprop);
  odsState.addOperands(x);
  odsState.addOperands(scale);
  odsState.addOperands(reserve_space_1);
  odsState.addOperands(reserve_space_2);
  odsState.addOperands(reserve_space_3);
  odsState.addAttribute("epsilon", epsilon);
  odsState.addAttribute("data_format", data_format);
  odsState.addAttribute("is_training", is_training);
  odsState.addTypes(x_backprop);
  odsState.addTypes(scale_backprop);
  odsState.addTypes(offset_backprop);
  odsState.addTypes(reserve_space_4);
  odsState.addTypes(reserve_space_5);
}

void FusedBatchNormGradV3Op::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value y_backprop, ::mlir::Value x, ::mlir::Value scale, ::mlir::Value reserve_space_1, ::mlir::Value reserve_space_2, ::mlir::Value reserve_space_3, ::mlir::FloatAttr epsilon, ::mlir::StringAttr data_format, ::mlir::BoolAttr is_training) {
  odsState.addOperands(y_backprop);
  odsState.addOperands(x);
  odsState.addOperands(scale);
  odsState.addOperands(reserve_space_1);
  odsState.addOperands(reserve_space_2);
  odsState.addOperands(reserve_space_3);
  odsState.addAttribute("epsilon", epsilon);
  odsState.addAttribute("data_format", data_format);
  odsState.addAttribute("is_training", is_training);
  assert(resultTypes.size() == 5u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void FusedBatchNormGradV3Op::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type x_backprop, ::mlir::Type scale_backprop, ::mlir::Type offset_backprop, ::mlir::Type reserve_space_4, ::mlir::Type reserve_space_5, ::mlir::Value y_backprop, ::mlir::Value x, ::mlir::Value scale, ::mlir::Value reserve_space_1, ::mlir::Value reserve_space_2, ::mlir::Value reserve_space_3, ::llvm::APFloat epsilon, ::llvm::StringRef data_format, bool is_training) {
  odsState.addOperands(y_backprop);
  odsState.addOperands(x);
  odsState.addOperands(scale);
  odsState.addOperands(reserve_space_1);
  odsState.addOperands(reserve_space_2);
  odsState.addOperands(reserve_space_3);
  odsState.addAttribute("epsilon", odsBuilder.getFloatAttr(odsBuilder.getF32Type(), epsilon));
  odsState.addAttribute("data_format", odsBuilder.getStringAttr(data_format));
  odsState.addAttribute("is_training", odsBuilder.getBoolAttr(is_training));
  odsState.addTypes(x_backprop);
  odsState.addTypes(scale_backprop);
  odsState.addTypes(offset_backprop);
  odsState.addTypes(reserve_space_4);
  odsState.addTypes(reserve_space_5);
}

void FusedBatchNormGradV3Op::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value y_backprop, ::mlir::Value x, ::mlir::Value scale, ::mlir::Value reserve_space_1, ::mlir::Value reserve_space_2, ::mlir::Value reserve_space_3, ::llvm::APFloat epsilon, ::llvm::StringRef data_format, bool is_training) {
  odsState.addOperands(y_backprop);
  odsState.addOperands(x);
  odsState.addOperands(scale);
  odsState.addOperands(reserve_space_1);
  odsState.addOperands(reserve_space_2);
  odsState.addOperands(reserve_space_3);
  odsState.addAttribute("epsilon", odsBuilder.getFloatAttr(odsBuilder.getF32Type(), epsilon));
  odsState.addAttribute("data_format", odsBuilder.getStringAttr(data_format));
  odsState.addAttribute("is_training", odsBuilder.getBoolAttr(is_training));
  assert(resultTypes.size() == 5u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void FusedBatchNormGradV3Op::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 6u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 5u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult FusedBatchNormGradV3Op::verify() {
  if (failed(FusedBatchNormGradV3OpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of bfloat16 or 16-bit float or 32-bit float values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of bfloat16 or 16-bit float or 32-bit float values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup2 = getODSOperands(2);
    for (::mlir::Value v : valueGroup2) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of 32-bit float values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup3 = getODSOperands(3);
    for (::mlir::Value v : valueGroup3) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of 32-bit float values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup4 = getODSOperands(4);
    for (::mlir::Value v : valueGroup4) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of 32-bit float values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup5 = getODSOperands(5);
    for (::mlir::Value v : valueGroup5) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of 32-bit float values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())))))) {
        return emitOpError("result #") << index << " must be tensor of bfloat16 or 16-bit float or 32-bit float values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSResults(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))))) {
        return emitOpError("result #") << index << " must be tensor of 32-bit float values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup2 = getODSResults(2);
    for (::mlir::Value v : valueGroup2) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))))) {
        return emitOpError("result #") << index << " must be tensor of 32-bit float values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup3 = getODSResults(3);
    for (::mlir::Value v : valueGroup3) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))))) {
        return emitOpError("result #") << index << " must be tensor of 32-bit float values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup4 = getODSResults(4);
    for (::mlir::Value v : valueGroup4) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))))) {
        return emitOpError("result #") << index << " must be tensor of 32-bit float values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void FusedBatchNormGradV3Op::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::FusedBatchNormOp definitions
//===----------------------------------------------------------------------===//

FusedBatchNormOpAdaptor::FusedBatchNormOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

FusedBatchNormOpAdaptor::FusedBatchNormOpAdaptor(FusedBatchNormOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> FusedBatchNormOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange FusedBatchNormOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value FusedBatchNormOpAdaptor::x() {
  return *getODSOperands(0).begin();
}

::mlir::Value FusedBatchNormOpAdaptor::scale() {
  return *getODSOperands(1).begin();
}

::mlir::Value FusedBatchNormOpAdaptor::offset() {
  return *getODSOperands(2).begin();
}

::mlir::Value FusedBatchNormOpAdaptor::mean() {
  return *getODSOperands(3).begin();
}

::mlir::Value FusedBatchNormOpAdaptor::variance() {
  return *getODSOperands(4).begin();
}

::mlir::FloatAttr FusedBatchNormOpAdaptor::epsilon() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::FloatAttr attr = odsAttrs.get("epsilon").dyn_cast_or_null<::mlir::FloatAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getFloatAttr(::mlir::Builder(odsAttrs.getContext()).getF32Type(), 0.0001f);
  return attr;
}

::mlir::FloatAttr FusedBatchNormOpAdaptor::exponential_avg_factor() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::FloatAttr attr = odsAttrs.get("exponential_avg_factor").dyn_cast_or_null<::mlir::FloatAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getFloatAttr(::mlir::Builder(odsAttrs.getContext()).getF32Type(), 1.0f);
  return attr;
}

::mlir::StringAttr FusedBatchNormOpAdaptor::data_format() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::StringAttr attr = odsAttrs.get("data_format").dyn_cast_or_null<::mlir::StringAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getStringAttr("NHWC");
  return attr;
}

::mlir::BoolAttr FusedBatchNormOpAdaptor::is_training() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::BoolAttr attr = odsAttrs.get("is_training").dyn_cast_or_null<::mlir::BoolAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getBoolAttr(true);
  return attr;
}

::mlir::LogicalResult FusedBatchNormOpAdaptor::verify(::mlir::Location loc) {
  {
  auto tblgen_epsilon = odsAttrs.get("epsilon");
  if (tblgen_epsilon) {
    if (!(((tblgen_epsilon.isa<::mlir::FloatAttr>())) && ((tblgen_epsilon.cast<::mlir::FloatAttr>().getType().isF32())))) return emitError(loc, "'tf.FusedBatchNorm' op ""attribute 'epsilon' failed to satisfy constraint: 32-bit float attribute");
  }
  }
  {
  auto tblgen_exponential_avg_factor = odsAttrs.get("exponential_avg_factor");
  if (tblgen_exponential_avg_factor) {
    if (!(((tblgen_exponential_avg_factor.isa<::mlir::FloatAttr>())) && ((tblgen_exponential_avg_factor.cast<::mlir::FloatAttr>().getType().isF32())))) return emitError(loc, "'tf.FusedBatchNorm' op ""attribute 'exponential_avg_factor' failed to satisfy constraint: 32-bit float attribute");
  }
  }
  {
  auto tblgen_data_format = odsAttrs.get("data_format");
  if (tblgen_data_format) {
    if (!((tblgen_data_format.cast<StringAttr>().getValue() == "NHWC" || tblgen_data_format.cast<StringAttr>().getValue() == "NCHW"))) return emitError(loc, "'tf.FusedBatchNorm' op ""attribute 'data_format' failed to satisfy constraint: 'NHWC' or 'NCHW' convnet data format");
  }
  }
  {
  auto tblgen_is_training = odsAttrs.get("is_training");
  if (tblgen_is_training) {
    if (!((tblgen_is_training.isa<::mlir::BoolAttr>()))) return emitError(loc, "'tf.FusedBatchNorm' op ""attribute 'is_training' failed to satisfy constraint: bool attribute");
  }
  }
  return ::mlir::success();
}

void FusedBatchNormOp::getAsmResultNames(::mlir::OpAsmSetValueNameFn setNameFn) {
  auto resultGroup0 = getODSResults(0);
  if (!llvm::empty(resultGroup0))
    setNameFn(*resultGroup0.begin(), "y");
  auto resultGroup1 = getODSResults(1);
  if (!llvm::empty(resultGroup1))
    setNameFn(*resultGroup1.begin(), "batch_mean");
  auto resultGroup2 = getODSResults(2);
  if (!llvm::empty(resultGroup2))
    setNameFn(*resultGroup2.begin(), "batch_variance");
  auto resultGroup3 = getODSResults(3);
  if (!llvm::empty(resultGroup3))
    setNameFn(*resultGroup3.begin(), "reserve_space_1");
  auto resultGroup4 = getODSResults(4);
  if (!llvm::empty(resultGroup4))
    setNameFn(*resultGroup4.begin(), "reserve_space_2");
}

::llvm::StringRef FusedBatchNormOp::getOperationName() {
  return "tf.FusedBatchNorm";
}

std::pair<unsigned, unsigned> FusedBatchNormOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range FusedBatchNormOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value FusedBatchNormOp::x() {
  return *getODSOperands(0).begin();
}

::mlir::Value FusedBatchNormOp::scale() {
  return *getODSOperands(1).begin();
}

::mlir::Value FusedBatchNormOp::offset() {
  return *getODSOperands(2).begin();
}

::mlir::Value FusedBatchNormOp::mean() {
  return *getODSOperands(3).begin();
}

::mlir::Value FusedBatchNormOp::variance() {
  return *getODSOperands(4).begin();
}

::mlir::MutableOperandRange FusedBatchNormOp::xMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange FusedBatchNormOp::scaleMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange FusedBatchNormOp::offsetMutable() {
  auto range = getODSOperandIndexAndLength(2);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange FusedBatchNormOp::meanMutable() {
  auto range = getODSOperandIndexAndLength(3);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange FusedBatchNormOp::varianceMutable() {
  auto range = getODSOperandIndexAndLength(4);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> FusedBatchNormOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range FusedBatchNormOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value FusedBatchNormOp::y() {
  return *getODSResults(0).begin();
}

::mlir::Value FusedBatchNormOp::batch_mean() {
  return *getODSResults(1).begin();
}

::mlir::Value FusedBatchNormOp::batch_variance() {
  return *getODSResults(2).begin();
}

::mlir::Value FusedBatchNormOp::reserve_space_1() {
  return *getODSResults(3).begin();
}

::mlir::Value FusedBatchNormOp::reserve_space_2() {
  return *getODSResults(4).begin();
}

::mlir::FloatAttr FusedBatchNormOp::epsilonAttr() {
  return this->getAttr("epsilon").dyn_cast_or_null<::mlir::FloatAttr>();
}

::llvm::APFloat FusedBatchNormOp::epsilon() {
  auto attr = epsilonAttr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getFloatAttr(::mlir::Builder(this->getContext()).getF32Type(), 0.0001f).getValue();
  return attr.getValue();
}

::mlir::FloatAttr FusedBatchNormOp::exponential_avg_factorAttr() {
  return this->getAttr("exponential_avg_factor").dyn_cast_or_null<::mlir::FloatAttr>();
}

::llvm::APFloat FusedBatchNormOp::exponential_avg_factor() {
  auto attr = exponential_avg_factorAttr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getFloatAttr(::mlir::Builder(this->getContext()).getF32Type(), 1.0f).getValue();
  return attr.getValue();
}

::mlir::StringAttr FusedBatchNormOp::data_formatAttr() {
  return this->getAttr("data_format").dyn_cast_or_null<::mlir::StringAttr>();
}

::llvm::StringRef FusedBatchNormOp::data_format() {
  auto attr = data_formatAttr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getStringAttr("NHWC").getValue();
  return attr.getValue();
}

::mlir::BoolAttr FusedBatchNormOp::is_trainingAttr() {
  return this->getAttr("is_training").dyn_cast_or_null<::mlir::BoolAttr>();
}

bool FusedBatchNormOp::is_training() {
  auto attr = is_trainingAttr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getBoolAttr(true).getValue();
  return attr.getValue();
}

Type FusedBatchNormOp::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

bool FusedBatchNormOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "T") return true;
 return false;
}

::mlir::DictionaryAttr FusedBatchNormOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())}
    }, ctx);
}

void FusedBatchNormOp::epsilonAttr(::mlir::FloatAttr attr) {
  this->getOperation()->setAttr("epsilon", attr);
}

void FusedBatchNormOp::exponential_avg_factorAttr(::mlir::FloatAttr attr) {
  this->getOperation()->setAttr("exponential_avg_factor", attr);
}

void FusedBatchNormOp::data_formatAttr(::mlir::StringAttr attr) {
  this->getOperation()->setAttr("data_format", attr);
}

void FusedBatchNormOp::is_trainingAttr(::mlir::BoolAttr attr) {
  this->getOperation()->setAttr("is_training", attr);
}

void FusedBatchNormOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type y, ::mlir::Type batch_mean, ::mlir::Type batch_variance, ::mlir::Type reserve_space_1, ::mlir::Type reserve_space_2, ::mlir::Value x, ::mlir::Value scale, ::mlir::Value offset, ::mlir::Value mean, ::mlir::Value variance, ::mlir::FloatAttr epsilon, ::mlir::FloatAttr exponential_avg_factor, ::mlir::StringAttr data_format, ::mlir::BoolAttr is_training) {
  odsState.addOperands(x);
  odsState.addOperands(scale);
  odsState.addOperands(offset);
  odsState.addOperands(mean);
  odsState.addOperands(variance);
  odsState.addAttribute("epsilon", epsilon);
  odsState.addAttribute("exponential_avg_factor", exponential_avg_factor);
  odsState.addAttribute("data_format", data_format);
  odsState.addAttribute("is_training", is_training);
  odsState.addTypes(y);
  odsState.addTypes(batch_mean);
  odsState.addTypes(batch_variance);
  odsState.addTypes(reserve_space_1);
  odsState.addTypes(reserve_space_2);
}

void FusedBatchNormOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value x, ::mlir::Value scale, ::mlir::Value offset, ::mlir::Value mean, ::mlir::Value variance, ::mlir::FloatAttr epsilon, ::mlir::FloatAttr exponential_avg_factor, ::mlir::StringAttr data_format, ::mlir::BoolAttr is_training) {
  odsState.addOperands(x);
  odsState.addOperands(scale);
  odsState.addOperands(offset);
  odsState.addOperands(mean);
  odsState.addOperands(variance);
  odsState.addAttribute("epsilon", epsilon);
  odsState.addAttribute("exponential_avg_factor", exponential_avg_factor);
  odsState.addAttribute("data_format", data_format);
  odsState.addAttribute("is_training", is_training);
  assert(resultTypes.size() == 5u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void FusedBatchNormOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type y, ::mlir::Type batch_mean, ::mlir::Type batch_variance, ::mlir::Type reserve_space_1, ::mlir::Type reserve_space_2, ::mlir::Value x, ::mlir::Value scale, ::mlir::Value offset, ::mlir::Value mean, ::mlir::Value variance, ::llvm::APFloat epsilon, ::llvm::APFloat exponential_avg_factor, ::llvm::StringRef data_format, bool is_training) {
  odsState.addOperands(x);
  odsState.addOperands(scale);
  odsState.addOperands(offset);
  odsState.addOperands(mean);
  odsState.addOperands(variance);
  odsState.addAttribute("epsilon", odsBuilder.getFloatAttr(odsBuilder.getF32Type(), epsilon));
  odsState.addAttribute("exponential_avg_factor", odsBuilder.getFloatAttr(odsBuilder.getF32Type(), exponential_avg_factor));
  odsState.addAttribute("data_format", odsBuilder.getStringAttr(data_format));
  odsState.addAttribute("is_training", odsBuilder.getBoolAttr(is_training));
  odsState.addTypes(y);
  odsState.addTypes(batch_mean);
  odsState.addTypes(batch_variance);
  odsState.addTypes(reserve_space_1);
  odsState.addTypes(reserve_space_2);
}

void FusedBatchNormOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value x, ::mlir::Value scale, ::mlir::Value offset, ::mlir::Value mean, ::mlir::Value variance, ::llvm::APFloat epsilon, ::llvm::APFloat exponential_avg_factor, ::llvm::StringRef data_format, bool is_training) {
  odsState.addOperands(x);
  odsState.addOperands(scale);
  odsState.addOperands(offset);
  odsState.addOperands(mean);
  odsState.addOperands(variance);
  odsState.addAttribute("epsilon", odsBuilder.getFloatAttr(odsBuilder.getF32Type(), epsilon));
  odsState.addAttribute("exponential_avg_factor", odsBuilder.getFloatAttr(odsBuilder.getF32Type(), exponential_avg_factor));
  odsState.addAttribute("data_format", odsBuilder.getStringAttr(data_format));
  odsState.addAttribute("is_training", odsBuilder.getBoolAttr(is_training));
  assert(resultTypes.size() == 5u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void FusedBatchNormOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 5u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 5u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult FusedBatchNormOp::verify() {
  if (failed(FusedBatchNormOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of 32-bit float values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of 32-bit float values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup2 = getODSOperands(2);
    for (::mlir::Value v : valueGroup2) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of 32-bit float values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup3 = getODSOperands(3);
    for (::mlir::Value v : valueGroup3) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of 32-bit float values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup4 = getODSOperands(4);
    for (::mlir::Value v : valueGroup4) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of 32-bit float values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))))) {
        return emitOpError("result #") << index << " must be tensor of 32-bit float values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSResults(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))))) {
        return emitOpError("result #") << index << " must be tensor of 32-bit float values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup2 = getODSResults(2);
    for (::mlir::Value v : valueGroup2) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))))) {
        return emitOpError("result #") << index << " must be tensor of 32-bit float values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup3 = getODSResults(3);
    for (::mlir::Value v : valueGroup3) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))))) {
        return emitOpError("result #") << index << " must be tensor of 32-bit float values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup4 = getODSResults(4);
    for (::mlir::Value v : valueGroup4) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))))) {
        return emitOpError("result #") << index << " must be tensor of 32-bit float values, but got " << v.getType();
      }
      ++index;
    }
  }
  return Verify(*this);
}



void FusedBatchNormOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::FusedBatchNormV2Op definitions
//===----------------------------------------------------------------------===//

FusedBatchNormV2OpAdaptor::FusedBatchNormV2OpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

FusedBatchNormV2OpAdaptor::FusedBatchNormV2OpAdaptor(FusedBatchNormV2Op&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> FusedBatchNormV2OpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange FusedBatchNormV2OpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value FusedBatchNormV2OpAdaptor::x() {
  return *getODSOperands(0).begin();
}

::mlir::Value FusedBatchNormV2OpAdaptor::scale() {
  return *getODSOperands(1).begin();
}

::mlir::Value FusedBatchNormV2OpAdaptor::offset() {
  return *getODSOperands(2).begin();
}

::mlir::Value FusedBatchNormV2OpAdaptor::mean() {
  return *getODSOperands(3).begin();
}

::mlir::Value FusedBatchNormV2OpAdaptor::variance() {
  return *getODSOperands(4).begin();
}

::mlir::FloatAttr FusedBatchNormV2OpAdaptor::epsilon() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::FloatAttr attr = odsAttrs.get("epsilon").dyn_cast_or_null<::mlir::FloatAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getFloatAttr(::mlir::Builder(odsAttrs.getContext()).getF32Type(), 0.0001f);
  return attr;
}

::mlir::FloatAttr FusedBatchNormV2OpAdaptor::exponential_avg_factor() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::FloatAttr attr = odsAttrs.get("exponential_avg_factor").dyn_cast_or_null<::mlir::FloatAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getFloatAttr(::mlir::Builder(odsAttrs.getContext()).getF32Type(), 1.0f);
  return attr;
}

::mlir::StringAttr FusedBatchNormV2OpAdaptor::data_format() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::StringAttr attr = odsAttrs.get("data_format").dyn_cast_or_null<::mlir::StringAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getStringAttr("NHWC");
  return attr;
}

::mlir::BoolAttr FusedBatchNormV2OpAdaptor::is_training() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::BoolAttr attr = odsAttrs.get("is_training").dyn_cast_or_null<::mlir::BoolAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getBoolAttr(true);
  return attr;
}

::mlir::LogicalResult FusedBatchNormV2OpAdaptor::verify(::mlir::Location loc) {
  {
  auto tblgen_epsilon = odsAttrs.get("epsilon");
  if (tblgen_epsilon) {
    if (!(((tblgen_epsilon.isa<::mlir::FloatAttr>())) && ((tblgen_epsilon.cast<::mlir::FloatAttr>().getType().isF32())))) return emitError(loc, "'tf.FusedBatchNormV2' op ""attribute 'epsilon' failed to satisfy constraint: 32-bit float attribute");
  }
  }
  {
  auto tblgen_exponential_avg_factor = odsAttrs.get("exponential_avg_factor");
  if (tblgen_exponential_avg_factor) {
    if (!(((tblgen_exponential_avg_factor.isa<::mlir::FloatAttr>())) && ((tblgen_exponential_avg_factor.cast<::mlir::FloatAttr>().getType().isF32())))) return emitError(loc, "'tf.FusedBatchNormV2' op ""attribute 'exponential_avg_factor' failed to satisfy constraint: 32-bit float attribute");
  }
  }
  {
  auto tblgen_data_format = odsAttrs.get("data_format");
  if (tblgen_data_format) {
    if (!((tblgen_data_format.cast<StringAttr>().getValue() == "NHWC" || tblgen_data_format.cast<StringAttr>().getValue() == "NCHW"))) return emitError(loc, "'tf.FusedBatchNormV2' op ""attribute 'data_format' failed to satisfy constraint: 'NHWC' or 'NCHW' convnet data format");
  }
  }
  {
  auto tblgen_is_training = odsAttrs.get("is_training");
  if (tblgen_is_training) {
    if (!((tblgen_is_training.isa<::mlir::BoolAttr>()))) return emitError(loc, "'tf.FusedBatchNormV2' op ""attribute 'is_training' failed to satisfy constraint: bool attribute");
  }
  }
  return ::mlir::success();
}

void FusedBatchNormV2Op::getAsmResultNames(::mlir::OpAsmSetValueNameFn setNameFn) {
  auto resultGroup0 = getODSResults(0);
  if (!llvm::empty(resultGroup0))
    setNameFn(*resultGroup0.begin(), "y");
  auto resultGroup1 = getODSResults(1);
  if (!llvm::empty(resultGroup1))
    setNameFn(*resultGroup1.begin(), "batch_mean");
  auto resultGroup2 = getODSResults(2);
  if (!llvm::empty(resultGroup2))
    setNameFn(*resultGroup2.begin(), "batch_variance");
  auto resultGroup3 = getODSResults(3);
  if (!llvm::empty(resultGroup3))
    setNameFn(*resultGroup3.begin(), "reserve_space_1");
  auto resultGroup4 = getODSResults(4);
  if (!llvm::empty(resultGroup4))
    setNameFn(*resultGroup4.begin(), "reserve_space_2");
}

::llvm::StringRef FusedBatchNormV2Op::getOperationName() {
  return "tf.FusedBatchNormV2";
}

std::pair<unsigned, unsigned> FusedBatchNormV2Op::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range FusedBatchNormV2Op::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value FusedBatchNormV2Op::x() {
  return *getODSOperands(0).begin();
}

::mlir::Value FusedBatchNormV2Op::scale() {
  return *getODSOperands(1).begin();
}

::mlir::Value FusedBatchNormV2Op::offset() {
  return *getODSOperands(2).begin();
}

::mlir::Value FusedBatchNormV2Op::mean() {
  return *getODSOperands(3).begin();
}

::mlir::Value FusedBatchNormV2Op::variance() {
  return *getODSOperands(4).begin();
}

::mlir::MutableOperandRange FusedBatchNormV2Op::xMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange FusedBatchNormV2Op::scaleMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange FusedBatchNormV2Op::offsetMutable() {
  auto range = getODSOperandIndexAndLength(2);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange FusedBatchNormV2Op::meanMutable() {
  auto range = getODSOperandIndexAndLength(3);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange FusedBatchNormV2Op::varianceMutable() {
  auto range = getODSOperandIndexAndLength(4);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> FusedBatchNormV2Op::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range FusedBatchNormV2Op::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value FusedBatchNormV2Op::y() {
  return *getODSResults(0).begin();
}

::mlir::Value FusedBatchNormV2Op::batch_mean() {
  return *getODSResults(1).begin();
}

::mlir::Value FusedBatchNormV2Op::batch_variance() {
  return *getODSResults(2).begin();
}

::mlir::Value FusedBatchNormV2Op::reserve_space_1() {
  return *getODSResults(3).begin();
}

::mlir::Value FusedBatchNormV2Op::reserve_space_2() {
  return *getODSResults(4).begin();
}

::mlir::FloatAttr FusedBatchNormV2Op::epsilonAttr() {
  return this->getAttr("epsilon").dyn_cast_or_null<::mlir::FloatAttr>();
}

::llvm::APFloat FusedBatchNormV2Op::epsilon() {
  auto attr = epsilonAttr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getFloatAttr(::mlir::Builder(this->getContext()).getF32Type(), 0.0001f).getValue();
  return attr.getValue();
}

::mlir::FloatAttr FusedBatchNormV2Op::exponential_avg_factorAttr() {
  return this->getAttr("exponential_avg_factor").dyn_cast_or_null<::mlir::FloatAttr>();
}

::llvm::APFloat FusedBatchNormV2Op::exponential_avg_factor() {
  auto attr = exponential_avg_factorAttr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getFloatAttr(::mlir::Builder(this->getContext()).getF32Type(), 1.0f).getValue();
  return attr.getValue();
}

::mlir::StringAttr FusedBatchNormV2Op::data_formatAttr() {
  return this->getAttr("data_format").dyn_cast_or_null<::mlir::StringAttr>();
}

::llvm::StringRef FusedBatchNormV2Op::data_format() {
  auto attr = data_formatAttr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getStringAttr("NHWC").getValue();
  return attr.getValue();
}

::mlir::BoolAttr FusedBatchNormV2Op::is_trainingAttr() {
  return this->getAttr("is_training").dyn_cast_or_null<::mlir::BoolAttr>();
}

bool FusedBatchNormV2Op::is_training() {
  auto attr = is_trainingAttr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getBoolAttr(true).getValue();
  return attr.getValue();
}

Type FusedBatchNormV2Op::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

Type FusedBatchNormV2Op::U() {
  return mlir::getElementTypeOrSelf(*getODSOperands(1).begin());
}

bool FusedBatchNormV2Op::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "T") return true;
  if (name == "U") return true;
 return false;
}

::mlir::DictionaryAttr FusedBatchNormV2Op::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())},
    {::mlir::Identifier::get("U", ctx),
::mlir::TypeAttr::get(U())}
    }, ctx);
}

void FusedBatchNormV2Op::epsilonAttr(::mlir::FloatAttr attr) {
  this->getOperation()->setAttr("epsilon", attr);
}

void FusedBatchNormV2Op::exponential_avg_factorAttr(::mlir::FloatAttr attr) {
  this->getOperation()->setAttr("exponential_avg_factor", attr);
}

void FusedBatchNormV2Op::data_formatAttr(::mlir::StringAttr attr) {
  this->getOperation()->setAttr("data_format", attr);
}

void FusedBatchNormV2Op::is_trainingAttr(::mlir::BoolAttr attr) {
  this->getOperation()->setAttr("is_training", attr);
}

void FusedBatchNormV2Op::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type y, ::mlir::Type batch_mean, ::mlir::Type batch_variance, ::mlir::Type reserve_space_1, ::mlir::Type reserve_space_2, ::mlir::Value x, ::mlir::Value scale, ::mlir::Value offset, ::mlir::Value mean, ::mlir::Value variance, ::mlir::FloatAttr epsilon, ::mlir::FloatAttr exponential_avg_factor, ::mlir::StringAttr data_format, ::mlir::BoolAttr is_training) {
  odsState.addOperands(x);
  odsState.addOperands(scale);
  odsState.addOperands(offset);
  odsState.addOperands(mean);
  odsState.addOperands(variance);
  odsState.addAttribute("epsilon", epsilon);
  odsState.addAttribute("exponential_avg_factor", exponential_avg_factor);
  odsState.addAttribute("data_format", data_format);
  odsState.addAttribute("is_training", is_training);
  odsState.addTypes(y);
  odsState.addTypes(batch_mean);
  odsState.addTypes(batch_variance);
  odsState.addTypes(reserve_space_1);
  odsState.addTypes(reserve_space_2);
}

void FusedBatchNormV2Op::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value x, ::mlir::Value scale, ::mlir::Value offset, ::mlir::Value mean, ::mlir::Value variance, ::mlir::FloatAttr epsilon, ::mlir::FloatAttr exponential_avg_factor, ::mlir::StringAttr data_format, ::mlir::BoolAttr is_training) {
  odsState.addOperands(x);
  odsState.addOperands(scale);
  odsState.addOperands(offset);
  odsState.addOperands(mean);
  odsState.addOperands(variance);
  odsState.addAttribute("epsilon", epsilon);
  odsState.addAttribute("exponential_avg_factor", exponential_avg_factor);
  odsState.addAttribute("data_format", data_format);
  odsState.addAttribute("is_training", is_training);
  assert(resultTypes.size() == 5u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void FusedBatchNormV2Op::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type y, ::mlir::Type batch_mean, ::mlir::Type batch_variance, ::mlir::Type reserve_space_1, ::mlir::Type reserve_space_2, ::mlir::Value x, ::mlir::Value scale, ::mlir::Value offset, ::mlir::Value mean, ::mlir::Value variance, ::llvm::APFloat epsilon, ::llvm::APFloat exponential_avg_factor, ::llvm::StringRef data_format, bool is_training) {
  odsState.addOperands(x);
  odsState.addOperands(scale);
  odsState.addOperands(offset);
  odsState.addOperands(mean);
  odsState.addOperands(variance);
  odsState.addAttribute("epsilon", odsBuilder.getFloatAttr(odsBuilder.getF32Type(), epsilon));
  odsState.addAttribute("exponential_avg_factor", odsBuilder.getFloatAttr(odsBuilder.getF32Type(), exponential_avg_factor));
  odsState.addAttribute("data_format", odsBuilder.getStringAttr(data_format));
  odsState.addAttribute("is_training", odsBuilder.getBoolAttr(is_training));
  odsState.addTypes(y);
  odsState.addTypes(batch_mean);
  odsState.addTypes(batch_variance);
  odsState.addTypes(reserve_space_1);
  odsState.addTypes(reserve_space_2);
}

void FusedBatchNormV2Op::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value x, ::mlir::Value scale, ::mlir::Value offset, ::mlir::Value mean, ::mlir::Value variance, ::llvm::APFloat epsilon, ::llvm::APFloat exponential_avg_factor, ::llvm::StringRef data_format, bool is_training) {
  odsState.addOperands(x);
  odsState.addOperands(scale);
  odsState.addOperands(offset);
  odsState.addOperands(mean);
  odsState.addOperands(variance);
  odsState.addAttribute("epsilon", odsBuilder.getFloatAttr(odsBuilder.getF32Type(), epsilon));
  odsState.addAttribute("exponential_avg_factor", odsBuilder.getFloatAttr(odsBuilder.getF32Type(), exponential_avg_factor));
  odsState.addAttribute("data_format", odsBuilder.getStringAttr(data_format));
  odsState.addAttribute("is_training", odsBuilder.getBoolAttr(is_training));
  assert(resultTypes.size() == 5u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void FusedBatchNormV2Op::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 5u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 5u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult FusedBatchNormV2Op::verify() {
  if (failed(FusedBatchNormV2OpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of bfloat16 or 16-bit float or 32-bit float values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of 32-bit float values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup2 = getODSOperands(2);
    for (::mlir::Value v : valueGroup2) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of 32-bit float values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup3 = getODSOperands(3);
    for (::mlir::Value v : valueGroup3) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of 32-bit float values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup4 = getODSOperands(4);
    for (::mlir::Value v : valueGroup4) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of 32-bit float values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())))))) {
        return emitOpError("result #") << index << " must be tensor of bfloat16 or 16-bit float or 32-bit float values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSResults(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))))) {
        return emitOpError("result #") << index << " must be tensor of 32-bit float values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup2 = getODSResults(2);
    for (::mlir::Value v : valueGroup2) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))))) {
        return emitOpError("result #") << index << " must be tensor of 32-bit float values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup3 = getODSResults(3);
    for (::mlir::Value v : valueGroup3) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))))) {
        return emitOpError("result #") << index << " must be tensor of 32-bit float values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup4 = getODSResults(4);
    for (::mlir::Value v : valueGroup4) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))))) {
        return emitOpError("result #") << index << " must be tensor of 32-bit float values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void FusedBatchNormV2Op::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::FusedBatchNormV3Op definitions
//===----------------------------------------------------------------------===//

FusedBatchNormV3OpAdaptor::FusedBatchNormV3OpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

FusedBatchNormV3OpAdaptor::FusedBatchNormV3OpAdaptor(FusedBatchNormV3Op&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> FusedBatchNormV3OpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange FusedBatchNormV3OpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value FusedBatchNormV3OpAdaptor::x() {
  return *getODSOperands(0).begin();
}

::mlir::Value FusedBatchNormV3OpAdaptor::scale() {
  return *getODSOperands(1).begin();
}

::mlir::Value FusedBatchNormV3OpAdaptor::offset() {
  return *getODSOperands(2).begin();
}

::mlir::Value FusedBatchNormV3OpAdaptor::mean() {
  return *getODSOperands(3).begin();
}

::mlir::Value FusedBatchNormV3OpAdaptor::variance() {
  return *getODSOperands(4).begin();
}

::mlir::FloatAttr FusedBatchNormV3OpAdaptor::epsilon() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::FloatAttr attr = odsAttrs.get("epsilon").dyn_cast_or_null<::mlir::FloatAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getFloatAttr(::mlir::Builder(odsAttrs.getContext()).getF32Type(), 0.0001f);
  return attr;
}

::mlir::FloatAttr FusedBatchNormV3OpAdaptor::exponential_avg_factor() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::FloatAttr attr = odsAttrs.get("exponential_avg_factor").dyn_cast_or_null<::mlir::FloatAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getFloatAttr(::mlir::Builder(odsAttrs.getContext()).getF32Type(), 1.0f);
  return attr;
}

::mlir::StringAttr FusedBatchNormV3OpAdaptor::data_format() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::StringAttr attr = odsAttrs.get("data_format").dyn_cast_or_null<::mlir::StringAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getStringAttr("NHWC");
  return attr;
}

::mlir::BoolAttr FusedBatchNormV3OpAdaptor::is_training() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::BoolAttr attr = odsAttrs.get("is_training").dyn_cast_or_null<::mlir::BoolAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getBoolAttr(true);
  return attr;
}

::mlir::LogicalResult FusedBatchNormV3OpAdaptor::verify(::mlir::Location loc) {
  {
  auto tblgen_epsilon = odsAttrs.get("epsilon");
  if (tblgen_epsilon) {
    if (!(((tblgen_epsilon.isa<::mlir::FloatAttr>())) && ((tblgen_epsilon.cast<::mlir::FloatAttr>().getType().isF32())))) return emitError(loc, "'tf.FusedBatchNormV3' op ""attribute 'epsilon' failed to satisfy constraint: 32-bit float attribute");
  }
  }
  {
  auto tblgen_exponential_avg_factor = odsAttrs.get("exponential_avg_factor");
  if (tblgen_exponential_avg_factor) {
    if (!(((tblgen_exponential_avg_factor.isa<::mlir::FloatAttr>())) && ((tblgen_exponential_avg_factor.cast<::mlir::FloatAttr>().getType().isF32())))) return emitError(loc, "'tf.FusedBatchNormV3' op ""attribute 'exponential_avg_factor' failed to satisfy constraint: 32-bit float attribute");
  }
  }
  {
  auto tblgen_data_format = odsAttrs.get("data_format");
  if (tblgen_data_format) {
    if (!((tblgen_data_format.cast<StringAttr>().getValue() == "NHWC" || tblgen_data_format.cast<StringAttr>().getValue() == "NCHW" || tblgen_data_format.cast<StringAttr>().getValue() == "NDHWC" || tblgen_data_format.cast<StringAttr>().getValue() == "NCDHW"))) return emitError(loc, "'tf.FusedBatchNormV3' op ""attribute 'data_format' failed to satisfy constraint: string attribute whose value is NHWC, or NCHW, or NDHWC, or NCDHW");
  }
  }
  {
  auto tblgen_is_training = odsAttrs.get("is_training");
  if (tblgen_is_training) {
    if (!((tblgen_is_training.isa<::mlir::BoolAttr>()))) return emitError(loc, "'tf.FusedBatchNormV3' op ""attribute 'is_training' failed to satisfy constraint: bool attribute");
  }
  }
  return ::mlir::success();
}

void FusedBatchNormV3Op::getAsmResultNames(::mlir::OpAsmSetValueNameFn setNameFn) {
  auto resultGroup0 = getODSResults(0);
  if (!llvm::empty(resultGroup0))
    setNameFn(*resultGroup0.begin(), "y");
  auto resultGroup1 = getODSResults(1);
  if (!llvm::empty(resultGroup1))
    setNameFn(*resultGroup1.begin(), "batch_mean");
  auto resultGroup2 = getODSResults(2);
  if (!llvm::empty(resultGroup2))
    setNameFn(*resultGroup2.begin(), "batch_variance");
  auto resultGroup3 = getODSResults(3);
  if (!llvm::empty(resultGroup3))
    setNameFn(*resultGroup3.begin(), "reserve_space_1");
  auto resultGroup4 = getODSResults(4);
  if (!llvm::empty(resultGroup4))
    setNameFn(*resultGroup4.begin(), "reserve_space_2");
  auto resultGroup5 = getODSResults(5);
  if (!llvm::empty(resultGroup5))
    setNameFn(*resultGroup5.begin(), "reserve_space_3");
}

::llvm::StringRef FusedBatchNormV3Op::getOperationName() {
  return "tf.FusedBatchNormV3";
}

std::pair<unsigned, unsigned> FusedBatchNormV3Op::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range FusedBatchNormV3Op::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value FusedBatchNormV3Op::x() {
  return *getODSOperands(0).begin();
}

::mlir::Value FusedBatchNormV3Op::scale() {
  return *getODSOperands(1).begin();
}

::mlir::Value FusedBatchNormV3Op::offset() {
  return *getODSOperands(2).begin();
}

::mlir::Value FusedBatchNormV3Op::mean() {
  return *getODSOperands(3).begin();
}

::mlir::Value FusedBatchNormV3Op::variance() {
  return *getODSOperands(4).begin();
}

::mlir::MutableOperandRange FusedBatchNormV3Op::xMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange FusedBatchNormV3Op::scaleMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange FusedBatchNormV3Op::offsetMutable() {
  auto range = getODSOperandIndexAndLength(2);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange FusedBatchNormV3Op::meanMutable() {
  auto range = getODSOperandIndexAndLength(3);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange FusedBatchNormV3Op::varianceMutable() {
  auto range = getODSOperandIndexAndLength(4);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> FusedBatchNormV3Op::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range FusedBatchNormV3Op::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value FusedBatchNormV3Op::y() {
  return *getODSResults(0).begin();
}

::mlir::Value FusedBatchNormV3Op::batch_mean() {
  return *getODSResults(1).begin();
}

::mlir::Value FusedBatchNormV3Op::batch_variance() {
  return *getODSResults(2).begin();
}

::mlir::Value FusedBatchNormV3Op::reserve_space_1() {
  return *getODSResults(3).begin();
}

::mlir::Value FusedBatchNormV3Op::reserve_space_2() {
  return *getODSResults(4).begin();
}

::mlir::Value FusedBatchNormV3Op::reserve_space_3() {
  return *getODSResults(5).begin();
}

::mlir::FloatAttr FusedBatchNormV3Op::epsilonAttr() {
  return this->getAttr("epsilon").dyn_cast_or_null<::mlir::FloatAttr>();
}

::llvm::APFloat FusedBatchNormV3Op::epsilon() {
  auto attr = epsilonAttr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getFloatAttr(::mlir::Builder(this->getContext()).getF32Type(), 0.0001f).getValue();
  return attr.getValue();
}

::mlir::FloatAttr FusedBatchNormV3Op::exponential_avg_factorAttr() {
  return this->getAttr("exponential_avg_factor").dyn_cast_or_null<::mlir::FloatAttr>();
}

::llvm::APFloat FusedBatchNormV3Op::exponential_avg_factor() {
  auto attr = exponential_avg_factorAttr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getFloatAttr(::mlir::Builder(this->getContext()).getF32Type(), 1.0f).getValue();
  return attr.getValue();
}

::mlir::StringAttr FusedBatchNormV3Op::data_formatAttr() {
  return this->getAttr("data_format").dyn_cast_or_null<::mlir::StringAttr>();
}

::llvm::StringRef FusedBatchNormV3Op::data_format() {
  auto attr = data_formatAttr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getStringAttr("NHWC").getValue();
  return attr.getValue();
}

::mlir::BoolAttr FusedBatchNormV3Op::is_trainingAttr() {
  return this->getAttr("is_training").dyn_cast_or_null<::mlir::BoolAttr>();
}

bool FusedBatchNormV3Op::is_training() {
  auto attr = is_trainingAttr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getBoolAttr(true).getValue();
  return attr.getValue();
}

Type FusedBatchNormV3Op::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

Type FusedBatchNormV3Op::U() {
  return mlir::getElementTypeOrSelf(*getODSOperands(1).begin());
}

bool FusedBatchNormV3Op::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "T") return true;
  if (name == "U") return true;
 return false;
}

::mlir::DictionaryAttr FusedBatchNormV3Op::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())},
    {::mlir::Identifier::get("U", ctx),
::mlir::TypeAttr::get(U())}
    }, ctx);
}

void FusedBatchNormV3Op::epsilonAttr(::mlir::FloatAttr attr) {
  this->getOperation()->setAttr("epsilon", attr);
}

void FusedBatchNormV3Op::exponential_avg_factorAttr(::mlir::FloatAttr attr) {
  this->getOperation()->setAttr("exponential_avg_factor", attr);
}

void FusedBatchNormV3Op::data_formatAttr(::mlir::StringAttr attr) {
  this->getOperation()->setAttr("data_format", attr);
}

void FusedBatchNormV3Op::is_trainingAttr(::mlir::BoolAttr attr) {
  this->getOperation()->setAttr("is_training", attr);
}

void FusedBatchNormV3Op::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type y, ::mlir::Type batch_mean, ::mlir::Type batch_variance, ::mlir::Type reserve_space_1, ::mlir::Type reserve_space_2, ::mlir::Type reserve_space_3, ::mlir::Value x, ::mlir::Value scale, ::mlir::Value offset, ::mlir::Value mean, ::mlir::Value variance, ::mlir::FloatAttr epsilon, ::mlir::FloatAttr exponential_avg_factor, ::mlir::StringAttr data_format, ::mlir::BoolAttr is_training) {
  odsState.addOperands(x);
  odsState.addOperands(scale);
  odsState.addOperands(offset);
  odsState.addOperands(mean);
  odsState.addOperands(variance);
  odsState.addAttribute("epsilon", epsilon);
  odsState.addAttribute("exponential_avg_factor", exponential_avg_factor);
  odsState.addAttribute("data_format", data_format);
  odsState.addAttribute("is_training", is_training);
  odsState.addTypes(y);
  odsState.addTypes(batch_mean);
  odsState.addTypes(batch_variance);
  odsState.addTypes(reserve_space_1);
  odsState.addTypes(reserve_space_2);
  odsState.addTypes(reserve_space_3);
}

void FusedBatchNormV3Op::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value x, ::mlir::Value scale, ::mlir::Value offset, ::mlir::Value mean, ::mlir::Value variance, ::mlir::FloatAttr epsilon, ::mlir::FloatAttr exponential_avg_factor, ::mlir::StringAttr data_format, ::mlir::BoolAttr is_training) {
  odsState.addOperands(x);
  odsState.addOperands(scale);
  odsState.addOperands(offset);
  odsState.addOperands(mean);
  odsState.addOperands(variance);
  odsState.addAttribute("epsilon", epsilon);
  odsState.addAttribute("exponential_avg_factor", exponential_avg_factor);
  odsState.addAttribute("data_format", data_format);
  odsState.addAttribute("is_training", is_training);
  assert(resultTypes.size() == 6u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void FusedBatchNormV3Op::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type y, ::mlir::Type batch_mean, ::mlir::Type batch_variance, ::mlir::Type reserve_space_1, ::mlir::Type reserve_space_2, ::mlir::Type reserve_space_3, ::mlir::Value x, ::mlir::Value scale, ::mlir::Value offset, ::mlir::Value mean, ::mlir::Value variance, ::llvm::APFloat epsilon, ::llvm::APFloat exponential_avg_factor, ::llvm::StringRef data_format, bool is_training) {
  odsState.addOperands(x);
  odsState.addOperands(scale);
  odsState.addOperands(offset);
  odsState.addOperands(mean);
  odsState.addOperands(variance);
  odsState.addAttribute("epsilon", odsBuilder.getFloatAttr(odsBuilder.getF32Type(), epsilon));
  odsState.addAttribute("exponential_avg_factor", odsBuilder.getFloatAttr(odsBuilder.getF32Type(), exponential_avg_factor));
  odsState.addAttribute("data_format", odsBuilder.getStringAttr(data_format));
  odsState.addAttribute("is_training", odsBuilder.getBoolAttr(is_training));
  odsState.addTypes(y);
  odsState.addTypes(batch_mean);
  odsState.addTypes(batch_variance);
  odsState.addTypes(reserve_space_1);
  odsState.addTypes(reserve_space_2);
  odsState.addTypes(reserve_space_3);
}

void FusedBatchNormV3Op::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value x, ::mlir::Value scale, ::mlir::Value offset, ::mlir::Value mean, ::mlir::Value variance, ::llvm::APFloat epsilon, ::llvm::APFloat exponential_avg_factor, ::llvm::StringRef data_format, bool is_training) {
  odsState.addOperands(x);
  odsState.addOperands(scale);
  odsState.addOperands(offset);
  odsState.addOperands(mean);
  odsState.addOperands(variance);
  odsState.addAttribute("epsilon", odsBuilder.getFloatAttr(odsBuilder.getF32Type(), epsilon));
  odsState.addAttribute("exponential_avg_factor", odsBuilder.getFloatAttr(odsBuilder.getF32Type(), exponential_avg_factor));
  odsState.addAttribute("data_format", odsBuilder.getStringAttr(data_format));
  odsState.addAttribute("is_training", odsBuilder.getBoolAttr(is_training));
  assert(resultTypes.size() == 6u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void FusedBatchNormV3Op::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 5u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 6u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult FusedBatchNormV3Op::verify() {
  if (failed(FusedBatchNormV3OpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of bfloat16 or 16-bit float or 32-bit float values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of 32-bit float values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup2 = getODSOperands(2);
    for (::mlir::Value v : valueGroup2) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of 32-bit float values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup3 = getODSOperands(3);
    for (::mlir::Value v : valueGroup3) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of 32-bit float values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup4 = getODSOperands(4);
    for (::mlir::Value v : valueGroup4) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of 32-bit float values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())))))) {
        return emitOpError("result #") << index << " must be tensor of bfloat16 or 16-bit float or 32-bit float values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSResults(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))))) {
        return emitOpError("result #") << index << " must be tensor of 32-bit float values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup2 = getODSResults(2);
    for (::mlir::Value v : valueGroup2) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))))) {
        return emitOpError("result #") << index << " must be tensor of 32-bit float values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup3 = getODSResults(3);
    for (::mlir::Value v : valueGroup3) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))))) {
        return emitOpError("result #") << index << " must be tensor of 32-bit float values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup4 = getODSResults(4);
    for (::mlir::Value v : valueGroup4) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))))) {
        return emitOpError("result #") << index << " must be tensor of 32-bit float values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup5 = getODSResults(5);
    for (::mlir::Value v : valueGroup5) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))))) {
        return emitOpError("result #") << index << " must be tensor of 32-bit float values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void FusedBatchNormV3Op::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::GatherNdOp definitions
//===----------------------------------------------------------------------===//

GatherNdOpAdaptor::GatherNdOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

GatherNdOpAdaptor::GatherNdOpAdaptor(GatherNdOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> GatherNdOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange GatherNdOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value GatherNdOpAdaptor::params() {
  return *getODSOperands(0).begin();
}

::mlir::Value GatherNdOpAdaptor::indices() {
  return *getODSOperands(1).begin();
}

::mlir::LogicalResult GatherNdOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

::llvm::StringRef GatherNdOp::getOperationName() {
  return "tf.GatherNd";
}

std::pair<unsigned, unsigned> GatherNdOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range GatherNdOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value GatherNdOp::params() {
  return *getODSOperands(0).begin();
}

::mlir::Value GatherNdOp::indices() {
  return *getODSOperands(1).begin();
}

::mlir::MutableOperandRange GatherNdOp::paramsMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange GatherNdOp::indicesMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> GatherNdOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range GatherNdOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value GatherNdOp::output() {
  return *getODSResults(0).begin();
}

Type GatherNdOp::Tindices() {
  return mlir::getElementTypeOrSelf(*getODSOperands(1).begin());
}

Type GatherNdOp::Tparams() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

bool GatherNdOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "Tindices") return true;
  if (name == "Tparams") return true;
 return false;
}

::mlir::DictionaryAttr GatherNdOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("Tindices", ctx),
::mlir::TypeAttr::get(Tindices())},
    {::mlir::Identifier::get("Tparams", ctx),
::mlir::TypeAttr::get(Tparams())}
    }, ctx);
}

void GatherNdOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value params, ::mlir::Value indices) {
  odsState.addOperands(params);
  odsState.addOperands(indices);
  odsState.addTypes(output);
}

void GatherNdOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value params, ::mlir::Value indices) {
  odsState.addOperands(params);
  odsState.addOperands(indices);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void GatherNdOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult GatherNdOp::verify() {
  if (failed(GatherNdOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>())))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::TensorFlowType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of tf.dtype values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of 32/64-bit signed integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>())))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::TensorFlowType>()))))) {
        return emitOpError("result #") << index << " must be tensor of tf.dtype values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void GatherNdOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::GatherOp definitions
//===----------------------------------------------------------------------===//

GatherOpAdaptor::GatherOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

GatherOpAdaptor::GatherOpAdaptor(GatherOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> GatherOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange GatherOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value GatherOpAdaptor::params() {
  return *getODSOperands(0).begin();
}

::mlir::Value GatherOpAdaptor::indices() {
  return *getODSOperands(1).begin();
}

::mlir::BoolAttr GatherOpAdaptor::validate_indices() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::BoolAttr attr = odsAttrs.get("validate_indices").dyn_cast_or_null<::mlir::BoolAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getBoolAttr(true);
  return attr;
}

::mlir::LogicalResult GatherOpAdaptor::verify(::mlir::Location loc) {
  {
  auto tblgen_validate_indices = odsAttrs.get("validate_indices");
  if (tblgen_validate_indices) {
    if (!((tblgen_validate_indices.isa<::mlir::BoolAttr>()))) return emitError(loc, "'tf.Gather' op ""attribute 'validate_indices' failed to satisfy constraint: bool attribute");
  }
  }
  return ::mlir::success();
}

::llvm::StringRef GatherOp::getOperationName() {
  return "tf.Gather";
}

std::pair<unsigned, unsigned> GatherOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range GatherOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value GatherOp::params() {
  return *getODSOperands(0).begin();
}

::mlir::Value GatherOp::indices() {
  return *getODSOperands(1).begin();
}

::mlir::MutableOperandRange GatherOp::paramsMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange GatherOp::indicesMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> GatherOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range GatherOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value GatherOp::output() {
  return *getODSResults(0).begin();
}

::mlir::BoolAttr GatherOp::validate_indicesAttr() {
  return this->getAttr("validate_indices").dyn_cast_or_null<::mlir::BoolAttr>();
}

bool GatherOp::validate_indices() {
  auto attr = validate_indicesAttr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getBoolAttr(true).getValue();
  return attr.getValue();
}

Type GatherOp::Tindices() {
  return mlir::getElementTypeOrSelf(*getODSOperands(1).begin());
}

Type GatherOp::Tparams() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

bool GatherOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "Tindices") return true;
  if (name == "Tparams") return true;
 return false;
}

::mlir::DictionaryAttr GatherOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("Tindices", ctx),
::mlir::TypeAttr::get(Tindices())},
    {::mlir::Identifier::get("Tparams", ctx),
::mlir::TypeAttr::get(Tparams())}
    }, ctx);
}

void GatherOp::validate_indicesAttr(::mlir::BoolAttr attr) {
  this->getOperation()->setAttr("validate_indices", attr);
}

void GatherOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value params, ::mlir::Value indices, ::mlir::BoolAttr validate_indices) {
  odsState.addOperands(params);
  odsState.addOperands(indices);
  odsState.addAttribute("validate_indices", validate_indices);
  odsState.addTypes(output);
}

void GatherOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value params, ::mlir::Value indices, ::mlir::BoolAttr validate_indices) {
  odsState.addOperands(params);
  odsState.addOperands(indices);
  odsState.addAttribute("validate_indices", validate_indices);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void GatherOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value params, ::mlir::Value indices, bool validate_indices) {
  odsState.addOperands(params);
  odsState.addOperands(indices);
  odsState.addAttribute("validate_indices", odsBuilder.getBoolAttr(validate_indices));
  odsState.addTypes(output);
}

void GatherOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value params, ::mlir::Value indices, bool validate_indices) {
  odsState.addOperands(params);
  odsState.addOperands(indices);
  odsState.addAttribute("validate_indices", odsBuilder.getBoolAttr(validate_indices));
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void GatherOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult GatherOp::verify() {
  if (failed(GatherOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>())))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::TensorFlowType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of tf.dtype values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of 32/64-bit signed integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>())))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::TensorFlowType>()))))) {
        return emitOpError("result #") << index << " must be tensor of tf.dtype values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void GatherOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::GatherV2Op definitions
//===----------------------------------------------------------------------===//

GatherV2OpAdaptor::GatherV2OpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

GatherV2OpAdaptor::GatherV2OpAdaptor(GatherV2Op&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> GatherV2OpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange GatherV2OpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value GatherV2OpAdaptor::params() {
  return *getODSOperands(0).begin();
}

::mlir::Value GatherV2OpAdaptor::indices() {
  return *getODSOperands(1).begin();
}

::mlir::Value GatherV2OpAdaptor::axis() {
  return *getODSOperands(2).begin();
}

::mlir::IntegerAttr GatherV2OpAdaptor::batch_dims() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::IntegerAttr attr = odsAttrs.get("batch_dims").dyn_cast_or_null<::mlir::IntegerAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getIntegerAttr(::mlir::Builder(odsAttrs.getContext()).getIntegerType(64), 0);
  return attr;
}

::mlir::LogicalResult GatherV2OpAdaptor::verify(::mlir::Location loc) {
  {
  auto tblgen_batch_dims = odsAttrs.get("batch_dims");
  if (tblgen_batch_dims) {
    if (!(((tblgen_batch_dims.isa<::mlir::IntegerAttr>())) && ((tblgen_batch_dims.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(64))))) return emitError(loc, "'tf.GatherV2' op ""attribute 'batch_dims' failed to satisfy constraint: 64-bit signless integer attribute");
  }
  }
  return ::mlir::success();
}

::llvm::StringRef GatherV2Op::getOperationName() {
  return "tf.GatherV2";
}

std::pair<unsigned, unsigned> GatherV2Op::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range GatherV2Op::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value GatherV2Op::params() {
  return *getODSOperands(0).begin();
}

::mlir::Value GatherV2Op::indices() {
  return *getODSOperands(1).begin();
}

::mlir::Value GatherV2Op::axis() {
  return *getODSOperands(2).begin();
}

::mlir::MutableOperandRange GatherV2Op::paramsMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange GatherV2Op::indicesMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange GatherV2Op::axisMutable() {
  auto range = getODSOperandIndexAndLength(2);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> GatherV2Op::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range GatherV2Op::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value GatherV2Op::output() {
  return *getODSResults(0).begin();
}

::mlir::IntegerAttr GatherV2Op::batch_dimsAttr() {
  return this->getAttr("batch_dims").dyn_cast_or_null<::mlir::IntegerAttr>();
}

uint64_t GatherV2Op::batch_dims() {
  auto attr = batch_dimsAttr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getIntegerAttr(::mlir::Builder(this->getContext()).getIntegerType(64), 0).getValue().getZExtValue();
  return attr.getValue().getZExtValue();
}

Type GatherV2Op::Tindices() {
  return mlir::getElementTypeOrSelf(*getODSOperands(1).begin());
}

Type GatherV2Op::Tparams() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

Type GatherV2Op::Taxis() {
  return mlir::getElementTypeOrSelf(*getODSOperands(2).begin());
}

bool GatherV2Op::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "Tindices") return true;
  if (name == "Tparams") return true;
  if (name == "Taxis") return true;
 return false;
}

::mlir::DictionaryAttr GatherV2Op::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("Tindices", ctx),
::mlir::TypeAttr::get(Tindices())},
    {::mlir::Identifier::get("Tparams", ctx),
::mlir::TypeAttr::get(Tparams())},
    {::mlir::Identifier::get("Taxis", ctx),
::mlir::TypeAttr::get(Taxis())}
    }, ctx);
}

void GatherV2Op::batch_dimsAttr(::mlir::IntegerAttr attr) {
  this->getOperation()->setAttr("batch_dims", attr);
}

void GatherV2Op::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value params, ::mlir::Value indices, ::mlir::Value axis, ::mlir::IntegerAttr batch_dims) {
  odsState.addOperands(params);
  odsState.addOperands(indices);
  odsState.addOperands(axis);
  odsState.addAttribute("batch_dims", batch_dims);
  odsState.addTypes(output);
}

void GatherV2Op::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value params, ::mlir::Value indices, ::mlir::Value axis, ::mlir::IntegerAttr batch_dims) {
  odsState.addOperands(params);
  odsState.addOperands(indices);
  odsState.addOperands(axis);
  odsState.addAttribute("batch_dims", batch_dims);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void GatherV2Op::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value params, ::mlir::Value indices, ::mlir::Value axis, uint64_t batch_dims) {
  odsState.addOperands(params);
  odsState.addOperands(indices);
  odsState.addOperands(axis);
  odsState.addAttribute("batch_dims", odsBuilder.getIntegerAttr(odsBuilder.getIntegerType(64), batch_dims));
  odsState.addTypes(output);
}

void GatherV2Op::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value params, ::mlir::Value indices, ::mlir::Value axis, uint64_t batch_dims) {
  odsState.addOperands(params);
  odsState.addOperands(indices);
  odsState.addOperands(axis);
  odsState.addAttribute("batch_dims", odsBuilder.getIntegerAttr(odsBuilder.getIntegerType(64), batch_dims));
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void GatherV2Op::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 3u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult GatherV2Op::verify() {
  if (failed(GatherV2OpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>())))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::TensorFlowType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of tf.dtype values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of 32/64-bit signed integer values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup2 = getODSOperands(2);
    for (::mlir::Value v : valueGroup2) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of 32/64-bit signed integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>())))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::TensorFlowType>()))))) {
        return emitOpError("result #") << index << " must be tensor of tf.dtype values, but got " << v.getType();
      }
      ++index;
    }
  }
  return Verify(*this);
}

void GatherV2Op::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::GreaterEqualOp definitions
//===----------------------------------------------------------------------===//

GreaterEqualOpAdaptor::GreaterEqualOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

GreaterEqualOpAdaptor::GreaterEqualOpAdaptor(GreaterEqualOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> GreaterEqualOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange GreaterEqualOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value GreaterEqualOpAdaptor::x() {
  return *getODSOperands(0).begin();
}

::mlir::Value GreaterEqualOpAdaptor::y() {
  return *getODSOperands(1).begin();
}

::mlir::LogicalResult GreaterEqualOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

::llvm::StringRef GreaterEqualOp::getOperationName() {
  return "tf.GreaterEqual";
}

std::pair<unsigned, unsigned> GreaterEqualOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range GreaterEqualOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value GreaterEqualOp::x() {
  return *getODSOperands(0).begin();
}

::mlir::Value GreaterEqualOp::y() {
  return *getODSOperands(1).begin();
}

::mlir::MutableOperandRange GreaterEqualOp::xMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange GreaterEqualOp::yMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> GreaterEqualOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range GreaterEqualOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value GreaterEqualOp::z() {
  return *getODSResults(0).begin();
}

Type GreaterEqualOp::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

bool GreaterEqualOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "T") return true;
 return false;
}

::mlir::DictionaryAttr GreaterEqualOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())}
    }, ctx);
}

void GreaterEqualOp::build(OpBuilder &builder, OperationState &result, Value  x, Value  y) {
  Type resultType;
  if (x.getType().isa<UnrankedTensorType>() ||
      y.getType().isa<UnrankedTensorType>()) {
    resultType = UnrankedTensorType::get(builder.getI1Type());
  } else {
    SmallVector<int64_t, 4> resultShape;
    if (!OpTrait::util::getBroadcastedShape(
            x.getType().cast<ShapedType>().getShape(),
            y.getType().cast<ShapedType>().getShape(), resultShape)) {
      mlir::emitError(result.location,
                      "operands have no broadcastable shapes");
    }

    resultType = RankedTensorType::get(resultShape, builder.getI1Type());
  }
  return build(builder, result, resultType, x, y);
}

void GreaterEqualOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type z, ::mlir::Value x, ::mlir::Value y) {
  odsState.addOperands(x);
  odsState.addOperands(y);
  odsState.addTypes(z);
}

void GreaterEqualOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value x, ::mlir::Value y) {
  odsState.addOperands(x);
  odsState.addOperands(y);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void GreaterEqualOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult GreaterEqualOp::verify() {
  if (failed(GreaterEqualOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of integer or floating-point values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of integer or floating-point values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))))) {
        return emitOpError("result #") << index << " must be tensor of bool values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void GreaterEqualOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::GreaterOp definitions
//===----------------------------------------------------------------------===//

GreaterOpAdaptor::GreaterOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

GreaterOpAdaptor::GreaterOpAdaptor(GreaterOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> GreaterOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange GreaterOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value GreaterOpAdaptor::x() {
  return *getODSOperands(0).begin();
}

::mlir::Value GreaterOpAdaptor::y() {
  return *getODSOperands(1).begin();
}

::mlir::LogicalResult GreaterOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

::llvm::StringRef GreaterOp::getOperationName() {
  return "tf.Greater";
}

std::pair<unsigned, unsigned> GreaterOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range GreaterOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value GreaterOp::x() {
  return *getODSOperands(0).begin();
}

::mlir::Value GreaterOp::y() {
  return *getODSOperands(1).begin();
}

::mlir::MutableOperandRange GreaterOp::xMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange GreaterOp::yMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> GreaterOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range GreaterOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value GreaterOp::z() {
  return *getODSResults(0).begin();
}

Type GreaterOp::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

bool GreaterOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "T") return true;
 return false;
}

::mlir::DictionaryAttr GreaterOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())}
    }, ctx);
}

void GreaterOp::build(OpBuilder &builder, OperationState &result, Value  x, Value  y) {
  Type resultType;
  if (x.getType().isa<UnrankedTensorType>() ||
      y.getType().isa<UnrankedTensorType>()) {
    resultType = UnrankedTensorType::get(builder.getI1Type());
  } else {
    SmallVector<int64_t, 4> resultShape;
    if (!OpTrait::util::getBroadcastedShape(
            x.getType().cast<ShapedType>().getShape(),
            y.getType().cast<ShapedType>().getShape(), resultShape)) {
      mlir::emitError(result.location,
                      "operands have no broadcastable shapes");
    }

    resultType = RankedTensorType::get(resultShape, builder.getI1Type());
  }
  return build(builder, result, resultType, x, y);
}

void GreaterOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type z, ::mlir::Value x, ::mlir::Value y) {
  odsState.addOperands(x);
  odsState.addOperands(y);
  odsState.addTypes(z);
}

void GreaterOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value x, ::mlir::Value y) {
  odsState.addOperands(x);
  odsState.addOperands(y);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void GreaterOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult GreaterOp::verify() {
  if (failed(GreaterOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of integer or floating-point values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of integer or floating-point values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))))) {
        return emitOpError("result #") << index << " must be tensor of bool values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void GreaterOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::HSVToRGBOp definitions
//===----------------------------------------------------------------------===//

HSVToRGBOpAdaptor::HSVToRGBOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

HSVToRGBOpAdaptor::HSVToRGBOpAdaptor(HSVToRGBOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> HSVToRGBOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange HSVToRGBOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value HSVToRGBOpAdaptor::images() {
  return *getODSOperands(0).begin();
}

::mlir::LogicalResult HSVToRGBOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

::llvm::StringRef HSVToRGBOp::getOperationName() {
  return "tf.HSVToRGB";
}

std::pair<unsigned, unsigned> HSVToRGBOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range HSVToRGBOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value HSVToRGBOp::images() {
  return *getODSOperands(0).begin();
}

::mlir::MutableOperandRange HSVToRGBOp::imagesMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> HSVToRGBOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range HSVToRGBOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value HSVToRGBOp::output() {
  return *getODSResults(0).begin();
}

Type HSVToRGBOp::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

bool HSVToRGBOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "T") return true;
 return false;
}

::mlir::DictionaryAttr HSVToRGBOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())}
    }, ctx);
}

void HSVToRGBOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value images) {
  odsState.addOperands(images);
  odsState.addTypes(output);
}

void HSVToRGBOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value images) {
  odsState.addOperands(images);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void HSVToRGBOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult HSVToRGBOp::verify() {
  if (failed(HSVToRGBOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of floating-point values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))))) {
        return emitOpError("result #") << index << " must be tensor of floating-point values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void HSVToRGBOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::HashTableV2Op definitions
//===----------------------------------------------------------------------===//

HashTableV2OpAdaptor::HashTableV2OpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

HashTableV2OpAdaptor::HashTableV2OpAdaptor(HashTableV2Op&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> HashTableV2OpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange HashTableV2OpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::StringAttr HashTableV2OpAdaptor::container() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::StringAttr attr = odsAttrs.get("container").cast<::mlir::StringAttr>();
  return attr;
}

::mlir::StringAttr HashTableV2OpAdaptor::shared_name() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::StringAttr attr = odsAttrs.get("shared_name").cast<::mlir::StringAttr>();
  return attr;
}

::mlir::BoolAttr HashTableV2OpAdaptor::use_node_name_sharing() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::BoolAttr attr = odsAttrs.get("use_node_name_sharing").dyn_cast_or_null<::mlir::BoolAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getBoolAttr(false);
  return attr;
}

::mlir::TypeAttr HashTableV2OpAdaptor::key_dtype() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::TypeAttr attr = odsAttrs.get("key_dtype").cast<::mlir::TypeAttr>();
  return attr;
}

::mlir::TypeAttr HashTableV2OpAdaptor::value_dtype() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::TypeAttr attr = odsAttrs.get("value_dtype").cast<::mlir::TypeAttr>();
  return attr;
}

::mlir::LogicalResult HashTableV2OpAdaptor::verify(::mlir::Location loc) {
  {
  auto tblgen_container = odsAttrs.get("container");
  if (!tblgen_container) return emitError(loc, "'tf.HashTableV2' op ""requires attribute 'container'");
    if (!((tblgen_container.isa<::mlir::StringAttr>()))) return emitError(loc, "'tf.HashTableV2' op ""attribute 'container' failed to satisfy constraint: string attribute");
  }
  {
  auto tblgen_shared_name = odsAttrs.get("shared_name");
  if (!tblgen_shared_name) return emitError(loc, "'tf.HashTableV2' op ""requires attribute 'shared_name'");
    if (!((tblgen_shared_name.isa<::mlir::StringAttr>()))) return emitError(loc, "'tf.HashTableV2' op ""attribute 'shared_name' failed to satisfy constraint: string attribute");
  }
  {
  auto tblgen_use_node_name_sharing = odsAttrs.get("use_node_name_sharing");
  if (tblgen_use_node_name_sharing) {
    if (!((tblgen_use_node_name_sharing.isa<::mlir::BoolAttr>()))) return emitError(loc, "'tf.HashTableV2' op ""attribute 'use_node_name_sharing' failed to satisfy constraint: bool attribute");
  }
  }
  {
  auto tblgen_key_dtype = odsAttrs.get("key_dtype");
  if (!tblgen_key_dtype) return emitError(loc, "'tf.HashTableV2' op ""requires attribute 'key_dtype'");
    if (!(((tblgen_key_dtype.isa<::mlir::TypeAttr>())) && ((tblgen_key_dtype.cast<::mlir::TypeAttr>().getValue().isa<::mlir::Type>())))) return emitError(loc, "'tf.HashTableV2' op ""attribute 'key_dtype' failed to satisfy constraint: any type attribute");
  }
  {
  auto tblgen_value_dtype = odsAttrs.get("value_dtype");
  if (!tblgen_value_dtype) return emitError(loc, "'tf.HashTableV2' op ""requires attribute 'value_dtype'");
    if (!(((tblgen_value_dtype.isa<::mlir::TypeAttr>())) && ((tblgen_value_dtype.cast<::mlir::TypeAttr>().getValue().isa<::mlir::Type>())))) return emitError(loc, "'tf.HashTableV2' op ""attribute 'value_dtype' failed to satisfy constraint: any type attribute");
  }
  return ::mlir::success();
}

::llvm::StringRef HashTableV2Op::getOperationName() {
  return "tf.HashTableV2";
}

std::pair<unsigned, unsigned> HashTableV2Op::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range HashTableV2Op::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

std::pair<unsigned, unsigned> HashTableV2Op::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range HashTableV2Op::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value HashTableV2Op::table_handle() {
  return *getODSResults(0).begin();
}

::mlir::StringAttr HashTableV2Op::containerAttr() {
  return this->getAttr("container").cast<::mlir::StringAttr>();
}

::llvm::StringRef HashTableV2Op::container() {
  auto attr = containerAttr();
  return attr.getValue();
}

::mlir::StringAttr HashTableV2Op::shared_nameAttr() {
  return this->getAttr("shared_name").cast<::mlir::StringAttr>();
}

::llvm::StringRef HashTableV2Op::shared_name() {
  auto attr = shared_nameAttr();
  return attr.getValue();
}

::mlir::BoolAttr HashTableV2Op::use_node_name_sharingAttr() {
  return this->getAttr("use_node_name_sharing").dyn_cast_or_null<::mlir::BoolAttr>();
}

bool HashTableV2Op::use_node_name_sharing() {
  auto attr = use_node_name_sharingAttr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getBoolAttr(false).getValue();
  return attr.getValue();
}

::mlir::TypeAttr HashTableV2Op::key_dtypeAttr() {
  return this->getAttr("key_dtype").cast<::mlir::TypeAttr>();
}

::mlir::Type HashTableV2Op::key_dtype() {
  auto attr = key_dtypeAttr();
  return attr.getValue().cast<::mlir::Type>();
}

::mlir::TypeAttr HashTableV2Op::value_dtypeAttr() {
  return this->getAttr("value_dtype").cast<::mlir::TypeAttr>();
}

::mlir::Type HashTableV2Op::value_dtype() {
  auto attr = value_dtypeAttr();
  return attr.getValue().cast<::mlir::Type>();
}

void HashTableV2Op::containerAttr(::mlir::StringAttr attr) {
  this->getOperation()->setAttr("container", attr);
}

void HashTableV2Op::shared_nameAttr(::mlir::StringAttr attr) {
  this->getOperation()->setAttr("shared_name", attr);
}

void HashTableV2Op::use_node_name_sharingAttr(::mlir::BoolAttr attr) {
  this->getOperation()->setAttr("use_node_name_sharing", attr);
}

void HashTableV2Op::key_dtypeAttr(::mlir::TypeAttr attr) {
  this->getOperation()->setAttr("key_dtype", attr);
}

void HashTableV2Op::value_dtypeAttr(::mlir::TypeAttr attr) {
  this->getOperation()->setAttr("value_dtype", attr);
}

void HashTableV2Op::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type table_handle, ::mlir::StringAttr container, ::mlir::StringAttr shared_name, ::mlir::BoolAttr use_node_name_sharing, ::mlir::TypeAttr key_dtype, ::mlir::TypeAttr value_dtype) {
  odsState.addAttribute("container", container);
  odsState.addAttribute("shared_name", shared_name);
  odsState.addAttribute("use_node_name_sharing", use_node_name_sharing);
  odsState.addAttribute("key_dtype", key_dtype);
  odsState.addAttribute("value_dtype", value_dtype);
  odsState.addTypes(table_handle);
}

void HashTableV2Op::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::StringAttr container, ::mlir::StringAttr shared_name, ::mlir::BoolAttr use_node_name_sharing, ::mlir::TypeAttr key_dtype, ::mlir::TypeAttr value_dtype) {
  odsState.addAttribute("container", container);
  odsState.addAttribute("shared_name", shared_name);
  odsState.addAttribute("use_node_name_sharing", use_node_name_sharing);
  odsState.addAttribute("key_dtype", key_dtype);
  odsState.addAttribute("value_dtype", value_dtype);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void HashTableV2Op::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type table_handle, ::llvm::StringRef container, ::llvm::StringRef shared_name, bool use_node_name_sharing, ::mlir::TypeAttr key_dtype, ::mlir::TypeAttr value_dtype) {
  odsState.addAttribute("container", odsBuilder.getStringAttr(container));
  odsState.addAttribute("shared_name", odsBuilder.getStringAttr(shared_name));
  odsState.addAttribute("use_node_name_sharing", odsBuilder.getBoolAttr(use_node_name_sharing));
  odsState.addAttribute("key_dtype", key_dtype);
  odsState.addAttribute("value_dtype", value_dtype);
  odsState.addTypes(table_handle);
}

void HashTableV2Op::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::llvm::StringRef container, ::llvm::StringRef shared_name, bool use_node_name_sharing, ::mlir::TypeAttr key_dtype, ::mlir::TypeAttr value_dtype) {
  odsState.addAttribute("container", odsBuilder.getStringAttr(container));
  odsState.addAttribute("shared_name", odsBuilder.getStringAttr(shared_name));
  odsState.addAttribute("use_node_name_sharing", odsBuilder.getBoolAttr(use_node_name_sharing));
  odsState.addAttribute("key_dtype", key_dtype);
  odsState.addAttribute("value_dtype", value_dtype);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void HashTableV2Op::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 0u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult HashTableV2Op::verify() {
  if (failed(HashTableV2OpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::ResourceType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::ResourceRefType>()))))) {
        return emitOpError("result #") << index << " must be tensor of resource values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void HashTableV2Op::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
  for (::mlir::Value value : getODSResults(0))
    effects.emplace_back(MemoryEffects::Allocate::get(), value, ::mlir::TF::ResourceEffects::LookupTable::get());
}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::IFFT2DOp definitions
//===----------------------------------------------------------------------===//

IFFT2DOpAdaptor::IFFT2DOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

IFFT2DOpAdaptor::IFFT2DOpAdaptor(IFFT2DOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> IFFT2DOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange IFFT2DOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value IFFT2DOpAdaptor::input() {
  return *getODSOperands(0).begin();
}

::mlir::LogicalResult IFFT2DOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

::llvm::StringRef IFFT2DOp::getOperationName() {
  return "tf.IFFT2D";
}

std::pair<unsigned, unsigned> IFFT2DOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range IFFT2DOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value IFFT2DOp::input() {
  return *getODSOperands(0).begin();
}

::mlir::MutableOperandRange IFFT2DOp::inputMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> IFFT2DOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range IFFT2DOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value IFFT2DOp::output() {
  return *getODSResults(0).begin();
}

Type IFFT2DOp::Tcomplex() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

bool IFFT2DOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "Tcomplex") return true;
 return false;
}

::mlir::DictionaryAttr IFFT2DOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("Tcomplex", ctx),
::mlir::TypeAttr::get(Tcomplex())}
    }, ctx);
}

void IFFT2DOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value input) {
  odsState.addOperands(input);
  odsState.addTypes(output);
}

void IFFT2DOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input) {
  odsState.addOperands(input);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void IFFT2DOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult IFFT2DOp::verify() {
  if (failed(IFFT2DOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of 128-bit complex or 64-bit complex values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>())))))) {
        return emitOpError("result #") << index << " must be tensor of 128-bit complex or 64-bit complex values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void IFFT2DOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::IFFT3DOp definitions
//===----------------------------------------------------------------------===//

IFFT3DOpAdaptor::IFFT3DOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

IFFT3DOpAdaptor::IFFT3DOpAdaptor(IFFT3DOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> IFFT3DOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange IFFT3DOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value IFFT3DOpAdaptor::input() {
  return *getODSOperands(0).begin();
}

::mlir::LogicalResult IFFT3DOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

::llvm::StringRef IFFT3DOp::getOperationName() {
  return "tf.IFFT3D";
}

std::pair<unsigned, unsigned> IFFT3DOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range IFFT3DOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value IFFT3DOp::input() {
  return *getODSOperands(0).begin();
}

::mlir::MutableOperandRange IFFT3DOp::inputMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> IFFT3DOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range IFFT3DOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value IFFT3DOp::output() {
  return *getODSResults(0).begin();
}

Type IFFT3DOp::Tcomplex() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

bool IFFT3DOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "Tcomplex") return true;
 return false;
}

::mlir::DictionaryAttr IFFT3DOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("Tcomplex", ctx),
::mlir::TypeAttr::get(Tcomplex())}
    }, ctx);
}

void IFFT3DOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value input) {
  odsState.addOperands(input);
  odsState.addTypes(output);
}

void IFFT3DOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input) {
  odsState.addOperands(input);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void IFFT3DOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult IFFT3DOp::verify() {
  if (failed(IFFT3DOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of 128-bit complex or 64-bit complex values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>())))))) {
        return emitOpError("result #") << index << " must be tensor of 128-bit complex or 64-bit complex values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void IFFT3DOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::IFFTOp definitions
//===----------------------------------------------------------------------===//

IFFTOpAdaptor::IFFTOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

IFFTOpAdaptor::IFFTOpAdaptor(IFFTOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> IFFTOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange IFFTOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value IFFTOpAdaptor::input() {
  return *getODSOperands(0).begin();
}

::mlir::LogicalResult IFFTOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

::llvm::StringRef IFFTOp::getOperationName() {
  return "tf.IFFT";
}

std::pair<unsigned, unsigned> IFFTOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range IFFTOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value IFFTOp::input() {
  return *getODSOperands(0).begin();
}

::mlir::MutableOperandRange IFFTOp::inputMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> IFFTOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range IFFTOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value IFFTOp::output() {
  return *getODSResults(0).begin();
}

Type IFFTOp::Tcomplex() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

bool IFFTOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "Tcomplex") return true;
 return false;
}

::mlir::DictionaryAttr IFFTOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("Tcomplex", ctx),
::mlir::TypeAttr::get(Tcomplex())}
    }, ctx);
}

void IFFTOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value input) {
  odsState.addOperands(input);
  odsState.addTypes(output);
}

void IFFTOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input) {
  odsState.addOperands(input);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void IFFTOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult IFFTOp::verify() {
  if (failed(IFFTOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of 128-bit complex or 64-bit complex values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>())))))) {
        return emitOpError("result #") << index << " must be tensor of 128-bit complex or 64-bit complex values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void IFFTOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::IRFFT2DOp definitions
//===----------------------------------------------------------------------===//

IRFFT2DOpAdaptor::IRFFT2DOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

IRFFT2DOpAdaptor::IRFFT2DOpAdaptor(IRFFT2DOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> IRFFT2DOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange IRFFT2DOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value IRFFT2DOpAdaptor::input() {
  return *getODSOperands(0).begin();
}

::mlir::Value IRFFT2DOpAdaptor::fft_length() {
  return *getODSOperands(1).begin();
}

::mlir::LogicalResult IRFFT2DOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

::llvm::StringRef IRFFT2DOp::getOperationName() {
  return "tf.IRFFT2D";
}

std::pair<unsigned, unsigned> IRFFT2DOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range IRFFT2DOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value IRFFT2DOp::input() {
  return *getODSOperands(0).begin();
}

::mlir::Value IRFFT2DOp::fft_length() {
  return *getODSOperands(1).begin();
}

::mlir::MutableOperandRange IRFFT2DOp::inputMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange IRFFT2DOp::fft_lengthMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> IRFFT2DOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range IRFFT2DOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value IRFFT2DOp::output() {
  return *getODSResults(0).begin();
}

Type IRFFT2DOp::Treal() {
  return mlir::getElementTypeOrSelf(*getODSResults(0).begin());
}

Type IRFFT2DOp::Tcomplex() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

bool IRFFT2DOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "Treal") return true;
  if (name == "Tcomplex") return true;
 return false;
}

::mlir::DictionaryAttr IRFFT2DOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("Treal", ctx),
::mlir::TypeAttr::get(Treal())},
    {::mlir::Identifier::get("Tcomplex", ctx),
::mlir::TypeAttr::get(Tcomplex())}
    }, ctx);
}

void IRFFT2DOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value input, ::mlir::Value fft_length) {
  odsState.addOperands(input);
  odsState.addOperands(fft_length);
  odsState.addTypes(output);
}

void IRFFT2DOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input, ::mlir::Value fft_length) {
  odsState.addOperands(input);
  odsState.addOperands(fft_length);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void IRFFT2DOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult IRFFT2DOp::verify() {
  if (failed(IRFFT2DOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of 128-bit complex or 64-bit complex values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of 32-bit integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())))))) {
        return emitOpError("result #") << index << " must be tensor of 32/64-bit float values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void IRFFT2DOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::IRFFT3DOp definitions
//===----------------------------------------------------------------------===//

IRFFT3DOpAdaptor::IRFFT3DOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

IRFFT3DOpAdaptor::IRFFT3DOpAdaptor(IRFFT3DOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> IRFFT3DOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange IRFFT3DOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value IRFFT3DOpAdaptor::input() {
  return *getODSOperands(0).begin();
}

::mlir::Value IRFFT3DOpAdaptor::fft_length() {
  return *getODSOperands(1).begin();
}

::mlir::LogicalResult IRFFT3DOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

::llvm::StringRef IRFFT3DOp::getOperationName() {
  return "tf.IRFFT3D";
}

std::pair<unsigned, unsigned> IRFFT3DOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range IRFFT3DOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value IRFFT3DOp::input() {
  return *getODSOperands(0).begin();
}

::mlir::Value IRFFT3DOp::fft_length() {
  return *getODSOperands(1).begin();
}

::mlir::MutableOperandRange IRFFT3DOp::inputMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange IRFFT3DOp::fft_lengthMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> IRFFT3DOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range IRFFT3DOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value IRFFT3DOp::output() {
  return *getODSResults(0).begin();
}

Type IRFFT3DOp::Treal() {
  return mlir::getElementTypeOrSelf(*getODSResults(0).begin());
}

Type IRFFT3DOp::Tcomplex() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

bool IRFFT3DOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "Treal") return true;
  if (name == "Tcomplex") return true;
 return false;
}

::mlir::DictionaryAttr IRFFT3DOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("Treal", ctx),
::mlir::TypeAttr::get(Treal())},
    {::mlir::Identifier::get("Tcomplex", ctx),
::mlir::TypeAttr::get(Tcomplex())}
    }, ctx);
}

void IRFFT3DOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value input, ::mlir::Value fft_length) {
  odsState.addOperands(input);
  odsState.addOperands(fft_length);
  odsState.addTypes(output);
}

void IRFFT3DOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input, ::mlir::Value fft_length) {
  odsState.addOperands(input);
  odsState.addOperands(fft_length);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void IRFFT3DOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult IRFFT3DOp::verify() {
  if (failed(IRFFT3DOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of 128-bit complex or 64-bit complex values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of 32-bit integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())))))) {
        return emitOpError("result #") << index << " must be tensor of 32/64-bit float values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void IRFFT3DOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::IRFFTOp definitions
//===----------------------------------------------------------------------===//

IRFFTOpAdaptor::IRFFTOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

IRFFTOpAdaptor::IRFFTOpAdaptor(IRFFTOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> IRFFTOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange IRFFTOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value IRFFTOpAdaptor::input() {
  return *getODSOperands(0).begin();
}

::mlir::Value IRFFTOpAdaptor::fft_length() {
  return *getODSOperands(1).begin();
}

::mlir::LogicalResult IRFFTOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

::llvm::StringRef IRFFTOp::getOperationName() {
  return "tf.IRFFT";
}

std::pair<unsigned, unsigned> IRFFTOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range IRFFTOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value IRFFTOp::input() {
  return *getODSOperands(0).begin();
}

::mlir::Value IRFFTOp::fft_length() {
  return *getODSOperands(1).begin();
}

::mlir::MutableOperandRange IRFFTOp::inputMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange IRFFTOp::fft_lengthMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> IRFFTOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range IRFFTOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value IRFFTOp::output() {
  return *getODSResults(0).begin();
}

Type IRFFTOp::Treal() {
  return mlir::getElementTypeOrSelf(*getODSResults(0).begin());
}

Type IRFFTOp::Tcomplex() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

bool IRFFTOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "Treal") return true;
  if (name == "Tcomplex") return true;
 return false;
}

::mlir::DictionaryAttr IRFFTOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("Treal", ctx),
::mlir::TypeAttr::get(Treal())},
    {::mlir::Identifier::get("Tcomplex", ctx),
::mlir::TypeAttr::get(Tcomplex())}
    }, ctx);
}

void IRFFTOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value input, ::mlir::Value fft_length) {
  odsState.addOperands(input);
  odsState.addOperands(fft_length);
  odsState.addTypes(output);
}

void IRFFTOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input, ::mlir::Value fft_length) {
  odsState.addOperands(input);
  odsState.addOperands(fft_length);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void IRFFTOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult IRFFTOp::verify() {
  if (failed(IRFFTOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of 128-bit complex or 64-bit complex values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of 32-bit integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())))))) {
        return emitOpError("result #") << index << " must be tensor of 32/64-bit float values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void IRFFTOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::IdentityNOp definitions
//===----------------------------------------------------------------------===//

IdentityNOpAdaptor::IdentityNOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

IdentityNOpAdaptor::IdentityNOpAdaptor(IdentityNOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> IdentityNOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  bool isVariadic[] = {true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (odsOperands.size() - 0) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::mlir::ValueRange IdentityNOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::ValueRange IdentityNOpAdaptor::input() {
  return getODSOperands(0);
}

::mlir::LogicalResult IdentityNOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

::llvm::StringRef IdentityNOp::getOperationName() {
  return "tf.IdentityN";
}

std::pair<unsigned, unsigned> IdentityNOp::getODSOperandIndexAndLength(unsigned index) {
  bool isVariadic[] = {true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (getOperation()->getNumOperands() - 0) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::mlir::Operation::operand_range IdentityNOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Operation::operand_range IdentityNOp::input() {
  return getODSOperands(0);
}

::mlir::MutableOperandRange IdentityNOp::inputMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> IdentityNOp::getODSResultIndexAndLength(unsigned index) {
  bool isVariadic[] = {true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (getOperation()->getNumResults() - 0) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::mlir::Operation::result_range IdentityNOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Operation::result_range IdentityNOp::output() {
  return getODSResults(0);
}

mlir::OperandElementTypeRange IdentityNOp::T() {
  auto values = getODSOperands(0);
return {mlir::OperandElementTypeIterator(values.begin()), mlir::OperandElementTypeIterator(values.end())};
}

bool IdentityNOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "T") return true;
 return false;
}

::mlir::DictionaryAttr IdentityNOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("T", ctx),
ArrayAttr::get(
    [&]() {
      llvm::SmallVector<Attribute, 4> ret;
      for (auto t : T())
        ret.push_back(TypeAttr::get(t));
      return ret;
    }(), ctx)}
    }, ctx);
}

void IdentityNOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult IdentityNOp::verify() {
  if (failed(IdentityNOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>())))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::TensorFlowType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of tf.dtype values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>())))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::TensorFlowType>()))))) {
        return emitOpError("result #") << index << " must be tensor of tf.dtype values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void IdentityNOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::IdentityOp definitions
//===----------------------------------------------------------------------===//

IdentityOpAdaptor::IdentityOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

IdentityOpAdaptor::IdentityOpAdaptor(IdentityOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> IdentityOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange IdentityOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value IdentityOpAdaptor::input() {
  return *getODSOperands(0).begin();
}

::mlir::LogicalResult IdentityOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

::llvm::StringRef IdentityOp::getOperationName() {
  return "tf.Identity";
}

std::pair<unsigned, unsigned> IdentityOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range IdentityOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value IdentityOp::input() {
  return *getODSOperands(0).begin();
}

::mlir::MutableOperandRange IdentityOp::inputMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> IdentityOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range IdentityOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value IdentityOp::output() {
  return *getODSResults(0).begin();
}

Type IdentityOp::T() {
  return mlir::getElementTypeOrSelf(*getODSResults(0).begin());
}

bool IdentityOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "T") return true;
 return false;
}

::mlir::DictionaryAttr IdentityOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())}
    }, ctx);
}

void IdentityOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value input) {
  odsState.addOperands(input);
  odsState.addTypes(output);
}

void IdentityOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input) {
  odsState.addOperands(input);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void IdentityOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult IdentityOp::verify() {
  if (failed(IdentityOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>())))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::TensorFlowType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of tf.dtype values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>())))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::TensorFlowType>()))))) {
        return emitOpError("result #") << index << " must be tensor of tf.dtype values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::IfOp definitions
//===----------------------------------------------------------------------===//

IfOpAdaptor::IfOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

IfOpAdaptor::IfOpAdaptor(IfOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> IfOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  bool isVariadic[] = {false, true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (odsOperands.size() - 1) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::mlir::ValueRange IfOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value IfOpAdaptor::cond() {
  return *getODSOperands(0).begin();
}

::mlir::ValueRange IfOpAdaptor::input() {
  return getODSOperands(1);
}

::mlir::FlatSymbolRefAttr IfOpAdaptor::then_branch() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::FlatSymbolRefAttr attr = odsAttrs.get("then_branch").cast<::mlir::FlatSymbolRefAttr>();
  return attr;
}

::mlir::FlatSymbolRefAttr IfOpAdaptor::else_branch() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::FlatSymbolRefAttr attr = odsAttrs.get("else_branch").cast<::mlir::FlatSymbolRefAttr>();
  return attr;
}

::mlir::BoolAttr IfOpAdaptor::is_stateless() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::BoolAttr attr = odsAttrs.get("is_stateless").cast<::mlir::BoolAttr>();
  return attr;
}

::mlir::LogicalResult IfOpAdaptor::verify(::mlir::Location loc) {
  {
  auto tblgen_then_branch = odsAttrs.get("then_branch");
  if (!tblgen_then_branch) return emitError(loc, "'tf.If' op ""requires attribute 'then_branch'");
    if (!((tblgen_then_branch.isa<::mlir::FlatSymbolRefAttr>()))) return emitError(loc, "'tf.If' op ""attribute 'then_branch' failed to satisfy constraint: flat symbol reference attribute");
  }
  {
  auto tblgen_else_branch = odsAttrs.get("else_branch");
  if (!tblgen_else_branch) return emitError(loc, "'tf.If' op ""requires attribute 'else_branch'");
    if (!((tblgen_else_branch.isa<::mlir::FlatSymbolRefAttr>()))) return emitError(loc, "'tf.If' op ""attribute 'else_branch' failed to satisfy constraint: flat symbol reference attribute");
  }
  {
  auto tblgen_is_stateless = odsAttrs.get("is_stateless");
  if (!tblgen_is_stateless) return emitError(loc, "'tf.If' op ""requires attribute 'is_stateless'");
    if (!((tblgen_is_stateless.isa<::mlir::BoolAttr>()))) return emitError(loc, "'tf.If' op ""attribute 'is_stateless' failed to satisfy constraint: bool attribute");
  }
  return ::mlir::success();
}

::llvm::StringRef IfOp::getOperationName() {
  return "tf.If";
}

std::pair<unsigned, unsigned> IfOp::getODSOperandIndexAndLength(unsigned index) {
  bool isVariadic[] = {false, true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (getOperation()->getNumOperands() - 1) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::mlir::Operation::operand_range IfOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value IfOp::cond() {
  return *getODSOperands(0).begin();
}

::mlir::Operation::operand_range IfOp::input() {
  return getODSOperands(1);
}

::mlir::MutableOperandRange IfOp::condMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange IfOp::inputMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> IfOp::getODSResultIndexAndLength(unsigned index) {
  bool isVariadic[] = {true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (getOperation()->getNumResults() - 0) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::mlir::Operation::result_range IfOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Operation::result_range IfOp::output() {
  return getODSResults(0);
}

::mlir::FlatSymbolRefAttr IfOp::then_branchAttr() {
  return this->getAttr("then_branch").cast<::mlir::FlatSymbolRefAttr>();
}

::llvm::StringRef IfOp::then_branch() {
  auto attr = then_branchAttr();
  return attr.getValue();
}

::mlir::FlatSymbolRefAttr IfOp::else_branchAttr() {
  return this->getAttr("else_branch").cast<::mlir::FlatSymbolRefAttr>();
}

::llvm::StringRef IfOp::else_branch() {
  auto attr = else_branchAttr();
  return attr.getValue();
}

::mlir::BoolAttr IfOp::is_statelessAttr() {
  return this->getAttr("is_stateless").cast<::mlir::BoolAttr>();
}

bool IfOp::is_stateless() {
  auto attr = is_statelessAttr();
  return attr.getValue();
}

Type IfOp::Tcond() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

mlir::OperandElementTypeRange IfOp::Tin() {
  auto values = getODSOperands(1);
return {mlir::OperandElementTypeIterator(values.begin()), mlir::OperandElementTypeIterator(values.end())};
}

mlir::ResultElementTypeRange IfOp::Tout() {
  auto values = getODSResults(0);
return {mlir::ResultElementTypeIterator(values.begin()), mlir::ResultElementTypeIterator(values.end())};
}

mlir::TF::ResultShapeRange IfOp::output_shapes() {
  auto values = getODSResults(0);
return {mlir::TF::ResultShapeIterator(values.begin()), mlir::TF::ResultShapeIterator(values.end())};
}

bool IfOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "Tcond") return true;
  if (name == "Tin") return true;
  if (name == "Tout") return true;
  if (name == "output_shapes") return true;
 return false;
}

::mlir::DictionaryAttr IfOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("Tcond", ctx),
::mlir::TypeAttr::get(Tcond())},
    {::mlir::Identifier::get("Tin", ctx),
ArrayAttr::get(
    [&]() {
      llvm::SmallVector<Attribute, 4> ret;
      for (auto t : Tin())
        ret.push_back(TypeAttr::get(t));
      return ret;
    }(), ctx)},
    {::mlir::Identifier::get("Tout", ctx),
ArrayAttr::get(
    [&]() {
      llvm::SmallVector<Attribute, 4> ret;
      for (auto t : Tout())
        ret.push_back(TypeAttr::get(t));
      return ret;
    }(), ctx)},
    {::mlir::Identifier::get("output_shapes", ctx),
ArrayAttr::get(
      [&](){
        llvm::SmallVector<Attribute, 4> ret;
        for (auto shape : output_shapes())
          ret.push_back(mlir::TF::ShapeAttr::get(ctx, shape));
        return ret;
      }(), ctx)}
    }, ctx);
}

void IfOp::then_branchAttr(::mlir::FlatSymbolRefAttr attr) {
  this->getOperation()->setAttr("then_branch", attr);
}

void IfOp::else_branchAttr(::mlir::FlatSymbolRefAttr attr) {
  this->getOperation()->setAttr("else_branch", attr);
}

void IfOp::is_statelessAttr(::mlir::BoolAttr attr) {
  this->getOperation()->setAttr("is_stateless", attr);
}

void IfOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange output, ::mlir::Value cond, ::mlir::ValueRange input, ::mlir::FlatSymbolRefAttr then_branch, ::mlir::FlatSymbolRefAttr else_branch, ::mlir::BoolAttr is_stateless) {
  odsState.addOperands(cond);
  odsState.addOperands(input);
  odsState.addAttribute("then_branch", then_branch);
  odsState.addAttribute("else_branch", else_branch);
  odsState.addAttribute("is_stateless", is_stateless);
  odsState.addTypes(output);
}

void IfOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange output, ::mlir::Value cond, ::mlir::ValueRange input, ::llvm::StringRef then_branch, ::llvm::StringRef else_branch, bool is_stateless) {
  odsState.addOperands(cond);
  odsState.addOperands(input);
  odsState.addAttribute("then_branch", odsBuilder.getSymbolRefAttr(then_branch));
  odsState.addAttribute("else_branch", odsBuilder.getSymbolRefAttr(else_branch));
  odsState.addAttribute("is_stateless", odsBuilder.getBoolAttr(is_stateless));
  odsState.addTypes(output);
}

void IfOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() >= 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult IfOp::verify() {
  if (failed(IfOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>())))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::TensorFlowType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of tf.dtype values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>())))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::TensorFlowType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of tf.dtype values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>())))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::TensorFlowType>()))))) {
        return emitOpError("result #") << index << " must be tensor of tf.dtype values, but got " << v.getType();
      }
      ++index;
    }
  }
  return Verify(*this);
}



} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::IfRegionOp definitions
//===----------------------------------------------------------------------===//

IfRegionOpAdaptor::IfRegionOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

IfRegionOpAdaptor::IfRegionOpAdaptor(IfRegionOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> IfRegionOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange IfRegionOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value IfRegionOpAdaptor::cond() {
  return *getODSOperands(0).begin();
}

::mlir::BoolAttr IfRegionOpAdaptor::is_stateless() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::BoolAttr attr = odsAttrs.get("is_stateless").cast<::mlir::BoolAttr>();
  return attr;
}

::mlir::LogicalResult IfRegionOpAdaptor::verify(::mlir::Location loc) {
  {
  auto tblgen_is_stateless = odsAttrs.get("is_stateless");
  if (!tblgen_is_stateless) return emitError(loc, "'tf.IfRegion' op ""requires attribute 'is_stateless'");
    if (!((tblgen_is_stateless.isa<::mlir::BoolAttr>()))) return emitError(loc, "'tf.IfRegion' op ""attribute 'is_stateless' failed to satisfy constraint: bool attribute");
  }
  return ::mlir::success();
}

::llvm::StringRef IfRegionOp::getOperationName() {
  return "tf.IfRegion";
}

std::pair<unsigned, unsigned> IfRegionOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range IfRegionOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value IfRegionOp::cond() {
  return *getODSOperands(0).begin();
}

::mlir::MutableOperandRange IfRegionOp::condMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> IfRegionOp::getODSResultIndexAndLength(unsigned index) {
  bool isVariadic[] = {true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (getOperation()->getNumResults() - 0) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::mlir::Operation::result_range IfRegionOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Operation::result_range IfRegionOp::output() {
  return getODSResults(0);
}

::mlir::Region &IfRegionOp::then_branch() {
  return this->getOperation()->getRegion(0);
}

::mlir::Region &IfRegionOp::else_branch() {
  return this->getOperation()->getRegion(1);
}

::mlir::BoolAttr IfRegionOp::is_statelessAttr() {
  return this->getAttr("is_stateless").cast<::mlir::BoolAttr>();
}

bool IfRegionOp::is_stateless() {
  auto attr = is_statelessAttr();
  return attr.getValue();
}

void IfRegionOp::is_statelessAttr(::mlir::BoolAttr attr) {
  this->getOperation()->setAttr("is_stateless", attr);
}

void IfRegionOp::build(OpBuilder &builder, OperationState &result, TypeRange resultTypes, ValueRange operands, llvm::ArrayRef<::mlir::NamedAttribute> attributes, unsigned numRegions) {
      assert(numRegions == 2u && "mismatched number of regions");
      build(builder, result, resultTypes, operands, attributes);
    
}

void IfRegionOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange output, ::mlir::Value cond, ::mlir::BoolAttr is_stateless) {
  odsState.addOperands(cond);
  odsState.addAttribute("is_stateless", is_stateless);
  (void)odsState.addRegion();
  (void)odsState.addRegion();
  odsState.addTypes(output);
}

void IfRegionOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange output, ::mlir::Value cond, bool is_stateless) {
  odsState.addOperands(cond);
  odsState.addAttribute("is_stateless", odsBuilder.getBoolAttr(is_stateless));
  (void)odsState.addRegion();
  (void)odsState.addRegion();
  odsState.addTypes(output);
}

void IfRegionOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  for (unsigned i = 0; i != 2; ++i)
    (void)odsState.addRegion();
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult IfRegionOp::verify() {
  if (failed(IfRegionOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!((((v.getType().isa<::mlir::TensorType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1)))) && (((v.getType().cast<::mlir::ShapedType>().hasRank())) && ((v.getType().cast<::mlir::ShapedType>().getRank()
                         == 0))))) {
        return emitOpError("operand #") << index << " must be 0D tensor of 1-bit signless integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>())))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::TensorFlowType>()))))) {
        return emitOpError("result #") << index << " must be tensor of tf.dtype values, but got " << v.getType();
      }
      ++index;
    }
  }
{
    unsigned index = 0; (void)index;
    for (::mlir::Region &region : ::mlir::MutableArrayRef<::mlir::Region>(this->getOperation()->getRegion(0))) {
      (void)region;
      if (!((::llvm::hasNItems(region, 1)))) {
        return emitOpError("region #") << index << " ('then_branch') failed to verify constraint: region with 1 blocks";
      }
      ++index;
    }
    for (::mlir::Region &region : ::mlir::MutableArrayRef<::mlir::Region>(this->getOperation()->getRegion(1))) {
      (void)region;
      if (!((::llvm::hasNItems(region, 1)))) {
        return emitOpError("region #") << index << " ('else_branch') failed to verify constraint: region with 1 blocks";
      }
      ++index;
    }
  }
  return Verify(*this);
}



} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::IgammaGradAOp definitions
//===----------------------------------------------------------------------===//

IgammaGradAOpAdaptor::IgammaGradAOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

IgammaGradAOpAdaptor::IgammaGradAOpAdaptor(IgammaGradAOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> IgammaGradAOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange IgammaGradAOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value IgammaGradAOpAdaptor::a() {
  return *getODSOperands(0).begin();
}

::mlir::Value IgammaGradAOpAdaptor::x() {
  return *getODSOperands(1).begin();
}

::mlir::LogicalResult IgammaGradAOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

::llvm::StringRef IgammaGradAOp::getOperationName() {
  return "tf.IgammaGradA";
}

std::pair<unsigned, unsigned> IgammaGradAOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range IgammaGradAOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value IgammaGradAOp::a() {
  return *getODSOperands(0).begin();
}

::mlir::Value IgammaGradAOp::x() {
  return *getODSOperands(1).begin();
}

::mlir::MutableOperandRange IgammaGradAOp::aMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange IgammaGradAOp::xMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> IgammaGradAOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range IgammaGradAOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value IgammaGradAOp::z() {
  return *getODSResults(0).begin();
}

Type IgammaGradAOp::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

bool IgammaGradAOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "T") return true;
 return false;
}

::mlir::DictionaryAttr IgammaGradAOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())}
    }, ctx);
}

void IgammaGradAOp::build(OpBuilder &builder, OperationState &result, Value  x, Value  y) {
  auto resultType =
      OpTrait::util::getBroadcastedType(x.getType(), y.getType());
  if (!resultType)
    mlir::emitError(result.location, "non-broadcastable operands");
  return build(builder, result, resultType, x, y);
}

void IgammaGradAOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type z, ::mlir::Value a, ::mlir::Value x) {
  odsState.addOperands(a);
  odsState.addOperands(x);
  odsState.addTypes(z);
}

void IgammaGradAOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value a, ::mlir::Value x) {
  odsState.addOperands(a);
  odsState.addOperands(x);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void IgammaGradAOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult IgammaGradAOp::verify() {
  if (failed(IgammaGradAOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of 32/64-bit float values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of 32/64-bit float values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())))))) {
        return emitOpError("result #") << index << " must be tensor of 32/64-bit float values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void IgammaGradAOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::IgammaOp definitions
//===----------------------------------------------------------------------===//

IgammaOpAdaptor::IgammaOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

IgammaOpAdaptor::IgammaOpAdaptor(IgammaOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> IgammaOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange IgammaOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value IgammaOpAdaptor::a() {
  return *getODSOperands(0).begin();
}

::mlir::Value IgammaOpAdaptor::x() {
  return *getODSOperands(1).begin();
}

::mlir::LogicalResult IgammaOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

::llvm::StringRef IgammaOp::getOperationName() {
  return "tf.Igamma";
}

std::pair<unsigned, unsigned> IgammaOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range IgammaOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value IgammaOp::a() {
  return *getODSOperands(0).begin();
}

::mlir::Value IgammaOp::x() {
  return *getODSOperands(1).begin();
}

::mlir::MutableOperandRange IgammaOp::aMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange IgammaOp::xMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> IgammaOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range IgammaOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value IgammaOp::z() {
  return *getODSResults(0).begin();
}

Type IgammaOp::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

bool IgammaOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "T") return true;
 return false;
}

::mlir::DictionaryAttr IgammaOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())}
    }, ctx);
}

void IgammaOp::build(OpBuilder &builder, OperationState &result, Value  x, Value  y) {
  auto resultType =
      OpTrait::util::getBroadcastedType(x.getType(), y.getType());
  if (!resultType)
    mlir::emitError(result.location, "non-broadcastable operands");
  return build(builder, result, resultType, x, y);
}

void IgammaOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type z, ::mlir::Value a, ::mlir::Value x) {
  odsState.addOperands(a);
  odsState.addOperands(x);
  odsState.addTypes(z);
}

void IgammaOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value a, ::mlir::Value x) {
  odsState.addOperands(a);
  odsState.addOperands(x);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void IgammaOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult IgammaOp::verify() {
  if (failed(IgammaOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of 32/64-bit float values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of 32/64-bit float values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())))))) {
        return emitOpError("result #") << index << " must be tensor of 32/64-bit float values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void IgammaOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::IgammacOp definitions
//===----------------------------------------------------------------------===//

IgammacOpAdaptor::IgammacOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

IgammacOpAdaptor::IgammacOpAdaptor(IgammacOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> IgammacOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange IgammacOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value IgammacOpAdaptor::a() {
  return *getODSOperands(0).begin();
}

::mlir::Value IgammacOpAdaptor::x() {
  return *getODSOperands(1).begin();
}

::mlir::LogicalResult IgammacOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

::llvm::StringRef IgammacOp::getOperationName() {
  return "tf.Igammac";
}

std::pair<unsigned, unsigned> IgammacOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range IgammacOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value IgammacOp::a() {
  return *getODSOperands(0).begin();
}

::mlir::Value IgammacOp::x() {
  return *getODSOperands(1).begin();
}

::mlir::MutableOperandRange IgammacOp::aMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange IgammacOp::xMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> IgammacOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range IgammacOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value IgammacOp::z() {
  return *getODSResults(0).begin();
}

Type IgammacOp::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

bool IgammacOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "T") return true;
 return false;
}

::mlir::DictionaryAttr IgammacOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())}
    }, ctx);
}

void IgammacOp::build(OpBuilder &builder, OperationState &result, Value  x, Value  y) {
  auto resultType =
      OpTrait::util::getBroadcastedType(x.getType(), y.getType());
  if (!resultType)
    mlir::emitError(result.location, "non-broadcastable operands");
  return build(builder, result, resultType, x, y);
}

void IgammacOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type z, ::mlir::Value a, ::mlir::Value x) {
  odsState.addOperands(a);
  odsState.addOperands(x);
  odsState.addTypes(z);
}

void IgammacOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value a, ::mlir::Value x) {
  odsState.addOperands(a);
  odsState.addOperands(x);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void IgammacOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult IgammacOp::verify() {
  if (failed(IgammacOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of 32/64-bit float values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of 32/64-bit float values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())))))) {
        return emitOpError("result #") << index << " must be tensor of 32/64-bit float values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void IgammacOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::ImagOp definitions
//===----------------------------------------------------------------------===//

ImagOpAdaptor::ImagOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

ImagOpAdaptor::ImagOpAdaptor(ImagOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> ImagOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange ImagOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value ImagOpAdaptor::input() {
  return *getODSOperands(0).begin();
}

::mlir::LogicalResult ImagOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

::llvm::StringRef ImagOp::getOperationName() {
  return "tf.Imag";
}

std::pair<unsigned, unsigned> ImagOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range ImagOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value ImagOp::input() {
  return *getODSOperands(0).begin();
}

::mlir::MutableOperandRange ImagOp::inputMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> ImagOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range ImagOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value ImagOp::output() {
  return *getODSResults(0).begin();
}

Type ImagOp::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

Type ImagOp::Tout() {
  return mlir::getElementTypeOrSelf(*getODSResults(0).begin());
}

bool ImagOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "T") return true;
  if (name == "Tout") return true;
 return false;
}

::mlir::DictionaryAttr ImagOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())},
    {::mlir::Identifier::get("Tout", ctx),
::mlir::TypeAttr::get(Tout())}
    }, ctx);
}

void ImagOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value input) {
  odsState.addOperands(input);
  odsState.addTypes(output);
}

void ImagOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input) {
  odsState.addOperands(input);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void ImagOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult ImagOp::verify() {
  if (failed(ImagOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of 128-bit complex or 64-bit complex values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())))))) {
        return emitOpError("result #") << index << " must be tensor of 32/64-bit float values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void ImagOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::ImportEventOp definitions
//===----------------------------------------------------------------------===//

ImportEventOpAdaptor::ImportEventOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

ImportEventOpAdaptor::ImportEventOpAdaptor(ImportEventOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> ImportEventOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange ImportEventOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value ImportEventOpAdaptor::writer() {
  return *getODSOperands(0).begin();
}

::mlir::Value ImportEventOpAdaptor::event() {
  return *getODSOperands(1).begin();
}

::mlir::LogicalResult ImportEventOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

::llvm::StringRef ImportEventOp::getOperationName() {
  return "tf.ImportEvent";
}

std::pair<unsigned, unsigned> ImportEventOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range ImportEventOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value ImportEventOp::writer() {
  return *getODSOperands(0).begin();
}

::mlir::Value ImportEventOp::event() {
  return *getODSOperands(1).begin();
}

::mlir::MutableOperandRange ImportEventOp::writerMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange ImportEventOp::eventMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> ImportEventOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range ImportEventOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

void ImportEventOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value writer, ::mlir::Value event) {
  odsState.addOperands(writer);
  odsState.addOperands(event);
}

void ImportEventOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value writer, ::mlir::Value event) {
  odsState.addOperands(writer);
  odsState.addOperands(event);
  assert(resultTypes.size() == 0u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void ImportEventOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 0u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult ImportEventOp::verify() {
  if (failed(ImportEventOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::ResourceType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::ResourceRefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of resource values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::StringType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::StringRefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of string values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
  }
  return ::mlir::success();
}

void ImportEventOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
  for (::mlir::Value value : getODSOperands(0))
    effects.emplace_back(MemoryEffects::Write::get(), value, ::mlir::TF::ResourceEffects::Summary::get());
}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::InTopKV2Op definitions
//===----------------------------------------------------------------------===//

InTopKV2OpAdaptor::InTopKV2OpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

InTopKV2OpAdaptor::InTopKV2OpAdaptor(InTopKV2Op&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> InTopKV2OpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange InTopKV2OpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value InTopKV2OpAdaptor::predictions() {
  return *getODSOperands(0).begin();
}

::mlir::Value InTopKV2OpAdaptor::targets() {
  return *getODSOperands(1).begin();
}

::mlir::Value InTopKV2OpAdaptor::k() {
  return *getODSOperands(2).begin();
}

::mlir::LogicalResult InTopKV2OpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

::llvm::StringRef InTopKV2Op::getOperationName() {
  return "tf.InTopKV2";
}

std::pair<unsigned, unsigned> InTopKV2Op::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range InTopKV2Op::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value InTopKV2Op::predictions() {
  return *getODSOperands(0).begin();
}

::mlir::Value InTopKV2Op::targets() {
  return *getODSOperands(1).begin();
}

::mlir::Value InTopKV2Op::k() {
  return *getODSOperands(2).begin();
}

::mlir::MutableOperandRange InTopKV2Op::predictionsMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange InTopKV2Op::targetsMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange InTopKV2Op::kMutable() {
  auto range = getODSOperandIndexAndLength(2);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> InTopKV2Op::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range InTopKV2Op::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value InTopKV2Op::precision() {
  return *getODSResults(0).begin();
}

Type InTopKV2Op::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(1).begin());
}

bool InTopKV2Op::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "T") return true;
 return false;
}

::mlir::DictionaryAttr InTopKV2Op::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())}
    }, ctx);
}

void InTopKV2Op::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type precision, ::mlir::Value predictions, ::mlir::Value targets, ::mlir::Value k) {
  odsState.addOperands(predictions);
  odsState.addOperands(targets);
  odsState.addOperands(k);
  odsState.addTypes(precision);
}

void InTopKV2Op::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value predictions, ::mlir::Value targets, ::mlir::Value k) {
  odsState.addOperands(predictions);
  odsState.addOperands(targets);
  odsState.addOperands(k);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void InTopKV2Op::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 3u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult InTopKV2Op::verify() {
  if (failed(InTopKV2OpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())))) {
        return emitOpError("operand #") << index << " must be tensor of 32-bit float values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of 32/64-bit signed integer values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup2 = getODSOperands(2);
    for (::mlir::Value v : valueGroup2) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of 32/64-bit signed integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))))) {
        return emitOpError("result #") << index << " must be tensor of 1-bit signless integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void InTopKV2Op::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::InfeedDequeueOp definitions
//===----------------------------------------------------------------------===//

InfeedDequeueOpAdaptor::InfeedDequeueOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

InfeedDequeueOpAdaptor::InfeedDequeueOpAdaptor(InfeedDequeueOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> InfeedDequeueOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange InfeedDequeueOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

Attribute InfeedDequeueOpAdaptor::shape() {
  assert(odsAttrs && "no attributes when constructing adapter");
  Attribute attr = odsAttrs.get("shape").cast<Attribute>();
  return attr;
}

::mlir::LogicalResult InfeedDequeueOpAdaptor::verify(::mlir::Location loc) {
  {
  auto tblgen_shape = odsAttrs.get("shape");
  if (!tblgen_shape) return emitError(loc, "'tf.InfeedDequeue' op ""requires attribute 'shape'");
    if (!((tblgen_shape.isa<mlir::TF::ShapeAttr>()))) return emitError(loc, "'tf.InfeedDequeue' op ""attribute 'shape' failed to satisfy constraint: TensorFlow shape attribute");
  }
  return ::mlir::success();
}

::llvm::StringRef InfeedDequeueOp::getOperationName() {
  return "tf.InfeedDequeue";
}

std::pair<unsigned, unsigned> InfeedDequeueOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range InfeedDequeueOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

std::pair<unsigned, unsigned> InfeedDequeueOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range InfeedDequeueOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value InfeedDequeueOp::output() {
  return *getODSResults(0).begin();
}

Attribute InfeedDequeueOp::shapeAttr() {
  return this->getAttr("shape").cast<Attribute>();
}

llvm::Optional<llvm::ArrayRef<int64_t>> InfeedDequeueOp::shape() {
  auto attr = shapeAttr();
  return attr.cast<mlir::TF::ShapeAttr>().getValue();
}

Type InfeedDequeueOp::dtype() {
  return mlir::getElementTypeOrSelf(*getODSResults(0).begin());
}

bool InfeedDequeueOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "dtype") return true;
 return false;
}

::mlir::DictionaryAttr InfeedDequeueOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("dtype", ctx),
::mlir::TypeAttr::get(dtype())}
    }, ctx);
}

void InfeedDequeueOp::shapeAttr(Attribute attr) {
  this->getOperation()->setAttr("shape", attr);
}

void InfeedDequeueOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, Attribute shape) {
  odsState.addAttribute("shape", shape);
  odsState.addTypes(output);
}

void InfeedDequeueOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, Attribute shape) {
  odsState.addAttribute("shape", shape);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void InfeedDequeueOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, llvm::Optional<llvm::ArrayRef<int64_t>> shape) {
  odsState.addAttribute("shape", mlir::TF::ShapeAttr::get(odsBuilder.getContext(), shape));
  odsState.addTypes(output);
}

void InfeedDequeueOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, llvm::Optional<llvm::ArrayRef<int64_t>> shape) {
  odsState.addAttribute("shape", mlir::TF::ShapeAttr::get(odsBuilder.getContext(), shape));
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void InfeedDequeueOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 0u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult InfeedDequeueOp::verify() {
  if (failed(InfeedDequeueOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>())))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::TensorFlowType>()))))) {
        return emitOpError("result #") << index << " must be tensor of tf.dtype values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::InfeedDequeueTupleOp definitions
//===----------------------------------------------------------------------===//

InfeedDequeueTupleOpAdaptor::InfeedDequeueTupleOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

InfeedDequeueTupleOpAdaptor::InfeedDequeueTupleOpAdaptor(InfeedDequeueTupleOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> InfeedDequeueTupleOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange InfeedDequeueTupleOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::StringAttr InfeedDequeueTupleOpAdaptor::_XlaSharding() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::StringAttr attr = odsAttrs.get("_XlaSharding").dyn_cast_or_null<::mlir::StringAttr>();
  return attr;
}

::mlir::LogicalResult InfeedDequeueTupleOpAdaptor::verify(::mlir::Location loc) {
  {
  auto tblgen__XlaSharding = odsAttrs.get("_XlaSharding");
  if (tblgen__XlaSharding) {
    if (!((tblgen__XlaSharding.isa<::mlir::StringAttr>()))) return emitError(loc, "'tf.InfeedDequeueTuple' op ""attribute '_XlaSharding' failed to satisfy constraint: string attribute");
  }
  }
  return ::mlir::success();
}

::llvm::StringRef InfeedDequeueTupleOp::getOperationName() {
  return "tf.InfeedDequeueTuple";
}

std::pair<unsigned, unsigned> InfeedDequeueTupleOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range InfeedDequeueTupleOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

std::pair<unsigned, unsigned> InfeedDequeueTupleOp::getODSResultIndexAndLength(unsigned index) {
  bool isVariadic[] = {true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (getOperation()->getNumResults() - 0) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::mlir::Operation::result_range InfeedDequeueTupleOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Operation::result_range InfeedDequeueTupleOp::outputs() {
  return getODSResults(0);
}

::mlir::StringAttr InfeedDequeueTupleOp::_XlaShardingAttr() {
  return this->getAttr("_XlaSharding").dyn_cast_or_null<::mlir::StringAttr>();
}

::llvm::Optional< ::llvm::StringRef > InfeedDequeueTupleOp::_XlaSharding() {
  auto attr = _XlaShardingAttr();
  return attr ? ::llvm::Optional< ::llvm::StringRef >(attr.getValue()) : (::llvm::None);
}

mlir::TF::ResultShapeRange InfeedDequeueTupleOp::shapes() {
  auto values = getODSResults(0);
return {mlir::TF::ResultShapeIterator(values.begin()), mlir::TF::ResultShapeIterator(values.end())};
}

mlir::ResultElementTypeRange InfeedDequeueTupleOp::dtypes() {
  auto values = getODSResults(0);
return {mlir::ResultElementTypeIterator(values.begin()), mlir::ResultElementTypeIterator(values.end())};
}

bool InfeedDequeueTupleOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "shapes") return true;
  if (name == "dtypes") return true;
 return false;
}

::mlir::DictionaryAttr InfeedDequeueTupleOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("shapes", ctx),
ArrayAttr::get(
      [&](){
        llvm::SmallVector<Attribute, 4> ret;
        for (auto shape : shapes())
          ret.push_back(mlir::TF::ShapeAttr::get(ctx, shape));
        return ret;
      }(), ctx)},
    {::mlir::Identifier::get("dtypes", ctx),
ArrayAttr::get(
    [&]() {
      llvm::SmallVector<Attribute, 4> ret;
      for (auto t : dtypes())
        ret.push_back(TypeAttr::get(t));
      return ret;
    }(), ctx)}
    }, ctx);
}

void InfeedDequeueTupleOp::_XlaShardingAttr(::mlir::StringAttr attr) {
  this->getOperation()->setAttr("_XlaSharding", attr);
}

void InfeedDequeueTupleOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange outputs, /*optional*/::mlir::StringAttr _XlaSharding) {
  if (_XlaSharding) {
  odsState.addAttribute("_XlaSharding", _XlaSharding);
  }
  odsState.addTypes(outputs);
}

void InfeedDequeueTupleOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 0u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult InfeedDequeueTupleOp::verify() {
  if (failed(InfeedDequeueTupleOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>())))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::TensorFlowType>()))))) {
        return emitOpError("result #") << index << " must be tensor of tf.dtype values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::InitializeTableFromDatasetOp definitions
//===----------------------------------------------------------------------===//

InitializeTableFromDatasetOpAdaptor::InitializeTableFromDatasetOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

InitializeTableFromDatasetOpAdaptor::InitializeTableFromDatasetOpAdaptor(InitializeTableFromDatasetOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> InitializeTableFromDatasetOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange InitializeTableFromDatasetOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value InitializeTableFromDatasetOpAdaptor::table_handle() {
  return *getODSOperands(0).begin();
}

::mlir::Value InitializeTableFromDatasetOpAdaptor::dataset() {
  return *getODSOperands(1).begin();
}

::mlir::LogicalResult InitializeTableFromDatasetOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

::llvm::StringRef InitializeTableFromDatasetOp::getOperationName() {
  return "tf.InitializeTableFromDataset";
}

std::pair<unsigned, unsigned> InitializeTableFromDatasetOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range InitializeTableFromDatasetOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value InitializeTableFromDatasetOp::table_handle() {
  return *getODSOperands(0).begin();
}

::mlir::Value InitializeTableFromDatasetOp::dataset() {
  return *getODSOperands(1).begin();
}

::mlir::MutableOperandRange InitializeTableFromDatasetOp::table_handleMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange InitializeTableFromDatasetOp::datasetMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> InitializeTableFromDatasetOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range InitializeTableFromDatasetOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

void InitializeTableFromDatasetOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value table_handle, ::mlir::Value dataset) {
  odsState.addOperands(table_handle);
  odsState.addOperands(dataset);
}

void InitializeTableFromDatasetOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value table_handle, ::mlir::Value dataset) {
  odsState.addOperands(table_handle);
  odsState.addOperands(dataset);
  assert(resultTypes.size() == 0u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void InitializeTableFromDatasetOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 0u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult InitializeTableFromDatasetOp::verify() {
  if (failed(InitializeTableFromDatasetOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::ResourceType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::ResourceRefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of resource values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::VariantType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::VariantRefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of variant values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
  }
  return ::mlir::success();
}

void InitializeTableFromDatasetOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
  for (::mlir::Value value : getODSOperands(0))
    effects.emplace_back(MemoryEffects::Write::get(), value, ::mlir::TF::ResourceEffects::LookupTable::get());
}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::InitializeTableFromTextFileV2Op definitions
//===----------------------------------------------------------------------===//

InitializeTableFromTextFileV2OpAdaptor::InitializeTableFromTextFileV2OpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

InitializeTableFromTextFileV2OpAdaptor::InitializeTableFromTextFileV2OpAdaptor(InitializeTableFromTextFileV2Op&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> InitializeTableFromTextFileV2OpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange InitializeTableFromTextFileV2OpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value InitializeTableFromTextFileV2OpAdaptor::table_handle() {
  return *getODSOperands(0).begin();
}

::mlir::Value InitializeTableFromTextFileV2OpAdaptor::filename() {
  return *getODSOperands(1).begin();
}

::mlir::IntegerAttr InitializeTableFromTextFileV2OpAdaptor::key_index() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::IntegerAttr attr = odsAttrs.get("key_index").cast<::mlir::IntegerAttr>();
  return attr;
}

::mlir::IntegerAttr InitializeTableFromTextFileV2OpAdaptor::value_index() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::IntegerAttr attr = odsAttrs.get("value_index").cast<::mlir::IntegerAttr>();
  return attr;
}

::mlir::IntegerAttr InitializeTableFromTextFileV2OpAdaptor::vocab_size() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::IntegerAttr attr = odsAttrs.get("vocab_size").dyn_cast_or_null<::mlir::IntegerAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getIntegerAttr(::mlir::Builder(odsAttrs.getContext()).getIntegerType(64), -1);
  return attr;
}

::mlir::StringAttr InitializeTableFromTextFileV2OpAdaptor::delimiter() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::StringAttr attr = odsAttrs.get("delimiter").cast<::mlir::StringAttr>();
  return attr;
}

::mlir::LogicalResult InitializeTableFromTextFileV2OpAdaptor::verify(::mlir::Location loc) {
  {
  auto tblgen_key_index = odsAttrs.get("key_index");
  if (!tblgen_key_index) return emitError(loc, "'tf.InitializeTableFromTextFileV2' op ""requires attribute 'key_index'");
    if (!((((tblgen_key_index.isa<::mlir::IntegerAttr>())) && ((tblgen_key_index.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(64)))) && ((tblgen_key_index.cast<::mlir::IntegerAttr>().getInt() >= -2)))) return emitError(loc, "'tf.InitializeTableFromTextFileV2' op ""attribute 'key_index' failed to satisfy constraint: 64-bit signless integer attribute whose minimum value is -2");
  }
  {
  auto tblgen_value_index = odsAttrs.get("value_index");
  if (!tblgen_value_index) return emitError(loc, "'tf.InitializeTableFromTextFileV2' op ""requires attribute 'value_index'");
    if (!((((tblgen_value_index.isa<::mlir::IntegerAttr>())) && ((tblgen_value_index.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(64)))) && ((tblgen_value_index.cast<::mlir::IntegerAttr>().getInt() >= -2)))) return emitError(loc, "'tf.InitializeTableFromTextFileV2' op ""attribute 'value_index' failed to satisfy constraint: 64-bit signless integer attribute whose minimum value is -2");
  }
  {
  auto tblgen_vocab_size = odsAttrs.get("vocab_size");
  if (tblgen_vocab_size) {
    if (!((((tblgen_vocab_size.isa<::mlir::IntegerAttr>())) && ((tblgen_vocab_size.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(64)))) && ((tblgen_vocab_size.cast<::mlir::IntegerAttr>().getInt() >= -1)))) return emitError(loc, "'tf.InitializeTableFromTextFileV2' op ""attribute 'vocab_size' failed to satisfy constraint: 64-bit signless integer attribute whose minimum value is -1");
  }
  }
  {
  auto tblgen_delimiter = odsAttrs.get("delimiter");
  if (!tblgen_delimiter) return emitError(loc, "'tf.InitializeTableFromTextFileV2' op ""requires attribute 'delimiter'");
    if (!((tblgen_delimiter.isa<::mlir::StringAttr>()))) return emitError(loc, "'tf.InitializeTableFromTextFileV2' op ""attribute 'delimiter' failed to satisfy constraint: string attribute");
  }
  return ::mlir::success();
}

::llvm::StringRef InitializeTableFromTextFileV2Op::getOperationName() {
  return "tf.InitializeTableFromTextFileV2";
}

std::pair<unsigned, unsigned> InitializeTableFromTextFileV2Op::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range InitializeTableFromTextFileV2Op::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value InitializeTableFromTextFileV2Op::table_handle() {
  return *getODSOperands(0).begin();
}

::mlir::Value InitializeTableFromTextFileV2Op::filename() {
  return *getODSOperands(1).begin();
}

::mlir::MutableOperandRange InitializeTableFromTextFileV2Op::table_handleMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange InitializeTableFromTextFileV2Op::filenameMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> InitializeTableFromTextFileV2Op::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range InitializeTableFromTextFileV2Op::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::IntegerAttr InitializeTableFromTextFileV2Op::key_indexAttr() {
  return this->getAttr("key_index").cast<::mlir::IntegerAttr>();
}

uint64_t InitializeTableFromTextFileV2Op::key_index() {
  auto attr = key_indexAttr();
  return attr.getValue().getZExtValue();
}

::mlir::IntegerAttr InitializeTableFromTextFileV2Op::value_indexAttr() {
  return this->getAttr("value_index").cast<::mlir::IntegerAttr>();
}

uint64_t InitializeTableFromTextFileV2Op::value_index() {
  auto attr = value_indexAttr();
  return attr.getValue().getZExtValue();
}

::mlir::IntegerAttr InitializeTableFromTextFileV2Op::vocab_sizeAttr() {
  return this->getAttr("vocab_size").dyn_cast_or_null<::mlir::IntegerAttr>();
}

uint64_t InitializeTableFromTextFileV2Op::vocab_size() {
  auto attr = vocab_sizeAttr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getIntegerAttr(::mlir::Builder(this->getContext()).getIntegerType(64), -1).getValue().getZExtValue();
  return attr.getValue().getZExtValue();
}

::mlir::StringAttr InitializeTableFromTextFileV2Op::delimiterAttr() {
  return this->getAttr("delimiter").cast<::mlir::StringAttr>();
}

::llvm::StringRef InitializeTableFromTextFileV2Op::delimiter() {
  auto attr = delimiterAttr();
  return attr.getValue();
}

void InitializeTableFromTextFileV2Op::key_indexAttr(::mlir::IntegerAttr attr) {
  this->getOperation()->setAttr("key_index", attr);
}

void InitializeTableFromTextFileV2Op::value_indexAttr(::mlir::IntegerAttr attr) {
  this->getOperation()->setAttr("value_index", attr);
}

void InitializeTableFromTextFileV2Op::vocab_sizeAttr(::mlir::IntegerAttr attr) {
  this->getOperation()->setAttr("vocab_size", attr);
}

void InitializeTableFromTextFileV2Op::delimiterAttr(::mlir::StringAttr attr) {
  this->getOperation()->setAttr("delimiter", attr);
}

void InitializeTableFromTextFileV2Op::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value table_handle, ::mlir::Value filename, ::mlir::IntegerAttr key_index, ::mlir::IntegerAttr value_index, ::mlir::IntegerAttr vocab_size, ::mlir::StringAttr delimiter) {
  odsState.addOperands(table_handle);
  odsState.addOperands(filename);
  odsState.addAttribute("key_index", key_index);
  odsState.addAttribute("value_index", value_index);
  odsState.addAttribute("vocab_size", vocab_size);
  odsState.addAttribute("delimiter", delimiter);
}

void InitializeTableFromTextFileV2Op::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value table_handle, ::mlir::Value filename, ::mlir::IntegerAttr key_index, ::mlir::IntegerAttr value_index, ::mlir::IntegerAttr vocab_size, ::mlir::StringAttr delimiter) {
  odsState.addOperands(table_handle);
  odsState.addOperands(filename);
  odsState.addAttribute("key_index", key_index);
  odsState.addAttribute("value_index", value_index);
  odsState.addAttribute("vocab_size", vocab_size);
  odsState.addAttribute("delimiter", delimiter);
  assert(resultTypes.size() == 0u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void InitializeTableFromTextFileV2Op::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value table_handle, ::mlir::Value filename, uint64_t key_index, uint64_t value_index, uint64_t vocab_size, ::llvm::StringRef delimiter) {
  odsState.addOperands(table_handle);
  odsState.addOperands(filename);
  odsState.addAttribute("key_index", odsBuilder.getIntegerAttr(odsBuilder.getIntegerType(64), key_index));
  odsState.addAttribute("value_index", odsBuilder.getIntegerAttr(odsBuilder.getIntegerType(64), value_index));
  odsState.addAttribute("vocab_size", odsBuilder.getIntegerAttr(odsBuilder.getIntegerType(64), vocab_size));
  odsState.addAttribute("delimiter", odsBuilder.getStringAttr(delimiter));
}

void InitializeTableFromTextFileV2Op::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value table_handle, ::mlir::Value filename, uint64_t key_index, uint64_t value_index, uint64_t vocab_size, ::llvm::StringRef delimiter) {
  odsState.addOperands(table_handle);
  odsState.addOperands(filename);
  odsState.addAttribute("key_index", odsBuilder.getIntegerAttr(odsBuilder.getIntegerType(64), key_index));
  odsState.addAttribute("value_index", odsBuilder.getIntegerAttr(odsBuilder.getIntegerType(64), value_index));
  odsState.addAttribute("vocab_size", odsBuilder.getIntegerAttr(odsBuilder.getIntegerType(64), vocab_size));
  odsState.addAttribute("delimiter", odsBuilder.getStringAttr(delimiter));
  assert(resultTypes.size() == 0u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void InitializeTableFromTextFileV2Op::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 0u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult InitializeTableFromTextFileV2Op::verify() {
  if (failed(InitializeTableFromTextFileV2OpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::ResourceType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::ResourceRefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of resource values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::StringType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::StringRefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of string values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
  }
  return ::mlir::success();
}

void InitializeTableFromTextFileV2Op::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
  for (::mlir::Value value : getODSOperands(0))
    effects.emplace_back(MemoryEffects::Write::get(), value, ::mlir::TF::ResourceEffects::LookupTable::get());
}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::InitializeTableV2Op definitions
//===----------------------------------------------------------------------===//

InitializeTableV2OpAdaptor::InitializeTableV2OpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

InitializeTableV2OpAdaptor::InitializeTableV2OpAdaptor(InitializeTableV2Op&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> InitializeTableV2OpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange InitializeTableV2OpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value InitializeTableV2OpAdaptor::table_handle() {
  return *getODSOperands(0).begin();
}

::mlir::Value InitializeTableV2OpAdaptor::keys() {
  return *getODSOperands(1).begin();
}

::mlir::Value InitializeTableV2OpAdaptor::values() {
  return *getODSOperands(2).begin();
}

::mlir::LogicalResult InitializeTableV2OpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

::llvm::StringRef InitializeTableV2Op::getOperationName() {
  return "tf.InitializeTableV2";
}

std::pair<unsigned, unsigned> InitializeTableV2Op::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range InitializeTableV2Op::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value InitializeTableV2Op::table_handle() {
  return *getODSOperands(0).begin();
}

::mlir::Value InitializeTableV2Op::keys() {
  return *getODSOperands(1).begin();
}

::mlir::Value InitializeTableV2Op::values() {
  return *getODSOperands(2).begin();
}

::mlir::MutableOperandRange InitializeTableV2Op::table_handleMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange InitializeTableV2Op::keysMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange InitializeTableV2Op::valuesMutable() {
  auto range = getODSOperandIndexAndLength(2);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> InitializeTableV2Op::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range InitializeTableV2Op::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

Type InitializeTableV2Op::Tval() {
  return mlir::getElementTypeOrSelf(*getODSOperands(2).begin());
}

Type InitializeTableV2Op::Tkey() {
  return mlir::getElementTypeOrSelf(*getODSOperands(1).begin());
}

bool InitializeTableV2Op::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "Tval") return true;
  if (name == "Tkey") return true;
 return false;
}

::mlir::DictionaryAttr InitializeTableV2Op::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("Tval", ctx),
::mlir::TypeAttr::get(Tval())},
    {::mlir::Identifier::get("Tkey", ctx),
::mlir::TypeAttr::get(Tkey())}
    }, ctx);
}

void InitializeTableV2Op::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value table_handle, ::mlir::Value keys, ::mlir::Value values) {
  odsState.addOperands(table_handle);
  odsState.addOperands(keys);
  odsState.addOperands(values);
}

void InitializeTableV2Op::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value table_handle, ::mlir::Value keys, ::mlir::Value values) {
  odsState.addOperands(table_handle);
  odsState.addOperands(keys);
  odsState.addOperands(values);
  assert(resultTypes.size() == 0u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void InitializeTableV2Op::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 3u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 0u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult InitializeTableV2Op::verify() {
  if (failed(InitializeTableV2OpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::ResourceType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::ResourceRefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of resource values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>())))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::TensorFlowType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of tf.dtype values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup2 = getODSOperands(2);
    for (::mlir::Value v : valueGroup2) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>())))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::TensorFlowType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of tf.dtype values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
  }
  return ::mlir::success();
}

void InitializeTableV2Op::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
  for (::mlir::Value value : getODSOperands(0))
    effects.emplace_back(MemoryEffects::Write::get(), value, ::mlir::TF::ResourceEffects::LookupTable::get());
}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::InplaceUpdateOp definitions
//===----------------------------------------------------------------------===//

InplaceUpdateOpAdaptor::InplaceUpdateOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

InplaceUpdateOpAdaptor::InplaceUpdateOpAdaptor(InplaceUpdateOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> InplaceUpdateOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange InplaceUpdateOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value InplaceUpdateOpAdaptor::x() {
  return *getODSOperands(0).begin();
}

::mlir::Value InplaceUpdateOpAdaptor::i() {
  return *getODSOperands(1).begin();
}

::mlir::Value InplaceUpdateOpAdaptor::v() {
  return *getODSOperands(2).begin();
}

::mlir::LogicalResult InplaceUpdateOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

::llvm::StringRef InplaceUpdateOp::getOperationName() {
  return "tf.InplaceUpdate";
}

std::pair<unsigned, unsigned> InplaceUpdateOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range InplaceUpdateOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value InplaceUpdateOp::x() {
  return *getODSOperands(0).begin();
}

::mlir::Value InplaceUpdateOp::i() {
  return *getODSOperands(1).begin();
}

::mlir::Value InplaceUpdateOp::v() {
  return *getODSOperands(2).begin();
}

::mlir::MutableOperandRange InplaceUpdateOp::xMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange InplaceUpdateOp::iMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange InplaceUpdateOp::vMutable() {
  auto range = getODSOperandIndexAndLength(2);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> InplaceUpdateOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range InplaceUpdateOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value InplaceUpdateOp::y() {
  return *getODSResults(0).begin();
}

Type InplaceUpdateOp::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

bool InplaceUpdateOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "T") return true;
 return false;
}

::mlir::DictionaryAttr InplaceUpdateOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())}
    }, ctx);
}

void InplaceUpdateOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type y, ::mlir::Value x, ::mlir::Value i, ::mlir::Value v) {
  odsState.addOperands(x);
  odsState.addOperands(i);
  odsState.addOperands(v);
  odsState.addTypes(y);
}

void InplaceUpdateOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value x, ::mlir::Value i, ::mlir::Value v) {
  odsState.addOperands(x);
  odsState.addOperands(i);
  odsState.addOperands(v);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void InplaceUpdateOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 3u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult InplaceUpdateOp::verify() {
  if (failed(InplaceUpdateOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>())))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::TensorFlowType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of tf.dtype values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of 32-bit integer values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup2 = getODSOperands(2);
    for (::mlir::Value v : valueGroup2) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>())))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::TensorFlowType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of tf.dtype values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>())))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::TensorFlowType>()))))) {
        return emitOpError("result #") << index << " must be tensor of tf.dtype values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void InplaceUpdateOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::InvOp definitions
//===----------------------------------------------------------------------===//

InvOpAdaptor::InvOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

InvOpAdaptor::InvOpAdaptor(InvOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> InvOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange InvOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value InvOpAdaptor::x() {
  return *getODSOperands(0).begin();
}

::mlir::LogicalResult InvOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

::llvm::StringRef InvOp::getOperationName() {
  return "tf.Inv";
}

std::pair<unsigned, unsigned> InvOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range InvOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value InvOp::x() {
  return *getODSOperands(0).begin();
}

::mlir::MutableOperandRange InvOp::xMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> InvOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range InvOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value InvOp::y() {
  return *getODSResults(0).begin();
}

Type InvOp::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

bool InvOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "T") return true;
 return false;
}

::mlir::DictionaryAttr InvOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())}
    }, ctx);
}

void InvOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type y, ::mlir::Value x) {
  odsState.addOperands(x);
  odsState.addTypes(y);
}

void InvOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value x) {
  odsState.addOperands(x);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void InvOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

void InvOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value x) {
  odsState.addOperands(x);
  odsState.addTypes({x.getType()});

}

void InvOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  odsState.addTypes({operands[0].getType()});

}

::mlir::LogicalResult InvOp::verify() {
  if (failed(InvOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of bfloat16 or 128-bit complex or 64-bit complex or 16-bit float or 32-bit float or 64-bit float or 16-bit integer or 32-bit integer or 64-bit integer or 8-bit integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>())))))) {
        return emitOpError("result #") << index << " must be tensor of bfloat16 or 128-bit complex or 64-bit complex or 16-bit float or 32-bit float or 64-bit float or 16-bit integer or 32-bit integer or 64-bit integer or 8-bit integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void InvOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::InvertOp definitions
//===----------------------------------------------------------------------===//

InvertOpAdaptor::InvertOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

InvertOpAdaptor::InvertOpAdaptor(InvertOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> InvertOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange InvertOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value InvertOpAdaptor::x() {
  return *getODSOperands(0).begin();
}

::mlir::LogicalResult InvertOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

::llvm::StringRef InvertOp::getOperationName() {
  return "tf.Invert";
}

std::pair<unsigned, unsigned> InvertOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range InvertOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value InvertOp::x() {
  return *getODSOperands(0).begin();
}

::mlir::MutableOperandRange InvertOp::xMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> InvertOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range InvertOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value InvertOp::y() {
  return *getODSResults(0).begin();
}

Type InvertOp::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

bool InvertOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "T") return true;
 return false;
}

::mlir::DictionaryAttr InvertOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())}
    }, ctx);
}

void InvertOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type y, ::mlir::Value x) {
  odsState.addOperands(x);
  odsState.addTypes(y);
}

void InvertOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value x) {
  odsState.addOperands(x);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void InvertOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

void InvertOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value x) {
  odsState.addOperands(x);
  odsState.addTypes({x.getType()});

}

void InvertOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  odsState.addTypes({operands[0].getType()});

}

::mlir::LogicalResult InvertOp::verify() {
  if (failed(InvertOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))))) {
        return emitOpError("operand #") << index << " must be tensor of integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))))) {
        return emitOpError("result #") << index << " must be tensor of integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}



void InvertOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::InvertPermutationOp definitions
//===----------------------------------------------------------------------===//

InvertPermutationOpAdaptor::InvertPermutationOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

InvertPermutationOpAdaptor::InvertPermutationOpAdaptor(InvertPermutationOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> InvertPermutationOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange InvertPermutationOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value InvertPermutationOpAdaptor::x() {
  return *getODSOperands(0).begin();
}

::mlir::LogicalResult InvertPermutationOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

::llvm::StringRef InvertPermutationOp::getOperationName() {
  return "tf.InvertPermutation";
}

std::pair<unsigned, unsigned> InvertPermutationOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range InvertPermutationOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value InvertPermutationOp::x() {
  return *getODSOperands(0).begin();
}

::mlir::MutableOperandRange InvertPermutationOp::xMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> InvertPermutationOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range InvertPermutationOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value InvertPermutationOp::y() {
  return *getODSResults(0).begin();
}

Type InvertPermutationOp::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

bool InvertPermutationOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "T") return true;
 return false;
}

::mlir::DictionaryAttr InvertPermutationOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())}
    }, ctx);
}

void InvertPermutationOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type y, ::mlir::Value x) {
  odsState.addOperands(x);
  odsState.addTypes(y);
}

void InvertPermutationOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value x) {
  odsState.addOperands(x);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void InvertPermutationOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult InvertPermutationOp::verify() {
  if (failed(InvertPermutationOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of 32/64-bit signed integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))))) {
        return emitOpError("result #") << index << " must be tensor of 32/64-bit signed integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  return Verify(*this);
}

void InvertPermutationOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::IsFiniteOp definitions
//===----------------------------------------------------------------------===//

IsFiniteOpAdaptor::IsFiniteOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

IsFiniteOpAdaptor::IsFiniteOpAdaptor(IsFiniteOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> IsFiniteOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange IsFiniteOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value IsFiniteOpAdaptor::x() {
  return *getODSOperands(0).begin();
}

::mlir::LogicalResult IsFiniteOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

::llvm::StringRef IsFiniteOp::getOperationName() {
  return "tf.IsFinite";
}

std::pair<unsigned, unsigned> IsFiniteOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range IsFiniteOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value IsFiniteOp::x() {
  return *getODSOperands(0).begin();
}

::mlir::MutableOperandRange IsFiniteOp::xMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> IsFiniteOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range IsFiniteOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value IsFiniteOp::y() {
  return *getODSResults(0).begin();
}

Type IsFiniteOp::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

bool IsFiniteOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "T") return true;
 return false;
}

::mlir::DictionaryAttr IsFiniteOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())}
    }, ctx);
}

void IsFiniteOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type y, ::mlir::Value x) {
  odsState.addOperands(x);
  odsState.addTypes(y);
}

void IsFiniteOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value x) {
  odsState.addOperands(x);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void IsFiniteOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult IsFiniteOp::verify() {
  if (failed(IsFiniteOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of floating-point values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))))) {
        return emitOpError("result #") << index << " must be tensor of bool values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void IsFiniteOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::IsInfOp definitions
//===----------------------------------------------------------------------===//

IsInfOpAdaptor::IsInfOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

IsInfOpAdaptor::IsInfOpAdaptor(IsInfOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> IsInfOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange IsInfOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value IsInfOpAdaptor::x() {
  return *getODSOperands(0).begin();
}

::mlir::LogicalResult IsInfOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

::llvm::StringRef IsInfOp::getOperationName() {
  return "tf.IsInf";
}

std::pair<unsigned, unsigned> IsInfOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range IsInfOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value IsInfOp::x() {
  return *getODSOperands(0).begin();
}

::mlir::MutableOperandRange IsInfOp::xMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> IsInfOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range IsInfOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value IsInfOp::y() {
  return *getODSResults(0).begin();
}

Type IsInfOp::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

bool IsInfOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "T") return true;
 return false;
}

::mlir::DictionaryAttr IsInfOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())}
    }, ctx);
}

void IsInfOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type y, ::mlir::Value x) {
  odsState.addOperands(x);
  odsState.addTypes(y);
}

void IsInfOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value x) {
  odsState.addOperands(x);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void IsInfOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult IsInfOp::verify() {
  if (failed(IsInfOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of floating-point values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))))) {
        return emitOpError("result #") << index << " must be tensor of bool values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void IsInfOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::IsNanOp definitions
//===----------------------------------------------------------------------===//

IsNanOpAdaptor::IsNanOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

IsNanOpAdaptor::IsNanOpAdaptor(IsNanOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> IsNanOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange IsNanOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value IsNanOpAdaptor::x() {
  return *getODSOperands(0).begin();
}

::mlir::LogicalResult IsNanOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

::llvm::StringRef IsNanOp::getOperationName() {
  return "tf.IsNan";
}

std::pair<unsigned, unsigned> IsNanOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range IsNanOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value IsNanOp::x() {
  return *getODSOperands(0).begin();
}

::mlir::MutableOperandRange IsNanOp::xMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> IsNanOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range IsNanOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value IsNanOp::y() {
  return *getODSResults(0).begin();
}

Type IsNanOp::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

bool IsNanOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "T") return true;
 return false;
}

::mlir::DictionaryAttr IsNanOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())}
    }, ctx);
}

void IsNanOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type y, ::mlir::Value x) {
  odsState.addOperands(x);
  odsState.addTypes(y);
}

void IsNanOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value x) {
  odsState.addOperands(x);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void IsNanOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult IsNanOp::verify() {
  if (failed(IsNanOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of floating-point values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))))) {
        return emitOpError("result #") << index << " must be tensor of bool values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void IsNanOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::IteratorFromStringHandleOp definitions
//===----------------------------------------------------------------------===//

IteratorFromStringHandleOpAdaptor::IteratorFromStringHandleOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

IteratorFromStringHandleOpAdaptor::IteratorFromStringHandleOpAdaptor(IteratorFromStringHandleOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> IteratorFromStringHandleOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange IteratorFromStringHandleOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value IteratorFromStringHandleOpAdaptor::string_handle() {
  return *getODSOperands(0).begin();
}

::mlir::ArrayAttr IteratorFromStringHandleOpAdaptor::output_types() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::ArrayAttr attr = odsAttrs.get("output_types").dyn_cast_or_null<::mlir::ArrayAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getTypeArrayAttr({});
  return attr;
}

::mlir::ArrayAttr IteratorFromStringHandleOpAdaptor::output_shapes() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::ArrayAttr attr = odsAttrs.get("output_shapes").dyn_cast_or_null<::mlir::ArrayAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getArrayAttr({});
  return attr;
}

::mlir::LogicalResult IteratorFromStringHandleOpAdaptor::verify(::mlir::Location loc) {
  {
  auto tblgen_output_types = odsAttrs.get("output_types");
  if (tblgen_output_types) {
    if (!(((tblgen_output_types.isa<::mlir::ArrayAttr>())) && (::llvm::all_of(tblgen_output_types.cast<::mlir::ArrayAttr>(), [](::mlir::Attribute attr) { return ((attr.isa<::mlir::TypeAttr>())) && ((attr.cast<::mlir::TypeAttr>().getValue().isa<::mlir::Type>())); })))) return emitError(loc, "'tf.IteratorFromStringHandle' op ""attribute 'output_types' failed to satisfy constraint: type array attribute");
  }
  }
  {
  auto tblgen_output_shapes = odsAttrs.get("output_shapes");
  if (tblgen_output_shapes) {
    if (!(((tblgen_output_shapes.isa<::mlir::ArrayAttr>())) && (::llvm::all_of(tblgen_output_shapes.cast<::mlir::ArrayAttr>(), [](::mlir::Attribute attr) { return (attr.isa<mlir::TF::ShapeAttr>()); })))) return emitError(loc, "'tf.IteratorFromStringHandle' op ""attribute 'output_shapes' failed to satisfy constraint: tensorflow shape attribute array");
  }
  }
  return ::mlir::success();
}

::llvm::StringRef IteratorFromStringHandleOp::getOperationName() {
  return "tf.IteratorFromStringHandle";
}

std::pair<unsigned, unsigned> IteratorFromStringHandleOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range IteratorFromStringHandleOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value IteratorFromStringHandleOp::string_handle() {
  return *getODSOperands(0).begin();
}

::mlir::MutableOperandRange IteratorFromStringHandleOp::string_handleMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> IteratorFromStringHandleOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range IteratorFromStringHandleOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value IteratorFromStringHandleOp::resource_handle() {
  return *getODSResults(0).begin();
}

::mlir::ArrayAttr IteratorFromStringHandleOp::output_typesAttr() {
  return this->getAttr("output_types").dyn_cast_or_null<::mlir::ArrayAttr>();
}

::mlir::ArrayAttr IteratorFromStringHandleOp::output_types() {
  auto attr = output_typesAttr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getTypeArrayAttr({});
  return attr;
}

::mlir::ArrayAttr IteratorFromStringHandleOp::output_shapesAttr() {
  return this->getAttr("output_shapes").dyn_cast_or_null<::mlir::ArrayAttr>();
}

::mlir::ArrayAttr IteratorFromStringHandleOp::output_shapes() {
  auto attr = output_shapesAttr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getArrayAttr({});
  return attr;
}

void IteratorFromStringHandleOp::output_typesAttr(::mlir::ArrayAttr attr) {
  this->getOperation()->setAttr("output_types", attr);
}

void IteratorFromStringHandleOp::output_shapesAttr(::mlir::ArrayAttr attr) {
  this->getOperation()->setAttr("output_shapes", attr);
}

void IteratorFromStringHandleOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type resource_handle, ::mlir::Value string_handle, ::mlir::ArrayAttr output_types, ::mlir::ArrayAttr output_shapes) {
  odsState.addOperands(string_handle);
  odsState.addAttribute("output_types", output_types);
  odsState.addAttribute("output_shapes", output_shapes);
  odsState.addTypes(resource_handle);
}

void IteratorFromStringHandleOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value string_handle, ::mlir::ArrayAttr output_types, ::mlir::ArrayAttr output_shapes) {
  odsState.addOperands(string_handle);
  odsState.addAttribute("output_types", output_types);
  odsState.addAttribute("output_shapes", output_shapes);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void IteratorFromStringHandleOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult IteratorFromStringHandleOp::verify() {
  if (failed(IteratorFromStringHandleOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::StringType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::StringRefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of string values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::ResourceType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::ResourceRefType>()))))) {
        return emitOpError("result #") << index << " must be tensor of resource values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void IteratorFromStringHandleOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
  for (::mlir::Value value : getODSResults(0))
    effects.emplace_back(MemoryEffects::Allocate::get(), value, ::mlir::TF::ResourceEffects::DatasetIterator::get());
}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::IteratorFromStringHandleV2Op definitions
//===----------------------------------------------------------------------===//

IteratorFromStringHandleV2OpAdaptor::IteratorFromStringHandleV2OpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

IteratorFromStringHandleV2OpAdaptor::IteratorFromStringHandleV2OpAdaptor(IteratorFromStringHandleV2Op&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> IteratorFromStringHandleV2OpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange IteratorFromStringHandleV2OpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value IteratorFromStringHandleV2OpAdaptor::string_handle() {
  return *getODSOperands(0).begin();
}

::mlir::ArrayAttr IteratorFromStringHandleV2OpAdaptor::output_types() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::ArrayAttr attr = odsAttrs.get("output_types").dyn_cast_or_null<::mlir::ArrayAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getTypeArrayAttr({});
  return attr;
}

::mlir::ArrayAttr IteratorFromStringHandleV2OpAdaptor::output_shapes() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::ArrayAttr attr = odsAttrs.get("output_shapes").dyn_cast_or_null<::mlir::ArrayAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getArrayAttr({});
  return attr;
}

::mlir::LogicalResult IteratorFromStringHandleV2OpAdaptor::verify(::mlir::Location loc) {
  {
  auto tblgen_output_types = odsAttrs.get("output_types");
  if (tblgen_output_types) {
    if (!(((tblgen_output_types.isa<::mlir::ArrayAttr>())) && (::llvm::all_of(tblgen_output_types.cast<::mlir::ArrayAttr>(), [](::mlir::Attribute attr) { return ((attr.isa<::mlir::TypeAttr>())) && ((attr.cast<::mlir::TypeAttr>().getValue().isa<::mlir::Type>())); })))) return emitError(loc, "'tf.IteratorFromStringHandleV2' op ""attribute 'output_types' failed to satisfy constraint: type array attribute");
  }
  }
  {
  auto tblgen_output_shapes = odsAttrs.get("output_shapes");
  if (tblgen_output_shapes) {
    if (!(((tblgen_output_shapes.isa<::mlir::ArrayAttr>())) && (::llvm::all_of(tblgen_output_shapes.cast<::mlir::ArrayAttr>(), [](::mlir::Attribute attr) { return (attr.isa<mlir::TF::ShapeAttr>()); })))) return emitError(loc, "'tf.IteratorFromStringHandleV2' op ""attribute 'output_shapes' failed to satisfy constraint: tensorflow shape attribute array");
  }
  }
  return ::mlir::success();
}

::llvm::StringRef IteratorFromStringHandleV2Op::getOperationName() {
  return "tf.IteratorFromStringHandleV2";
}

std::pair<unsigned, unsigned> IteratorFromStringHandleV2Op::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range IteratorFromStringHandleV2Op::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value IteratorFromStringHandleV2Op::string_handle() {
  return *getODSOperands(0).begin();
}

::mlir::MutableOperandRange IteratorFromStringHandleV2Op::string_handleMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> IteratorFromStringHandleV2Op::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range IteratorFromStringHandleV2Op::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value IteratorFromStringHandleV2Op::resource_handle() {
  return *getODSResults(0).begin();
}

::mlir::ArrayAttr IteratorFromStringHandleV2Op::output_typesAttr() {
  return this->getAttr("output_types").dyn_cast_or_null<::mlir::ArrayAttr>();
}

::mlir::ArrayAttr IteratorFromStringHandleV2Op::output_types() {
  auto attr = output_typesAttr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getTypeArrayAttr({});
  return attr;
}

::mlir::ArrayAttr IteratorFromStringHandleV2Op::output_shapesAttr() {
  return this->getAttr("output_shapes").dyn_cast_or_null<::mlir::ArrayAttr>();
}

::mlir::ArrayAttr IteratorFromStringHandleV2Op::output_shapes() {
  auto attr = output_shapesAttr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getArrayAttr({});
  return attr;
}

void IteratorFromStringHandleV2Op::output_typesAttr(::mlir::ArrayAttr attr) {
  this->getOperation()->setAttr("output_types", attr);
}

void IteratorFromStringHandleV2Op::output_shapesAttr(::mlir::ArrayAttr attr) {
  this->getOperation()->setAttr("output_shapes", attr);
}

void IteratorFromStringHandleV2Op::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type resource_handle, ::mlir::Value string_handle, ::mlir::ArrayAttr output_types, ::mlir::ArrayAttr output_shapes) {
  odsState.addOperands(string_handle);
  odsState.addAttribute("output_types", output_types);
  odsState.addAttribute("output_shapes", output_shapes);
  odsState.addTypes(resource_handle);
}

void IteratorFromStringHandleV2Op::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value string_handle, ::mlir::ArrayAttr output_types, ::mlir::ArrayAttr output_shapes) {
  odsState.addOperands(string_handle);
  odsState.addAttribute("output_types", output_types);
  odsState.addAttribute("output_shapes", output_shapes);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void IteratorFromStringHandleV2Op::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult IteratorFromStringHandleV2Op::verify() {
  if (failed(IteratorFromStringHandleV2OpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::StringType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::StringRefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of string values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::ResourceType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::ResourceRefType>()))))) {
        return emitOpError("result #") << index << " must be tensor of resource values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void IteratorFromStringHandleV2Op::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
  for (::mlir::Value value : getODSResults(0))
    effects.emplace_back(MemoryEffects::Allocate::get(), value, ::mlir::TF::ResourceEffects::DatasetIterator::get());
}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::IteratorGetNextAsOptionalOp definitions
//===----------------------------------------------------------------------===//

IteratorGetNextAsOptionalOpAdaptor::IteratorGetNextAsOptionalOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

IteratorGetNextAsOptionalOpAdaptor::IteratorGetNextAsOptionalOpAdaptor(IteratorGetNextAsOptionalOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> IteratorGetNextAsOptionalOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange IteratorGetNextAsOptionalOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value IteratorGetNextAsOptionalOpAdaptor::iterator() {
  return *getODSOperands(0).begin();
}

::mlir::ArrayAttr IteratorGetNextAsOptionalOpAdaptor::output_types() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::ArrayAttr attr = odsAttrs.get("output_types").cast<::mlir::ArrayAttr>();
  return attr;
}

::mlir::ArrayAttr IteratorGetNextAsOptionalOpAdaptor::output_shapes() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::ArrayAttr attr = odsAttrs.get("output_shapes").cast<::mlir::ArrayAttr>();
  return attr;
}

::mlir::LogicalResult IteratorGetNextAsOptionalOpAdaptor::verify(::mlir::Location loc) {
  {
  auto tblgen_output_types = odsAttrs.get("output_types");
  if (!tblgen_output_types) return emitError(loc, "'tf.IteratorGetNextAsOptional' op ""requires attribute 'output_types'");
    if (!((((tblgen_output_types.isa<::mlir::ArrayAttr>())) && (::llvm::all_of(tblgen_output_types.cast<::mlir::ArrayAttr>(), [](::mlir::Attribute attr) { return ((attr.isa<::mlir::TypeAttr>())) && ((attr.cast<::mlir::TypeAttr>().getValue().isa<::mlir::Type>())); }))) && ((tblgen_output_types.cast<::mlir::ArrayAttr>().size() >= 1)))) return emitError(loc, "'tf.IteratorGetNextAsOptional' op ""attribute 'output_types' failed to satisfy constraint: type array attribute with at least 1 elements");
  }
  {
  auto tblgen_output_shapes = odsAttrs.get("output_shapes");
  if (!tblgen_output_shapes) return emitError(loc, "'tf.IteratorGetNextAsOptional' op ""requires attribute 'output_shapes'");
    if (!((((tblgen_output_shapes.isa<::mlir::ArrayAttr>())) && (::llvm::all_of(tblgen_output_shapes.cast<::mlir::ArrayAttr>(), [](::mlir::Attribute attr) { return (attr.isa<mlir::TF::ShapeAttr>()); }))) && ((tblgen_output_shapes.cast<::mlir::ArrayAttr>().size() >= 1)))) return emitError(loc, "'tf.IteratorGetNextAsOptional' op ""attribute 'output_shapes' failed to satisfy constraint: tensorflow shape attribute array with at least 1 elements");
  }
  return ::mlir::success();
}

::llvm::StringRef IteratorGetNextAsOptionalOp::getOperationName() {
  return "tf.IteratorGetNextAsOptional";
}

std::pair<unsigned, unsigned> IteratorGetNextAsOptionalOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range IteratorGetNextAsOptionalOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value IteratorGetNextAsOptionalOp::iterator() {
  return *getODSOperands(0).begin();
}

::mlir::MutableOperandRange IteratorGetNextAsOptionalOp::iteratorMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> IteratorGetNextAsOptionalOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range IteratorGetNextAsOptionalOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value IteratorGetNextAsOptionalOp::optional() {
  return *getODSResults(0).begin();
}

::mlir::ArrayAttr IteratorGetNextAsOptionalOp::output_typesAttr() {
  return this->getAttr("output_types").cast<::mlir::ArrayAttr>();
}

::mlir::ArrayAttr IteratorGetNextAsOptionalOp::output_types() {
  auto attr = output_typesAttr();
  return attr;
}

::mlir::ArrayAttr IteratorGetNextAsOptionalOp::output_shapesAttr() {
  return this->getAttr("output_shapes").cast<::mlir::ArrayAttr>();
}

::mlir::ArrayAttr IteratorGetNextAsOptionalOp::output_shapes() {
  auto attr = output_shapesAttr();
  return attr;
}

void IteratorGetNextAsOptionalOp::output_typesAttr(::mlir::ArrayAttr attr) {
  this->getOperation()->setAttr("output_types", attr);
}

void IteratorGetNextAsOptionalOp::output_shapesAttr(::mlir::ArrayAttr attr) {
  this->getOperation()->setAttr("output_shapes", attr);
}

void IteratorGetNextAsOptionalOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type optional, ::mlir::Value iterator, ::mlir::ArrayAttr output_types, ::mlir::ArrayAttr output_shapes) {
  odsState.addOperands(iterator);
  odsState.addAttribute("output_types", output_types);
  odsState.addAttribute("output_shapes", output_shapes);
  odsState.addTypes(optional);
}

void IteratorGetNextAsOptionalOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value iterator, ::mlir::ArrayAttr output_types, ::mlir::ArrayAttr output_shapes) {
  odsState.addOperands(iterator);
  odsState.addAttribute("output_types", output_types);
  odsState.addAttribute("output_shapes", output_shapes);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void IteratorGetNextAsOptionalOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult IteratorGetNextAsOptionalOp::verify() {
  if (failed(IteratorGetNextAsOptionalOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::ResourceType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::ResourceRefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of resource values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::VariantType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::VariantRefType>()))))) {
        return emitOpError("result #") << index << " must be tensor of variant values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void IteratorGetNextAsOptionalOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
  for (::mlir::Value value : getODSOperands(0))
    effects.emplace_back(MemoryEffects::Read::get(), value, ::mlir::TF::ResourceEffects::DatasetIterator::get());
  for (::mlir::Value value : getODSOperands(0))
    effects.emplace_back(MemoryEffects::Write::get(), value, ::mlir::TF::ResourceEffects::DatasetIterator::get());
}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::IteratorGetNextOp definitions
//===----------------------------------------------------------------------===//

IteratorGetNextOpAdaptor::IteratorGetNextOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

IteratorGetNextOpAdaptor::IteratorGetNextOpAdaptor(IteratorGetNextOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> IteratorGetNextOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange IteratorGetNextOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value IteratorGetNextOpAdaptor::iterator() {
  return *getODSOperands(0).begin();
}

::mlir::LogicalResult IteratorGetNextOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

::llvm::StringRef IteratorGetNextOp::getOperationName() {
  return "tf.IteratorGetNext";
}

std::pair<unsigned, unsigned> IteratorGetNextOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range IteratorGetNextOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value IteratorGetNextOp::iterator() {
  return *getODSOperands(0).begin();
}

::mlir::MutableOperandRange IteratorGetNextOp::iteratorMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> IteratorGetNextOp::getODSResultIndexAndLength(unsigned index) {
  bool isVariadic[] = {true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (getOperation()->getNumResults() - 0) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::mlir::Operation::result_range IteratorGetNextOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Operation::result_range IteratorGetNextOp::components() {
  return getODSResults(0);
}

mlir::TF::ResultShapeRange IteratorGetNextOp::output_shapes() {
  auto values = getODSResults(0);
return {mlir::TF::ResultShapeIterator(values.begin()), mlir::TF::ResultShapeIterator(values.end())};
}

mlir::ResultElementTypeRange IteratorGetNextOp::output_types() {
  auto values = getODSResults(0);
return {mlir::ResultElementTypeIterator(values.begin()), mlir::ResultElementTypeIterator(values.end())};
}

bool IteratorGetNextOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "output_shapes") return true;
  if (name == "output_types") return true;
 return false;
}

::mlir::DictionaryAttr IteratorGetNextOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("output_shapes", ctx),
ArrayAttr::get(
      [&](){
        llvm::SmallVector<Attribute, 4> ret;
        for (auto shape : output_shapes())
          ret.push_back(mlir::TF::ShapeAttr::get(ctx, shape));
        return ret;
      }(), ctx)},
    {::mlir::Identifier::get("output_types", ctx),
ArrayAttr::get(
    [&]() {
      llvm::SmallVector<Attribute, 4> ret;
      for (auto t : output_types())
        ret.push_back(TypeAttr::get(t));
      return ret;
    }(), ctx)}
    }, ctx);
}

void IteratorGetNextOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange components, ::mlir::Value iterator) {
  odsState.addOperands(iterator);
  odsState.addTypes(components);
}

void IteratorGetNextOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult IteratorGetNextOp::verify() {
  if (failed(IteratorGetNextOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::ResourceType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::ResourceRefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of resource values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>())))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::TensorFlowType>()))))) {
        return emitOpError("result #") << index << " must be tensor of tf.dtype values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void IteratorGetNextOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
  for (::mlir::Value value : getODSOperands(0))
    effects.emplace_back(MemoryEffects::Read::get(), value, ::mlir::TF::ResourceEffects::DatasetIterator::get());
  for (::mlir::Value value : getODSOperands(0))
    effects.emplace_back(MemoryEffects::Write::get(), value, ::mlir::TF::ResourceEffects::DatasetIterator::get());
}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::IteratorGetNextSyncOp definitions
//===----------------------------------------------------------------------===//

IteratorGetNextSyncOpAdaptor::IteratorGetNextSyncOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

IteratorGetNextSyncOpAdaptor::IteratorGetNextSyncOpAdaptor(IteratorGetNextSyncOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> IteratorGetNextSyncOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange IteratorGetNextSyncOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value IteratorGetNextSyncOpAdaptor::iterator() {
  return *getODSOperands(0).begin();
}

::mlir::LogicalResult IteratorGetNextSyncOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

::llvm::StringRef IteratorGetNextSyncOp::getOperationName() {
  return "tf.IteratorGetNextSync";
}

std::pair<unsigned, unsigned> IteratorGetNextSyncOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range IteratorGetNextSyncOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value IteratorGetNextSyncOp::iterator() {
  return *getODSOperands(0).begin();
}

::mlir::MutableOperandRange IteratorGetNextSyncOp::iteratorMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> IteratorGetNextSyncOp::getODSResultIndexAndLength(unsigned index) {
  bool isVariadic[] = {true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (getOperation()->getNumResults() - 0) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::mlir::Operation::result_range IteratorGetNextSyncOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Operation::result_range IteratorGetNextSyncOp::components() {
  return getODSResults(0);
}

mlir::TF::ResultShapeRange IteratorGetNextSyncOp::output_shapes() {
  auto values = getODSResults(0);
return {mlir::TF::ResultShapeIterator(values.begin()), mlir::TF::ResultShapeIterator(values.end())};
}

mlir::ResultElementTypeRange IteratorGetNextSyncOp::output_types() {
  auto values = getODSResults(0);
return {mlir::ResultElementTypeIterator(values.begin()), mlir::ResultElementTypeIterator(values.end())};
}

bool IteratorGetNextSyncOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "output_shapes") return true;
  if (name == "output_types") return true;
 return false;
}

::mlir::DictionaryAttr IteratorGetNextSyncOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("output_shapes", ctx),
ArrayAttr::get(
      [&](){
        llvm::SmallVector<Attribute, 4> ret;
        for (auto shape : output_shapes())
          ret.push_back(mlir::TF::ShapeAttr::get(ctx, shape));
        return ret;
      }(), ctx)},
    {::mlir::Identifier::get("output_types", ctx),
ArrayAttr::get(
    [&]() {
      llvm::SmallVector<Attribute, 4> ret;
      for (auto t : output_types())
        ret.push_back(TypeAttr::get(t));
      return ret;
    }(), ctx)}
    }, ctx);
}

void IteratorGetNextSyncOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange components, ::mlir::Value iterator) {
  odsState.addOperands(iterator);
  odsState.addTypes(components);
}

void IteratorGetNextSyncOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult IteratorGetNextSyncOp::verify() {
  if (failed(IteratorGetNextSyncOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::ResourceType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::ResourceRefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of resource values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>())))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::TensorFlowType>()))))) {
        return emitOpError("result #") << index << " must be tensor of tf.dtype values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void IteratorGetNextSyncOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
  for (::mlir::Value value : getODSOperands(0))
    effects.emplace_back(MemoryEffects::Read::get(), value, ::mlir::TF::ResourceEffects::DatasetIterator::get());
  for (::mlir::Value value : getODSOperands(0))
    effects.emplace_back(MemoryEffects::Write::get(), value, ::mlir::TF::ResourceEffects::DatasetIterator::get());
}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::IteratorOp definitions
//===----------------------------------------------------------------------===//

IteratorOpAdaptor::IteratorOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

IteratorOpAdaptor::IteratorOpAdaptor(IteratorOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> IteratorOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange IteratorOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::StringAttr IteratorOpAdaptor::shared_name() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::StringAttr attr = odsAttrs.get("shared_name").cast<::mlir::StringAttr>();
  return attr;
}

::mlir::StringAttr IteratorOpAdaptor::container() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::StringAttr attr = odsAttrs.get("container").cast<::mlir::StringAttr>();
  return attr;
}

::mlir::ArrayAttr IteratorOpAdaptor::output_types() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::ArrayAttr attr = odsAttrs.get("output_types").cast<::mlir::ArrayAttr>();
  return attr;
}

::mlir::ArrayAttr IteratorOpAdaptor::output_shapes() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::ArrayAttr attr = odsAttrs.get("output_shapes").cast<::mlir::ArrayAttr>();
  return attr;
}

::mlir::LogicalResult IteratorOpAdaptor::verify(::mlir::Location loc) {
  {
  auto tblgen_shared_name = odsAttrs.get("shared_name");
  if (!tblgen_shared_name) return emitError(loc, "'tf.Iterator' op ""requires attribute 'shared_name'");
    if (!((tblgen_shared_name.isa<::mlir::StringAttr>()))) return emitError(loc, "'tf.Iterator' op ""attribute 'shared_name' failed to satisfy constraint: string attribute");
  }
  {
  auto tblgen_container = odsAttrs.get("container");
  if (!tblgen_container) return emitError(loc, "'tf.Iterator' op ""requires attribute 'container'");
    if (!((tblgen_container.isa<::mlir::StringAttr>()))) return emitError(loc, "'tf.Iterator' op ""attribute 'container' failed to satisfy constraint: string attribute");
  }
  {
  auto tblgen_output_types = odsAttrs.get("output_types");
  if (!tblgen_output_types) return emitError(loc, "'tf.Iterator' op ""requires attribute 'output_types'");
    if (!((((tblgen_output_types.isa<::mlir::ArrayAttr>())) && (::llvm::all_of(tblgen_output_types.cast<::mlir::ArrayAttr>(), [](::mlir::Attribute attr) { return ((attr.isa<::mlir::TypeAttr>())) && ((attr.cast<::mlir::TypeAttr>().getValue().isa<::mlir::Type>())); }))) && ((tblgen_output_types.cast<::mlir::ArrayAttr>().size() >= 1)))) return emitError(loc, "'tf.Iterator' op ""attribute 'output_types' failed to satisfy constraint: type array attribute with at least 1 elements");
  }
  {
  auto tblgen_output_shapes = odsAttrs.get("output_shapes");
  if (!tblgen_output_shapes) return emitError(loc, "'tf.Iterator' op ""requires attribute 'output_shapes'");
    if (!((((tblgen_output_shapes.isa<::mlir::ArrayAttr>())) && (::llvm::all_of(tblgen_output_shapes.cast<::mlir::ArrayAttr>(), [](::mlir::Attribute attr) { return (attr.isa<mlir::TF::ShapeAttr>()); }))) && ((tblgen_output_shapes.cast<::mlir::ArrayAttr>().size() >= 1)))) return emitError(loc, "'tf.Iterator' op ""attribute 'output_shapes' failed to satisfy constraint: tensorflow shape attribute array with at least 1 elements");
  }
  return ::mlir::success();
}

::llvm::StringRef IteratorOp::getOperationName() {
  return "tf.Iterator";
}

std::pair<unsigned, unsigned> IteratorOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range IteratorOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

std::pair<unsigned, unsigned> IteratorOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range IteratorOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value IteratorOp::handle() {
  return *getODSResults(0).begin();
}

::mlir::StringAttr IteratorOp::shared_nameAttr() {
  return this->getAttr("shared_name").cast<::mlir::StringAttr>();
}

::llvm::StringRef IteratorOp::shared_name() {
  auto attr = shared_nameAttr();
  return attr.getValue();
}

::mlir::StringAttr IteratorOp::containerAttr() {
  return this->getAttr("container").cast<::mlir::StringAttr>();
}

::llvm::StringRef IteratorOp::container() {
  auto attr = containerAttr();
  return attr.getValue();
}

::mlir::ArrayAttr IteratorOp::output_typesAttr() {
  return this->getAttr("output_types").cast<::mlir::ArrayAttr>();
}

::mlir::ArrayAttr IteratorOp::output_types() {
  auto attr = output_typesAttr();
  return attr;
}

::mlir::ArrayAttr IteratorOp::output_shapesAttr() {
  return this->getAttr("output_shapes").cast<::mlir::ArrayAttr>();
}

::mlir::ArrayAttr IteratorOp::output_shapes() {
  auto attr = output_shapesAttr();
  return attr;
}

void IteratorOp::shared_nameAttr(::mlir::StringAttr attr) {
  this->getOperation()->setAttr("shared_name", attr);
}

void IteratorOp::containerAttr(::mlir::StringAttr attr) {
  this->getOperation()->setAttr("container", attr);
}

void IteratorOp::output_typesAttr(::mlir::ArrayAttr attr) {
  this->getOperation()->setAttr("output_types", attr);
}

void IteratorOp::output_shapesAttr(::mlir::ArrayAttr attr) {
  this->getOperation()->setAttr("output_shapes", attr);
}

void IteratorOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type handle, ::mlir::StringAttr shared_name, ::mlir::StringAttr container, ::mlir::ArrayAttr output_types, ::mlir::ArrayAttr output_shapes) {
  odsState.addAttribute("shared_name", shared_name);
  odsState.addAttribute("container", container);
  odsState.addAttribute("output_types", output_types);
  odsState.addAttribute("output_shapes", output_shapes);
  odsState.addTypes(handle);
}

void IteratorOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::StringAttr shared_name, ::mlir::StringAttr container, ::mlir::ArrayAttr output_types, ::mlir::ArrayAttr output_shapes) {
  odsState.addAttribute("shared_name", shared_name);
  odsState.addAttribute("container", container);
  odsState.addAttribute("output_types", output_types);
  odsState.addAttribute("output_shapes", output_shapes);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void IteratorOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type handle, ::llvm::StringRef shared_name, ::llvm::StringRef container, ::mlir::ArrayAttr output_types, ::mlir::ArrayAttr output_shapes) {
  odsState.addAttribute("shared_name", odsBuilder.getStringAttr(shared_name));
  odsState.addAttribute("container", odsBuilder.getStringAttr(container));
  odsState.addAttribute("output_types", output_types);
  odsState.addAttribute("output_shapes", output_shapes);
  odsState.addTypes(handle);
}

void IteratorOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::llvm::StringRef shared_name, ::llvm::StringRef container, ::mlir::ArrayAttr output_types, ::mlir::ArrayAttr output_shapes) {
  odsState.addAttribute("shared_name", odsBuilder.getStringAttr(shared_name));
  odsState.addAttribute("container", odsBuilder.getStringAttr(container));
  odsState.addAttribute("output_types", output_types);
  odsState.addAttribute("output_shapes", output_shapes);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void IteratorOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 0u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult IteratorOp::verify() {
  if (failed(IteratorOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::ResourceType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::ResourceRefType>()))))) {
        return emitOpError("result #") << index << " must be tensor of resource values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void IteratorOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
  for (::mlir::Value value : getODSResults(0))
    effects.emplace_back(MemoryEffects::Allocate::get(), value, ::mlir::TF::ResourceEffects::DatasetIterator::get());
}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::IteratorToStringHandleOp definitions
//===----------------------------------------------------------------------===//

IteratorToStringHandleOpAdaptor::IteratorToStringHandleOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

IteratorToStringHandleOpAdaptor::IteratorToStringHandleOpAdaptor(IteratorToStringHandleOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> IteratorToStringHandleOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange IteratorToStringHandleOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value IteratorToStringHandleOpAdaptor::resource_handle() {
  return *getODSOperands(0).begin();
}

::mlir::LogicalResult IteratorToStringHandleOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

::llvm::StringRef IteratorToStringHandleOp::getOperationName() {
  return "tf.IteratorToStringHandle";
}

std::pair<unsigned, unsigned> IteratorToStringHandleOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range IteratorToStringHandleOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value IteratorToStringHandleOp::resource_handle() {
  return *getODSOperands(0).begin();
}

::mlir::MutableOperandRange IteratorToStringHandleOp::resource_handleMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> IteratorToStringHandleOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range IteratorToStringHandleOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value IteratorToStringHandleOp::string_handle() {
  return *getODSResults(0).begin();
}

void IteratorToStringHandleOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type string_handle, ::mlir::Value resource_handle) {
  odsState.addOperands(resource_handle);
  odsState.addTypes(string_handle);
}

void IteratorToStringHandleOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value resource_handle) {
  odsState.addOperands(resource_handle);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void IteratorToStringHandleOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult IteratorToStringHandleOp::verify() {
  if (failed(IteratorToStringHandleOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::ResourceType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::ResourceRefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of resource values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::StringType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::StringRefType>()))))) {
        return emitOpError("result #") << index << " must be tensor of string values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void IteratorToStringHandleOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
  for (::mlir::Value value : getODSOperands(0))
    effects.emplace_back(MemoryEffects::Read::get(), value, ::mlir::TF::ResourceEffects::DatasetIterator::get());
}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::IteratorV2Op definitions
//===----------------------------------------------------------------------===//

IteratorV2OpAdaptor::IteratorV2OpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

IteratorV2OpAdaptor::IteratorV2OpAdaptor(IteratorV2Op&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> IteratorV2OpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange IteratorV2OpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::StringAttr IteratorV2OpAdaptor::shared_name() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::StringAttr attr = odsAttrs.get("shared_name").cast<::mlir::StringAttr>();
  return attr;
}

::mlir::StringAttr IteratorV2OpAdaptor::container() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::StringAttr attr = odsAttrs.get("container").cast<::mlir::StringAttr>();
  return attr;
}

::mlir::ArrayAttr IteratorV2OpAdaptor::output_types() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::ArrayAttr attr = odsAttrs.get("output_types").cast<::mlir::ArrayAttr>();
  return attr;
}

::mlir::ArrayAttr IteratorV2OpAdaptor::output_shapes() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::ArrayAttr attr = odsAttrs.get("output_shapes").cast<::mlir::ArrayAttr>();
  return attr;
}

::mlir::LogicalResult IteratorV2OpAdaptor::verify(::mlir::Location loc) {
  {
  auto tblgen_shared_name = odsAttrs.get("shared_name");
  if (!tblgen_shared_name) return emitError(loc, "'tf.IteratorV2' op ""requires attribute 'shared_name'");
    if (!((tblgen_shared_name.isa<::mlir::StringAttr>()))) return emitError(loc, "'tf.IteratorV2' op ""attribute 'shared_name' failed to satisfy constraint: string attribute");
  }
  {
  auto tblgen_container = odsAttrs.get("container");
  if (!tblgen_container) return emitError(loc, "'tf.IteratorV2' op ""requires attribute 'container'");
    if (!((tblgen_container.isa<::mlir::StringAttr>()))) return emitError(loc, "'tf.IteratorV2' op ""attribute 'container' failed to satisfy constraint: string attribute");
  }
  {
  auto tblgen_output_types = odsAttrs.get("output_types");
  if (!tblgen_output_types) return emitError(loc, "'tf.IteratorV2' op ""requires attribute 'output_types'");
    if (!((((tblgen_output_types.isa<::mlir::ArrayAttr>())) && (::llvm::all_of(tblgen_output_types.cast<::mlir::ArrayAttr>(), [](::mlir::Attribute attr) { return ((attr.isa<::mlir::TypeAttr>())) && ((attr.cast<::mlir::TypeAttr>().getValue().isa<::mlir::Type>())); }))) && ((tblgen_output_types.cast<::mlir::ArrayAttr>().size() >= 1)))) return emitError(loc, "'tf.IteratorV2' op ""attribute 'output_types' failed to satisfy constraint: type array attribute with at least 1 elements");
  }
  {
  auto tblgen_output_shapes = odsAttrs.get("output_shapes");
  if (!tblgen_output_shapes) return emitError(loc, "'tf.IteratorV2' op ""requires attribute 'output_shapes'");
    if (!((((tblgen_output_shapes.isa<::mlir::ArrayAttr>())) && (::llvm::all_of(tblgen_output_shapes.cast<::mlir::ArrayAttr>(), [](::mlir::Attribute attr) { return (attr.isa<mlir::TF::ShapeAttr>()); }))) && ((tblgen_output_shapes.cast<::mlir::ArrayAttr>().size() >= 1)))) return emitError(loc, "'tf.IteratorV2' op ""attribute 'output_shapes' failed to satisfy constraint: tensorflow shape attribute array with at least 1 elements");
  }
  return ::mlir::success();
}

::llvm::StringRef IteratorV2Op::getOperationName() {
  return "tf.IteratorV2";
}

std::pair<unsigned, unsigned> IteratorV2Op::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range IteratorV2Op::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

std::pair<unsigned, unsigned> IteratorV2Op::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range IteratorV2Op::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value IteratorV2Op::handle() {
  return *getODSResults(0).begin();
}

::mlir::StringAttr IteratorV2Op::shared_nameAttr() {
  return this->getAttr("shared_name").cast<::mlir::StringAttr>();
}

::llvm::StringRef IteratorV2Op::shared_name() {
  auto attr = shared_nameAttr();
  return attr.getValue();
}

::mlir::StringAttr IteratorV2Op::containerAttr() {
  return this->getAttr("container").cast<::mlir::StringAttr>();
}

::llvm::StringRef IteratorV2Op::container() {
  auto attr = containerAttr();
  return attr.getValue();
}

::mlir::ArrayAttr IteratorV2Op::output_typesAttr() {
  return this->getAttr("output_types").cast<::mlir::ArrayAttr>();
}

::mlir::ArrayAttr IteratorV2Op::output_types() {
  auto attr = output_typesAttr();
  return attr;
}

::mlir::ArrayAttr IteratorV2Op::output_shapesAttr() {
  return this->getAttr("output_shapes").cast<::mlir::ArrayAttr>();
}

::mlir::ArrayAttr IteratorV2Op::output_shapes() {
  auto attr = output_shapesAttr();
  return attr;
}

void IteratorV2Op::shared_nameAttr(::mlir::StringAttr attr) {
  this->getOperation()->setAttr("shared_name", attr);
}

void IteratorV2Op::containerAttr(::mlir::StringAttr attr) {
  this->getOperation()->setAttr("container", attr);
}

void IteratorV2Op::output_typesAttr(::mlir::ArrayAttr attr) {
  this->getOperation()->setAttr("output_types", attr);
}

void IteratorV2Op::output_shapesAttr(::mlir::ArrayAttr attr) {
  this->getOperation()->setAttr("output_shapes", attr);
}

void IteratorV2Op::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type handle, ::mlir::StringAttr shared_name, ::mlir::StringAttr container, ::mlir::ArrayAttr output_types, ::mlir::ArrayAttr output_shapes) {
  odsState.addAttribute("shared_name", shared_name);
  odsState.addAttribute("container", container);
  odsState.addAttribute("output_types", output_types);
  odsState.addAttribute("output_shapes", output_shapes);
  odsState.addTypes(handle);
}

void IteratorV2Op::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::StringAttr shared_name, ::mlir::StringAttr container, ::mlir::ArrayAttr output_types, ::mlir::ArrayAttr output_shapes) {
  odsState.addAttribute("shared_name", shared_name);
  odsState.addAttribute("container", container);
  odsState.addAttribute("output_types", output_types);
  odsState.addAttribute("output_shapes", output_shapes);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void IteratorV2Op::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type handle, ::llvm::StringRef shared_name, ::llvm::StringRef container, ::mlir::ArrayAttr output_types, ::mlir::ArrayAttr output_shapes) {
  odsState.addAttribute("shared_name", odsBuilder.getStringAttr(shared_name));
  odsState.addAttribute("container", odsBuilder.getStringAttr(container));
  odsState.addAttribute("output_types", output_types);
  odsState.addAttribute("output_shapes", output_shapes);
  odsState.addTypes(handle);
}

void IteratorV2Op::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::llvm::StringRef shared_name, ::llvm::StringRef container, ::mlir::ArrayAttr output_types, ::mlir::ArrayAttr output_shapes) {
  odsState.addAttribute("shared_name", odsBuilder.getStringAttr(shared_name));
  odsState.addAttribute("container", odsBuilder.getStringAttr(container));
  odsState.addAttribute("output_types", output_types);
  odsState.addAttribute("output_shapes", output_shapes);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void IteratorV2Op::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 0u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult IteratorV2Op::verify() {
  if (failed(IteratorV2OpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::ResourceType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::ResourceRefType>()))))) {
        return emitOpError("result #") << index << " must be tensor of resource values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void IteratorV2Op::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
  for (::mlir::Value value : getODSResults(0))
    effects.emplace_back(MemoryEffects::Allocate::get(), value, ::mlir::TF::ResourceEffects::DatasetIterator::get());
}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::L2LossOp definitions
//===----------------------------------------------------------------------===//

L2LossOpAdaptor::L2LossOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

L2LossOpAdaptor::L2LossOpAdaptor(L2LossOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> L2LossOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange L2LossOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value L2LossOpAdaptor::t() {
  return *getODSOperands(0).begin();
}

::mlir::LogicalResult L2LossOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

::llvm::StringRef L2LossOp::getOperationName() {
  return "tf.L2Loss";
}

std::pair<unsigned, unsigned> L2LossOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range L2LossOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value L2LossOp::t() {
  return *getODSOperands(0).begin();
}

::mlir::MutableOperandRange L2LossOp::tMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> L2LossOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range L2LossOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value L2LossOp::output() {
  return *getODSResults(0).begin();
}

Type L2LossOp::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

bool L2LossOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "T") return true;
 return false;
}

::mlir::DictionaryAttr L2LossOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())}
    }, ctx);
}

void L2LossOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value t) {
  odsState.addOperands(t);
  odsState.addTypes(output);
}

void L2LossOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value t) {
  odsState.addOperands(t);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void L2LossOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult L2LossOp::verify() {
  if (failed(L2LossOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of floating-point values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))))) {
        return emitOpError("result #") << index << " must be tensor of floating-point values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void L2LossOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::LRNGradOp definitions
//===----------------------------------------------------------------------===//

LRNGradOpAdaptor::LRNGradOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

LRNGradOpAdaptor::LRNGradOpAdaptor(LRNGradOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> LRNGradOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange LRNGradOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value LRNGradOpAdaptor::input_grads() {
  return *getODSOperands(0).begin();
}

::mlir::Value LRNGradOpAdaptor::input_image() {
  return *getODSOperands(1).begin();
}

::mlir::Value LRNGradOpAdaptor::output_image() {
  return *getODSOperands(2).begin();
}

::mlir::IntegerAttr LRNGradOpAdaptor::depth_radius() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::IntegerAttr attr = odsAttrs.get("depth_radius").dyn_cast_or_null<::mlir::IntegerAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getIntegerAttr(::mlir::Builder(odsAttrs.getContext()).getIntegerType(64), 5);
  return attr;
}

::mlir::FloatAttr LRNGradOpAdaptor::bias() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::FloatAttr attr = odsAttrs.get("bias").dyn_cast_or_null<::mlir::FloatAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getFloatAttr(::mlir::Builder(odsAttrs.getContext()).getF32Type(), 1.0f);
  return attr;
}

::mlir::FloatAttr LRNGradOpAdaptor::alpha() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::FloatAttr attr = odsAttrs.get("alpha").dyn_cast_or_null<::mlir::FloatAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getFloatAttr(::mlir::Builder(odsAttrs.getContext()).getF32Type(), 1.0f);
  return attr;
}

::mlir::FloatAttr LRNGradOpAdaptor::beta() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::FloatAttr attr = odsAttrs.get("beta").dyn_cast_or_null<::mlir::FloatAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getFloatAttr(::mlir::Builder(odsAttrs.getContext()).getF32Type(), 0.5f);
  return attr;
}

::mlir::LogicalResult LRNGradOpAdaptor::verify(::mlir::Location loc) {
  {
  auto tblgen_depth_radius = odsAttrs.get("depth_radius");
  if (tblgen_depth_radius) {
    if (!(((tblgen_depth_radius.isa<::mlir::IntegerAttr>())) && ((tblgen_depth_radius.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(64))))) return emitError(loc, "'tf.LRNGrad' op ""attribute 'depth_radius' failed to satisfy constraint: 64-bit signless integer attribute");
  }
  }
  {
  auto tblgen_bias = odsAttrs.get("bias");
  if (tblgen_bias) {
    if (!(((tblgen_bias.isa<::mlir::FloatAttr>())) && ((tblgen_bias.cast<::mlir::FloatAttr>().getType().isF32())))) return emitError(loc, "'tf.LRNGrad' op ""attribute 'bias' failed to satisfy constraint: 32-bit float attribute");
  }
  }
  {
  auto tblgen_alpha = odsAttrs.get("alpha");
  if (tblgen_alpha) {
    if (!(((tblgen_alpha.isa<::mlir::FloatAttr>())) && ((tblgen_alpha.cast<::mlir::FloatAttr>().getType().isF32())))) return emitError(loc, "'tf.LRNGrad' op ""attribute 'alpha' failed to satisfy constraint: 32-bit float attribute");
  }
  }
  {
  auto tblgen_beta = odsAttrs.get("beta");
  if (tblgen_beta) {
    if (!(((tblgen_beta.isa<::mlir::FloatAttr>())) && ((tblgen_beta.cast<::mlir::FloatAttr>().getType().isF32())))) return emitError(loc, "'tf.LRNGrad' op ""attribute 'beta' failed to satisfy constraint: 32-bit float attribute");
  }
  }
  return ::mlir::success();
}

::llvm::StringRef LRNGradOp::getOperationName() {
  return "tf.LRNGrad";
}

std::pair<unsigned, unsigned> LRNGradOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range LRNGradOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value LRNGradOp::input_grads() {
  return *getODSOperands(0).begin();
}

::mlir::Value LRNGradOp::input_image() {
  return *getODSOperands(1).begin();
}

::mlir::Value LRNGradOp::output_image() {
  return *getODSOperands(2).begin();
}

::mlir::MutableOperandRange LRNGradOp::input_gradsMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange LRNGradOp::input_imageMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange LRNGradOp::output_imageMutable() {
  auto range = getODSOperandIndexAndLength(2);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> LRNGradOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range LRNGradOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value LRNGradOp::output() {
  return *getODSResults(0).begin();
}

::mlir::IntegerAttr LRNGradOp::depth_radiusAttr() {
  return this->getAttr("depth_radius").dyn_cast_or_null<::mlir::IntegerAttr>();
}

uint64_t LRNGradOp::depth_radius() {
  auto attr = depth_radiusAttr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getIntegerAttr(::mlir::Builder(this->getContext()).getIntegerType(64), 5).getValue().getZExtValue();
  return attr.getValue().getZExtValue();
}

::mlir::FloatAttr LRNGradOp::biasAttr() {
  return this->getAttr("bias").dyn_cast_or_null<::mlir::FloatAttr>();
}

::llvm::APFloat LRNGradOp::bias() {
  auto attr = biasAttr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getFloatAttr(::mlir::Builder(this->getContext()).getF32Type(), 1.0f).getValue();
  return attr.getValue();
}

::mlir::FloatAttr LRNGradOp::alphaAttr() {
  return this->getAttr("alpha").dyn_cast_or_null<::mlir::FloatAttr>();
}

::llvm::APFloat LRNGradOp::alpha() {
  auto attr = alphaAttr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getFloatAttr(::mlir::Builder(this->getContext()).getF32Type(), 1.0f).getValue();
  return attr.getValue();
}

::mlir::FloatAttr LRNGradOp::betaAttr() {
  return this->getAttr("beta").dyn_cast_or_null<::mlir::FloatAttr>();
}

::llvm::APFloat LRNGradOp::beta() {
  auto attr = betaAttr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getFloatAttr(::mlir::Builder(this->getContext()).getF32Type(), 0.5f).getValue();
  return attr.getValue();
}

Type LRNGradOp::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

bool LRNGradOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "T") return true;
 return false;
}

::mlir::DictionaryAttr LRNGradOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())}
    }, ctx);
}

void LRNGradOp::depth_radiusAttr(::mlir::IntegerAttr attr) {
  this->getOperation()->setAttr("depth_radius", attr);
}

void LRNGradOp::biasAttr(::mlir::FloatAttr attr) {
  this->getOperation()->setAttr("bias", attr);
}

void LRNGradOp::alphaAttr(::mlir::FloatAttr attr) {
  this->getOperation()->setAttr("alpha", attr);
}

void LRNGradOp::betaAttr(::mlir::FloatAttr attr) {
  this->getOperation()->setAttr("beta", attr);
}

void LRNGradOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value input_grads, ::mlir::Value input_image, ::mlir::Value output_image, ::mlir::IntegerAttr depth_radius, ::mlir::FloatAttr bias, ::mlir::FloatAttr alpha, ::mlir::FloatAttr beta) {
  odsState.addOperands(input_grads);
  odsState.addOperands(input_image);
  odsState.addOperands(output_image);
  odsState.addAttribute("depth_radius", depth_radius);
  odsState.addAttribute("bias", bias);
  odsState.addAttribute("alpha", alpha);
  odsState.addAttribute("beta", beta);
  odsState.addTypes(output);
}

void LRNGradOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input_grads, ::mlir::Value input_image, ::mlir::Value output_image, ::mlir::IntegerAttr depth_radius, ::mlir::FloatAttr bias, ::mlir::FloatAttr alpha, ::mlir::FloatAttr beta) {
  odsState.addOperands(input_grads);
  odsState.addOperands(input_image);
  odsState.addOperands(output_image);
  odsState.addAttribute("depth_radius", depth_radius);
  odsState.addAttribute("bias", bias);
  odsState.addAttribute("alpha", alpha);
  odsState.addAttribute("beta", beta);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void LRNGradOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value input_grads, ::mlir::Value input_image, ::mlir::Value output_image, uint64_t depth_radius, ::llvm::APFloat bias, ::llvm::APFloat alpha, ::llvm::APFloat beta) {
  odsState.addOperands(input_grads);
  odsState.addOperands(input_image);
  odsState.addOperands(output_image);
  odsState.addAttribute("depth_radius", odsBuilder.getIntegerAttr(odsBuilder.getIntegerType(64), depth_radius));
  odsState.addAttribute("bias", odsBuilder.getFloatAttr(odsBuilder.getF32Type(), bias));
  odsState.addAttribute("alpha", odsBuilder.getFloatAttr(odsBuilder.getF32Type(), alpha));
  odsState.addAttribute("beta", odsBuilder.getFloatAttr(odsBuilder.getF32Type(), beta));
  odsState.addTypes(output);
}

void LRNGradOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input_grads, ::mlir::Value input_image, ::mlir::Value output_image, uint64_t depth_radius, ::llvm::APFloat bias, ::llvm::APFloat alpha, ::llvm::APFloat beta) {
  odsState.addOperands(input_grads);
  odsState.addOperands(input_image);
  odsState.addOperands(output_image);
  odsState.addAttribute("depth_radius", odsBuilder.getIntegerAttr(odsBuilder.getIntegerType(64), depth_radius));
  odsState.addAttribute("bias", odsBuilder.getFloatAttr(odsBuilder.getF32Type(), bias));
  odsState.addAttribute("alpha", odsBuilder.getFloatAttr(odsBuilder.getF32Type(), alpha));
  odsState.addAttribute("beta", odsBuilder.getFloatAttr(odsBuilder.getF32Type(), beta));
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void LRNGradOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 3u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult LRNGradOp::verify() {
  if (failed(LRNGradOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of bfloat16 or 16-bit float or 32-bit float values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of bfloat16 or 16-bit float or 32-bit float values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup2 = getODSOperands(2);
    for (::mlir::Value v : valueGroup2) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of bfloat16 or 16-bit float or 32-bit float values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())))))) {
        return emitOpError("result #") << index << " must be tensor of bfloat16 or 16-bit float or 32-bit float values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void LRNGradOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::LRNOp definitions
//===----------------------------------------------------------------------===//

LRNOpAdaptor::LRNOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

LRNOpAdaptor::LRNOpAdaptor(LRNOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> LRNOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange LRNOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value LRNOpAdaptor::input() {
  return *getODSOperands(0).begin();
}

::mlir::IntegerAttr LRNOpAdaptor::depth_radius() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::IntegerAttr attr = odsAttrs.get("depth_radius").dyn_cast_or_null<::mlir::IntegerAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getIntegerAttr(::mlir::Builder(odsAttrs.getContext()).getIntegerType(64), 5);
  return attr;
}

::mlir::FloatAttr LRNOpAdaptor::bias() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::FloatAttr attr = odsAttrs.get("bias").dyn_cast_or_null<::mlir::FloatAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getFloatAttr(::mlir::Builder(odsAttrs.getContext()).getF32Type(), 1.0f);
  return attr;
}

::mlir::FloatAttr LRNOpAdaptor::alpha() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::FloatAttr attr = odsAttrs.get("alpha").dyn_cast_or_null<::mlir::FloatAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getFloatAttr(::mlir::Builder(odsAttrs.getContext()).getF32Type(), 1.0f);
  return attr;
}

::mlir::FloatAttr LRNOpAdaptor::beta() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::FloatAttr attr = odsAttrs.get("beta").dyn_cast_or_null<::mlir::FloatAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getFloatAttr(::mlir::Builder(odsAttrs.getContext()).getF32Type(), 0.5f);
  return attr;
}

::mlir::LogicalResult LRNOpAdaptor::verify(::mlir::Location loc) {
  {
  auto tblgen_depth_radius = odsAttrs.get("depth_radius");
  if (tblgen_depth_radius) {
    if (!(((tblgen_depth_radius.isa<::mlir::IntegerAttr>())) && ((tblgen_depth_radius.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(64))))) return emitError(loc, "'tf.LRN' op ""attribute 'depth_radius' failed to satisfy constraint: 64-bit signless integer attribute");
  }
  }
  {
  auto tblgen_bias = odsAttrs.get("bias");
  if (tblgen_bias) {
    if (!(((tblgen_bias.isa<::mlir::FloatAttr>())) && ((tblgen_bias.cast<::mlir::FloatAttr>().getType().isF32())))) return emitError(loc, "'tf.LRN' op ""attribute 'bias' failed to satisfy constraint: 32-bit float attribute");
  }
  }
  {
  auto tblgen_alpha = odsAttrs.get("alpha");
  if (tblgen_alpha) {
    if (!(((tblgen_alpha.isa<::mlir::FloatAttr>())) && ((tblgen_alpha.cast<::mlir::FloatAttr>().getType().isF32())))) return emitError(loc, "'tf.LRN' op ""attribute 'alpha' failed to satisfy constraint: 32-bit float attribute");
  }
  }
  {
  auto tblgen_beta = odsAttrs.get("beta");
  if (tblgen_beta) {
    if (!(((tblgen_beta.isa<::mlir::FloatAttr>())) && ((tblgen_beta.cast<::mlir::FloatAttr>().getType().isF32())))) return emitError(loc, "'tf.LRN' op ""attribute 'beta' failed to satisfy constraint: 32-bit float attribute");
  }
  }
  return ::mlir::success();
}

::llvm::StringRef LRNOp::getOperationName() {
  return "tf.LRN";
}

std::pair<unsigned, unsigned> LRNOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range LRNOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value LRNOp::input() {
  return *getODSOperands(0).begin();
}

::mlir::MutableOperandRange LRNOp::inputMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> LRNOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range LRNOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value LRNOp::output() {
  return *getODSResults(0).begin();
}

::mlir::IntegerAttr LRNOp::depth_radiusAttr() {
  return this->getAttr("depth_radius").dyn_cast_or_null<::mlir::IntegerAttr>();
}

uint64_t LRNOp::depth_radius() {
  auto attr = depth_radiusAttr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getIntegerAttr(::mlir::Builder(this->getContext()).getIntegerType(64), 5).getValue().getZExtValue();
  return attr.getValue().getZExtValue();
}

::mlir::FloatAttr LRNOp::biasAttr() {
  return this->getAttr("bias").dyn_cast_or_null<::mlir::FloatAttr>();
}

::llvm::APFloat LRNOp::bias() {
  auto attr = biasAttr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getFloatAttr(::mlir::Builder(this->getContext()).getF32Type(), 1.0f).getValue();
  return attr.getValue();
}

::mlir::FloatAttr LRNOp::alphaAttr() {
  return this->getAttr("alpha").dyn_cast_or_null<::mlir::FloatAttr>();
}

::llvm::APFloat LRNOp::alpha() {
  auto attr = alphaAttr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getFloatAttr(::mlir::Builder(this->getContext()).getF32Type(), 1.0f).getValue();
  return attr.getValue();
}

::mlir::FloatAttr LRNOp::betaAttr() {
  return this->getAttr("beta").dyn_cast_or_null<::mlir::FloatAttr>();
}

::llvm::APFloat LRNOp::beta() {
  auto attr = betaAttr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getFloatAttr(::mlir::Builder(this->getContext()).getF32Type(), 0.5f).getValue();
  return attr.getValue();
}

Type LRNOp::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

bool LRNOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "T") return true;
 return false;
}

::mlir::DictionaryAttr LRNOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())}
    }, ctx);
}

void LRNOp::depth_radiusAttr(::mlir::IntegerAttr attr) {
  this->getOperation()->setAttr("depth_radius", attr);
}

void LRNOp::biasAttr(::mlir::FloatAttr attr) {
  this->getOperation()->setAttr("bias", attr);
}

void LRNOp::alphaAttr(::mlir::FloatAttr attr) {
  this->getOperation()->setAttr("alpha", attr);
}

void LRNOp::betaAttr(::mlir::FloatAttr attr) {
  this->getOperation()->setAttr("beta", attr);
}

void LRNOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value input, ::mlir::IntegerAttr depth_radius, ::mlir::FloatAttr bias, ::mlir::FloatAttr alpha, ::mlir::FloatAttr beta) {
  odsState.addOperands(input);
  odsState.addAttribute("depth_radius", depth_radius);
  odsState.addAttribute("bias", bias);
  odsState.addAttribute("alpha", alpha);
  odsState.addAttribute("beta", beta);
  odsState.addTypes(output);
}

void LRNOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input, ::mlir::IntegerAttr depth_radius, ::mlir::FloatAttr bias, ::mlir::FloatAttr alpha, ::mlir::FloatAttr beta) {
  odsState.addOperands(input);
  odsState.addAttribute("depth_radius", depth_radius);
  odsState.addAttribute("bias", bias);
  odsState.addAttribute("alpha", alpha);
  odsState.addAttribute("beta", beta);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void LRNOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value input, uint64_t depth_radius, ::llvm::APFloat bias, ::llvm::APFloat alpha, ::llvm::APFloat beta) {
  odsState.addOperands(input);
  odsState.addAttribute("depth_radius", odsBuilder.getIntegerAttr(odsBuilder.getIntegerType(64), depth_radius));
  odsState.addAttribute("bias", odsBuilder.getFloatAttr(odsBuilder.getF32Type(), bias));
  odsState.addAttribute("alpha", odsBuilder.getFloatAttr(odsBuilder.getF32Type(), alpha));
  odsState.addAttribute("beta", odsBuilder.getFloatAttr(odsBuilder.getF32Type(), beta));
  odsState.addTypes(output);
}

void LRNOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input, uint64_t depth_radius, ::llvm::APFloat bias, ::llvm::APFloat alpha, ::llvm::APFloat beta) {
  odsState.addOperands(input);
  odsState.addAttribute("depth_radius", odsBuilder.getIntegerAttr(odsBuilder.getIntegerType(64), depth_radius));
  odsState.addAttribute("bias", odsBuilder.getFloatAttr(odsBuilder.getF32Type(), bias));
  odsState.addAttribute("alpha", odsBuilder.getFloatAttr(odsBuilder.getF32Type(), alpha));
  odsState.addAttribute("beta", odsBuilder.getFloatAttr(odsBuilder.getF32Type(), beta));
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void LRNOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult LRNOp::verify() {
  if (failed(LRNOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of bfloat16 or 16-bit float or 32-bit float values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())))))) {
        return emitOpError("result #") << index << " must be tensor of bfloat16 or 16-bit float or 32-bit float values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void LRNOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::LeakyReluGradOp definitions
//===----------------------------------------------------------------------===//

LeakyReluGradOpAdaptor::LeakyReluGradOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

LeakyReluGradOpAdaptor::LeakyReluGradOpAdaptor(LeakyReluGradOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> LeakyReluGradOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange LeakyReluGradOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value LeakyReluGradOpAdaptor::gradients() {
  return *getODSOperands(0).begin();
}

::mlir::Value LeakyReluGradOpAdaptor::features() {
  return *getODSOperands(1).begin();
}

::mlir::FloatAttr LeakyReluGradOpAdaptor::alpha() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::FloatAttr attr = odsAttrs.get("alpha").dyn_cast_or_null<::mlir::FloatAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getFloatAttr(::mlir::Builder(odsAttrs.getContext()).getF32Type(), 0.2f);
  return attr;
}

::mlir::LogicalResult LeakyReluGradOpAdaptor::verify(::mlir::Location loc) {
  {
  auto tblgen_alpha = odsAttrs.get("alpha");
  if (tblgen_alpha) {
    if (!(((tblgen_alpha.isa<::mlir::FloatAttr>())) && ((tblgen_alpha.cast<::mlir::FloatAttr>().getType().isF32())))) return emitError(loc, "'tf.LeakyReluGrad' op ""attribute 'alpha' failed to satisfy constraint: 32-bit float attribute");
  }
  }
  return ::mlir::success();
}

::llvm::StringRef LeakyReluGradOp::getOperationName() {
  return "tf.LeakyReluGrad";
}

std::pair<unsigned, unsigned> LeakyReluGradOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range LeakyReluGradOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value LeakyReluGradOp::gradients() {
  return *getODSOperands(0).begin();
}

::mlir::Value LeakyReluGradOp::features() {
  return *getODSOperands(1).begin();
}

::mlir::MutableOperandRange LeakyReluGradOp::gradientsMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange LeakyReluGradOp::featuresMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> LeakyReluGradOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range LeakyReluGradOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value LeakyReluGradOp::backprops() {
  return *getODSResults(0).begin();
}

::mlir::FloatAttr LeakyReluGradOp::alphaAttr() {
  return this->getAttr("alpha").dyn_cast_or_null<::mlir::FloatAttr>();
}

::llvm::APFloat LeakyReluGradOp::alpha() {
  auto attr = alphaAttr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getFloatAttr(::mlir::Builder(this->getContext()).getF32Type(), 0.2f).getValue();
  return attr.getValue();
}

Type LeakyReluGradOp::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

bool LeakyReluGradOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "T") return true;
 return false;
}

::mlir::DictionaryAttr LeakyReluGradOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())}
    }, ctx);
}

void LeakyReluGradOp::alphaAttr(::mlir::FloatAttr attr) {
  this->getOperation()->setAttr("alpha", attr);
}

void LeakyReluGradOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type backprops, ::mlir::Value gradients, ::mlir::Value features, ::mlir::FloatAttr alpha) {
  odsState.addOperands(gradients);
  odsState.addOperands(features);
  odsState.addAttribute("alpha", alpha);
  odsState.addTypes(backprops);
}

void LeakyReluGradOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value gradients, ::mlir::Value features, ::mlir::FloatAttr alpha) {
  odsState.addOperands(gradients);
  odsState.addOperands(features);
  odsState.addAttribute("alpha", alpha);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void LeakyReluGradOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type backprops, ::mlir::Value gradients, ::mlir::Value features, ::llvm::APFloat alpha) {
  odsState.addOperands(gradients);
  odsState.addOperands(features);
  odsState.addAttribute("alpha", odsBuilder.getFloatAttr(odsBuilder.getF32Type(), alpha));
  odsState.addTypes(backprops);
}

void LeakyReluGradOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value gradients, ::mlir::Value features, ::llvm::APFloat alpha) {
  odsState.addOperands(gradients);
  odsState.addOperands(features);
  odsState.addAttribute("alpha", odsBuilder.getFloatAttr(odsBuilder.getF32Type(), alpha));
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void LeakyReluGradOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

void LeakyReluGradOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value gradients, ::mlir::Value features, ::mlir::FloatAttr alpha) {
  odsState.addOperands(gradients);
  odsState.addOperands(features);
  odsState.addAttribute("alpha", alpha);
  odsState.addTypes({gradients.getType()});

}

void LeakyReluGradOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  odsState.addTypes({operands[0].getType()});

}

::mlir::LogicalResult LeakyReluGradOp::verify() {
  if (failed(LeakyReluGradOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of floating-point values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of floating-point values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))))) {
        return emitOpError("result #") << index << " must be tensor of floating-point values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void LeakyReluGradOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::LeakyReluOp definitions
//===----------------------------------------------------------------------===//

LeakyReluOpAdaptor::LeakyReluOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

LeakyReluOpAdaptor::LeakyReluOpAdaptor(LeakyReluOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> LeakyReluOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange LeakyReluOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value LeakyReluOpAdaptor::features() {
  return *getODSOperands(0).begin();
}

::mlir::FloatAttr LeakyReluOpAdaptor::alpha() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::FloatAttr attr = odsAttrs.get("alpha").dyn_cast_or_null<::mlir::FloatAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getFloatAttr(::mlir::Builder(odsAttrs.getContext()).getF32Type(), 0.2f);
  return attr;
}

::mlir::LogicalResult LeakyReluOpAdaptor::verify(::mlir::Location loc) {
  {
  auto tblgen_alpha = odsAttrs.get("alpha");
  if (tblgen_alpha) {
    if (!(((tblgen_alpha.isa<::mlir::FloatAttr>())) && ((tblgen_alpha.cast<::mlir::FloatAttr>().getType().isF32())))) return emitError(loc, "'tf.LeakyRelu' op ""attribute 'alpha' failed to satisfy constraint: 32-bit float attribute");
  }
  }
  return ::mlir::success();
}

::llvm::StringRef LeakyReluOp::getOperationName() {
  return "tf.LeakyRelu";
}

std::pair<unsigned, unsigned> LeakyReluOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range LeakyReluOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value LeakyReluOp::features() {
  return *getODSOperands(0).begin();
}

::mlir::MutableOperandRange LeakyReluOp::featuresMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> LeakyReluOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range LeakyReluOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value LeakyReluOp::activations() {
  return *getODSResults(0).begin();
}

::mlir::FloatAttr LeakyReluOp::alphaAttr() {
  return this->getAttr("alpha").dyn_cast_or_null<::mlir::FloatAttr>();
}

::llvm::APFloat LeakyReluOp::alpha() {
  auto attr = alphaAttr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getFloatAttr(::mlir::Builder(this->getContext()).getF32Type(), 0.2f).getValue();
  return attr.getValue();
}

Type LeakyReluOp::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

bool LeakyReluOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "T") return true;
 return false;
}

::mlir::DictionaryAttr LeakyReluOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())}
    }, ctx);
}

void LeakyReluOp::alphaAttr(::mlir::FloatAttr attr) {
  this->getOperation()->setAttr("alpha", attr);
}

void LeakyReluOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type activations, ::mlir::Value features, ::mlir::FloatAttr alpha) {
  odsState.addOperands(features);
  odsState.addAttribute("alpha", alpha);
  odsState.addTypes(activations);
}

void LeakyReluOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value features, ::mlir::FloatAttr alpha) {
  odsState.addOperands(features);
  odsState.addAttribute("alpha", alpha);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void LeakyReluOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type activations, ::mlir::Value features, ::llvm::APFloat alpha) {
  odsState.addOperands(features);
  odsState.addAttribute("alpha", odsBuilder.getFloatAttr(odsBuilder.getF32Type(), alpha));
  odsState.addTypes(activations);
}

void LeakyReluOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value features, ::llvm::APFloat alpha) {
  odsState.addOperands(features);
  odsState.addAttribute("alpha", odsBuilder.getFloatAttr(odsBuilder.getF32Type(), alpha));
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void LeakyReluOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

void LeakyReluOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value features, ::mlir::FloatAttr alpha) {
  odsState.addOperands(features);
  odsState.addAttribute("alpha", alpha);
  odsState.addTypes({features.getType()});

}

void LeakyReluOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  odsState.addTypes({operands[0].getType()});

}

::mlir::LogicalResult LeakyReluOp::verify() {
  if (failed(LeakyReluOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of floating-point values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))))) {
        return emitOpError("result #") << index << " must be tensor of floating-point values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}



void LeakyReluOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::LeftShiftOp definitions
//===----------------------------------------------------------------------===//

LeftShiftOpAdaptor::LeftShiftOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

LeftShiftOpAdaptor::LeftShiftOpAdaptor(LeftShiftOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> LeftShiftOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange LeftShiftOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value LeftShiftOpAdaptor::x() {
  return *getODSOperands(0).begin();
}

::mlir::Value LeftShiftOpAdaptor::y() {
  return *getODSOperands(1).begin();
}

::mlir::LogicalResult LeftShiftOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

::llvm::StringRef LeftShiftOp::getOperationName() {
  return "tf.LeftShift";
}

std::pair<unsigned, unsigned> LeftShiftOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range LeftShiftOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value LeftShiftOp::x() {
  return *getODSOperands(0).begin();
}

::mlir::Value LeftShiftOp::y() {
  return *getODSOperands(1).begin();
}

::mlir::MutableOperandRange LeftShiftOp::xMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange LeftShiftOp::yMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> LeftShiftOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range LeftShiftOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value LeftShiftOp::z() {
  return *getODSResults(0).begin();
}

Type LeftShiftOp::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

bool LeftShiftOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "T") return true;
 return false;
}

::mlir::DictionaryAttr LeftShiftOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())}
    }, ctx);
}

void LeftShiftOp::build(OpBuilder &builder, OperationState &result, Value  x, Value  y) {
  auto resultType =
      OpTrait::util::getBroadcastedType(x.getType(), y.getType());
  if (!resultType)
    mlir::emitError(result.location, "non-broadcastable operands");
  return build(builder, result, resultType, x, y);
}

void LeftShiftOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type z, ::mlir::Value x, ::mlir::Value y) {
  odsState.addOperands(x);
  odsState.addOperands(y);
  odsState.addTypes(z);
}

void LeftShiftOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value x, ::mlir::Value y) {
  odsState.addOperands(x);
  odsState.addOperands(y);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void LeftShiftOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult LeftShiftOp::verify() {
  if (failed(LeftShiftOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))))) {
        return emitOpError("operand #") << index << " must be tensor of integer values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))))) {
        return emitOpError("operand #") << index << " must be tensor of integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))))) {
        return emitOpError("result #") << index << " must be tensor of integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void LeftShiftOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::LegacyCallOp definitions
//===----------------------------------------------------------------------===//

LegacyCallOpAdaptor::LegacyCallOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

LegacyCallOpAdaptor::LegacyCallOpAdaptor(LegacyCallOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> LegacyCallOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  bool isVariadic[] = {true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (odsOperands.size() - 0) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::mlir::ValueRange LegacyCallOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::ValueRange LegacyCallOpAdaptor::args() {
  return getODSOperands(0);
}

::mlir::FlatSymbolRefAttr LegacyCallOpAdaptor::f() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::FlatSymbolRefAttr attr = odsAttrs.get("f").cast<::mlir::FlatSymbolRefAttr>();
  return attr;
}

::mlir::BoolAttr LegacyCallOpAdaptor::_disable_call_shape_inference() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::BoolAttr attr = odsAttrs.get("_disable_call_shape_inference").dyn_cast_or_null<::mlir::BoolAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getBoolAttr(false);
  return attr;
}

::mlir::LogicalResult LegacyCallOpAdaptor::verify(::mlir::Location loc) {
  {
  auto tblgen_f = odsAttrs.get("f");
  if (!tblgen_f) return emitError(loc, "'tf.LegacyCall' op ""requires attribute 'f'");
    if (!((tblgen_f.isa<::mlir::FlatSymbolRefAttr>()))) return emitError(loc, "'tf.LegacyCall' op ""attribute 'f' failed to satisfy constraint: flat symbol reference attribute");
  }
  {
  auto tblgen__disable_call_shape_inference = odsAttrs.get("_disable_call_shape_inference");
  if (tblgen__disable_call_shape_inference) {
    if (!((tblgen__disable_call_shape_inference.isa<::mlir::BoolAttr>()))) return emitError(loc, "'tf.LegacyCall' op ""attribute '_disable_call_shape_inference' failed to satisfy constraint: bool attribute");
  }
  }
  return ::mlir::success();
}

::llvm::StringRef LegacyCallOp::getOperationName() {
  return "tf.LegacyCall";
}

std::pair<unsigned, unsigned> LegacyCallOp::getODSOperandIndexAndLength(unsigned index) {
  bool isVariadic[] = {true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (getOperation()->getNumOperands() - 0) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::mlir::Operation::operand_range LegacyCallOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Operation::operand_range LegacyCallOp::args() {
  return getODSOperands(0);
}

::mlir::MutableOperandRange LegacyCallOp::argsMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> LegacyCallOp::getODSResultIndexAndLength(unsigned index) {
  bool isVariadic[] = {true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (getOperation()->getNumResults() - 0) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::mlir::Operation::result_range LegacyCallOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Operation::result_range LegacyCallOp::output() {
  return getODSResults(0);
}

::mlir::FlatSymbolRefAttr LegacyCallOp::fAttr() {
  return this->getAttr("f").cast<::mlir::FlatSymbolRefAttr>();
}

::llvm::StringRef LegacyCallOp::f() {
  auto attr = fAttr();
  return attr.getValue();
}

::mlir::BoolAttr LegacyCallOp::_disable_call_shape_inferenceAttr() {
  return this->getAttr("_disable_call_shape_inference").dyn_cast_or_null<::mlir::BoolAttr>();
}

bool LegacyCallOp::_disable_call_shape_inference() {
  auto attr = _disable_call_shape_inferenceAttr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getBoolAttr(false).getValue();
  return attr.getValue();
}

void LegacyCallOp::fAttr(::mlir::FlatSymbolRefAttr attr) {
  this->getOperation()->setAttr("f", attr);
}

void LegacyCallOp::_disable_call_shape_inferenceAttr(::mlir::BoolAttr attr) {
  this->getOperation()->setAttr("_disable_call_shape_inference", attr);
}

void LegacyCallOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange output, ::mlir::ValueRange args, ::mlir::FlatSymbolRefAttr f, ::mlir::BoolAttr _disable_call_shape_inference) {
  odsState.addOperands(args);
  odsState.addAttribute("f", f);
  odsState.addAttribute("_disable_call_shape_inference", _disable_call_shape_inference);
  odsState.addTypes(output);
}

void LegacyCallOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange output, ::mlir::ValueRange args, ::llvm::StringRef f, bool _disable_call_shape_inference) {
  odsState.addOperands(args);
  odsState.addAttribute("f", odsBuilder.getSymbolRefAttr(f));
  odsState.addAttribute("_disable_call_shape_inference", odsBuilder.getBoolAttr(_disable_call_shape_inference));
  odsState.addTypes(output);
}

void LegacyCallOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult LegacyCallOp::verify() {
  if (failed(LegacyCallOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>())))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::TensorFlowType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of tf.dtype values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>())))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::TensorFlowType>()))))) {
        return emitOpError("result #") << index << " must be tensor of tf.dtype values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void LegacyCallOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::LessEqualOp definitions
//===----------------------------------------------------------------------===//

LessEqualOpAdaptor::LessEqualOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

LessEqualOpAdaptor::LessEqualOpAdaptor(LessEqualOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> LessEqualOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange LessEqualOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value LessEqualOpAdaptor::x() {
  return *getODSOperands(0).begin();
}

::mlir::Value LessEqualOpAdaptor::y() {
  return *getODSOperands(1).begin();
}

::mlir::LogicalResult LessEqualOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

::llvm::StringRef LessEqualOp::getOperationName() {
  return "tf.LessEqual";
}

std::pair<unsigned, unsigned> LessEqualOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range LessEqualOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value LessEqualOp::x() {
  return *getODSOperands(0).begin();
}

::mlir::Value LessEqualOp::y() {
  return *getODSOperands(1).begin();
}

::mlir::MutableOperandRange LessEqualOp::xMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange LessEqualOp::yMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> LessEqualOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range LessEqualOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value LessEqualOp::z() {
  return *getODSResults(0).begin();
}

Type LessEqualOp::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

bool LessEqualOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "T") return true;
 return false;
}

::mlir::DictionaryAttr LessEqualOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())}
    }, ctx);
}

void LessEqualOp::build(OpBuilder &builder, OperationState &result, Value  x, Value  y) {
  Type resultType;
  if (x.getType().isa<UnrankedTensorType>() ||
      y.getType().isa<UnrankedTensorType>()) {
    resultType = UnrankedTensorType::get(builder.getI1Type());
  } else {
    SmallVector<int64_t, 4> resultShape;
    if (!OpTrait::util::getBroadcastedShape(
            x.getType().cast<ShapedType>().getShape(),
            y.getType().cast<ShapedType>().getShape(), resultShape)) {
      mlir::emitError(result.location,
                      "operands have no broadcastable shapes");
    }

    resultType = RankedTensorType::get(resultShape, builder.getI1Type());
  }
  return build(builder, result, resultType, x, y);
}

void LessEqualOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type z, ::mlir::Value x, ::mlir::Value y) {
  odsState.addOperands(x);
  odsState.addOperands(y);
  odsState.addTypes(z);
}

void LessEqualOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value x, ::mlir::Value y) {
  odsState.addOperands(x);
  odsState.addOperands(y);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void LessEqualOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult LessEqualOp::verify() {
  if (failed(LessEqualOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of integer or floating-point values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of integer or floating-point values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))))) {
        return emitOpError("result #") << index << " must be tensor of bool values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void LessEqualOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::LessOp definitions
//===----------------------------------------------------------------------===//

LessOpAdaptor::LessOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

LessOpAdaptor::LessOpAdaptor(LessOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> LessOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange LessOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value LessOpAdaptor::x() {
  return *getODSOperands(0).begin();
}

::mlir::Value LessOpAdaptor::y() {
  return *getODSOperands(1).begin();
}

::mlir::LogicalResult LessOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

::llvm::StringRef LessOp::getOperationName() {
  return "tf.Less";
}

std::pair<unsigned, unsigned> LessOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range LessOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value LessOp::x() {
  return *getODSOperands(0).begin();
}

::mlir::Value LessOp::y() {
  return *getODSOperands(1).begin();
}

::mlir::MutableOperandRange LessOp::xMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange LessOp::yMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> LessOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range LessOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value LessOp::z() {
  return *getODSResults(0).begin();
}

Type LessOp::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

bool LessOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "T") return true;
 return false;
}

::mlir::DictionaryAttr LessOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())}
    }, ctx);
}

void LessOp::build(OpBuilder &builder, OperationState &result, Value  x, Value  y) {
  Type resultType;
  if (x.getType().isa<UnrankedTensorType>() ||
      y.getType().isa<UnrankedTensorType>()) {
    resultType = UnrankedTensorType::get(builder.getI1Type());
  } else {
    SmallVector<int64_t, 4> resultShape;
    if (!OpTrait::util::getBroadcastedShape(
            x.getType().cast<ShapedType>().getShape(),
            y.getType().cast<ShapedType>().getShape(), resultShape)) {
      mlir::emitError(result.location,
                      "operands have no broadcastable shapes");
    }

    resultType = RankedTensorType::get(resultShape, builder.getI1Type());
  }
  return build(builder, result, resultType, x, y);
}

void LessOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type z, ::mlir::Value x, ::mlir::Value y) {
  odsState.addOperands(x);
  odsState.addOperands(y);
  odsState.addTypes(z);
}

void LessOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value x, ::mlir::Value y) {
  odsState.addOperands(x);
  odsState.addOperands(y);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void LessOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult LessOp::verify() {
  if (failed(LessOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of integer or floating-point values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of integer or floating-point values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))))) {
        return emitOpError("result #") << index << " must be tensor of bool values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void LessOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::LgammaOp definitions
//===----------------------------------------------------------------------===//

LgammaOpAdaptor::LgammaOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

LgammaOpAdaptor::LgammaOpAdaptor(LgammaOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> LgammaOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange LgammaOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value LgammaOpAdaptor::x() {
  return *getODSOperands(0).begin();
}

::mlir::LogicalResult LgammaOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

::llvm::StringRef LgammaOp::getOperationName() {
  return "tf.Lgamma";
}

std::pair<unsigned, unsigned> LgammaOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range LgammaOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value LgammaOp::x() {
  return *getODSOperands(0).begin();
}

::mlir::MutableOperandRange LgammaOp::xMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> LgammaOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range LgammaOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value LgammaOp::y() {
  return *getODSResults(0).begin();
}

Type LgammaOp::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

bool LgammaOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "T") return true;
 return false;
}

::mlir::DictionaryAttr LgammaOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())}
    }, ctx);
}

void LgammaOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type y, ::mlir::Value x) {
  odsState.addOperands(x);
  odsState.addTypes(y);
}

void LgammaOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value x) {
  odsState.addOperands(x);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void LgammaOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

void LgammaOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value x) {
  odsState.addOperands(x);
  odsState.addTypes({x.getType()});

}

void LgammaOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  odsState.addTypes({operands[0].getType()});

}

::mlir::LogicalResult LgammaOp::verify() {
  if (failed(LgammaOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of floating-point values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))))) {
        return emitOpError("result #") << index << " must be tensor of floating-point values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void LgammaOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::LinSpaceOp definitions
//===----------------------------------------------------------------------===//

LinSpaceOpAdaptor::LinSpaceOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

LinSpaceOpAdaptor::LinSpaceOpAdaptor(LinSpaceOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> LinSpaceOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange LinSpaceOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value LinSpaceOpAdaptor::start() {
  return *getODSOperands(0).begin();
}

::mlir::Value LinSpaceOpAdaptor::stop() {
  return *getODSOperands(1).begin();
}

::mlir::Value LinSpaceOpAdaptor::num() {
  return *getODSOperands(2).begin();
}

::mlir::LogicalResult LinSpaceOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

::llvm::StringRef LinSpaceOp::getOperationName() {
  return "tf.LinSpace";
}

std::pair<unsigned, unsigned> LinSpaceOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range LinSpaceOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value LinSpaceOp::start() {
  return *getODSOperands(0).begin();
}

::mlir::Value LinSpaceOp::stop() {
  return *getODSOperands(1).begin();
}

::mlir::Value LinSpaceOp::num() {
  return *getODSOperands(2).begin();
}

::mlir::MutableOperandRange LinSpaceOp::startMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange LinSpaceOp::stopMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange LinSpaceOp::numMutable() {
  auto range = getODSOperandIndexAndLength(2);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> LinSpaceOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range LinSpaceOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value LinSpaceOp::output() {
  return *getODSResults(0).begin();
}

Type LinSpaceOp::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

Type LinSpaceOp::Tidx() {
  return mlir::getElementTypeOrSelf(*getODSOperands(2).begin());
}

bool LinSpaceOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "T") return true;
  if (name == "Tidx") return true;
 return false;
}

::mlir::DictionaryAttr LinSpaceOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())},
    {::mlir::Identifier::get("Tidx", ctx),
::mlir::TypeAttr::get(Tidx())}
    }, ctx);
}

void LinSpaceOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value start, ::mlir::Value stop, ::mlir::Value num) {
  odsState.addOperands(start);
  odsState.addOperands(stop);
  odsState.addOperands(num);
  odsState.addTypes(output);
}

void LinSpaceOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value start, ::mlir::Value stop, ::mlir::Value num) {
  odsState.addOperands(start);
  odsState.addOperands(stop);
  odsState.addOperands(num);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void LinSpaceOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 3u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult LinSpaceOp::verify() {
  if (failed(LinSpaceOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of floating-point values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of floating-point values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup2 = getODSOperands(2);
    for (::mlir::Value v : valueGroup2) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of 32/64-bit signed integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))))) {
        return emitOpError("result #") << index << " must be tensor of floating-point values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void LinSpaceOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::ListDiffOp definitions
//===----------------------------------------------------------------------===//

ListDiffOpAdaptor::ListDiffOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

ListDiffOpAdaptor::ListDiffOpAdaptor(ListDiffOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> ListDiffOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange ListDiffOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value ListDiffOpAdaptor::x() {
  return *getODSOperands(0).begin();
}

::mlir::Value ListDiffOpAdaptor::y() {
  return *getODSOperands(1).begin();
}

::mlir::LogicalResult ListDiffOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

void ListDiffOp::getAsmResultNames(::mlir::OpAsmSetValueNameFn setNameFn) {
  auto resultGroup0 = getODSResults(0);
  if (!llvm::empty(resultGroup0))
    setNameFn(*resultGroup0.begin(), "out");
  auto resultGroup1 = getODSResults(1);
  if (!llvm::empty(resultGroup1))
    setNameFn(*resultGroup1.begin(), "idx");
}

::llvm::StringRef ListDiffOp::getOperationName() {
  return "tf.ListDiff";
}

std::pair<unsigned, unsigned> ListDiffOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range ListDiffOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value ListDiffOp::x() {
  return *getODSOperands(0).begin();
}

::mlir::Value ListDiffOp::y() {
  return *getODSOperands(1).begin();
}

::mlir::MutableOperandRange ListDiffOp::xMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange ListDiffOp::yMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> ListDiffOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range ListDiffOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value ListDiffOp::out() {
  return *getODSResults(0).begin();
}

::mlir::Value ListDiffOp::idx() {
  return *getODSResults(1).begin();
}

Type ListDiffOp::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

Type ListDiffOp::out_idx() {
  return mlir::getElementTypeOrSelf(*getODSResults(1).begin());
}

bool ListDiffOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "T") return true;
  if (name == "out_idx") return true;
 return false;
}

::mlir::DictionaryAttr ListDiffOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())},
    {::mlir::Identifier::get("out_idx", ctx),
::mlir::TypeAttr::get(out_idx())}
    }, ctx);
}

void ListDiffOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type out, ::mlir::Type idx, ::mlir::Value x, ::mlir::Value y) {
  odsState.addOperands(x);
  odsState.addOperands(y);
  odsState.addTypes(out);
  odsState.addTypes(idx);
}

void ListDiffOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value x, ::mlir::Value y) {
  odsState.addOperands(x);
  odsState.addOperands(y);
  assert(resultTypes.size() == 2u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void ListDiffOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 2u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult ListDiffOp::verify() {
  if (failed(ListDiffOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>())))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::TensorFlowType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of tf.dtype values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>())))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::TensorFlowType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of tf.dtype values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>())))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::TensorFlowType>()))))) {
        return emitOpError("result #") << index << " must be tensor of tf.dtype values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSResults(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))))) {
        return emitOpError("result #") << index << " must be tensor of 32/64-bit signed integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void ListDiffOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::Log1pOp definitions
//===----------------------------------------------------------------------===//

Log1pOpAdaptor::Log1pOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

Log1pOpAdaptor::Log1pOpAdaptor(Log1pOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> Log1pOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange Log1pOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value Log1pOpAdaptor::x() {
  return *getODSOperands(0).begin();
}

::mlir::LogicalResult Log1pOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

::llvm::StringRef Log1pOp::getOperationName() {
  return "tf.Log1p";
}

std::pair<unsigned, unsigned> Log1pOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range Log1pOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value Log1pOp::x() {
  return *getODSOperands(0).begin();
}

::mlir::MutableOperandRange Log1pOp::xMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> Log1pOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range Log1pOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value Log1pOp::y() {
  return *getODSResults(0).begin();
}

Type Log1pOp::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

bool Log1pOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "T") return true;
 return false;
}

::mlir::DictionaryAttr Log1pOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())}
    }, ctx);
}

void Log1pOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type y, ::mlir::Value x) {
  odsState.addOperands(x);
  odsState.addTypes(y);
}

void Log1pOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value x) {
  odsState.addOperands(x);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void Log1pOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

void Log1pOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value x) {
  odsState.addOperands(x);
  odsState.addTypes({x.getType()});

}

void Log1pOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  odsState.addTypes({operands[0].getType()});

}

::mlir::LogicalResult Log1pOp::verify() {
  if (failed(Log1pOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))))))) {
        return emitOpError("operand #") << index << " must be tensor of floating-point or complex values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))))))) {
        return emitOpError("result #") << index << " must be tensor of floating-point or complex values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void Log1pOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::LogOp definitions
//===----------------------------------------------------------------------===//

LogOpAdaptor::LogOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

LogOpAdaptor::LogOpAdaptor(LogOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> LogOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange LogOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value LogOpAdaptor::x() {
  return *getODSOperands(0).begin();
}

::mlir::LogicalResult LogOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

::llvm::StringRef LogOp::getOperationName() {
  return "tf.Log";
}

std::pair<unsigned, unsigned> LogOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range LogOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value LogOp::x() {
  return *getODSOperands(0).begin();
}

::mlir::MutableOperandRange LogOp::xMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> LogOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range LogOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value LogOp::y() {
  return *getODSResults(0).begin();
}

Type LogOp::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

bool LogOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "T") return true;
 return false;
}

::mlir::DictionaryAttr LogOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())}
    }, ctx);
}

void LogOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type y, ::mlir::Value x) {
  odsState.addOperands(x);
  odsState.addTypes(y);
}

void LogOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value x) {
  odsState.addOperands(x);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void LogOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

void LogOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value x) {
  odsState.addOperands(x);
  odsState.addTypes({x.getType()});

}

void LogOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  odsState.addTypes({operands[0].getType()});

}

::mlir::LogicalResult LogOp::verify() {
  if (failed(LogOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))))))) {
        return emitOpError("operand #") << index << " must be tensor of floating-point or complex values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))))))) {
        return emitOpError("result #") << index << " must be tensor of floating-point or complex values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}



void LogOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::LogSoftmaxOp definitions
//===----------------------------------------------------------------------===//

LogSoftmaxOpAdaptor::LogSoftmaxOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

LogSoftmaxOpAdaptor::LogSoftmaxOpAdaptor(LogSoftmaxOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> LogSoftmaxOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange LogSoftmaxOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value LogSoftmaxOpAdaptor::logits() {
  return *getODSOperands(0).begin();
}

::mlir::LogicalResult LogSoftmaxOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

::llvm::StringRef LogSoftmaxOp::getOperationName() {
  return "tf.LogSoftmax";
}

std::pair<unsigned, unsigned> LogSoftmaxOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range LogSoftmaxOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value LogSoftmaxOp::logits() {
  return *getODSOperands(0).begin();
}

::mlir::MutableOperandRange LogSoftmaxOp::logitsMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> LogSoftmaxOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range LogSoftmaxOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value LogSoftmaxOp::logsoftmax() {
  return *getODSResults(0).begin();
}

Type LogSoftmaxOp::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

bool LogSoftmaxOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "T") return true;
 return false;
}

::mlir::DictionaryAttr LogSoftmaxOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())}
    }, ctx);
}

void LogSoftmaxOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type logsoftmax, ::mlir::Value logits) {
  odsState.addOperands(logits);
  odsState.addTypes(logsoftmax);
}

void LogSoftmaxOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value logits) {
  odsState.addOperands(logits);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void LogSoftmaxOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

void LogSoftmaxOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value logits) {
  odsState.addOperands(logits);
  odsState.addTypes({logits.getType()});

}

void LogSoftmaxOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  odsState.addTypes({operands[0].getType()});

}

::mlir::LogicalResult LogSoftmaxOp::verify() {
  if (failed(LogSoftmaxOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of floating-point values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))))) {
        return emitOpError("result #") << index << " must be tensor of floating-point values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void LogSoftmaxOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::LogicalAndOp definitions
//===----------------------------------------------------------------------===//

LogicalAndOpAdaptor::LogicalAndOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

LogicalAndOpAdaptor::LogicalAndOpAdaptor(LogicalAndOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> LogicalAndOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange LogicalAndOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value LogicalAndOpAdaptor::x() {
  return *getODSOperands(0).begin();
}

::mlir::Value LogicalAndOpAdaptor::y() {
  return *getODSOperands(1).begin();
}

::mlir::LogicalResult LogicalAndOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

::llvm::StringRef LogicalAndOp::getOperationName() {
  return "tf.LogicalAnd";
}

std::pair<unsigned, unsigned> LogicalAndOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range LogicalAndOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value LogicalAndOp::x() {
  return *getODSOperands(0).begin();
}

::mlir::Value LogicalAndOp::y() {
  return *getODSOperands(1).begin();
}

::mlir::MutableOperandRange LogicalAndOp::xMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange LogicalAndOp::yMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> LogicalAndOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range LogicalAndOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value LogicalAndOp::z() {
  return *getODSResults(0).begin();
}

void LogicalAndOp::build(OpBuilder &builder, OperationState &result, Value  x, Value  y) {
  auto resultType =
      OpTrait::util::getBroadcastedType(x.getType(), y.getType());
  if (!resultType)
    mlir::emitError(result.location, "non-broadcastable operands");
  return build(builder, result, resultType, x, y);
}

void LogicalAndOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type z, ::mlir::Value x, ::mlir::Value y) {
  odsState.addOperands(x);
  odsState.addOperands(y);
  odsState.addTypes(z);
}

void LogicalAndOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value x, ::mlir::Value y) {
  odsState.addOperands(x);
  odsState.addOperands(y);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void LogicalAndOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult LogicalAndOp::verify() {
  if (failed(LogicalAndOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of bool values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of bool values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))))) {
        return emitOpError("result #") << index << " must be tensor of bool values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void LogicalAndOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::LogicalNotOp definitions
//===----------------------------------------------------------------------===//

LogicalNotOpAdaptor::LogicalNotOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

LogicalNotOpAdaptor::LogicalNotOpAdaptor(LogicalNotOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> LogicalNotOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange LogicalNotOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value LogicalNotOpAdaptor::x() {
  return *getODSOperands(0).begin();
}

::mlir::LogicalResult LogicalNotOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

::llvm::StringRef LogicalNotOp::getOperationName() {
  return "tf.LogicalNot";
}

std::pair<unsigned, unsigned> LogicalNotOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range LogicalNotOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value LogicalNotOp::x() {
  return *getODSOperands(0).begin();
}

::mlir::MutableOperandRange LogicalNotOp::xMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> LogicalNotOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range LogicalNotOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value LogicalNotOp::y() {
  return *getODSResults(0).begin();
}

void LogicalNotOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type y, ::mlir::Value x) {
  odsState.addOperands(x);
  odsState.addTypes(y);
}

void LogicalNotOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value x) {
  odsState.addOperands(x);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void LogicalNotOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

void LogicalNotOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value x) {
  odsState.addOperands(x);
  odsState.addTypes({x.getType()});

}

void LogicalNotOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  odsState.addTypes({operands[0].getType()});

}

::mlir::LogicalResult LogicalNotOp::verify() {
  if (failed(LogicalNotOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of bool values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))))) {
        return emitOpError("result #") << index << " must be tensor of bool values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}



void LogicalNotOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::LogicalOrOp definitions
//===----------------------------------------------------------------------===//

LogicalOrOpAdaptor::LogicalOrOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

LogicalOrOpAdaptor::LogicalOrOpAdaptor(LogicalOrOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> LogicalOrOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange LogicalOrOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value LogicalOrOpAdaptor::x() {
  return *getODSOperands(0).begin();
}

::mlir::Value LogicalOrOpAdaptor::y() {
  return *getODSOperands(1).begin();
}

::mlir::LogicalResult LogicalOrOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

::llvm::StringRef LogicalOrOp::getOperationName() {
  return "tf.LogicalOr";
}

std::pair<unsigned, unsigned> LogicalOrOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range LogicalOrOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value LogicalOrOp::x() {
  return *getODSOperands(0).begin();
}

::mlir::Value LogicalOrOp::y() {
  return *getODSOperands(1).begin();
}

::mlir::MutableOperandRange LogicalOrOp::xMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange LogicalOrOp::yMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> LogicalOrOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range LogicalOrOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value LogicalOrOp::z() {
  return *getODSResults(0).begin();
}

void LogicalOrOp::build(OpBuilder &builder, OperationState &result, Value  x, Value  y) {
  auto resultType =
      OpTrait::util::getBroadcastedType(x.getType(), y.getType());
  if (!resultType)
    mlir::emitError(result.location, "non-broadcastable operands");
  return build(builder, result, resultType, x, y);
}

void LogicalOrOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type z, ::mlir::Value x, ::mlir::Value y) {
  odsState.addOperands(x);
  odsState.addOperands(y);
  odsState.addTypes(z);
}

void LogicalOrOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value x, ::mlir::Value y) {
  odsState.addOperands(x);
  odsState.addOperands(y);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void LogicalOrOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult LogicalOrOp::verify() {
  if (failed(LogicalOrOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of bool values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of bool values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))))) {
        return emitOpError("result #") << index << " must be tensor of bool values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void LogicalOrOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::LookupTableExportV2Op definitions
//===----------------------------------------------------------------------===//

LookupTableExportV2OpAdaptor::LookupTableExportV2OpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

LookupTableExportV2OpAdaptor::LookupTableExportV2OpAdaptor(LookupTableExportV2Op&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> LookupTableExportV2OpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange LookupTableExportV2OpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value LookupTableExportV2OpAdaptor::table_handle() {
  return *getODSOperands(0).begin();
}

::mlir::LogicalResult LookupTableExportV2OpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

void LookupTableExportV2Op::getAsmResultNames(::mlir::OpAsmSetValueNameFn setNameFn) {
  auto resultGroup0 = getODSResults(0);
  if (!llvm::empty(resultGroup0))
    setNameFn(*resultGroup0.begin(), "keys");
  auto resultGroup1 = getODSResults(1);
  if (!llvm::empty(resultGroup1))
    setNameFn(*resultGroup1.begin(), "values");
}

::llvm::StringRef LookupTableExportV2Op::getOperationName() {
  return "tf.LookupTableExportV2";
}

std::pair<unsigned, unsigned> LookupTableExportV2Op::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range LookupTableExportV2Op::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value LookupTableExportV2Op::table_handle() {
  return *getODSOperands(0).begin();
}

::mlir::MutableOperandRange LookupTableExportV2Op::table_handleMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> LookupTableExportV2Op::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range LookupTableExportV2Op::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value LookupTableExportV2Op::keys() {
  return *getODSResults(0).begin();
}

::mlir::Value LookupTableExportV2Op::values() {
  return *getODSResults(1).begin();
}

Type LookupTableExportV2Op::Tkeys() {
  return mlir::getElementTypeOrSelf(*getODSResults(0).begin());
}

Type LookupTableExportV2Op::Tvalues() {
  return mlir::getElementTypeOrSelf(*getODSResults(1).begin());
}

bool LookupTableExportV2Op::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "Tkeys") return true;
  if (name == "Tvalues") return true;
 return false;
}

::mlir::DictionaryAttr LookupTableExportV2Op::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("Tkeys", ctx),
::mlir::TypeAttr::get(Tkeys())},
    {::mlir::Identifier::get("Tvalues", ctx),
::mlir::TypeAttr::get(Tvalues())}
    }, ctx);
}

void LookupTableExportV2Op::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type keys, ::mlir::Type values, ::mlir::Value table_handle) {
  odsState.addOperands(table_handle);
  odsState.addTypes(keys);
  odsState.addTypes(values);
}

void LookupTableExportV2Op::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value table_handle) {
  odsState.addOperands(table_handle);
  assert(resultTypes.size() == 2u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void LookupTableExportV2Op::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 2u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult LookupTableExportV2Op::verify() {
  if (failed(LookupTableExportV2OpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::ResourceType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::ResourceRefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of resource values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>())))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::TensorFlowType>()))))) {
        return emitOpError("result #") << index << " must be tensor of tf.dtype values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSResults(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>())))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::TensorFlowType>()))))) {
        return emitOpError("result #") << index << " must be tensor of tf.dtype values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void LookupTableExportV2Op::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
  for (::mlir::Value value : getODSOperands(0))
    effects.emplace_back(MemoryEffects::Read::get(), value, ::mlir::TF::ResourceEffects::LookupTable::get());
}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::LookupTableFindV2Op definitions
//===----------------------------------------------------------------------===//

LookupTableFindV2OpAdaptor::LookupTableFindV2OpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

LookupTableFindV2OpAdaptor::LookupTableFindV2OpAdaptor(LookupTableFindV2Op&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> LookupTableFindV2OpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange LookupTableFindV2OpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value LookupTableFindV2OpAdaptor::table_handle() {
  return *getODSOperands(0).begin();
}

::mlir::Value LookupTableFindV2OpAdaptor::keys() {
  return *getODSOperands(1).begin();
}

::mlir::Value LookupTableFindV2OpAdaptor::default_value() {
  return *getODSOperands(2).begin();
}

::mlir::LogicalResult LookupTableFindV2OpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

::llvm::StringRef LookupTableFindV2Op::getOperationName() {
  return "tf.LookupTableFindV2";
}

std::pair<unsigned, unsigned> LookupTableFindV2Op::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range LookupTableFindV2Op::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value LookupTableFindV2Op::table_handle() {
  return *getODSOperands(0).begin();
}

::mlir::Value LookupTableFindV2Op::keys() {
  return *getODSOperands(1).begin();
}

::mlir::Value LookupTableFindV2Op::default_value() {
  return *getODSOperands(2).begin();
}

::mlir::MutableOperandRange LookupTableFindV2Op::table_handleMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange LookupTableFindV2Op::keysMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange LookupTableFindV2Op::default_valueMutable() {
  auto range = getODSOperandIndexAndLength(2);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> LookupTableFindV2Op::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range LookupTableFindV2Op::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value LookupTableFindV2Op::values() {
  return *getODSResults(0).begin();
}

Type LookupTableFindV2Op::Tin() {
  return mlir::getElementTypeOrSelf(*getODSOperands(1).begin());
}

Type LookupTableFindV2Op::Tout() {
  return mlir::getElementTypeOrSelf(*getODSOperands(2).begin());
}

bool LookupTableFindV2Op::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "Tin") return true;
  if (name == "Tout") return true;
 return false;
}

::mlir::DictionaryAttr LookupTableFindV2Op::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("Tin", ctx),
::mlir::TypeAttr::get(Tin())},
    {::mlir::Identifier::get("Tout", ctx),
::mlir::TypeAttr::get(Tout())}
    }, ctx);
}

void LookupTableFindV2Op::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type values, ::mlir::Value table_handle, ::mlir::Value keys, ::mlir::Value default_value) {
  odsState.addOperands(table_handle);
  odsState.addOperands(keys);
  odsState.addOperands(default_value);
  odsState.addTypes(values);
}

void LookupTableFindV2Op::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value table_handle, ::mlir::Value keys, ::mlir::Value default_value) {
  odsState.addOperands(table_handle);
  odsState.addOperands(keys);
  odsState.addOperands(default_value);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void LookupTableFindV2Op::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 3u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult LookupTableFindV2Op::verify() {
  if (failed(LookupTableFindV2OpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::ResourceType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::ResourceRefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of resource values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>())))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::TensorFlowType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of tf.dtype values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup2 = getODSOperands(2);
    for (::mlir::Value v : valueGroup2) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>())))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::TensorFlowType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of tf.dtype values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>())))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::TensorFlowType>()))))) {
        return emitOpError("result #") << index << " must be tensor of tf.dtype values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void LookupTableFindV2Op::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
  for (::mlir::Value value : getODSOperands(0))
    effects.emplace_back(MemoryEffects::Read::get(), value, ::mlir::TF::ResourceEffects::LookupTable::get());
}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::LookupTableImportV2Op definitions
//===----------------------------------------------------------------------===//

LookupTableImportV2OpAdaptor::LookupTableImportV2OpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

LookupTableImportV2OpAdaptor::LookupTableImportV2OpAdaptor(LookupTableImportV2Op&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> LookupTableImportV2OpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange LookupTableImportV2OpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value LookupTableImportV2OpAdaptor::table_handle() {
  return *getODSOperands(0).begin();
}

::mlir::Value LookupTableImportV2OpAdaptor::keys() {
  return *getODSOperands(1).begin();
}

::mlir::Value LookupTableImportV2OpAdaptor::values() {
  return *getODSOperands(2).begin();
}

::mlir::LogicalResult LookupTableImportV2OpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

::llvm::StringRef LookupTableImportV2Op::getOperationName() {
  return "tf.LookupTableImportV2";
}

std::pair<unsigned, unsigned> LookupTableImportV2Op::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range LookupTableImportV2Op::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value LookupTableImportV2Op::table_handle() {
  return *getODSOperands(0).begin();
}

::mlir::Value LookupTableImportV2Op::keys() {
  return *getODSOperands(1).begin();
}

::mlir::Value LookupTableImportV2Op::values() {
  return *getODSOperands(2).begin();
}

::mlir::MutableOperandRange LookupTableImportV2Op::table_handleMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange LookupTableImportV2Op::keysMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange LookupTableImportV2Op::valuesMutable() {
  auto range = getODSOperandIndexAndLength(2);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> LookupTableImportV2Op::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range LookupTableImportV2Op::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

Type LookupTableImportV2Op::Tin() {
  return mlir::getElementTypeOrSelf(*getODSOperands(1).begin());
}

Type LookupTableImportV2Op::Tout() {
  return mlir::getElementTypeOrSelf(*getODSOperands(2).begin());
}

bool LookupTableImportV2Op::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "Tin") return true;
  if (name == "Tout") return true;
 return false;
}

::mlir::DictionaryAttr LookupTableImportV2Op::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("Tin", ctx),
::mlir::TypeAttr::get(Tin())},
    {::mlir::Identifier::get("Tout", ctx),
::mlir::TypeAttr::get(Tout())}
    }, ctx);
}

void LookupTableImportV2Op::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value table_handle, ::mlir::Value keys, ::mlir::Value values) {
  odsState.addOperands(table_handle);
  odsState.addOperands(keys);
  odsState.addOperands(values);
}

void LookupTableImportV2Op::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value table_handle, ::mlir::Value keys, ::mlir::Value values) {
  odsState.addOperands(table_handle);
  odsState.addOperands(keys);
  odsState.addOperands(values);
  assert(resultTypes.size() == 0u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void LookupTableImportV2Op::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 3u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 0u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult LookupTableImportV2Op::verify() {
  if (failed(LookupTableImportV2OpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::ResourceType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::ResourceRefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of resource values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>())))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::TensorFlowType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of tf.dtype values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup2 = getODSOperands(2);
    for (::mlir::Value v : valueGroup2) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>())))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::TensorFlowType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of tf.dtype values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
  }
  return ::mlir::success();
}

void LookupTableImportV2Op::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
  for (::mlir::Value value : getODSOperands(0))
    effects.emplace_back(MemoryEffects::Write::get(), value, ::mlir::TF::ResourceEffects::LookupTable::get());
}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::LookupTableInsertV2Op definitions
//===----------------------------------------------------------------------===//

LookupTableInsertV2OpAdaptor::LookupTableInsertV2OpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

LookupTableInsertV2OpAdaptor::LookupTableInsertV2OpAdaptor(LookupTableInsertV2Op&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> LookupTableInsertV2OpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange LookupTableInsertV2OpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value LookupTableInsertV2OpAdaptor::table_handle() {
  return *getODSOperands(0).begin();
}

::mlir::Value LookupTableInsertV2OpAdaptor::keys() {
  return *getODSOperands(1).begin();
}

::mlir::Value LookupTableInsertV2OpAdaptor::values() {
  return *getODSOperands(2).begin();
}

::mlir::LogicalResult LookupTableInsertV2OpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

::llvm::StringRef LookupTableInsertV2Op::getOperationName() {
  return "tf.LookupTableInsertV2";
}

std::pair<unsigned, unsigned> LookupTableInsertV2Op::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range LookupTableInsertV2Op::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value LookupTableInsertV2Op::table_handle() {
  return *getODSOperands(0).begin();
}

::mlir::Value LookupTableInsertV2Op::keys() {
  return *getODSOperands(1).begin();
}

::mlir::Value LookupTableInsertV2Op::values() {
  return *getODSOperands(2).begin();
}

::mlir::MutableOperandRange LookupTableInsertV2Op::table_handleMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange LookupTableInsertV2Op::keysMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange LookupTableInsertV2Op::valuesMutable() {
  auto range = getODSOperandIndexAndLength(2);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> LookupTableInsertV2Op::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range LookupTableInsertV2Op::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

Type LookupTableInsertV2Op::Tin() {
  return mlir::getElementTypeOrSelf(*getODSOperands(1).begin());
}

Type LookupTableInsertV2Op::Tout() {
  return mlir::getElementTypeOrSelf(*getODSOperands(2).begin());
}

bool LookupTableInsertV2Op::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "Tin") return true;
  if (name == "Tout") return true;
 return false;
}

::mlir::DictionaryAttr LookupTableInsertV2Op::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("Tin", ctx),
::mlir::TypeAttr::get(Tin())},
    {::mlir::Identifier::get("Tout", ctx),
::mlir::TypeAttr::get(Tout())}
    }, ctx);
}

void LookupTableInsertV2Op::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value table_handle, ::mlir::Value keys, ::mlir::Value values) {
  odsState.addOperands(table_handle);
  odsState.addOperands(keys);
  odsState.addOperands(values);
}

void LookupTableInsertV2Op::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value table_handle, ::mlir::Value keys, ::mlir::Value values) {
  odsState.addOperands(table_handle);
  odsState.addOperands(keys);
  odsState.addOperands(values);
  assert(resultTypes.size() == 0u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void LookupTableInsertV2Op::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 3u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 0u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult LookupTableInsertV2Op::verify() {
  if (failed(LookupTableInsertV2OpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::ResourceType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::ResourceRefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of resource values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>())))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::TensorFlowType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of tf.dtype values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup2 = getODSOperands(2);
    for (::mlir::Value v : valueGroup2) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>())))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::TensorFlowType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of tf.dtype values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
  }
  return ::mlir::success();
}

void LookupTableInsertV2Op::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
  for (::mlir::Value value : getODSOperands(0))
    effects.emplace_back(MemoryEffects::Write::get(), value, ::mlir::TF::ResourceEffects::LookupTable::get());
}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::LookupTableRemoveV2Op definitions
//===----------------------------------------------------------------------===//

LookupTableRemoveV2OpAdaptor::LookupTableRemoveV2OpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

LookupTableRemoveV2OpAdaptor::LookupTableRemoveV2OpAdaptor(LookupTableRemoveV2Op&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> LookupTableRemoveV2OpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange LookupTableRemoveV2OpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value LookupTableRemoveV2OpAdaptor::table_handle() {
  return *getODSOperands(0).begin();
}

::mlir::Value LookupTableRemoveV2OpAdaptor::keys() {
  return *getODSOperands(1).begin();
}

::mlir::LogicalResult LookupTableRemoveV2OpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

::llvm::StringRef LookupTableRemoveV2Op::getOperationName() {
  return "tf.LookupTableRemoveV2";
}

std::pair<unsigned, unsigned> LookupTableRemoveV2Op::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range LookupTableRemoveV2Op::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value LookupTableRemoveV2Op::table_handle() {
  return *getODSOperands(0).begin();
}

::mlir::Value LookupTableRemoveV2Op::keys() {
  return *getODSOperands(1).begin();
}

::mlir::MutableOperandRange LookupTableRemoveV2Op::table_handleMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange LookupTableRemoveV2Op::keysMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> LookupTableRemoveV2Op::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range LookupTableRemoveV2Op::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

Type LookupTableRemoveV2Op::Tin() {
  return mlir::getElementTypeOrSelf(*getODSOperands(1).begin());
}

bool LookupTableRemoveV2Op::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "Tin") return true;
 return false;
}

::mlir::DictionaryAttr LookupTableRemoveV2Op::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("Tin", ctx),
::mlir::TypeAttr::get(Tin())}
    }, ctx);
}

void LookupTableRemoveV2Op::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value table_handle, ::mlir::Value keys) {
  odsState.addOperands(table_handle);
  odsState.addOperands(keys);
}

void LookupTableRemoveV2Op::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value table_handle, ::mlir::Value keys) {
  odsState.addOperands(table_handle);
  odsState.addOperands(keys);
  assert(resultTypes.size() == 0u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void LookupTableRemoveV2Op::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 0u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult LookupTableRemoveV2Op::verify() {
  if (failed(LookupTableRemoveV2OpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::ResourceType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::ResourceRefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of resource values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>())))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::TensorFlowType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of tf.dtype values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
  }
  return ::mlir::success();
}

void LookupTableRemoveV2Op::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
  for (::mlir::Value value : getODSOperands(0))
    effects.emplace_back(MemoryEffects::Write::get(), value, ::mlir::TF::ResourceEffects::LookupTable::get());
}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::LookupTableSizeV2Op definitions
//===----------------------------------------------------------------------===//

LookupTableSizeV2OpAdaptor::LookupTableSizeV2OpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

LookupTableSizeV2OpAdaptor::LookupTableSizeV2OpAdaptor(LookupTableSizeV2Op&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> LookupTableSizeV2OpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange LookupTableSizeV2OpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value LookupTableSizeV2OpAdaptor::table_handle() {
  return *getODSOperands(0).begin();
}

::mlir::LogicalResult LookupTableSizeV2OpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

::llvm::StringRef LookupTableSizeV2Op::getOperationName() {
  return "tf.LookupTableSizeV2";
}

std::pair<unsigned, unsigned> LookupTableSizeV2Op::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range LookupTableSizeV2Op::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value LookupTableSizeV2Op::table_handle() {
  return *getODSOperands(0).begin();
}

::mlir::MutableOperandRange LookupTableSizeV2Op::table_handleMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> LookupTableSizeV2Op::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range LookupTableSizeV2Op::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value LookupTableSizeV2Op::size() {
  return *getODSResults(0).begin();
}

void LookupTableSizeV2Op::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type size, ::mlir::Value table_handle) {
  odsState.addOperands(table_handle);
  odsState.addTypes(size);
}

void LookupTableSizeV2Op::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value table_handle) {
  odsState.addOperands(table_handle);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void LookupTableSizeV2Op::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult LookupTableSizeV2Op::verify() {
  if (failed(LookupTableSizeV2OpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::ResourceType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::ResourceRefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of resource values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))))) {
        return emitOpError("result #") << index << " must be tensor of 64-bit integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::LowerBoundOp definitions
//===----------------------------------------------------------------------===//

LowerBoundOpAdaptor::LowerBoundOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

LowerBoundOpAdaptor::LowerBoundOpAdaptor(LowerBoundOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> LowerBoundOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange LowerBoundOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value LowerBoundOpAdaptor::sorted_inputs() {
  return *getODSOperands(0).begin();
}

::mlir::Value LowerBoundOpAdaptor::values() {
  return *getODSOperands(1).begin();
}

::mlir::LogicalResult LowerBoundOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

::llvm::StringRef LowerBoundOp::getOperationName() {
  return "tf.LowerBound";
}

std::pair<unsigned, unsigned> LowerBoundOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range LowerBoundOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value LowerBoundOp::sorted_inputs() {
  return *getODSOperands(0).begin();
}

::mlir::Value LowerBoundOp::values() {
  return *getODSOperands(1).begin();
}

::mlir::MutableOperandRange LowerBoundOp::sorted_inputsMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange LowerBoundOp::valuesMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> LowerBoundOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range LowerBoundOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value LowerBoundOp::output() {
  return *getODSResults(0).begin();
}

Type LowerBoundOp::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

Type LowerBoundOp::out_type() {
  return mlir::getElementTypeOrSelf(*getODSResults(0).begin());
}

bool LowerBoundOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "T") return true;
  if (name == "out_type") return true;
 return false;
}

::mlir::DictionaryAttr LowerBoundOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())},
    {::mlir::Identifier::get("out_type", ctx),
::mlir::TypeAttr::get(out_type())}
    }, ctx);
}

void LowerBoundOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value sorted_inputs, ::mlir::Value values) {
  odsState.addOperands(sorted_inputs);
  odsState.addOperands(values);
  odsState.addTypes(output);
}

void LowerBoundOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value sorted_inputs, ::mlir::Value values) {
  odsState.addOperands(sorted_inputs);
  odsState.addOperands(values);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void LowerBoundOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult LowerBoundOp::verify() {
  if (failed(LowerBoundOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>())))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::TensorFlowType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of tf.dtype values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>())))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::TensorFlowType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of tf.dtype values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))))) {
        return emitOpError("result #") << index << " must be tensor of 32/64-bit signed integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void LowerBoundOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::MakeIteratorOp definitions
//===----------------------------------------------------------------------===//

MakeIteratorOpAdaptor::MakeIteratorOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

MakeIteratorOpAdaptor::MakeIteratorOpAdaptor(MakeIteratorOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> MakeIteratorOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange MakeIteratorOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value MakeIteratorOpAdaptor::dataset() {
  return *getODSOperands(0).begin();
}

::mlir::Value MakeIteratorOpAdaptor::iterator() {
  return *getODSOperands(1).begin();
}

::mlir::LogicalResult MakeIteratorOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

::llvm::StringRef MakeIteratorOp::getOperationName() {
  return "tf.MakeIterator";
}

std::pair<unsigned, unsigned> MakeIteratorOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range MakeIteratorOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value MakeIteratorOp::dataset() {
  return *getODSOperands(0).begin();
}

::mlir::Value MakeIteratorOp::iterator() {
  return *getODSOperands(1).begin();
}

::mlir::MutableOperandRange MakeIteratorOp::datasetMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange MakeIteratorOp::iteratorMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> MakeIteratorOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range MakeIteratorOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

void MakeIteratorOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value dataset, ::mlir::Value iterator) {
  odsState.addOperands(dataset);
  odsState.addOperands(iterator);
}

void MakeIteratorOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value dataset, ::mlir::Value iterator) {
  odsState.addOperands(dataset);
  odsState.addOperands(iterator);
  assert(resultTypes.size() == 0u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void MakeIteratorOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 0u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult MakeIteratorOp::verify() {
  if (failed(MakeIteratorOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::VariantType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::VariantRefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of variant values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::ResourceType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::ResourceRefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of resource values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
  }
  return ::mlir::success();
}

void MakeIteratorOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
  for (::mlir::Value value : getODSOperands(1))
    effects.emplace_back(MemoryEffects::Write::get(), value, ::mlir::TF::ResourceEffects::DatasetIterator::get());
}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::MapAndBatchDatasetOp definitions
//===----------------------------------------------------------------------===//

MapAndBatchDatasetOpAdaptor::MapAndBatchDatasetOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

MapAndBatchDatasetOpAdaptor::MapAndBatchDatasetOpAdaptor(MapAndBatchDatasetOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> MapAndBatchDatasetOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  bool isVariadic[] = {false, true, false, false, false};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (odsOperands.size() - 4) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::mlir::ValueRange MapAndBatchDatasetOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value MapAndBatchDatasetOpAdaptor::input_dataset() {
  return *getODSOperands(0).begin();
}

::mlir::ValueRange MapAndBatchDatasetOpAdaptor::other_arguments() {
  return getODSOperands(1);
}

::mlir::Value MapAndBatchDatasetOpAdaptor::batch_size() {
  return *getODSOperands(2).begin();
}

::mlir::Value MapAndBatchDatasetOpAdaptor::num_parallel_calls() {
  return *getODSOperands(3).begin();
}

::mlir::Value MapAndBatchDatasetOpAdaptor::drop_remainder() {
  return *getODSOperands(4).begin();
}

::mlir::SymbolRefAttr MapAndBatchDatasetOpAdaptor::f() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::SymbolRefAttr attr = odsAttrs.get("f").cast<::mlir::SymbolRefAttr>();
  return attr;
}

::mlir::ArrayAttr MapAndBatchDatasetOpAdaptor::output_types() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::ArrayAttr attr = odsAttrs.get("output_types").cast<::mlir::ArrayAttr>();
  return attr;
}

::mlir::ArrayAttr MapAndBatchDatasetOpAdaptor::output_shapes() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::ArrayAttr attr = odsAttrs.get("output_shapes").cast<::mlir::ArrayAttr>();
  return attr;
}

::mlir::BoolAttr MapAndBatchDatasetOpAdaptor::preserve_cardinality() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::BoolAttr attr = odsAttrs.get("preserve_cardinality").dyn_cast_or_null<::mlir::BoolAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getBoolAttr(false);
  return attr;
}

::mlir::LogicalResult MapAndBatchDatasetOpAdaptor::verify(::mlir::Location loc) {
  {
  auto tblgen_f = odsAttrs.get("f");
  if (!tblgen_f) return emitError(loc, "'tf.MapAndBatchDataset' op ""requires attribute 'f'");
    if (!((tblgen_f.isa<::mlir::SymbolRefAttr>()))) return emitError(loc, "'tf.MapAndBatchDataset' op ""attribute 'f' failed to satisfy constraint: symbol reference attribute");
  }
  {
  auto tblgen_output_types = odsAttrs.get("output_types");
  if (!tblgen_output_types) return emitError(loc, "'tf.MapAndBatchDataset' op ""requires attribute 'output_types'");
    if (!((((tblgen_output_types.isa<::mlir::ArrayAttr>())) && (::llvm::all_of(tblgen_output_types.cast<::mlir::ArrayAttr>(), [](::mlir::Attribute attr) { return ((attr.isa<::mlir::TypeAttr>())) && ((attr.cast<::mlir::TypeAttr>().getValue().isa<::mlir::Type>())); }))) && ((tblgen_output_types.cast<::mlir::ArrayAttr>().size() >= 1)))) return emitError(loc, "'tf.MapAndBatchDataset' op ""attribute 'output_types' failed to satisfy constraint: type array attribute with at least 1 elements");
  }
  {
  auto tblgen_output_shapes = odsAttrs.get("output_shapes");
  if (!tblgen_output_shapes) return emitError(loc, "'tf.MapAndBatchDataset' op ""requires attribute 'output_shapes'");
    if (!((((tblgen_output_shapes.isa<::mlir::ArrayAttr>())) && (::llvm::all_of(tblgen_output_shapes.cast<::mlir::ArrayAttr>(), [](::mlir::Attribute attr) { return (attr.isa<mlir::TF::ShapeAttr>()); }))) && ((tblgen_output_shapes.cast<::mlir::ArrayAttr>().size() >= 1)))) return emitError(loc, "'tf.MapAndBatchDataset' op ""attribute 'output_shapes' failed to satisfy constraint: tensorflow shape attribute array with at least 1 elements");
  }
  {
  auto tblgen_preserve_cardinality = odsAttrs.get("preserve_cardinality");
  if (tblgen_preserve_cardinality) {
    if (!((tblgen_preserve_cardinality.isa<::mlir::BoolAttr>()))) return emitError(loc, "'tf.MapAndBatchDataset' op ""attribute 'preserve_cardinality' failed to satisfy constraint: bool attribute");
  }
  }
  return ::mlir::success();
}

::llvm::StringRef MapAndBatchDatasetOp::getOperationName() {
  return "tf.MapAndBatchDataset";
}

std::pair<unsigned, unsigned> MapAndBatchDatasetOp::getODSOperandIndexAndLength(unsigned index) {
  bool isVariadic[] = {false, true, false, false, false};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (getOperation()->getNumOperands() - 4) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::mlir::Operation::operand_range MapAndBatchDatasetOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value MapAndBatchDatasetOp::input_dataset() {
  return *getODSOperands(0).begin();
}

::mlir::Operation::operand_range MapAndBatchDatasetOp::other_arguments() {
  return getODSOperands(1);
}

::mlir::Value MapAndBatchDatasetOp::batch_size() {
  return *getODSOperands(2).begin();
}

::mlir::Value MapAndBatchDatasetOp::num_parallel_calls() {
  return *getODSOperands(3).begin();
}

::mlir::Value MapAndBatchDatasetOp::drop_remainder() {
  return *getODSOperands(4).begin();
}

::mlir::MutableOperandRange MapAndBatchDatasetOp::input_datasetMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange MapAndBatchDatasetOp::other_argumentsMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange MapAndBatchDatasetOp::batch_sizeMutable() {
  auto range = getODSOperandIndexAndLength(2);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange MapAndBatchDatasetOp::num_parallel_callsMutable() {
  auto range = getODSOperandIndexAndLength(3);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange MapAndBatchDatasetOp::drop_remainderMutable() {
  auto range = getODSOperandIndexAndLength(4);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> MapAndBatchDatasetOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range MapAndBatchDatasetOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value MapAndBatchDatasetOp::handle() {
  return *getODSResults(0).begin();
}

::mlir::SymbolRefAttr MapAndBatchDatasetOp::fAttr() {
  return this->getAttr("f").cast<::mlir::SymbolRefAttr>();
}

::mlir::SymbolRefAttr MapAndBatchDatasetOp::f() {
  auto attr = fAttr();
  return attr;
}

::mlir::ArrayAttr MapAndBatchDatasetOp::output_typesAttr() {
  return this->getAttr("output_types").cast<::mlir::ArrayAttr>();
}

::mlir::ArrayAttr MapAndBatchDatasetOp::output_types() {
  auto attr = output_typesAttr();
  return attr;
}

::mlir::ArrayAttr MapAndBatchDatasetOp::output_shapesAttr() {
  return this->getAttr("output_shapes").cast<::mlir::ArrayAttr>();
}

::mlir::ArrayAttr MapAndBatchDatasetOp::output_shapes() {
  auto attr = output_shapesAttr();
  return attr;
}

::mlir::BoolAttr MapAndBatchDatasetOp::preserve_cardinalityAttr() {
  return this->getAttr("preserve_cardinality").dyn_cast_or_null<::mlir::BoolAttr>();
}

bool MapAndBatchDatasetOp::preserve_cardinality() {
  auto attr = preserve_cardinalityAttr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getBoolAttr(false).getValue();
  return attr.getValue();
}

mlir::OperandElementTypeRange MapAndBatchDatasetOp::Targuments() {
  auto values = getODSOperands(1);
return {mlir::OperandElementTypeIterator(values.begin()), mlir::OperandElementTypeIterator(values.end())};
}

bool MapAndBatchDatasetOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "Targuments") return true;
 return false;
}

::mlir::DictionaryAttr MapAndBatchDatasetOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("Targuments", ctx),
ArrayAttr::get(
    [&]() {
      llvm::SmallVector<Attribute, 4> ret;
      for (auto t : Targuments())
        ret.push_back(TypeAttr::get(t));
      return ret;
    }(), ctx)}
    }, ctx);
}

void MapAndBatchDatasetOp::fAttr(::mlir::SymbolRefAttr attr) {
  this->getOperation()->setAttr("f", attr);
}

void MapAndBatchDatasetOp::output_typesAttr(::mlir::ArrayAttr attr) {
  this->getOperation()->setAttr("output_types", attr);
}

void MapAndBatchDatasetOp::output_shapesAttr(::mlir::ArrayAttr attr) {
  this->getOperation()->setAttr("output_shapes", attr);
}

void MapAndBatchDatasetOp::preserve_cardinalityAttr(::mlir::BoolAttr attr) {
  this->getOperation()->setAttr("preserve_cardinality", attr);
}

void MapAndBatchDatasetOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type handle, ::mlir::Value input_dataset, ::mlir::ValueRange other_arguments, ::mlir::Value batch_size, ::mlir::Value num_parallel_calls, ::mlir::Value drop_remainder, ::mlir::SymbolRefAttr f, ::mlir::ArrayAttr output_types, ::mlir::ArrayAttr output_shapes, ::mlir::BoolAttr preserve_cardinality) {
  odsState.addOperands(input_dataset);
  odsState.addOperands(other_arguments);
  odsState.addOperands(batch_size);
  odsState.addOperands(num_parallel_calls);
  odsState.addOperands(drop_remainder);
  odsState.addAttribute("f", f);
  odsState.addAttribute("output_types", output_types);
  odsState.addAttribute("output_shapes", output_shapes);
  odsState.addAttribute("preserve_cardinality", preserve_cardinality);
  odsState.addTypes(handle);
}

void MapAndBatchDatasetOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input_dataset, ::mlir::ValueRange other_arguments, ::mlir::Value batch_size, ::mlir::Value num_parallel_calls, ::mlir::Value drop_remainder, ::mlir::SymbolRefAttr f, ::mlir::ArrayAttr output_types, ::mlir::ArrayAttr output_shapes, ::mlir::BoolAttr preserve_cardinality) {
  odsState.addOperands(input_dataset);
  odsState.addOperands(other_arguments);
  odsState.addOperands(batch_size);
  odsState.addOperands(num_parallel_calls);
  odsState.addOperands(drop_remainder);
  odsState.addAttribute("f", f);
  odsState.addAttribute("output_types", output_types);
  odsState.addAttribute("output_shapes", output_shapes);
  odsState.addAttribute("preserve_cardinality", preserve_cardinality);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void MapAndBatchDatasetOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type handle, ::mlir::Value input_dataset, ::mlir::ValueRange other_arguments, ::mlir::Value batch_size, ::mlir::Value num_parallel_calls, ::mlir::Value drop_remainder, ::mlir::SymbolRefAttr f, ::mlir::ArrayAttr output_types, ::mlir::ArrayAttr output_shapes, bool preserve_cardinality) {
  odsState.addOperands(input_dataset);
  odsState.addOperands(other_arguments);
  odsState.addOperands(batch_size);
  odsState.addOperands(num_parallel_calls);
  odsState.addOperands(drop_remainder);
  odsState.addAttribute("f", f);
  odsState.addAttribute("output_types", output_types);
  odsState.addAttribute("output_shapes", output_shapes);
  odsState.addAttribute("preserve_cardinality", odsBuilder.getBoolAttr(preserve_cardinality));
  odsState.addTypes(handle);
}

void MapAndBatchDatasetOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input_dataset, ::mlir::ValueRange other_arguments, ::mlir::Value batch_size, ::mlir::Value num_parallel_calls, ::mlir::Value drop_remainder, ::mlir::SymbolRefAttr f, ::mlir::ArrayAttr output_types, ::mlir::ArrayAttr output_shapes, bool preserve_cardinality) {
  odsState.addOperands(input_dataset);
  odsState.addOperands(other_arguments);
  odsState.addOperands(batch_size);
  odsState.addOperands(num_parallel_calls);
  odsState.addOperands(drop_remainder);
  odsState.addAttribute("f", f);
  odsState.addAttribute("output_types", output_types);
  odsState.addAttribute("output_shapes", output_shapes);
  odsState.addAttribute("preserve_cardinality", odsBuilder.getBoolAttr(preserve_cardinality));
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void MapAndBatchDatasetOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() >= 4u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult MapAndBatchDatasetOp::verify() {
  if (failed(MapAndBatchDatasetOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::VariantType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::VariantRefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of variant values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>())))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::TensorFlowType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of tf.dtype values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup2 = getODSOperands(2);
    for (::mlir::Value v : valueGroup2) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of 64-bit integer values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup3 = getODSOperands(3);
    for (::mlir::Value v : valueGroup3) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of 64-bit integer values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup4 = getODSOperands(4);
    for (::mlir::Value v : valueGroup4) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of bool values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::VariantType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::VariantRefType>()))))) {
        return emitOpError("result #") << index << " must be tensor of variant values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void MapAndBatchDatasetOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::MapDatasetOp definitions
//===----------------------------------------------------------------------===//

MapDatasetOpAdaptor::MapDatasetOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

MapDatasetOpAdaptor::MapDatasetOpAdaptor(MapDatasetOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> MapDatasetOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  bool isVariadic[] = {false, true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (odsOperands.size() - 1) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::mlir::ValueRange MapDatasetOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value MapDatasetOpAdaptor::input_dataset() {
  return *getODSOperands(0).begin();
}

::mlir::ValueRange MapDatasetOpAdaptor::other_arguments() {
  return getODSOperands(1);
}

::mlir::SymbolRefAttr MapDatasetOpAdaptor::f() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::SymbolRefAttr attr = odsAttrs.get("f").cast<::mlir::SymbolRefAttr>();
  return attr;
}

::mlir::ArrayAttr MapDatasetOpAdaptor::output_types() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::ArrayAttr attr = odsAttrs.get("output_types").cast<::mlir::ArrayAttr>();
  return attr;
}

::mlir::ArrayAttr MapDatasetOpAdaptor::output_shapes() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::ArrayAttr attr = odsAttrs.get("output_shapes").cast<::mlir::ArrayAttr>();
  return attr;
}

::mlir::BoolAttr MapDatasetOpAdaptor::use_inter_op_parallelism() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::BoolAttr attr = odsAttrs.get("use_inter_op_parallelism").dyn_cast_or_null<::mlir::BoolAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getBoolAttr(true);
  return attr;
}

::mlir::BoolAttr MapDatasetOpAdaptor::preserve_cardinality() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::BoolAttr attr = odsAttrs.get("preserve_cardinality").dyn_cast_or_null<::mlir::BoolAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getBoolAttr(false);
  return attr;
}

::mlir::LogicalResult MapDatasetOpAdaptor::verify(::mlir::Location loc) {
  {
  auto tblgen_f = odsAttrs.get("f");
  if (!tblgen_f) return emitError(loc, "'tf.MapDataset' op ""requires attribute 'f'");
    if (!((tblgen_f.isa<::mlir::SymbolRefAttr>()))) return emitError(loc, "'tf.MapDataset' op ""attribute 'f' failed to satisfy constraint: symbol reference attribute");
  }
  {
  auto tblgen_output_types = odsAttrs.get("output_types");
  if (!tblgen_output_types) return emitError(loc, "'tf.MapDataset' op ""requires attribute 'output_types'");
    if (!((((tblgen_output_types.isa<::mlir::ArrayAttr>())) && (::llvm::all_of(tblgen_output_types.cast<::mlir::ArrayAttr>(), [](::mlir::Attribute attr) { return ((attr.isa<::mlir::TypeAttr>())) && ((attr.cast<::mlir::TypeAttr>().getValue().isa<::mlir::Type>())); }))) && ((tblgen_output_types.cast<::mlir::ArrayAttr>().size() >= 1)))) return emitError(loc, "'tf.MapDataset' op ""attribute 'output_types' failed to satisfy constraint: type array attribute with at least 1 elements");
  }
  {
  auto tblgen_output_shapes = odsAttrs.get("output_shapes");
  if (!tblgen_output_shapes) return emitError(loc, "'tf.MapDataset' op ""requires attribute 'output_shapes'");
    if (!((((tblgen_output_shapes.isa<::mlir::ArrayAttr>())) && (::llvm::all_of(tblgen_output_shapes.cast<::mlir::ArrayAttr>(), [](::mlir::Attribute attr) { return (attr.isa<mlir::TF::ShapeAttr>()); }))) && ((tblgen_output_shapes.cast<::mlir::ArrayAttr>().size() >= 1)))) return emitError(loc, "'tf.MapDataset' op ""attribute 'output_shapes' failed to satisfy constraint: tensorflow shape attribute array with at least 1 elements");
  }
  {
  auto tblgen_use_inter_op_parallelism = odsAttrs.get("use_inter_op_parallelism");
  if (tblgen_use_inter_op_parallelism) {
    if (!((tblgen_use_inter_op_parallelism.isa<::mlir::BoolAttr>()))) return emitError(loc, "'tf.MapDataset' op ""attribute 'use_inter_op_parallelism' failed to satisfy constraint: bool attribute");
  }
  }
  {
  auto tblgen_preserve_cardinality = odsAttrs.get("preserve_cardinality");
  if (tblgen_preserve_cardinality) {
    if (!((tblgen_preserve_cardinality.isa<::mlir::BoolAttr>()))) return emitError(loc, "'tf.MapDataset' op ""attribute 'preserve_cardinality' failed to satisfy constraint: bool attribute");
  }
  }
  return ::mlir::success();
}

::llvm::StringRef MapDatasetOp::getOperationName() {
  return "tf.MapDataset";
}

std::pair<unsigned, unsigned> MapDatasetOp::getODSOperandIndexAndLength(unsigned index) {
  bool isVariadic[] = {false, true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (getOperation()->getNumOperands() - 1) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::mlir::Operation::operand_range MapDatasetOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value MapDatasetOp::input_dataset() {
  return *getODSOperands(0).begin();
}

::mlir::Operation::operand_range MapDatasetOp::other_arguments() {
  return getODSOperands(1);
}

::mlir::MutableOperandRange MapDatasetOp::input_datasetMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange MapDatasetOp::other_argumentsMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> MapDatasetOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range MapDatasetOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value MapDatasetOp::handle() {
  return *getODSResults(0).begin();
}

::mlir::SymbolRefAttr MapDatasetOp::fAttr() {
  return this->getAttr("f").cast<::mlir::SymbolRefAttr>();
}

::mlir::SymbolRefAttr MapDatasetOp::f() {
  auto attr = fAttr();
  return attr;
}

::mlir::ArrayAttr MapDatasetOp::output_typesAttr() {
  return this->getAttr("output_types").cast<::mlir::ArrayAttr>();
}

::mlir::ArrayAttr MapDatasetOp::output_types() {
  auto attr = output_typesAttr();
  return attr;
}

::mlir::ArrayAttr MapDatasetOp::output_shapesAttr() {
  return this->getAttr("output_shapes").cast<::mlir::ArrayAttr>();
}

::mlir::ArrayAttr MapDatasetOp::output_shapes() {
  auto attr = output_shapesAttr();
  return attr;
}

::mlir::BoolAttr MapDatasetOp::use_inter_op_parallelismAttr() {
  return this->getAttr("use_inter_op_parallelism").dyn_cast_or_null<::mlir::BoolAttr>();
}

bool MapDatasetOp::use_inter_op_parallelism() {
  auto attr = use_inter_op_parallelismAttr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getBoolAttr(true).getValue();
  return attr.getValue();
}

::mlir::BoolAttr MapDatasetOp::preserve_cardinalityAttr() {
  return this->getAttr("preserve_cardinality").dyn_cast_or_null<::mlir::BoolAttr>();
}

bool MapDatasetOp::preserve_cardinality() {
  auto attr = preserve_cardinalityAttr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getBoolAttr(false).getValue();
  return attr.getValue();
}

mlir::OperandElementTypeRange MapDatasetOp::Targuments() {
  auto values = getODSOperands(1);
return {mlir::OperandElementTypeIterator(values.begin()), mlir::OperandElementTypeIterator(values.end())};
}

bool MapDatasetOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "Targuments") return true;
 return false;
}

::mlir::DictionaryAttr MapDatasetOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("Targuments", ctx),
ArrayAttr::get(
    [&]() {
      llvm::SmallVector<Attribute, 4> ret;
      for (auto t : Targuments())
        ret.push_back(TypeAttr::get(t));
      return ret;
    }(), ctx)}
    }, ctx);
}

void MapDatasetOp::fAttr(::mlir::SymbolRefAttr attr) {
  this->getOperation()->setAttr("f", attr);
}

void MapDatasetOp::output_typesAttr(::mlir::ArrayAttr attr) {
  this->getOperation()->setAttr("output_types", attr);
}

void MapDatasetOp::output_shapesAttr(::mlir::ArrayAttr attr) {
  this->getOperation()->setAttr("output_shapes", attr);
}

void MapDatasetOp::use_inter_op_parallelismAttr(::mlir::BoolAttr attr) {
  this->getOperation()->setAttr("use_inter_op_parallelism", attr);
}

void MapDatasetOp::preserve_cardinalityAttr(::mlir::BoolAttr attr) {
  this->getOperation()->setAttr("preserve_cardinality", attr);
}

void MapDatasetOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type handle, ::mlir::Value input_dataset, ::mlir::ValueRange other_arguments, ::mlir::SymbolRefAttr f, ::mlir::ArrayAttr output_types, ::mlir::ArrayAttr output_shapes, ::mlir::BoolAttr use_inter_op_parallelism, ::mlir::BoolAttr preserve_cardinality) {
  odsState.addOperands(input_dataset);
  odsState.addOperands(other_arguments);
  odsState.addAttribute("f", f);
  odsState.addAttribute("output_types", output_types);
  odsState.addAttribute("output_shapes", output_shapes);
  odsState.addAttribute("use_inter_op_parallelism", use_inter_op_parallelism);
  odsState.addAttribute("preserve_cardinality", preserve_cardinality);
  odsState.addTypes(handle);
}

void MapDatasetOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input_dataset, ::mlir::ValueRange other_arguments, ::mlir::SymbolRefAttr f, ::mlir::ArrayAttr output_types, ::mlir::ArrayAttr output_shapes, ::mlir::BoolAttr use_inter_op_parallelism, ::mlir::BoolAttr preserve_cardinality) {
  odsState.addOperands(input_dataset);
  odsState.addOperands(other_arguments);
  odsState.addAttribute("f", f);
  odsState.addAttribute("output_types", output_types);
  odsState.addAttribute("output_shapes", output_shapes);
  odsState.addAttribute("use_inter_op_parallelism", use_inter_op_parallelism);
  odsState.addAttribute("preserve_cardinality", preserve_cardinality);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void MapDatasetOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type handle, ::mlir::Value input_dataset, ::mlir::ValueRange other_arguments, ::mlir::SymbolRefAttr f, ::mlir::ArrayAttr output_types, ::mlir::ArrayAttr output_shapes, bool use_inter_op_parallelism, bool preserve_cardinality) {
  odsState.addOperands(input_dataset);
  odsState.addOperands(other_arguments);
  odsState.addAttribute("f", f);
  odsState.addAttribute("output_types", output_types);
  odsState.addAttribute("output_shapes", output_shapes);
  odsState.addAttribute("use_inter_op_parallelism", odsBuilder.getBoolAttr(use_inter_op_parallelism));
  odsState.addAttribute("preserve_cardinality", odsBuilder.getBoolAttr(preserve_cardinality));
  odsState.addTypes(handle);
}

void MapDatasetOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input_dataset, ::mlir::ValueRange other_arguments, ::mlir::SymbolRefAttr f, ::mlir::ArrayAttr output_types, ::mlir::ArrayAttr output_shapes, bool use_inter_op_parallelism, bool preserve_cardinality) {
  odsState.addOperands(input_dataset);
  odsState.addOperands(other_arguments);
  odsState.addAttribute("f", f);
  odsState.addAttribute("output_types", output_types);
  odsState.addAttribute("output_shapes", output_shapes);
  odsState.addAttribute("use_inter_op_parallelism", odsBuilder.getBoolAttr(use_inter_op_parallelism));
  odsState.addAttribute("preserve_cardinality", odsBuilder.getBoolAttr(preserve_cardinality));
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void MapDatasetOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() >= 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult MapDatasetOp::verify() {
  if (failed(MapDatasetOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::VariantType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::VariantRefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of variant values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>())))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::TensorFlowType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of tf.dtype values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::VariantType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::VariantRefType>()))))) {
        return emitOpError("result #") << index << " must be tensor of variant values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void MapDatasetOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::MatMulOp definitions
//===----------------------------------------------------------------------===//

MatMulOpAdaptor::MatMulOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

MatMulOpAdaptor::MatMulOpAdaptor(MatMulOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> MatMulOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange MatMulOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value MatMulOpAdaptor::a() {
  return *getODSOperands(0).begin();
}

::mlir::Value MatMulOpAdaptor::b() {
  return *getODSOperands(1).begin();
}

::mlir::BoolAttr MatMulOpAdaptor::transpose_a() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::BoolAttr attr = odsAttrs.get("transpose_a").dyn_cast_or_null<::mlir::BoolAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getBoolAttr(false);
  return attr;
}

::mlir::BoolAttr MatMulOpAdaptor::transpose_b() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::BoolAttr attr = odsAttrs.get("transpose_b").dyn_cast_or_null<::mlir::BoolAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getBoolAttr(false);
  return attr;
}

::mlir::LogicalResult MatMulOpAdaptor::verify(::mlir::Location loc) {
  {
  auto tblgen_transpose_a = odsAttrs.get("transpose_a");
  if (tblgen_transpose_a) {
    if (!((tblgen_transpose_a.isa<::mlir::BoolAttr>()))) return emitError(loc, "'tf.MatMul' op ""attribute 'transpose_a' failed to satisfy constraint: bool attribute");
  }
  }
  {
  auto tblgen_transpose_b = odsAttrs.get("transpose_b");
  if (tblgen_transpose_b) {
    if (!((tblgen_transpose_b.isa<::mlir::BoolAttr>()))) return emitError(loc, "'tf.MatMul' op ""attribute 'transpose_b' failed to satisfy constraint: bool attribute");
  }
  }
  return ::mlir::success();
}

::llvm::StringRef MatMulOp::getOperationName() {
  return "tf.MatMul";
}

std::pair<unsigned, unsigned> MatMulOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range MatMulOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value MatMulOp::a() {
  return *getODSOperands(0).begin();
}

::mlir::Value MatMulOp::b() {
  return *getODSOperands(1).begin();
}

::mlir::MutableOperandRange MatMulOp::aMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange MatMulOp::bMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> MatMulOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range MatMulOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value MatMulOp::product() {
  return *getODSResults(0).begin();
}

::mlir::BoolAttr MatMulOp::transpose_aAttr() {
  return this->getAttr("transpose_a").dyn_cast_or_null<::mlir::BoolAttr>();
}

bool MatMulOp::transpose_a() {
  auto attr = transpose_aAttr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getBoolAttr(false).getValue();
  return attr.getValue();
}

::mlir::BoolAttr MatMulOp::transpose_bAttr() {
  return this->getAttr("transpose_b").dyn_cast_or_null<::mlir::BoolAttr>();
}

bool MatMulOp::transpose_b() {
  auto attr = transpose_bAttr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getBoolAttr(false).getValue();
  return attr.getValue();
}

Type MatMulOp::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

bool MatMulOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "T") return true;
 return false;
}

::mlir::DictionaryAttr MatMulOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())}
    }, ctx);
}

void MatMulOp::transpose_aAttr(::mlir::BoolAttr attr) {
  this->getOperation()->setAttr("transpose_a", attr);
}

void MatMulOp::transpose_bAttr(::mlir::BoolAttr attr) {
  this->getOperation()->setAttr("transpose_b", attr);
}

void MatMulOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type product, ::mlir::Value a, ::mlir::Value b, ::mlir::BoolAttr transpose_a, ::mlir::BoolAttr transpose_b) {
  odsState.addOperands(a);
  odsState.addOperands(b);
  odsState.addAttribute("transpose_a", transpose_a);
  odsState.addAttribute("transpose_b", transpose_b);
  odsState.addTypes(product);
}

void MatMulOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value a, ::mlir::Value b, ::mlir::BoolAttr transpose_a, ::mlir::BoolAttr transpose_b) {
  odsState.addOperands(a);
  odsState.addOperands(b);
  odsState.addAttribute("transpose_a", transpose_a);
  odsState.addAttribute("transpose_b", transpose_b);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void MatMulOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type product, ::mlir::Value a, ::mlir::Value b, bool transpose_a, bool transpose_b) {
  odsState.addOperands(a);
  odsState.addOperands(b);
  odsState.addAttribute("transpose_a", odsBuilder.getBoolAttr(transpose_a));
  odsState.addAttribute("transpose_b", odsBuilder.getBoolAttr(transpose_b));
  odsState.addTypes(product);
}

void MatMulOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value a, ::mlir::Value b, bool transpose_a, bool transpose_b) {
  odsState.addOperands(a);
  odsState.addOperands(b);
  odsState.addAttribute("transpose_a", odsBuilder.getBoolAttr(transpose_a));
  odsState.addAttribute("transpose_b", odsBuilder.getBoolAttr(transpose_b));
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void MatMulOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult MatMulOp::verify() {
  if (failed(MatMulOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of bfloat16 or 128-bit complex or 64-bit complex or 16-bit float or 32-bit float or 64-bit float or 32-bit integer or 64-bit integer values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of bfloat16 or 128-bit complex or 64-bit complex or 16-bit float or 32-bit float or 64-bit float or 32-bit integer or 64-bit integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))))) {
        return emitOpError("result #") << index << " must be tensor of bfloat16 or 128-bit complex or 64-bit complex or 16-bit float or 32-bit float or 64-bit float or 32-bit integer or 64-bit integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void MatMulOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::MatrixBandPartOp definitions
//===----------------------------------------------------------------------===//

MatrixBandPartOpAdaptor::MatrixBandPartOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

MatrixBandPartOpAdaptor::MatrixBandPartOpAdaptor(MatrixBandPartOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> MatrixBandPartOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange MatrixBandPartOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value MatrixBandPartOpAdaptor::input() {
  return *getODSOperands(0).begin();
}

::mlir::Value MatrixBandPartOpAdaptor::num_lower() {
  return *getODSOperands(1).begin();
}

::mlir::Value MatrixBandPartOpAdaptor::num_upper() {
  return *getODSOperands(2).begin();
}

::mlir::LogicalResult MatrixBandPartOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

::llvm::StringRef MatrixBandPartOp::getOperationName() {
  return "tf.MatrixBandPart";
}

std::pair<unsigned, unsigned> MatrixBandPartOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range MatrixBandPartOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value MatrixBandPartOp::input() {
  return *getODSOperands(0).begin();
}

::mlir::Value MatrixBandPartOp::num_lower() {
  return *getODSOperands(1).begin();
}

::mlir::Value MatrixBandPartOp::num_upper() {
  return *getODSOperands(2).begin();
}

::mlir::MutableOperandRange MatrixBandPartOp::inputMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange MatrixBandPartOp::num_lowerMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange MatrixBandPartOp::num_upperMutable() {
  auto range = getODSOperandIndexAndLength(2);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> MatrixBandPartOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range MatrixBandPartOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value MatrixBandPartOp::band() {
  return *getODSResults(0).begin();
}

Type MatrixBandPartOp::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

Type MatrixBandPartOp::Tindex() {
  return mlir::getElementTypeOrSelf(*getODSOperands(1).begin());
}

bool MatrixBandPartOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "T") return true;
  if (name == "Tindex") return true;
 return false;
}

::mlir::DictionaryAttr MatrixBandPartOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())},
    {::mlir::Identifier::get("Tindex", ctx),
::mlir::TypeAttr::get(Tindex())}
    }, ctx);
}

void MatrixBandPartOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type band, ::mlir::Value input, ::mlir::Value num_lower, ::mlir::Value num_upper) {
  odsState.addOperands(input);
  odsState.addOperands(num_lower);
  odsState.addOperands(num_upper);
  odsState.addTypes(band);
}

void MatrixBandPartOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input, ::mlir::Value num_lower, ::mlir::Value num_upper) {
  odsState.addOperands(input);
  odsState.addOperands(num_lower);
  odsState.addOperands(num_upper);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void MatrixBandPartOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 3u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult MatrixBandPartOp::verify() {
  if (failed(MatrixBandPartOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>())))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::TensorFlowType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of tf.dtype values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of 32/64-bit signed integer values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup2 = getODSOperands(2);
    for (::mlir::Value v : valueGroup2) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of 32/64-bit signed integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>())))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::TensorFlowType>()))))) {
        return emitOpError("result #") << index << " must be tensor of tf.dtype values, but got " << v.getType();
      }
      ++index;
    }
  }
  if (!((TF::AreCastCompatible(llvm::makeArrayRef({(*this->getODSOperands(0).begin()).getType(), (*this->getODSResults(0).begin()).getType()})))))
    return emitOpError("failed to verify that all of {input, band} have dynamically equal types ");
  return Verify(*this);
}

void MatrixBandPartOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::MatrixDiagOp definitions
//===----------------------------------------------------------------------===//

MatrixDiagOpAdaptor::MatrixDiagOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

MatrixDiagOpAdaptor::MatrixDiagOpAdaptor(MatrixDiagOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> MatrixDiagOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange MatrixDiagOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value MatrixDiagOpAdaptor::diagonal() {
  return *getODSOperands(0).begin();
}

::mlir::LogicalResult MatrixDiagOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

::llvm::StringRef MatrixDiagOp::getOperationName() {
  return "tf.MatrixDiag";
}

std::pair<unsigned, unsigned> MatrixDiagOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range MatrixDiagOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value MatrixDiagOp::diagonal() {
  return *getODSOperands(0).begin();
}

::mlir::MutableOperandRange MatrixDiagOp::diagonalMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> MatrixDiagOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range MatrixDiagOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value MatrixDiagOp::output() {
  return *getODSResults(0).begin();
}

Type MatrixDiagOp::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

bool MatrixDiagOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "T") return true;
 return false;
}

::mlir::DictionaryAttr MatrixDiagOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())}
    }, ctx);
}

void MatrixDiagOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value diagonal) {
  odsState.addOperands(diagonal);
  odsState.addTypes(output);
}

void MatrixDiagOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value diagonal) {
  odsState.addOperands(diagonal);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void MatrixDiagOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult MatrixDiagOp::verify() {
  if (failed(MatrixDiagOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>())))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::TensorFlowType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of tf.dtype values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>())))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::TensorFlowType>()))))) {
        return emitOpError("result #") << index << " must be tensor of tf.dtype values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void MatrixDiagOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::MatrixDiagPartV3Op definitions
//===----------------------------------------------------------------------===//

MatrixDiagPartV3OpAdaptor::MatrixDiagPartV3OpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

MatrixDiagPartV3OpAdaptor::MatrixDiagPartV3OpAdaptor(MatrixDiagPartV3Op&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> MatrixDiagPartV3OpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange MatrixDiagPartV3OpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value MatrixDiagPartV3OpAdaptor::input() {
  return *getODSOperands(0).begin();
}

::mlir::Value MatrixDiagPartV3OpAdaptor::k() {
  return *getODSOperands(1).begin();
}

::mlir::Value MatrixDiagPartV3OpAdaptor::padding_value() {
  return *getODSOperands(2).begin();
}

::mlir::StringAttr MatrixDiagPartV3OpAdaptor::align() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::StringAttr attr = odsAttrs.get("align").dyn_cast_or_null<::mlir::StringAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getStringAttr("RIGHT_LEFT");
  return attr;
}

::mlir::LogicalResult MatrixDiagPartV3OpAdaptor::verify(::mlir::Location loc) {
  {
  auto tblgen_align = odsAttrs.get("align");
  if (tblgen_align) {
    if (!((tblgen_align.cast<StringAttr>().getValue() == "LEFT_RIGHT" || tblgen_align.cast<StringAttr>().getValue() == "RIGHT_LEFT" || tblgen_align.cast<StringAttr>().getValue() == "LEFT_LEFT" || tblgen_align.cast<StringAttr>().getValue() == "RIGHT_RIGHT"))) return emitError(loc, "'tf.MatrixDiagPartV3' op ""attribute 'align' failed to satisfy constraint: string attribute whose value is LEFT_RIGHT, or RIGHT_LEFT, or LEFT_LEFT, or RIGHT_RIGHT");
  }
  }
  return ::mlir::success();
}

::llvm::StringRef MatrixDiagPartV3Op::getOperationName() {
  return "tf.MatrixDiagPartV3";
}

std::pair<unsigned, unsigned> MatrixDiagPartV3Op::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range MatrixDiagPartV3Op::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value MatrixDiagPartV3Op::input() {
  return *getODSOperands(0).begin();
}

::mlir::Value MatrixDiagPartV3Op::k() {
  return *getODSOperands(1).begin();
}

::mlir::Value MatrixDiagPartV3Op::padding_value() {
  return *getODSOperands(2).begin();
}

::mlir::MutableOperandRange MatrixDiagPartV3Op::inputMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange MatrixDiagPartV3Op::kMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange MatrixDiagPartV3Op::padding_valueMutable() {
  auto range = getODSOperandIndexAndLength(2);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> MatrixDiagPartV3Op::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range MatrixDiagPartV3Op::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value MatrixDiagPartV3Op::diagonal() {
  return *getODSResults(0).begin();
}

::mlir::StringAttr MatrixDiagPartV3Op::alignAttr() {
  return this->getAttr("align").dyn_cast_or_null<::mlir::StringAttr>();
}

::llvm::StringRef MatrixDiagPartV3Op::align() {
  auto attr = alignAttr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getStringAttr("RIGHT_LEFT").getValue();
  return attr.getValue();
}

Type MatrixDiagPartV3Op::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

bool MatrixDiagPartV3Op::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "T") return true;
 return false;
}

::mlir::DictionaryAttr MatrixDiagPartV3Op::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())}
    }, ctx);
}

void MatrixDiagPartV3Op::alignAttr(::mlir::StringAttr attr) {
  this->getOperation()->setAttr("align", attr);
}

void MatrixDiagPartV3Op::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type diagonal, ::mlir::Value input, ::mlir::Value k, ::mlir::Value padding_value, ::mlir::StringAttr align) {
  odsState.addOperands(input);
  odsState.addOperands(k);
  odsState.addOperands(padding_value);
  odsState.addAttribute("align", align);
  odsState.addTypes(diagonal);
}

void MatrixDiagPartV3Op::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input, ::mlir::Value k, ::mlir::Value padding_value, ::mlir::StringAttr align) {
  odsState.addOperands(input);
  odsState.addOperands(k);
  odsState.addOperands(padding_value);
  odsState.addAttribute("align", align);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void MatrixDiagPartV3Op::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type diagonal, ::mlir::Value input, ::mlir::Value k, ::mlir::Value padding_value, ::llvm::StringRef align) {
  odsState.addOperands(input);
  odsState.addOperands(k);
  odsState.addOperands(padding_value);
  odsState.addAttribute("align", odsBuilder.getStringAttr(align));
  odsState.addTypes(diagonal);
}

void MatrixDiagPartV3Op::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input, ::mlir::Value k, ::mlir::Value padding_value, ::llvm::StringRef align) {
  odsState.addOperands(input);
  odsState.addOperands(k);
  odsState.addOperands(padding_value);
  odsState.addAttribute("align", odsBuilder.getStringAttr(align));
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void MatrixDiagPartV3Op::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 3u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult MatrixDiagPartV3Op::verify() {
  if (failed(MatrixDiagPartV3OpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>())))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::TensorFlowType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of tf.dtype values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of 32-bit integer values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup2 = getODSOperands(2);
    for (::mlir::Value v : valueGroup2) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>())))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::TensorFlowType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of tf.dtype values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>())))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::TensorFlowType>()))))) {
        return emitOpError("result #") << index << " must be tensor of tf.dtype values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void MatrixDiagPartV3Op::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::MatrixDiagV2Op definitions
//===----------------------------------------------------------------------===//

MatrixDiagV2OpAdaptor::MatrixDiagV2OpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

MatrixDiagV2OpAdaptor::MatrixDiagV2OpAdaptor(MatrixDiagV2Op&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> MatrixDiagV2OpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange MatrixDiagV2OpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value MatrixDiagV2OpAdaptor::diagonal() {
  return *getODSOperands(0).begin();
}

::mlir::Value MatrixDiagV2OpAdaptor::k() {
  return *getODSOperands(1).begin();
}

::mlir::Value MatrixDiagV2OpAdaptor::num_rows() {
  return *getODSOperands(2).begin();
}

::mlir::Value MatrixDiagV2OpAdaptor::num_cols() {
  return *getODSOperands(3).begin();
}

::mlir::Value MatrixDiagV2OpAdaptor::padding_value() {
  return *getODSOperands(4).begin();
}

::mlir::LogicalResult MatrixDiagV2OpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

::llvm::StringRef MatrixDiagV2Op::getOperationName() {
  return "tf.MatrixDiagV2";
}

std::pair<unsigned, unsigned> MatrixDiagV2Op::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range MatrixDiagV2Op::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value MatrixDiagV2Op::diagonal() {
  return *getODSOperands(0).begin();
}

::mlir::Value MatrixDiagV2Op::k() {
  return *getODSOperands(1).begin();
}

::mlir::Value MatrixDiagV2Op::num_rows() {
  return *getODSOperands(2).begin();
}

::mlir::Value MatrixDiagV2Op::num_cols() {
  return *getODSOperands(3).begin();
}

::mlir::Value MatrixDiagV2Op::padding_value() {
  return *getODSOperands(4).begin();
}

::mlir::MutableOperandRange MatrixDiagV2Op::diagonalMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange MatrixDiagV2Op::kMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange MatrixDiagV2Op::num_rowsMutable() {
  auto range = getODSOperandIndexAndLength(2);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange MatrixDiagV2Op::num_colsMutable() {
  auto range = getODSOperandIndexAndLength(3);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange MatrixDiagV2Op::padding_valueMutable() {
  auto range = getODSOperandIndexAndLength(4);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> MatrixDiagV2Op::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range MatrixDiagV2Op::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value MatrixDiagV2Op::output() {
  return *getODSResults(0).begin();
}

Type MatrixDiagV2Op::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

bool MatrixDiagV2Op::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "T") return true;
 return false;
}

::mlir::DictionaryAttr MatrixDiagV2Op::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())}
    }, ctx);
}

void MatrixDiagV2Op::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value diagonal, ::mlir::Value k, ::mlir::Value num_rows, ::mlir::Value num_cols, ::mlir::Value padding_value) {
  odsState.addOperands(diagonal);
  odsState.addOperands(k);
  odsState.addOperands(num_rows);
  odsState.addOperands(num_cols);
  odsState.addOperands(padding_value);
  odsState.addTypes(output);
}

void MatrixDiagV2Op::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value diagonal, ::mlir::Value k, ::mlir::Value num_rows, ::mlir::Value num_cols, ::mlir::Value padding_value) {
  odsState.addOperands(diagonal);
  odsState.addOperands(k);
  odsState.addOperands(num_rows);
  odsState.addOperands(num_cols);
  odsState.addOperands(padding_value);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void MatrixDiagV2Op::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 5u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult MatrixDiagV2Op::verify() {
  if (failed(MatrixDiagV2OpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>())))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::TensorFlowType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of tf.dtype values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of 32-bit integer values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup2 = getODSOperands(2);
    for (::mlir::Value v : valueGroup2) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of 32-bit integer values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup3 = getODSOperands(3);
    for (::mlir::Value v : valueGroup3) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of 32-bit integer values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup4 = getODSOperands(4);
    for (::mlir::Value v : valueGroup4) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>())))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::TensorFlowType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of tf.dtype values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>())))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::TensorFlowType>()))))) {
        return emitOpError("result #") << index << " must be tensor of tf.dtype values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void MatrixDiagV2Op::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::MatrixDiagV3Op definitions
//===----------------------------------------------------------------------===//

MatrixDiagV3OpAdaptor::MatrixDiagV3OpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

MatrixDiagV3OpAdaptor::MatrixDiagV3OpAdaptor(MatrixDiagV3Op&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> MatrixDiagV3OpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange MatrixDiagV3OpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value MatrixDiagV3OpAdaptor::diagonal() {
  return *getODSOperands(0).begin();
}

::mlir::Value MatrixDiagV3OpAdaptor::k() {
  return *getODSOperands(1).begin();
}

::mlir::Value MatrixDiagV3OpAdaptor::num_rows() {
  return *getODSOperands(2).begin();
}

::mlir::Value MatrixDiagV3OpAdaptor::num_cols() {
  return *getODSOperands(3).begin();
}

::mlir::Value MatrixDiagV3OpAdaptor::padding_value() {
  return *getODSOperands(4).begin();
}

::mlir::StringAttr MatrixDiagV3OpAdaptor::align() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::StringAttr attr = odsAttrs.get("align").dyn_cast_or_null<::mlir::StringAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getStringAttr("RIGHT_LEFT");
  return attr;
}

::mlir::LogicalResult MatrixDiagV3OpAdaptor::verify(::mlir::Location loc) {
  {
  auto tblgen_align = odsAttrs.get("align");
  if (tblgen_align) {
    if (!((tblgen_align.cast<StringAttr>().getValue() == "LEFT_RIGHT" || tblgen_align.cast<StringAttr>().getValue() == "RIGHT_LEFT" || tblgen_align.cast<StringAttr>().getValue() == "LEFT_LEFT" || tblgen_align.cast<StringAttr>().getValue() == "RIGHT_RIGHT"))) return emitError(loc, "'tf.MatrixDiagV3' op ""attribute 'align' failed to satisfy constraint: string attribute whose value is LEFT_RIGHT, or RIGHT_LEFT, or LEFT_LEFT, or RIGHT_RIGHT");
  }
  }
  return ::mlir::success();
}

::llvm::StringRef MatrixDiagV3Op::getOperationName() {
  return "tf.MatrixDiagV3";
}

std::pair<unsigned, unsigned> MatrixDiagV3Op::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range MatrixDiagV3Op::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value MatrixDiagV3Op::diagonal() {
  return *getODSOperands(0).begin();
}

::mlir::Value MatrixDiagV3Op::k() {
  return *getODSOperands(1).begin();
}

::mlir::Value MatrixDiagV3Op::num_rows() {
  return *getODSOperands(2).begin();
}

::mlir::Value MatrixDiagV3Op::num_cols() {
  return *getODSOperands(3).begin();
}

::mlir::Value MatrixDiagV3Op::padding_value() {
  return *getODSOperands(4).begin();
}

::mlir::MutableOperandRange MatrixDiagV3Op::diagonalMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange MatrixDiagV3Op::kMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange MatrixDiagV3Op::num_rowsMutable() {
  auto range = getODSOperandIndexAndLength(2);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange MatrixDiagV3Op::num_colsMutable() {
  auto range = getODSOperandIndexAndLength(3);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange MatrixDiagV3Op::padding_valueMutable() {
  auto range = getODSOperandIndexAndLength(4);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> MatrixDiagV3Op::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range MatrixDiagV3Op::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value MatrixDiagV3Op::output() {
  return *getODSResults(0).begin();
}

::mlir::StringAttr MatrixDiagV3Op::alignAttr() {
  return this->getAttr("align").dyn_cast_or_null<::mlir::StringAttr>();
}

::llvm::StringRef MatrixDiagV3Op::align() {
  auto attr = alignAttr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getStringAttr("RIGHT_LEFT").getValue();
  return attr.getValue();
}

Type MatrixDiagV3Op::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

bool MatrixDiagV3Op::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "T") return true;
 return false;
}

::mlir::DictionaryAttr MatrixDiagV3Op::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())}
    }, ctx);
}

void MatrixDiagV3Op::alignAttr(::mlir::StringAttr attr) {
  this->getOperation()->setAttr("align", attr);
}

void MatrixDiagV3Op::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value diagonal, ::mlir::Value k, ::mlir::Value num_rows, ::mlir::Value num_cols, ::mlir::Value padding_value, ::mlir::StringAttr align) {
  odsState.addOperands(diagonal);
  odsState.addOperands(k);
  odsState.addOperands(num_rows);
  odsState.addOperands(num_cols);
  odsState.addOperands(padding_value);
  odsState.addAttribute("align", align);
  odsState.addTypes(output);
}

void MatrixDiagV3Op::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value diagonal, ::mlir::Value k, ::mlir::Value num_rows, ::mlir::Value num_cols, ::mlir::Value padding_value, ::mlir::StringAttr align) {
  odsState.addOperands(diagonal);
  odsState.addOperands(k);
  odsState.addOperands(num_rows);
  odsState.addOperands(num_cols);
  odsState.addOperands(padding_value);
  odsState.addAttribute("align", align);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void MatrixDiagV3Op::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value diagonal, ::mlir::Value k, ::mlir::Value num_rows, ::mlir::Value num_cols, ::mlir::Value padding_value, ::llvm::StringRef align) {
  odsState.addOperands(diagonal);
  odsState.addOperands(k);
  odsState.addOperands(num_rows);
  odsState.addOperands(num_cols);
  odsState.addOperands(padding_value);
  odsState.addAttribute("align", odsBuilder.getStringAttr(align));
  odsState.addTypes(output);
}

void MatrixDiagV3Op::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value diagonal, ::mlir::Value k, ::mlir::Value num_rows, ::mlir::Value num_cols, ::mlir::Value padding_value, ::llvm::StringRef align) {
  odsState.addOperands(diagonal);
  odsState.addOperands(k);
  odsState.addOperands(num_rows);
  odsState.addOperands(num_cols);
  odsState.addOperands(padding_value);
  odsState.addAttribute("align", odsBuilder.getStringAttr(align));
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void MatrixDiagV3Op::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 5u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult MatrixDiagV3Op::verify() {
  if (failed(MatrixDiagV3OpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>())))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::TensorFlowType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of tf.dtype values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of 32-bit integer values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup2 = getODSOperands(2);
    for (::mlir::Value v : valueGroup2) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of 32-bit integer values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup3 = getODSOperands(3);
    for (::mlir::Value v : valueGroup3) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of 32-bit integer values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup4 = getODSOperands(4);
    for (::mlir::Value v : valueGroup4) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>())))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::TensorFlowType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of tf.dtype values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>())))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::TensorFlowType>()))))) {
        return emitOpError("result #") << index << " must be tensor of tf.dtype values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void MatrixDiagV3Op::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::MatrixInverseOp definitions
//===----------------------------------------------------------------------===//

MatrixInverseOpAdaptor::MatrixInverseOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

MatrixInverseOpAdaptor::MatrixInverseOpAdaptor(MatrixInverseOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> MatrixInverseOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange MatrixInverseOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value MatrixInverseOpAdaptor::input() {
  return *getODSOperands(0).begin();
}

::mlir::BoolAttr MatrixInverseOpAdaptor::adjoint() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::BoolAttr attr = odsAttrs.get("adjoint").dyn_cast_or_null<::mlir::BoolAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getBoolAttr(false);
  return attr;
}

::mlir::LogicalResult MatrixInverseOpAdaptor::verify(::mlir::Location loc) {
  {
  auto tblgen_adjoint = odsAttrs.get("adjoint");
  if (tblgen_adjoint) {
    if (!((tblgen_adjoint.isa<::mlir::BoolAttr>()))) return emitError(loc, "'tf.MatrixInverse' op ""attribute 'adjoint' failed to satisfy constraint: bool attribute");
  }
  }
  return ::mlir::success();
}

::llvm::StringRef MatrixInverseOp::getOperationName() {
  return "tf.MatrixInverse";
}

std::pair<unsigned, unsigned> MatrixInverseOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range MatrixInverseOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value MatrixInverseOp::input() {
  return *getODSOperands(0).begin();
}

::mlir::MutableOperandRange MatrixInverseOp::inputMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> MatrixInverseOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range MatrixInverseOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value MatrixInverseOp::output() {
  return *getODSResults(0).begin();
}

::mlir::BoolAttr MatrixInverseOp::adjointAttr() {
  return this->getAttr("adjoint").dyn_cast_or_null<::mlir::BoolAttr>();
}

bool MatrixInverseOp::adjoint() {
  auto attr = adjointAttr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getBoolAttr(false).getValue();
  return attr.getValue();
}

Type MatrixInverseOp::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

bool MatrixInverseOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "T") return true;
 return false;
}

::mlir::DictionaryAttr MatrixInverseOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())}
    }, ctx);
}

void MatrixInverseOp::adjointAttr(::mlir::BoolAttr attr) {
  this->getOperation()->setAttr("adjoint", attr);
}

void MatrixInverseOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value input, ::mlir::BoolAttr adjoint) {
  odsState.addOperands(input);
  odsState.addAttribute("adjoint", adjoint);
  odsState.addTypes(output);
}

void MatrixInverseOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input, ::mlir::BoolAttr adjoint) {
  odsState.addOperands(input);
  odsState.addAttribute("adjoint", adjoint);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void MatrixInverseOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value input, bool adjoint) {
  odsState.addOperands(input);
  odsState.addAttribute("adjoint", odsBuilder.getBoolAttr(adjoint));
  odsState.addTypes(output);
}

void MatrixInverseOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input, bool adjoint) {
  odsState.addOperands(input);
  odsState.addAttribute("adjoint", odsBuilder.getBoolAttr(adjoint));
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void MatrixInverseOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult MatrixInverseOp::verify() {
  if (failed(MatrixInverseOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of 128-bit complex or 64-bit complex or 16-bit float or 32-bit float or 64-bit float values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())))))) {
        return emitOpError("result #") << index << " must be tensor of 128-bit complex or 64-bit complex or 16-bit float or 32-bit float or 64-bit float values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void MatrixInverseOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::MatrixSetDiagOp definitions
//===----------------------------------------------------------------------===//

MatrixSetDiagOpAdaptor::MatrixSetDiagOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

MatrixSetDiagOpAdaptor::MatrixSetDiagOpAdaptor(MatrixSetDiagOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> MatrixSetDiagOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange MatrixSetDiagOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value MatrixSetDiagOpAdaptor::input() {
  return *getODSOperands(0).begin();
}

::mlir::Value MatrixSetDiagOpAdaptor::diagonal() {
  return *getODSOperands(1).begin();
}

::mlir::LogicalResult MatrixSetDiagOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

::llvm::StringRef MatrixSetDiagOp::getOperationName() {
  return "tf.MatrixSetDiag";
}

std::pair<unsigned, unsigned> MatrixSetDiagOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range MatrixSetDiagOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value MatrixSetDiagOp::input() {
  return *getODSOperands(0).begin();
}

::mlir::Value MatrixSetDiagOp::diagonal() {
  return *getODSOperands(1).begin();
}

::mlir::MutableOperandRange MatrixSetDiagOp::inputMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange MatrixSetDiagOp::diagonalMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> MatrixSetDiagOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range MatrixSetDiagOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value MatrixSetDiagOp::output() {
  return *getODSResults(0).begin();
}

Type MatrixSetDiagOp::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

bool MatrixSetDiagOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "T") return true;
 return false;
}

::mlir::DictionaryAttr MatrixSetDiagOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())}
    }, ctx);
}

void MatrixSetDiagOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value input, ::mlir::Value diagonal) {
  odsState.addOperands(input);
  odsState.addOperands(diagonal);
  odsState.addTypes(output);
}

void MatrixSetDiagOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input, ::mlir::Value diagonal) {
  odsState.addOperands(input);
  odsState.addOperands(diagonal);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void MatrixSetDiagOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult MatrixSetDiagOp::verify() {
  if (failed(MatrixSetDiagOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>())))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::TensorFlowType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of tf.dtype values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>())))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::TensorFlowType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of tf.dtype values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>())))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::TensorFlowType>()))))) {
        return emitOpError("result #") << index << " must be tensor of tf.dtype values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void MatrixSetDiagOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::MatrixSetDiagV2Op definitions
//===----------------------------------------------------------------------===//

MatrixSetDiagV2OpAdaptor::MatrixSetDiagV2OpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

MatrixSetDiagV2OpAdaptor::MatrixSetDiagV2OpAdaptor(MatrixSetDiagV2Op&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> MatrixSetDiagV2OpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange MatrixSetDiagV2OpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value MatrixSetDiagV2OpAdaptor::input() {
  return *getODSOperands(0).begin();
}

::mlir::Value MatrixSetDiagV2OpAdaptor::diagonal() {
  return *getODSOperands(1).begin();
}

::mlir::Value MatrixSetDiagV2OpAdaptor::k() {
  return *getODSOperands(2).begin();
}

::mlir::LogicalResult MatrixSetDiagV2OpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

::llvm::StringRef MatrixSetDiagV2Op::getOperationName() {
  return "tf.MatrixSetDiagV2";
}

std::pair<unsigned, unsigned> MatrixSetDiagV2Op::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range MatrixSetDiagV2Op::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value MatrixSetDiagV2Op::input() {
  return *getODSOperands(0).begin();
}

::mlir::Value MatrixSetDiagV2Op::diagonal() {
  return *getODSOperands(1).begin();
}

::mlir::Value MatrixSetDiagV2Op::k() {
  return *getODSOperands(2).begin();
}

::mlir::MutableOperandRange MatrixSetDiagV2Op::inputMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange MatrixSetDiagV2Op::diagonalMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange MatrixSetDiagV2Op::kMutable() {
  auto range = getODSOperandIndexAndLength(2);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> MatrixSetDiagV2Op::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range MatrixSetDiagV2Op::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value MatrixSetDiagV2Op::output() {
  return *getODSResults(0).begin();
}

Type MatrixSetDiagV2Op::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

bool MatrixSetDiagV2Op::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "T") return true;
 return false;
}

::mlir::DictionaryAttr MatrixSetDiagV2Op::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())}
    }, ctx);
}

void MatrixSetDiagV2Op::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value input, ::mlir::Value diagonal, ::mlir::Value k) {
  odsState.addOperands(input);
  odsState.addOperands(diagonal);
  odsState.addOperands(k);
  odsState.addTypes(output);
}

void MatrixSetDiagV2Op::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input, ::mlir::Value diagonal, ::mlir::Value k) {
  odsState.addOperands(input);
  odsState.addOperands(diagonal);
  odsState.addOperands(k);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void MatrixSetDiagV2Op::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 3u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult MatrixSetDiagV2Op::verify() {
  if (failed(MatrixSetDiagV2OpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>())))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::TensorFlowType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of tf.dtype values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>())))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::TensorFlowType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of tf.dtype values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup2 = getODSOperands(2);
    for (::mlir::Value v : valueGroup2) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of 32-bit integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>())))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::TensorFlowType>()))))) {
        return emitOpError("result #") << index << " must be tensor of tf.dtype values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void MatrixSetDiagV2Op::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::MatrixSetDiagV3Op definitions
//===----------------------------------------------------------------------===//

MatrixSetDiagV3OpAdaptor::MatrixSetDiagV3OpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

MatrixSetDiagV3OpAdaptor::MatrixSetDiagV3OpAdaptor(MatrixSetDiagV3Op&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> MatrixSetDiagV3OpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange MatrixSetDiagV3OpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value MatrixSetDiagV3OpAdaptor::input() {
  return *getODSOperands(0).begin();
}

::mlir::Value MatrixSetDiagV3OpAdaptor::diagonal() {
  return *getODSOperands(1).begin();
}

::mlir::Value MatrixSetDiagV3OpAdaptor::k() {
  return *getODSOperands(2).begin();
}

::mlir::StringAttr MatrixSetDiagV3OpAdaptor::align() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::StringAttr attr = odsAttrs.get("align").dyn_cast_or_null<::mlir::StringAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getStringAttr("RIGHT_LEFT");
  return attr;
}

::mlir::LogicalResult MatrixSetDiagV3OpAdaptor::verify(::mlir::Location loc) {
  {
  auto tblgen_align = odsAttrs.get("align");
  if (tblgen_align) {
    if (!((tblgen_align.cast<StringAttr>().getValue() == "LEFT_RIGHT" || tblgen_align.cast<StringAttr>().getValue() == "RIGHT_LEFT" || tblgen_align.cast<StringAttr>().getValue() == "LEFT_LEFT" || tblgen_align.cast<StringAttr>().getValue() == "RIGHT_RIGHT"))) return emitError(loc, "'tf.MatrixSetDiagV3' op ""attribute 'align' failed to satisfy constraint: string attribute whose value is LEFT_RIGHT, or RIGHT_LEFT, or LEFT_LEFT, or RIGHT_RIGHT");
  }
  }
  return ::mlir::success();
}

::llvm::StringRef MatrixSetDiagV3Op::getOperationName() {
  return "tf.MatrixSetDiagV3";
}

std::pair<unsigned, unsigned> MatrixSetDiagV3Op::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range MatrixSetDiagV3Op::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value MatrixSetDiagV3Op::input() {
  return *getODSOperands(0).begin();
}

::mlir::Value MatrixSetDiagV3Op::diagonal() {
  return *getODSOperands(1).begin();
}

::mlir::Value MatrixSetDiagV3Op::k() {
  return *getODSOperands(2).begin();
}

::mlir::MutableOperandRange MatrixSetDiagV3Op::inputMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange MatrixSetDiagV3Op::diagonalMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange MatrixSetDiagV3Op::kMutable() {
  auto range = getODSOperandIndexAndLength(2);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> MatrixSetDiagV3Op::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range MatrixSetDiagV3Op::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value MatrixSetDiagV3Op::output() {
  return *getODSResults(0).begin();
}

::mlir::StringAttr MatrixSetDiagV3Op::alignAttr() {
  return this->getAttr("align").dyn_cast_or_null<::mlir::StringAttr>();
}

::llvm::StringRef MatrixSetDiagV3Op::align() {
  auto attr = alignAttr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getStringAttr("RIGHT_LEFT").getValue();
  return attr.getValue();
}

Type MatrixSetDiagV3Op::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

bool MatrixSetDiagV3Op::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "T") return true;
 return false;
}

::mlir::DictionaryAttr MatrixSetDiagV3Op::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())}
    }, ctx);
}

void MatrixSetDiagV3Op::alignAttr(::mlir::StringAttr attr) {
  this->getOperation()->setAttr("align", attr);
}

void MatrixSetDiagV3Op::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value input, ::mlir::Value diagonal, ::mlir::Value k, ::mlir::StringAttr align) {
  odsState.addOperands(input);
  odsState.addOperands(diagonal);
  odsState.addOperands(k);
  odsState.addAttribute("align", align);
  odsState.addTypes(output);
}

void MatrixSetDiagV3Op::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input, ::mlir::Value diagonal, ::mlir::Value k, ::mlir::StringAttr align) {
  odsState.addOperands(input);
  odsState.addOperands(diagonal);
  odsState.addOperands(k);
  odsState.addAttribute("align", align);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void MatrixSetDiagV3Op::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value input, ::mlir::Value diagonal, ::mlir::Value k, ::llvm::StringRef align) {
  odsState.addOperands(input);
  odsState.addOperands(diagonal);
  odsState.addOperands(k);
  odsState.addAttribute("align", odsBuilder.getStringAttr(align));
  odsState.addTypes(output);
}

void MatrixSetDiagV3Op::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input, ::mlir::Value diagonal, ::mlir::Value k, ::llvm::StringRef align) {
  odsState.addOperands(input);
  odsState.addOperands(diagonal);
  odsState.addOperands(k);
  odsState.addAttribute("align", odsBuilder.getStringAttr(align));
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void MatrixSetDiagV3Op::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 3u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult MatrixSetDiagV3Op::verify() {
  if (failed(MatrixSetDiagV3OpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>())))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::TensorFlowType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of tf.dtype values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>())))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::TensorFlowType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of tf.dtype values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup2 = getODSOperands(2);
    for (::mlir::Value v : valueGroup2) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of 32-bit integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>())))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::TensorFlowType>()))))) {
        return emitOpError("result #") << index << " must be tensor of tf.dtype values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void MatrixSetDiagV3Op::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::MatrixSolveOp definitions
//===----------------------------------------------------------------------===//

MatrixSolveOpAdaptor::MatrixSolveOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

MatrixSolveOpAdaptor::MatrixSolveOpAdaptor(MatrixSolveOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> MatrixSolveOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange MatrixSolveOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value MatrixSolveOpAdaptor::matrix() {
  return *getODSOperands(0).begin();
}

::mlir::Value MatrixSolveOpAdaptor::rhs() {
  return *getODSOperands(1).begin();
}

::mlir::BoolAttr MatrixSolveOpAdaptor::adjoint() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::BoolAttr attr = odsAttrs.get("adjoint").dyn_cast_or_null<::mlir::BoolAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getBoolAttr(false);
  return attr;
}

::mlir::LogicalResult MatrixSolveOpAdaptor::verify(::mlir::Location loc) {
  {
  auto tblgen_adjoint = odsAttrs.get("adjoint");
  if (tblgen_adjoint) {
    if (!((tblgen_adjoint.isa<::mlir::BoolAttr>()))) return emitError(loc, "'tf.MatrixSolve' op ""attribute 'adjoint' failed to satisfy constraint: bool attribute");
  }
  }
  return ::mlir::success();
}

::llvm::StringRef MatrixSolveOp::getOperationName() {
  return "tf.MatrixSolve";
}

std::pair<unsigned, unsigned> MatrixSolveOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range MatrixSolveOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value MatrixSolveOp::matrix() {
  return *getODSOperands(0).begin();
}

::mlir::Value MatrixSolveOp::rhs() {
  return *getODSOperands(1).begin();
}

::mlir::MutableOperandRange MatrixSolveOp::matrixMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange MatrixSolveOp::rhsMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> MatrixSolveOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range MatrixSolveOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value MatrixSolveOp::output() {
  return *getODSResults(0).begin();
}

::mlir::BoolAttr MatrixSolveOp::adjointAttr() {
  return this->getAttr("adjoint").dyn_cast_or_null<::mlir::BoolAttr>();
}

bool MatrixSolveOp::adjoint() {
  auto attr = adjointAttr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getBoolAttr(false).getValue();
  return attr.getValue();
}

Type MatrixSolveOp::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

bool MatrixSolveOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "T") return true;
 return false;
}

::mlir::DictionaryAttr MatrixSolveOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())}
    }, ctx);
}

void MatrixSolveOp::adjointAttr(::mlir::BoolAttr attr) {
  this->getOperation()->setAttr("adjoint", attr);
}

void MatrixSolveOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value matrix, ::mlir::Value rhs, ::mlir::BoolAttr adjoint) {
  odsState.addOperands(matrix);
  odsState.addOperands(rhs);
  odsState.addAttribute("adjoint", adjoint);
  odsState.addTypes(output);
}

void MatrixSolveOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value matrix, ::mlir::Value rhs, ::mlir::BoolAttr adjoint) {
  odsState.addOperands(matrix);
  odsState.addOperands(rhs);
  odsState.addAttribute("adjoint", adjoint);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void MatrixSolveOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value matrix, ::mlir::Value rhs, bool adjoint) {
  odsState.addOperands(matrix);
  odsState.addOperands(rhs);
  odsState.addAttribute("adjoint", odsBuilder.getBoolAttr(adjoint));
  odsState.addTypes(output);
}

void MatrixSolveOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value matrix, ::mlir::Value rhs, bool adjoint) {
  odsState.addOperands(matrix);
  odsState.addOperands(rhs);
  odsState.addAttribute("adjoint", odsBuilder.getBoolAttr(adjoint));
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void MatrixSolveOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult MatrixSolveOp::verify() {
  if (failed(MatrixSolveOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of 128-bit complex or 64-bit complex or 16-bit float or 32-bit float or 64-bit float values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of 128-bit complex or 64-bit complex or 16-bit float or 32-bit float or 64-bit float values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())))))) {
        return emitOpError("result #") << index << " must be tensor of 128-bit complex or 64-bit complex or 16-bit float or 32-bit float or 64-bit float values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void MatrixSolveOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::MatrixTriangularSolveOp definitions
//===----------------------------------------------------------------------===//

MatrixTriangularSolveOpAdaptor::MatrixTriangularSolveOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

MatrixTriangularSolveOpAdaptor::MatrixTriangularSolveOpAdaptor(MatrixTriangularSolveOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> MatrixTriangularSolveOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange MatrixTriangularSolveOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value MatrixTriangularSolveOpAdaptor::matrix() {
  return *getODSOperands(0).begin();
}

::mlir::Value MatrixTriangularSolveOpAdaptor::rhs() {
  return *getODSOperands(1).begin();
}

::mlir::BoolAttr MatrixTriangularSolveOpAdaptor::lower() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::BoolAttr attr = odsAttrs.get("lower").dyn_cast_or_null<::mlir::BoolAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getBoolAttr(true);
  return attr;
}

::mlir::BoolAttr MatrixTriangularSolveOpAdaptor::adjoint() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::BoolAttr attr = odsAttrs.get("adjoint").dyn_cast_or_null<::mlir::BoolAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getBoolAttr(false);
  return attr;
}

::mlir::LogicalResult MatrixTriangularSolveOpAdaptor::verify(::mlir::Location loc) {
  {
  auto tblgen_lower = odsAttrs.get("lower");
  if (tblgen_lower) {
    if (!((tblgen_lower.isa<::mlir::BoolAttr>()))) return emitError(loc, "'tf.MatrixTriangularSolve' op ""attribute 'lower' failed to satisfy constraint: bool attribute");
  }
  }
  {
  auto tblgen_adjoint = odsAttrs.get("adjoint");
  if (tblgen_adjoint) {
    if (!((tblgen_adjoint.isa<::mlir::BoolAttr>()))) return emitError(loc, "'tf.MatrixTriangularSolve' op ""attribute 'adjoint' failed to satisfy constraint: bool attribute");
  }
  }
  return ::mlir::success();
}

::llvm::StringRef MatrixTriangularSolveOp::getOperationName() {
  return "tf.MatrixTriangularSolve";
}

std::pair<unsigned, unsigned> MatrixTriangularSolveOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range MatrixTriangularSolveOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value MatrixTriangularSolveOp::matrix() {
  return *getODSOperands(0).begin();
}

::mlir::Value MatrixTriangularSolveOp::rhs() {
  return *getODSOperands(1).begin();
}

::mlir::MutableOperandRange MatrixTriangularSolveOp::matrixMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange MatrixTriangularSolveOp::rhsMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> MatrixTriangularSolveOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range MatrixTriangularSolveOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value MatrixTriangularSolveOp::output() {
  return *getODSResults(0).begin();
}

::mlir::BoolAttr MatrixTriangularSolveOp::lowerAttr() {
  return this->getAttr("lower").dyn_cast_or_null<::mlir::BoolAttr>();
}

bool MatrixTriangularSolveOp::lower() {
  auto attr = lowerAttr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getBoolAttr(true).getValue();
  return attr.getValue();
}

::mlir::BoolAttr MatrixTriangularSolveOp::adjointAttr() {
  return this->getAttr("adjoint").dyn_cast_or_null<::mlir::BoolAttr>();
}

bool MatrixTriangularSolveOp::adjoint() {
  auto attr = adjointAttr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getBoolAttr(false).getValue();
  return attr.getValue();
}

Type MatrixTriangularSolveOp::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

bool MatrixTriangularSolveOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "T") return true;
 return false;
}

::mlir::DictionaryAttr MatrixTriangularSolveOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())}
    }, ctx);
}

void MatrixTriangularSolveOp::lowerAttr(::mlir::BoolAttr attr) {
  this->getOperation()->setAttr("lower", attr);
}

void MatrixTriangularSolveOp::adjointAttr(::mlir::BoolAttr attr) {
  this->getOperation()->setAttr("adjoint", attr);
}

void MatrixTriangularSolveOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value matrix, ::mlir::Value rhs, ::mlir::BoolAttr lower, ::mlir::BoolAttr adjoint) {
  odsState.addOperands(matrix);
  odsState.addOperands(rhs);
  odsState.addAttribute("lower", lower);
  odsState.addAttribute("adjoint", adjoint);
  odsState.addTypes(output);
}

void MatrixTriangularSolveOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value matrix, ::mlir::Value rhs, ::mlir::BoolAttr lower, ::mlir::BoolAttr adjoint) {
  odsState.addOperands(matrix);
  odsState.addOperands(rhs);
  odsState.addAttribute("lower", lower);
  odsState.addAttribute("adjoint", adjoint);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void MatrixTriangularSolveOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value matrix, ::mlir::Value rhs, bool lower, bool adjoint) {
  odsState.addOperands(matrix);
  odsState.addOperands(rhs);
  odsState.addAttribute("lower", odsBuilder.getBoolAttr(lower));
  odsState.addAttribute("adjoint", odsBuilder.getBoolAttr(adjoint));
  odsState.addTypes(output);
}

void MatrixTriangularSolveOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value matrix, ::mlir::Value rhs, bool lower, bool adjoint) {
  odsState.addOperands(matrix);
  odsState.addOperands(rhs);
  odsState.addAttribute("lower", odsBuilder.getBoolAttr(lower));
  odsState.addAttribute("adjoint", odsBuilder.getBoolAttr(adjoint));
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void MatrixTriangularSolveOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult MatrixTriangularSolveOp::verify() {
  if (failed(MatrixTriangularSolveOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of 128-bit complex or 64-bit complex or 16-bit float or 32-bit float or 64-bit float values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of 128-bit complex or 64-bit complex or 16-bit float or 32-bit float or 64-bit float values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())))))) {
        return emitOpError("result #") << index << " must be tensor of 128-bit complex or 64-bit complex or 16-bit float or 32-bit float or 64-bit float values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void MatrixTriangularSolveOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::MaxOp definitions
//===----------------------------------------------------------------------===//

MaxOpAdaptor::MaxOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

MaxOpAdaptor::MaxOpAdaptor(MaxOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> MaxOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange MaxOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value MaxOpAdaptor::input() {
  return *getODSOperands(0).begin();
}

::mlir::Value MaxOpAdaptor::reduction_indices() {
  return *getODSOperands(1).begin();
}

::mlir::BoolAttr MaxOpAdaptor::keep_dims() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::BoolAttr attr = odsAttrs.get("keep_dims").dyn_cast_or_null<::mlir::BoolAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getBoolAttr(false);
  return attr;
}

::mlir::LogicalResult MaxOpAdaptor::verify(::mlir::Location loc) {
  {
  auto tblgen_keep_dims = odsAttrs.get("keep_dims");
  if (tblgen_keep_dims) {
    if (!((tblgen_keep_dims.isa<::mlir::BoolAttr>()))) return emitError(loc, "'tf.Max' op ""attribute 'keep_dims' failed to satisfy constraint: bool attribute");
  }
  }
  return ::mlir::success();
}

::llvm::StringRef MaxOp::getOperationName() {
  return "tf.Max";
}

std::pair<unsigned, unsigned> MaxOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range MaxOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value MaxOp::input() {
  return *getODSOperands(0).begin();
}

::mlir::Value MaxOp::reduction_indices() {
  return *getODSOperands(1).begin();
}

::mlir::MutableOperandRange MaxOp::inputMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange MaxOp::reduction_indicesMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> MaxOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range MaxOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value MaxOp::output() {
  return *getODSResults(0).begin();
}

::mlir::BoolAttr MaxOp::keep_dimsAttr() {
  return this->getAttr("keep_dims").dyn_cast_or_null<::mlir::BoolAttr>();
}

bool MaxOp::keep_dims() {
  auto attr = keep_dimsAttr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getBoolAttr(false).getValue();
  return attr.getValue();
}

Type MaxOp::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

Type MaxOp::Tidx() {
  return mlir::getElementTypeOrSelf(*getODSOperands(1).begin());
}

bool MaxOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "T") return true;
  if (name == "Tidx") return true;
 return false;
}

::mlir::DictionaryAttr MaxOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())},
    {::mlir::Identifier::get("Tidx", ctx),
::mlir::TypeAttr::get(Tidx())}
    }, ctx);
}

void MaxOp::keep_dimsAttr(::mlir::BoolAttr attr) {
  this->getOperation()->setAttr("keep_dims", attr);
}



void MaxOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value input, ::mlir::Value reduction_indices, ::mlir::BoolAttr keep_dims) {
  odsState.addOperands(input);
  odsState.addOperands(reduction_indices);
  odsState.addAttribute("keep_dims", keep_dims);
  odsState.addTypes(output);
}

void MaxOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input, ::mlir::Value reduction_indices, ::mlir::BoolAttr keep_dims) {
  odsState.addOperands(input);
  odsState.addOperands(reduction_indices);
  odsState.addAttribute("keep_dims", keep_dims);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void MaxOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value input, ::mlir::Value reduction_indices, bool keep_dims) {
  odsState.addOperands(input);
  odsState.addOperands(reduction_indices);
  odsState.addAttribute("keep_dims", odsBuilder.getBoolAttr(keep_dims));
  odsState.addTypes(output);
}

void MaxOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input, ::mlir::Value reduction_indices, bool keep_dims) {
  odsState.addOperands(input);
  odsState.addOperands(reduction_indices);
  odsState.addAttribute("keep_dims", odsBuilder.getBoolAttr(keep_dims));
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void MaxOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult MaxOp::verify() {
  if (failed(MaxOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint16Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint16Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of bfloat16 or 16-bit float or 32-bit float or 64-bit float or 16-bit integer or 32-bit integer or 64-bit integer or 8-bit integer or 16-bit quantized integer or 32-bit quantized integer or 8-bit quantized integer or 16-bit quantized unsigned integer or 8-bit quantized unsigned integer or 16-bit unsigned integer or 32-bit unsigned integer or 64-bit unsigned integer or 8-bit unsigned integer values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of 32/64-bit signed integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint16Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint16Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>())))))) {
        return emitOpError("result #") << index << " must be tensor of bfloat16 or 16-bit float or 32-bit float or 64-bit float or 16-bit integer or 32-bit integer or 64-bit integer or 8-bit integer or 16-bit quantized integer or 32-bit quantized integer or 8-bit quantized integer or 16-bit quantized unsigned integer or 8-bit quantized unsigned integer or 16-bit unsigned integer or 32-bit unsigned integer or 64-bit unsigned integer or 8-bit unsigned integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void MaxOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::MaxPool3DGradOp definitions
//===----------------------------------------------------------------------===//

MaxPool3DGradOpAdaptor::MaxPool3DGradOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

MaxPool3DGradOpAdaptor::MaxPool3DGradOpAdaptor(MaxPool3DGradOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> MaxPool3DGradOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange MaxPool3DGradOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value MaxPool3DGradOpAdaptor::orig_input() {
  return *getODSOperands(0).begin();
}

::mlir::Value MaxPool3DGradOpAdaptor::orig_output() {
  return *getODSOperands(1).begin();
}

::mlir::Value MaxPool3DGradOpAdaptor::grad() {
  return *getODSOperands(2).begin();
}

::mlir::ArrayAttr MaxPool3DGradOpAdaptor::ksize() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::ArrayAttr attr = odsAttrs.get("ksize").cast<::mlir::ArrayAttr>();
  return attr;
}

::mlir::ArrayAttr MaxPool3DGradOpAdaptor::strides() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::ArrayAttr attr = odsAttrs.get("strides").cast<::mlir::ArrayAttr>();
  return attr;
}

::mlir::StringAttr MaxPool3DGradOpAdaptor::padding() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::StringAttr attr = odsAttrs.get("padding").cast<::mlir::StringAttr>();
  return attr;
}

::mlir::StringAttr MaxPool3DGradOpAdaptor::data_format() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::StringAttr attr = odsAttrs.get("data_format").dyn_cast_or_null<::mlir::StringAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getStringAttr("NDHWC");
  return attr;
}

::mlir::LogicalResult MaxPool3DGradOpAdaptor::verify(::mlir::Location loc) {
  {
  auto tblgen_ksize = odsAttrs.get("ksize");
  if (!tblgen_ksize) return emitError(loc, "'tf.MaxPool3DGrad' op ""requires attribute 'ksize'");
    if (!((((tblgen_ksize.isa<::mlir::ArrayAttr>())) && (::llvm::all_of(tblgen_ksize.cast<::mlir::ArrayAttr>(), [](::mlir::Attribute attr) { return ((attr.isa<::mlir::IntegerAttr>())) && ((attr.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(64))); }))) && ((tblgen_ksize.cast<::mlir::ArrayAttr>().size() >= 5)))) return emitError(loc, "'tf.MaxPool3DGrad' op ""attribute 'ksize' failed to satisfy constraint: 64-bit integer array attribute with at least 5 elements");
  }
  {
  auto tblgen_strides = odsAttrs.get("strides");
  if (!tblgen_strides) return emitError(loc, "'tf.MaxPool3DGrad' op ""requires attribute 'strides'");
    if (!((((tblgen_strides.isa<::mlir::ArrayAttr>())) && (::llvm::all_of(tblgen_strides.cast<::mlir::ArrayAttr>(), [](::mlir::Attribute attr) { return ((attr.isa<::mlir::IntegerAttr>())) && ((attr.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(64))); }))) && ((tblgen_strides.cast<::mlir::ArrayAttr>().size() >= 5)))) return emitError(loc, "'tf.MaxPool3DGrad' op ""attribute 'strides' failed to satisfy constraint: 64-bit integer array attribute with at least 5 elements");
  }
  {
  auto tblgen_padding = odsAttrs.get("padding");
  if (!tblgen_padding) return emitError(loc, "'tf.MaxPool3DGrad' op ""requires attribute 'padding'");
    if (!((tblgen_padding.cast<StringAttr>().getValue() == "SAME" || tblgen_padding.cast<StringAttr>().getValue() == "VALID"))) return emitError(loc, "'tf.MaxPool3DGrad' op ""attribute 'padding' failed to satisfy constraint: string attribute whose value is SAME, or VALID");
  }
  {
  auto tblgen_data_format = odsAttrs.get("data_format");
  if (tblgen_data_format) {
    if (!((tblgen_data_format.cast<StringAttr>().getValue() == "NDHWC" || tblgen_data_format.cast<StringAttr>().getValue() == "NCDHW"))) return emitError(loc, "'tf.MaxPool3DGrad' op ""attribute 'data_format' failed to satisfy constraint: string attribute whose value is NDHWC, or NCDHW");
  }
  }
  return ::mlir::success();
}

::llvm::StringRef MaxPool3DGradOp::getOperationName() {
  return "tf.MaxPool3DGrad";
}

std::pair<unsigned, unsigned> MaxPool3DGradOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range MaxPool3DGradOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value MaxPool3DGradOp::orig_input() {
  return *getODSOperands(0).begin();
}

::mlir::Value MaxPool3DGradOp::orig_output() {
  return *getODSOperands(1).begin();
}

::mlir::Value MaxPool3DGradOp::grad() {
  return *getODSOperands(2).begin();
}

::mlir::MutableOperandRange MaxPool3DGradOp::orig_inputMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange MaxPool3DGradOp::orig_outputMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange MaxPool3DGradOp::gradMutable() {
  auto range = getODSOperandIndexAndLength(2);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> MaxPool3DGradOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range MaxPool3DGradOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value MaxPool3DGradOp::output() {
  return *getODSResults(0).begin();
}

::mlir::ArrayAttr MaxPool3DGradOp::ksizeAttr() {
  return this->getAttr("ksize").cast<::mlir::ArrayAttr>();
}

::mlir::ArrayAttr MaxPool3DGradOp::ksize() {
  auto attr = ksizeAttr();
  return attr;
}

::mlir::ArrayAttr MaxPool3DGradOp::stridesAttr() {
  return this->getAttr("strides").cast<::mlir::ArrayAttr>();
}

::mlir::ArrayAttr MaxPool3DGradOp::strides() {
  auto attr = stridesAttr();
  return attr;
}

::mlir::StringAttr MaxPool3DGradOp::paddingAttr() {
  return this->getAttr("padding").cast<::mlir::StringAttr>();
}

::llvm::StringRef MaxPool3DGradOp::padding() {
  auto attr = paddingAttr();
  return attr.getValue();
}

::mlir::StringAttr MaxPool3DGradOp::data_formatAttr() {
  return this->getAttr("data_format").dyn_cast_or_null<::mlir::StringAttr>();
}

::llvm::StringRef MaxPool3DGradOp::data_format() {
  auto attr = data_formatAttr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getStringAttr("NDHWC").getValue();
  return attr.getValue();
}

Type MaxPool3DGradOp::TInput() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

Type MaxPool3DGradOp::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(2).begin());
}

bool MaxPool3DGradOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "TInput") return true;
  if (name == "T") return true;
 return false;
}

::mlir::DictionaryAttr MaxPool3DGradOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("TInput", ctx),
::mlir::TypeAttr::get(TInput())},
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())}
    }, ctx);
}

void MaxPool3DGradOp::ksizeAttr(::mlir::ArrayAttr attr) {
  this->getOperation()->setAttr("ksize", attr);
}

void MaxPool3DGradOp::stridesAttr(::mlir::ArrayAttr attr) {
  this->getOperation()->setAttr("strides", attr);
}

void MaxPool3DGradOp::paddingAttr(::mlir::StringAttr attr) {
  this->getOperation()->setAttr("padding", attr);
}

void MaxPool3DGradOp::data_formatAttr(::mlir::StringAttr attr) {
  this->getOperation()->setAttr("data_format", attr);
}

void MaxPool3DGradOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value orig_input, ::mlir::Value orig_output, ::mlir::Value grad, ::mlir::ArrayAttr ksize, ::mlir::ArrayAttr strides, ::mlir::StringAttr padding, ::mlir::StringAttr data_format) {
  odsState.addOperands(orig_input);
  odsState.addOperands(orig_output);
  odsState.addOperands(grad);
  odsState.addAttribute("ksize", ksize);
  odsState.addAttribute("strides", strides);
  odsState.addAttribute("padding", padding);
  odsState.addAttribute("data_format", data_format);
  odsState.addTypes(output);
}

void MaxPool3DGradOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value orig_input, ::mlir::Value orig_output, ::mlir::Value grad, ::mlir::ArrayAttr ksize, ::mlir::ArrayAttr strides, ::mlir::StringAttr padding, ::mlir::StringAttr data_format) {
  odsState.addOperands(orig_input);
  odsState.addOperands(orig_output);
  odsState.addOperands(grad);
  odsState.addAttribute("ksize", ksize);
  odsState.addAttribute("strides", strides);
  odsState.addAttribute("padding", padding);
  odsState.addAttribute("data_format", data_format);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void MaxPool3DGradOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value orig_input, ::mlir::Value orig_output, ::mlir::Value grad, ::mlir::ArrayAttr ksize, ::mlir::ArrayAttr strides, ::llvm::StringRef padding, ::llvm::StringRef data_format) {
  odsState.addOperands(orig_input);
  odsState.addOperands(orig_output);
  odsState.addOperands(grad);
  odsState.addAttribute("ksize", ksize);
  odsState.addAttribute("strides", strides);
  odsState.addAttribute("padding", odsBuilder.getStringAttr(padding));
  odsState.addAttribute("data_format", odsBuilder.getStringAttr(data_format));
  odsState.addTypes(output);
}

void MaxPool3DGradOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value orig_input, ::mlir::Value orig_output, ::mlir::Value grad, ::mlir::ArrayAttr ksize, ::mlir::ArrayAttr strides, ::llvm::StringRef padding, ::llvm::StringRef data_format) {
  odsState.addOperands(orig_input);
  odsState.addOperands(orig_output);
  odsState.addOperands(grad);
  odsState.addAttribute("ksize", ksize);
  odsState.addAttribute("strides", strides);
  odsState.addAttribute("padding", odsBuilder.getStringAttr(padding));
  odsState.addAttribute("data_format", odsBuilder.getStringAttr(data_format));
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void MaxPool3DGradOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 3u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult MaxPool3DGradOp::verify() {
  if (failed(MaxPool3DGradOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of bfloat16 or 16-bit float or 32-bit float values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of bfloat16 or 16-bit float or 32-bit float values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup2 = getODSOperands(2);
    for (::mlir::Value v : valueGroup2) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of bfloat16 or 16-bit float or 32-bit float values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())))))) {
        return emitOpError("result #") << index << " must be tensor of bfloat16 or 16-bit float or 32-bit float values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void MaxPool3DGradOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::MaxPool3DOp definitions
//===----------------------------------------------------------------------===//

MaxPool3DOpAdaptor::MaxPool3DOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

MaxPool3DOpAdaptor::MaxPool3DOpAdaptor(MaxPool3DOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> MaxPool3DOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange MaxPool3DOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value MaxPool3DOpAdaptor::input() {
  return *getODSOperands(0).begin();
}

::mlir::ArrayAttr MaxPool3DOpAdaptor::ksize() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::ArrayAttr attr = odsAttrs.get("ksize").cast<::mlir::ArrayAttr>();
  return attr;
}

::mlir::ArrayAttr MaxPool3DOpAdaptor::strides() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::ArrayAttr attr = odsAttrs.get("strides").cast<::mlir::ArrayAttr>();
  return attr;
}

::mlir::StringAttr MaxPool3DOpAdaptor::padding() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::StringAttr attr = odsAttrs.get("padding").cast<::mlir::StringAttr>();
  return attr;
}

::mlir::StringAttr MaxPool3DOpAdaptor::data_format() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::StringAttr attr = odsAttrs.get("data_format").dyn_cast_or_null<::mlir::StringAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getStringAttr("NDHWC");
  return attr;
}

::mlir::LogicalResult MaxPool3DOpAdaptor::verify(::mlir::Location loc) {
  {
  auto tblgen_ksize = odsAttrs.get("ksize");
  if (!tblgen_ksize) return emitError(loc, "'tf.MaxPool3D' op ""requires attribute 'ksize'");
    if (!((((tblgen_ksize.isa<::mlir::ArrayAttr>())) && (::llvm::all_of(tblgen_ksize.cast<::mlir::ArrayAttr>(), [](::mlir::Attribute attr) { return ((attr.isa<::mlir::IntegerAttr>())) && ((attr.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(64))); }))) && ((tblgen_ksize.cast<::mlir::ArrayAttr>().size() >= 5)))) return emitError(loc, "'tf.MaxPool3D' op ""attribute 'ksize' failed to satisfy constraint: 64-bit integer array attribute with at least 5 elements");
  }
  {
  auto tblgen_strides = odsAttrs.get("strides");
  if (!tblgen_strides) return emitError(loc, "'tf.MaxPool3D' op ""requires attribute 'strides'");
    if (!((((tblgen_strides.isa<::mlir::ArrayAttr>())) && (::llvm::all_of(tblgen_strides.cast<::mlir::ArrayAttr>(), [](::mlir::Attribute attr) { return ((attr.isa<::mlir::IntegerAttr>())) && ((attr.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(64))); }))) && ((tblgen_strides.cast<::mlir::ArrayAttr>().size() >= 5)))) return emitError(loc, "'tf.MaxPool3D' op ""attribute 'strides' failed to satisfy constraint: 64-bit integer array attribute with at least 5 elements");
  }
  {
  auto tblgen_padding = odsAttrs.get("padding");
  if (!tblgen_padding) return emitError(loc, "'tf.MaxPool3D' op ""requires attribute 'padding'");
    if (!((tblgen_padding.cast<StringAttr>().getValue() == "SAME" || tblgen_padding.cast<StringAttr>().getValue() == "VALID"))) return emitError(loc, "'tf.MaxPool3D' op ""attribute 'padding' failed to satisfy constraint: string attribute whose value is SAME, or VALID");
  }
  {
  auto tblgen_data_format = odsAttrs.get("data_format");
  if (tblgen_data_format) {
    if (!((tblgen_data_format.cast<StringAttr>().getValue() == "NDHWC" || tblgen_data_format.cast<StringAttr>().getValue() == "NCDHW"))) return emitError(loc, "'tf.MaxPool3D' op ""attribute 'data_format' failed to satisfy constraint: string attribute whose value is NDHWC, or NCDHW");
  }
  }
  return ::mlir::success();
}

::llvm::StringRef MaxPool3DOp::getOperationName() {
  return "tf.MaxPool3D";
}

std::pair<unsigned, unsigned> MaxPool3DOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range MaxPool3DOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value MaxPool3DOp::input() {
  return *getODSOperands(0).begin();
}

::mlir::MutableOperandRange MaxPool3DOp::inputMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> MaxPool3DOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range MaxPool3DOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value MaxPool3DOp::output() {
  return *getODSResults(0).begin();
}

::mlir::ArrayAttr MaxPool3DOp::ksizeAttr() {
  return this->getAttr("ksize").cast<::mlir::ArrayAttr>();
}

::mlir::ArrayAttr MaxPool3DOp::ksize() {
  auto attr = ksizeAttr();
  return attr;
}

::mlir::ArrayAttr MaxPool3DOp::stridesAttr() {
  return this->getAttr("strides").cast<::mlir::ArrayAttr>();
}

::mlir::ArrayAttr MaxPool3DOp::strides() {
  auto attr = stridesAttr();
  return attr;
}

::mlir::StringAttr MaxPool3DOp::paddingAttr() {
  return this->getAttr("padding").cast<::mlir::StringAttr>();
}

::llvm::StringRef MaxPool3DOp::padding() {
  auto attr = paddingAttr();
  return attr.getValue();
}

::mlir::StringAttr MaxPool3DOp::data_formatAttr() {
  return this->getAttr("data_format").dyn_cast_or_null<::mlir::StringAttr>();
}

::llvm::StringRef MaxPool3DOp::data_format() {
  auto attr = data_formatAttr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getStringAttr("NDHWC").getValue();
  return attr.getValue();
}

Type MaxPool3DOp::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

bool MaxPool3DOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "T") return true;
 return false;
}

::mlir::DictionaryAttr MaxPool3DOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())}
    }, ctx);
}

void MaxPool3DOp::ksizeAttr(::mlir::ArrayAttr attr) {
  this->getOperation()->setAttr("ksize", attr);
}

void MaxPool3DOp::stridesAttr(::mlir::ArrayAttr attr) {
  this->getOperation()->setAttr("strides", attr);
}

void MaxPool3DOp::paddingAttr(::mlir::StringAttr attr) {
  this->getOperation()->setAttr("padding", attr);
}

void MaxPool3DOp::data_formatAttr(::mlir::StringAttr attr) {
  this->getOperation()->setAttr("data_format", attr);
}

void MaxPool3DOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value input, ::mlir::ArrayAttr ksize, ::mlir::ArrayAttr strides, ::mlir::StringAttr padding, ::mlir::StringAttr data_format) {
  odsState.addOperands(input);
  odsState.addAttribute("ksize", ksize);
  odsState.addAttribute("strides", strides);
  odsState.addAttribute("padding", padding);
  odsState.addAttribute("data_format", data_format);
  odsState.addTypes(output);
}

void MaxPool3DOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input, ::mlir::ArrayAttr ksize, ::mlir::ArrayAttr strides, ::mlir::StringAttr padding, ::mlir::StringAttr data_format) {
  odsState.addOperands(input);
  odsState.addAttribute("ksize", ksize);
  odsState.addAttribute("strides", strides);
  odsState.addAttribute("padding", padding);
  odsState.addAttribute("data_format", data_format);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void MaxPool3DOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value input, ::mlir::ArrayAttr ksize, ::mlir::ArrayAttr strides, ::llvm::StringRef padding, ::llvm::StringRef data_format) {
  odsState.addOperands(input);
  odsState.addAttribute("ksize", ksize);
  odsState.addAttribute("strides", strides);
  odsState.addAttribute("padding", odsBuilder.getStringAttr(padding));
  odsState.addAttribute("data_format", odsBuilder.getStringAttr(data_format));
  odsState.addTypes(output);
}

void MaxPool3DOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input, ::mlir::ArrayAttr ksize, ::mlir::ArrayAttr strides, ::llvm::StringRef padding, ::llvm::StringRef data_format) {
  odsState.addOperands(input);
  odsState.addAttribute("ksize", ksize);
  odsState.addAttribute("strides", strides);
  odsState.addAttribute("padding", odsBuilder.getStringAttr(padding));
  odsState.addAttribute("data_format", odsBuilder.getStringAttr(data_format));
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void MaxPool3DOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult MaxPool3DOp::verify() {
  if (failed(MaxPool3DOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of bfloat16 or 16-bit float or 32-bit float values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())))))) {
        return emitOpError("result #") << index << " must be tensor of bfloat16 or 16-bit float or 32-bit float values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void MaxPool3DOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::MaxPoolGradOp definitions
//===----------------------------------------------------------------------===//

MaxPoolGradOpAdaptor::MaxPoolGradOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

MaxPoolGradOpAdaptor::MaxPoolGradOpAdaptor(MaxPoolGradOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> MaxPoolGradOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange MaxPoolGradOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value MaxPoolGradOpAdaptor::orig_input() {
  return *getODSOperands(0).begin();
}

::mlir::Value MaxPoolGradOpAdaptor::orig_output() {
  return *getODSOperands(1).begin();
}

::mlir::Value MaxPoolGradOpAdaptor::grad() {
  return *getODSOperands(2).begin();
}

::mlir::ArrayAttr MaxPoolGradOpAdaptor::ksize() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::ArrayAttr attr = odsAttrs.get("ksize").cast<::mlir::ArrayAttr>();
  return attr;
}

::mlir::ArrayAttr MaxPoolGradOpAdaptor::strides() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::ArrayAttr attr = odsAttrs.get("strides").cast<::mlir::ArrayAttr>();
  return attr;
}

::mlir::StringAttr MaxPoolGradOpAdaptor::padding() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::StringAttr attr = odsAttrs.get("padding").cast<::mlir::StringAttr>();
  return attr;
}

::mlir::ArrayAttr MaxPoolGradOpAdaptor::explicit_paddings() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::ArrayAttr attr = odsAttrs.get("explicit_paddings").dyn_cast_or_null<::mlir::ArrayAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getI64ArrayAttr({});
  return attr;
}

::mlir::StringAttr MaxPoolGradOpAdaptor::data_format() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::StringAttr attr = odsAttrs.get("data_format").dyn_cast_or_null<::mlir::StringAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getStringAttr("NHWC");
  return attr;
}

::mlir::LogicalResult MaxPoolGradOpAdaptor::verify(::mlir::Location loc) {
  {
  auto tblgen_ksize = odsAttrs.get("ksize");
  if (!tblgen_ksize) return emitError(loc, "'tf.MaxPoolGrad' op ""requires attribute 'ksize'");
    if (!((((tblgen_ksize.isa<::mlir::ArrayAttr>())) && (::llvm::all_of(tblgen_ksize.cast<::mlir::ArrayAttr>(), [](::mlir::Attribute attr) { return ((attr.isa<::mlir::IntegerAttr>())) && ((attr.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(64))); }))) && ((tblgen_ksize.cast<::mlir::ArrayAttr>().size() >= 4)))) return emitError(loc, "'tf.MaxPoolGrad' op ""attribute 'ksize' failed to satisfy constraint: 64-bit integer array attribute with at least 4 elements");
  }
  {
  auto tblgen_strides = odsAttrs.get("strides");
  if (!tblgen_strides) return emitError(loc, "'tf.MaxPoolGrad' op ""requires attribute 'strides'");
    if (!((((tblgen_strides.isa<::mlir::ArrayAttr>())) && (::llvm::all_of(tblgen_strides.cast<::mlir::ArrayAttr>(), [](::mlir::Attribute attr) { return ((attr.isa<::mlir::IntegerAttr>())) && ((attr.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(64))); }))) && ((tblgen_strides.cast<::mlir::ArrayAttr>().size() >= 4)))) return emitError(loc, "'tf.MaxPoolGrad' op ""attribute 'strides' failed to satisfy constraint: 64-bit integer array attribute with at least 4 elements");
  }
  {
  auto tblgen_padding = odsAttrs.get("padding");
  if (!tblgen_padding) return emitError(loc, "'tf.MaxPoolGrad' op ""requires attribute 'padding'");
    if (!((tblgen_padding.cast<StringAttr>().getValue() == "SAME" || tblgen_padding.cast<StringAttr>().getValue() == "VALID" || tblgen_padding.cast<StringAttr>().getValue() == "EXPLICIT"))) return emitError(loc, "'tf.MaxPoolGrad' op ""attribute 'padding' failed to satisfy constraint: string attribute whose value is SAME, or VALID, or EXPLICIT");
  }
  {
  auto tblgen_explicit_paddings = odsAttrs.get("explicit_paddings");
  if (tblgen_explicit_paddings) {
    if (!(((tblgen_explicit_paddings.isa<::mlir::ArrayAttr>())) && (::llvm::all_of(tblgen_explicit_paddings.cast<::mlir::ArrayAttr>(), [](::mlir::Attribute attr) { return ((attr.isa<::mlir::IntegerAttr>())) && ((attr.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(64))); })))) return emitError(loc, "'tf.MaxPoolGrad' op ""attribute 'explicit_paddings' failed to satisfy constraint: 64-bit integer array attribute");
  }
  }
  {
  auto tblgen_data_format = odsAttrs.get("data_format");
  if (tblgen_data_format) {
    if (!((tblgen_data_format.cast<StringAttr>().getValue() == "NHWC" || tblgen_data_format.cast<StringAttr>().getValue() == "NCHW"))) return emitError(loc, "'tf.MaxPoolGrad' op ""attribute 'data_format' failed to satisfy constraint: 'NHWC' or 'NCHW' convnet data format");
  }
  }
  return ::mlir::success();
}

::llvm::StringRef MaxPoolGradOp::getOperationName() {
  return "tf.MaxPoolGrad";
}

std::pair<unsigned, unsigned> MaxPoolGradOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range MaxPoolGradOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value MaxPoolGradOp::orig_input() {
  return *getODSOperands(0).begin();
}

::mlir::Value MaxPoolGradOp::orig_output() {
  return *getODSOperands(1).begin();
}

::mlir::Value MaxPoolGradOp::grad() {
  return *getODSOperands(2).begin();
}

::mlir::MutableOperandRange MaxPoolGradOp::orig_inputMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange MaxPoolGradOp::orig_outputMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange MaxPoolGradOp::gradMutable() {
  auto range = getODSOperandIndexAndLength(2);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> MaxPoolGradOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range MaxPoolGradOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value MaxPoolGradOp::output() {
  return *getODSResults(0).begin();
}

::mlir::ArrayAttr MaxPoolGradOp::ksizeAttr() {
  return this->getAttr("ksize").cast<::mlir::ArrayAttr>();
}

::mlir::ArrayAttr MaxPoolGradOp::ksize() {
  auto attr = ksizeAttr();
  return attr;
}

::mlir::ArrayAttr MaxPoolGradOp::stridesAttr() {
  return this->getAttr("strides").cast<::mlir::ArrayAttr>();
}

::mlir::ArrayAttr MaxPoolGradOp::strides() {
  auto attr = stridesAttr();
  return attr;
}

::mlir::StringAttr MaxPoolGradOp::paddingAttr() {
  return this->getAttr("padding").cast<::mlir::StringAttr>();
}

::llvm::StringRef MaxPoolGradOp::padding() {
  auto attr = paddingAttr();
  return attr.getValue();
}

::mlir::ArrayAttr MaxPoolGradOp::explicit_paddingsAttr() {
  return this->getAttr("explicit_paddings").dyn_cast_or_null<::mlir::ArrayAttr>();
}

::mlir::ArrayAttr MaxPoolGradOp::explicit_paddings() {
  auto attr = explicit_paddingsAttr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getI64ArrayAttr({});
  return attr;
}

::mlir::StringAttr MaxPoolGradOp::data_formatAttr() {
  return this->getAttr("data_format").dyn_cast_or_null<::mlir::StringAttr>();
}

::llvm::StringRef MaxPoolGradOp::data_format() {
  auto attr = data_formatAttr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getStringAttr("NHWC").getValue();
  return attr.getValue();
}

Type MaxPoolGradOp::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

bool MaxPoolGradOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "T") return true;
 return false;
}

::mlir::DictionaryAttr MaxPoolGradOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())}
    }, ctx);
}

void MaxPoolGradOp::ksizeAttr(::mlir::ArrayAttr attr) {
  this->getOperation()->setAttr("ksize", attr);
}

void MaxPoolGradOp::stridesAttr(::mlir::ArrayAttr attr) {
  this->getOperation()->setAttr("strides", attr);
}

void MaxPoolGradOp::paddingAttr(::mlir::StringAttr attr) {
  this->getOperation()->setAttr("padding", attr);
}

void MaxPoolGradOp::explicit_paddingsAttr(::mlir::ArrayAttr attr) {
  this->getOperation()->setAttr("explicit_paddings", attr);
}

void MaxPoolGradOp::data_formatAttr(::mlir::StringAttr attr) {
  this->getOperation()->setAttr("data_format", attr);
}

void MaxPoolGradOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value orig_input, ::mlir::Value orig_output, ::mlir::Value grad, ::mlir::ArrayAttr ksize, ::mlir::ArrayAttr strides, ::mlir::StringAttr padding, ::mlir::ArrayAttr explicit_paddings, ::mlir::StringAttr data_format) {
  odsState.addOperands(orig_input);
  odsState.addOperands(orig_output);
  odsState.addOperands(grad);
  odsState.addAttribute("ksize", ksize);
  odsState.addAttribute("strides", strides);
  odsState.addAttribute("padding", padding);
  odsState.addAttribute("explicit_paddings", explicit_paddings);
  odsState.addAttribute("data_format", data_format);
  odsState.addTypes(output);
}

void MaxPoolGradOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value orig_input, ::mlir::Value orig_output, ::mlir::Value grad, ::mlir::ArrayAttr ksize, ::mlir::ArrayAttr strides, ::mlir::StringAttr padding, ::mlir::ArrayAttr explicit_paddings, ::mlir::StringAttr data_format) {
  odsState.addOperands(orig_input);
  odsState.addOperands(orig_output);
  odsState.addOperands(grad);
  odsState.addAttribute("ksize", ksize);
  odsState.addAttribute("strides", strides);
  odsState.addAttribute("padding", padding);
  odsState.addAttribute("explicit_paddings", explicit_paddings);
  odsState.addAttribute("data_format", data_format);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void MaxPoolGradOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value orig_input, ::mlir::Value orig_output, ::mlir::Value grad, ::mlir::ArrayAttr ksize, ::mlir::ArrayAttr strides, ::llvm::StringRef padding, ::mlir::ArrayAttr explicit_paddings, ::llvm::StringRef data_format) {
  odsState.addOperands(orig_input);
  odsState.addOperands(orig_output);
  odsState.addOperands(grad);
  odsState.addAttribute("ksize", ksize);
  odsState.addAttribute("strides", strides);
  odsState.addAttribute("padding", odsBuilder.getStringAttr(padding));
  odsState.addAttribute("explicit_paddings", explicit_paddings);
  odsState.addAttribute("data_format", odsBuilder.getStringAttr(data_format));
  odsState.addTypes(output);
}

void MaxPoolGradOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value orig_input, ::mlir::Value orig_output, ::mlir::Value grad, ::mlir::ArrayAttr ksize, ::mlir::ArrayAttr strides, ::llvm::StringRef padding, ::mlir::ArrayAttr explicit_paddings, ::llvm::StringRef data_format) {
  odsState.addOperands(orig_input);
  odsState.addOperands(orig_output);
  odsState.addOperands(grad);
  odsState.addAttribute("ksize", ksize);
  odsState.addAttribute("strides", strides);
  odsState.addAttribute("padding", odsBuilder.getStringAttr(padding));
  odsState.addAttribute("explicit_paddings", explicit_paddings);
  odsState.addAttribute("data_format", odsBuilder.getStringAttr(data_format));
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void MaxPoolGradOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 3u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult MaxPoolGradOp::verify() {
  if (failed(MaxPoolGradOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of integer or floating-point values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of integer or floating-point values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup2 = getODSOperands(2);
    for (::mlir::Value v : valueGroup2) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of integer or floating-point values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>())))))) {
        return emitOpError("result #") << index << " must be tensor of integer or floating-point values, but got " << v.getType();
      }
      ++index;
    }
  }
  return Verify(*this);
}

void MaxPoolGradOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::MaxPoolOp definitions
//===----------------------------------------------------------------------===//

MaxPoolOpAdaptor::MaxPoolOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

MaxPoolOpAdaptor::MaxPoolOpAdaptor(MaxPoolOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> MaxPoolOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange MaxPoolOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value MaxPoolOpAdaptor::input() {
  return *getODSOperands(0).begin();
}

::mlir::ArrayAttr MaxPoolOpAdaptor::ksize() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::ArrayAttr attr = odsAttrs.get("ksize").cast<::mlir::ArrayAttr>();
  return attr;
}

::mlir::ArrayAttr MaxPoolOpAdaptor::strides() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::ArrayAttr attr = odsAttrs.get("strides").cast<::mlir::ArrayAttr>();
  return attr;
}

::mlir::StringAttr MaxPoolOpAdaptor::padding() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::StringAttr attr = odsAttrs.get("padding").cast<::mlir::StringAttr>();
  return attr;
}

::mlir::ArrayAttr MaxPoolOpAdaptor::explicit_paddings() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::ArrayAttr attr = odsAttrs.get("explicit_paddings").dyn_cast_or_null<::mlir::ArrayAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getI64ArrayAttr({});
  return attr;
}

::mlir::StringAttr MaxPoolOpAdaptor::data_format() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::StringAttr attr = odsAttrs.get("data_format").dyn_cast_or_null<::mlir::StringAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getStringAttr("NHWC");
  return attr;
}

::mlir::LogicalResult MaxPoolOpAdaptor::verify(::mlir::Location loc) {
  {
  auto tblgen_ksize = odsAttrs.get("ksize");
  if (!tblgen_ksize) return emitError(loc, "'tf.MaxPool' op ""requires attribute 'ksize'");
    if (!((((tblgen_ksize.isa<::mlir::ArrayAttr>())) && (::llvm::all_of(tblgen_ksize.cast<::mlir::ArrayAttr>(), [](::mlir::Attribute attr) { return ((attr.isa<::mlir::IntegerAttr>())) && ((attr.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(64))); }))) && ((tblgen_ksize.cast<::mlir::ArrayAttr>().size() >= 4)))) return emitError(loc, "'tf.MaxPool' op ""attribute 'ksize' failed to satisfy constraint: 64-bit integer array attribute with at least 4 elements");
  }
  {
  auto tblgen_strides = odsAttrs.get("strides");
  if (!tblgen_strides) return emitError(loc, "'tf.MaxPool' op ""requires attribute 'strides'");
    if (!((((tblgen_strides.isa<::mlir::ArrayAttr>())) && (::llvm::all_of(tblgen_strides.cast<::mlir::ArrayAttr>(), [](::mlir::Attribute attr) { return ((attr.isa<::mlir::IntegerAttr>())) && ((attr.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(64))); }))) && ((tblgen_strides.cast<::mlir::ArrayAttr>().size() >= 4)))) return emitError(loc, "'tf.MaxPool' op ""attribute 'strides' failed to satisfy constraint: 64-bit integer array attribute with at least 4 elements");
  }
  {
  auto tblgen_padding = odsAttrs.get("padding");
  if (!tblgen_padding) return emitError(loc, "'tf.MaxPool' op ""requires attribute 'padding'");
    if (!((tblgen_padding.cast<StringAttr>().getValue() == "SAME" || tblgen_padding.cast<StringAttr>().getValue() == "VALID" || tblgen_padding.cast<StringAttr>().getValue() == "EXPLICIT"))) return emitError(loc, "'tf.MaxPool' op ""attribute 'padding' failed to satisfy constraint: string attribute whose value is SAME, or VALID, or EXPLICIT");
  }
  {
  auto tblgen_explicit_paddings = odsAttrs.get("explicit_paddings");
  if (tblgen_explicit_paddings) {
    if (!(((tblgen_explicit_paddings.isa<::mlir::ArrayAttr>())) && (::llvm::all_of(tblgen_explicit_paddings.cast<::mlir::ArrayAttr>(), [](::mlir::Attribute attr) { return ((attr.isa<::mlir::IntegerAttr>())) && ((attr.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(64))); })))) return emitError(loc, "'tf.MaxPool' op ""attribute 'explicit_paddings' failed to satisfy constraint: 64-bit integer array attribute");
  }
  }
  {
  auto tblgen_data_format = odsAttrs.get("data_format");
  if (tblgen_data_format) {
    if (!((tblgen_data_format.cast<StringAttr>().getValue() == "NHWC" || tblgen_data_format.cast<StringAttr>().getValue() == "NCHW" || tblgen_data_format.cast<StringAttr>().getValue() == "NCHW_VECT_C"))) return emitError(loc, "'tf.MaxPool' op ""attribute 'data_format' failed to satisfy constraint: string attribute whose value is NHWC, or NCHW, or NCHW_VECT_C");
  }
  }
  return ::mlir::success();
}

::llvm::StringRef MaxPoolOp::getOperationName() {
  return "tf.MaxPool";
}

std::pair<unsigned, unsigned> MaxPoolOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range MaxPoolOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value MaxPoolOp::input() {
  return *getODSOperands(0).begin();
}

::mlir::MutableOperandRange MaxPoolOp::inputMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> MaxPoolOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range MaxPoolOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value MaxPoolOp::output() {
  return *getODSResults(0).begin();
}

::mlir::ArrayAttr MaxPoolOp::ksizeAttr() {
  return this->getAttr("ksize").cast<::mlir::ArrayAttr>();
}

::mlir::ArrayAttr MaxPoolOp::ksize() {
  auto attr = ksizeAttr();
  return attr;
}

::mlir::ArrayAttr MaxPoolOp::stridesAttr() {
  return this->getAttr("strides").cast<::mlir::ArrayAttr>();
}

::mlir::ArrayAttr MaxPoolOp::strides() {
  auto attr = stridesAttr();
  return attr;
}

::mlir::StringAttr MaxPoolOp::paddingAttr() {
  return this->getAttr("padding").cast<::mlir::StringAttr>();
}

::llvm::StringRef MaxPoolOp::padding() {
  auto attr = paddingAttr();
  return attr.getValue();
}

::mlir::ArrayAttr MaxPoolOp::explicit_paddingsAttr() {
  return this->getAttr("explicit_paddings").dyn_cast_or_null<::mlir::ArrayAttr>();
}

::mlir::ArrayAttr MaxPoolOp::explicit_paddings() {
  auto attr = explicit_paddingsAttr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getI64ArrayAttr({});
  return attr;
}

::mlir::StringAttr MaxPoolOp::data_formatAttr() {
  return this->getAttr("data_format").dyn_cast_or_null<::mlir::StringAttr>();
}

::llvm::StringRef MaxPoolOp::data_format() {
  auto attr = data_formatAttr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getStringAttr("NHWC").getValue();
  return attr.getValue();
}

Type MaxPoolOp::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

bool MaxPoolOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "T") return true;
 return false;
}

::mlir::DictionaryAttr MaxPoolOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())}
    }, ctx);
}

void MaxPoolOp::ksizeAttr(::mlir::ArrayAttr attr) {
  this->getOperation()->setAttr("ksize", attr);
}

void MaxPoolOp::stridesAttr(::mlir::ArrayAttr attr) {
  this->getOperation()->setAttr("strides", attr);
}

void MaxPoolOp::paddingAttr(::mlir::StringAttr attr) {
  this->getOperation()->setAttr("padding", attr);
}

void MaxPoolOp::explicit_paddingsAttr(::mlir::ArrayAttr attr) {
  this->getOperation()->setAttr("explicit_paddings", attr);
}

void MaxPoolOp::data_formatAttr(::mlir::StringAttr attr) {
  this->getOperation()->setAttr("data_format", attr);
}

void MaxPoolOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value input, ::mlir::ArrayAttr ksize, ::mlir::ArrayAttr strides, ::mlir::StringAttr padding, ::mlir::ArrayAttr explicit_paddings, ::mlir::StringAttr data_format) {
  odsState.addOperands(input);
  odsState.addAttribute("ksize", ksize);
  odsState.addAttribute("strides", strides);
  odsState.addAttribute("padding", padding);
  odsState.addAttribute("explicit_paddings", explicit_paddings);
  odsState.addAttribute("data_format", data_format);
  odsState.addTypes(output);
}

void MaxPoolOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input, ::mlir::ArrayAttr ksize, ::mlir::ArrayAttr strides, ::mlir::StringAttr padding, ::mlir::ArrayAttr explicit_paddings, ::mlir::StringAttr data_format) {
  odsState.addOperands(input);
  odsState.addAttribute("ksize", ksize);
  odsState.addAttribute("strides", strides);
  odsState.addAttribute("padding", padding);
  odsState.addAttribute("explicit_paddings", explicit_paddings);
  odsState.addAttribute("data_format", data_format);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void MaxPoolOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value input, ::mlir::ArrayAttr ksize, ::mlir::ArrayAttr strides, ::llvm::StringRef padding, ::mlir::ArrayAttr explicit_paddings, ::llvm::StringRef data_format) {
  odsState.addOperands(input);
  odsState.addAttribute("ksize", ksize);
  odsState.addAttribute("strides", strides);
  odsState.addAttribute("padding", odsBuilder.getStringAttr(padding));
  odsState.addAttribute("explicit_paddings", explicit_paddings);
  odsState.addAttribute("data_format", odsBuilder.getStringAttr(data_format));
  odsState.addTypes(output);
}

void MaxPoolOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input, ::mlir::ArrayAttr ksize, ::mlir::ArrayAttr strides, ::llvm::StringRef padding, ::mlir::ArrayAttr explicit_paddings, ::llvm::StringRef data_format) {
  odsState.addOperands(input);
  odsState.addAttribute("ksize", ksize);
  odsState.addAttribute("strides", strides);
  odsState.addAttribute("padding", odsBuilder.getStringAttr(padding));
  odsState.addAttribute("explicit_paddings", explicit_paddings);
  odsState.addAttribute("data_format", odsBuilder.getStringAttr(data_format));
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void MaxPoolOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult MaxPoolOp::verify() {
  if (failed(MaxPoolOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of bfloat16 or 16-bit float or 32-bit float or 64-bit float or 16-bit integer or 32-bit integer or 64-bit integer or 8-bit integer or 8-bit quantized integer or 16-bit unsigned integer or 8-bit unsigned integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>())))))) {
        return emitOpError("result #") << index << " must be tensor of bfloat16 or 16-bit float or 32-bit float or 64-bit float or 16-bit integer or 32-bit integer or 64-bit integer or 8-bit integer or 8-bit quantized integer or 16-bit unsigned integer or 8-bit unsigned integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void MaxPoolOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::MaximumOp definitions
//===----------------------------------------------------------------------===//

MaximumOpAdaptor::MaximumOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

MaximumOpAdaptor::MaximumOpAdaptor(MaximumOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> MaximumOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange MaximumOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value MaximumOpAdaptor::x() {
  return *getODSOperands(0).begin();
}

::mlir::Value MaximumOpAdaptor::y() {
  return *getODSOperands(1).begin();
}

::mlir::LogicalResult MaximumOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

::llvm::StringRef MaximumOp::getOperationName() {
  return "tf.Maximum";
}

std::pair<unsigned, unsigned> MaximumOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range MaximumOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value MaximumOp::x() {
  return *getODSOperands(0).begin();
}

::mlir::Value MaximumOp::y() {
  return *getODSOperands(1).begin();
}

::mlir::MutableOperandRange MaximumOp::xMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange MaximumOp::yMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> MaximumOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range MaximumOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value MaximumOp::z() {
  return *getODSResults(0).begin();
}

Type MaximumOp::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

bool MaximumOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "T") return true;
 return false;
}

::mlir::DictionaryAttr MaximumOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())}
    }, ctx);
}

void MaximumOp::build(OpBuilder &builder, OperationState &result, Value  x, Value  y) {
  auto resultType =
      OpTrait::util::getBroadcastedType(x.getType(), y.getType());
  if (!resultType)
    mlir::emitError(result.location, "non-broadcastable operands");
  return build(builder, result, resultType, x, y);
}

void MaximumOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type z, ::mlir::Value x, ::mlir::Value y) {
  odsState.addOperands(x);
  odsState.addOperands(y);
  odsState.addTypes(z);
}

void MaximumOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value x, ::mlir::Value y) {
  odsState.addOperands(x);
  odsState.addOperands(y);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void MaximumOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult MaximumOp::verify() {
  if (failed(MaximumOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of floating-point or 16-bit integer or 32-bit integer or 64-bit integer or 8-bit unsigned integer values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of floating-point or 16-bit integer or 32-bit integer or 64-bit integer or 8-bit unsigned integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>())))))) {
        return emitOpError("result #") << index << " must be tensor of floating-point or 16-bit integer or 32-bit integer or 64-bit integer or 8-bit unsigned integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void MaximumOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::MeanOp definitions
//===----------------------------------------------------------------------===//

MeanOpAdaptor::MeanOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

MeanOpAdaptor::MeanOpAdaptor(MeanOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> MeanOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange MeanOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value MeanOpAdaptor::input() {
  return *getODSOperands(0).begin();
}

::mlir::Value MeanOpAdaptor::reduction_indices() {
  return *getODSOperands(1).begin();
}

::mlir::BoolAttr MeanOpAdaptor::keep_dims() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::BoolAttr attr = odsAttrs.get("keep_dims").dyn_cast_or_null<::mlir::BoolAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getBoolAttr(false);
  return attr;
}

::mlir::LogicalResult MeanOpAdaptor::verify(::mlir::Location loc) {
  {
  auto tblgen_keep_dims = odsAttrs.get("keep_dims");
  if (tblgen_keep_dims) {
    if (!((tblgen_keep_dims.isa<::mlir::BoolAttr>()))) return emitError(loc, "'tf.Mean' op ""attribute 'keep_dims' failed to satisfy constraint: bool attribute");
  }
  }
  return ::mlir::success();
}

::llvm::StringRef MeanOp::getOperationName() {
  return "tf.Mean";
}

std::pair<unsigned, unsigned> MeanOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range MeanOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value MeanOp::input() {
  return *getODSOperands(0).begin();
}

::mlir::Value MeanOp::reduction_indices() {
  return *getODSOperands(1).begin();
}

::mlir::MutableOperandRange MeanOp::inputMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange MeanOp::reduction_indicesMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> MeanOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range MeanOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value MeanOp::output() {
  return *getODSResults(0).begin();
}

::mlir::BoolAttr MeanOp::keep_dimsAttr() {
  return this->getAttr("keep_dims").dyn_cast_or_null<::mlir::BoolAttr>();
}

bool MeanOp::keep_dims() {
  auto attr = keep_dimsAttr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getBoolAttr(false).getValue();
  return attr.getValue();
}

Type MeanOp::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

Type MeanOp::Tidx() {
  return mlir::getElementTypeOrSelf(*getODSOperands(1).begin());
}

bool MeanOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "T") return true;
  if (name == "Tidx") return true;
 return false;
}

::mlir::DictionaryAttr MeanOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())},
    {::mlir::Identifier::get("Tidx", ctx),
::mlir::TypeAttr::get(Tidx())}
    }, ctx);
}

void MeanOp::keep_dimsAttr(::mlir::BoolAttr attr) {
  this->getOperation()->setAttr("keep_dims", attr);
}

void MeanOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value input, ::mlir::Value reduction_indices, ::mlir::BoolAttr keep_dims) {
  odsState.addOperands(input);
  odsState.addOperands(reduction_indices);
  odsState.addAttribute("keep_dims", keep_dims);
  odsState.addTypes(output);
}

void MeanOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input, ::mlir::Value reduction_indices, ::mlir::BoolAttr keep_dims) {
  odsState.addOperands(input);
  odsState.addOperands(reduction_indices);
  odsState.addAttribute("keep_dims", keep_dims);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void MeanOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value input, ::mlir::Value reduction_indices, bool keep_dims) {
  odsState.addOperands(input);
  odsState.addOperands(reduction_indices);
  odsState.addAttribute("keep_dims", odsBuilder.getBoolAttr(keep_dims));
  odsState.addTypes(output);
}

void MeanOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input, ::mlir::Value reduction_indices, bool keep_dims) {
  odsState.addOperands(input);
  odsState.addOperands(reduction_indices);
  odsState.addAttribute("keep_dims", odsBuilder.getBoolAttr(keep_dims));
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void MeanOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult MeanOp::verify() {
  if (failed(MeanOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of bfloat16 or 128-bit complex or 64-bit complex or 16-bit float or 32-bit float or 64-bit float or 16-bit integer or 32-bit integer or 64-bit integer or 8-bit integer or 32-bit quantized integer or 8-bit quantized integer or 8-bit quantized unsigned integer or 16-bit unsigned integer or 32-bit unsigned integer or 64-bit unsigned integer or 8-bit unsigned integer values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of 32/64-bit signed integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>())))))) {
        return emitOpError("result #") << index << " must be tensor of bfloat16 or 128-bit complex or 64-bit complex or 16-bit float or 32-bit float or 64-bit float or 16-bit integer or 32-bit integer or 64-bit integer or 8-bit integer or 32-bit quantized integer or 8-bit quantized integer or 8-bit quantized unsigned integer or 16-bit unsigned integer or 32-bit unsigned integer or 64-bit unsigned integer or 8-bit unsigned integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void MeanOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::MergeSummaryOp definitions
//===----------------------------------------------------------------------===//

MergeSummaryOpAdaptor::MergeSummaryOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

MergeSummaryOpAdaptor::MergeSummaryOpAdaptor(MergeSummaryOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> MergeSummaryOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  bool isVariadic[] = {true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (odsOperands.size() - 0) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::mlir::ValueRange MergeSummaryOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::ValueRange MergeSummaryOpAdaptor::inputs() {
  return getODSOperands(0);
}

::mlir::LogicalResult MergeSummaryOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

::llvm::StringRef MergeSummaryOp::getOperationName() {
  return "tf.MergeSummary";
}

std::pair<unsigned, unsigned> MergeSummaryOp::getODSOperandIndexAndLength(unsigned index) {
  bool isVariadic[] = {true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (getOperation()->getNumOperands() - 0) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::mlir::Operation::operand_range MergeSummaryOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Operation::operand_range MergeSummaryOp::inputs() {
  return getODSOperands(0);
}

::mlir::MutableOperandRange MergeSummaryOp::inputsMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> MergeSummaryOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range MergeSummaryOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value MergeSummaryOp::summary() {
  return *getODSResults(0).begin();
}

size_t MergeSummaryOp::N() {
  auto range = getODSOperands(0);
return std::distance(range.begin(), range.end());
}

bool MergeSummaryOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "N") return true;
 return false;
}

::mlir::DictionaryAttr MergeSummaryOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("N", ctx),
odsBuilder.getI64IntegerAttr(N())}
    }, ctx);
}

void MergeSummaryOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type summary, ::mlir::ValueRange inputs) {
  odsState.addOperands(inputs);
  odsState.addTypes(summary);
}

void MergeSummaryOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

void MergeSummaryOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  odsState.addTypes({operands[0].getType()});

}

::mlir::LogicalResult MergeSummaryOp::verify() {
  if (failed(MergeSummaryOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::StringType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::StringRefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of string values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::StringType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::StringRefType>()))))) {
        return emitOpError("result #") << index << " must be tensor of string values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void MergeSummaryOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::MergeV2CheckpointsOp definitions
//===----------------------------------------------------------------------===//

MergeV2CheckpointsOpAdaptor::MergeV2CheckpointsOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

MergeV2CheckpointsOpAdaptor::MergeV2CheckpointsOpAdaptor(MergeV2CheckpointsOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> MergeV2CheckpointsOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange MergeV2CheckpointsOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value MergeV2CheckpointsOpAdaptor::checkpoint_prefixes() {
  return *getODSOperands(0).begin();
}

::mlir::Value MergeV2CheckpointsOpAdaptor::destination_prefix() {
  return *getODSOperands(1).begin();
}

::mlir::BoolAttr MergeV2CheckpointsOpAdaptor::delete_old_dirs() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::BoolAttr attr = odsAttrs.get("delete_old_dirs").dyn_cast_or_null<::mlir::BoolAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getBoolAttr(true);
  return attr;
}

::mlir::LogicalResult MergeV2CheckpointsOpAdaptor::verify(::mlir::Location loc) {
  {
  auto tblgen_delete_old_dirs = odsAttrs.get("delete_old_dirs");
  if (tblgen_delete_old_dirs) {
    if (!((tblgen_delete_old_dirs.isa<::mlir::BoolAttr>()))) return emitError(loc, "'tf.MergeV2Checkpoints' op ""attribute 'delete_old_dirs' failed to satisfy constraint: bool attribute");
  }
  }
  return ::mlir::success();
}

::llvm::StringRef MergeV2CheckpointsOp::getOperationName() {
  return "tf.MergeV2Checkpoints";
}

std::pair<unsigned, unsigned> MergeV2CheckpointsOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range MergeV2CheckpointsOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value MergeV2CheckpointsOp::checkpoint_prefixes() {
  return *getODSOperands(0).begin();
}

::mlir::Value MergeV2CheckpointsOp::destination_prefix() {
  return *getODSOperands(1).begin();
}

::mlir::MutableOperandRange MergeV2CheckpointsOp::checkpoint_prefixesMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange MergeV2CheckpointsOp::destination_prefixMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> MergeV2CheckpointsOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range MergeV2CheckpointsOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::BoolAttr MergeV2CheckpointsOp::delete_old_dirsAttr() {
  return this->getAttr("delete_old_dirs").dyn_cast_or_null<::mlir::BoolAttr>();
}

bool MergeV2CheckpointsOp::delete_old_dirs() {
  auto attr = delete_old_dirsAttr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getBoolAttr(true).getValue();
  return attr.getValue();
}

void MergeV2CheckpointsOp::delete_old_dirsAttr(::mlir::BoolAttr attr) {
  this->getOperation()->setAttr("delete_old_dirs", attr);
}

void MergeV2CheckpointsOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value checkpoint_prefixes, ::mlir::Value destination_prefix, ::mlir::BoolAttr delete_old_dirs) {
  odsState.addOperands(checkpoint_prefixes);
  odsState.addOperands(destination_prefix);
  odsState.addAttribute("delete_old_dirs", delete_old_dirs);
}

void MergeV2CheckpointsOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value checkpoint_prefixes, ::mlir::Value destination_prefix, ::mlir::BoolAttr delete_old_dirs) {
  odsState.addOperands(checkpoint_prefixes);
  odsState.addOperands(destination_prefix);
  odsState.addAttribute("delete_old_dirs", delete_old_dirs);
  assert(resultTypes.size() == 0u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void MergeV2CheckpointsOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value checkpoint_prefixes, ::mlir::Value destination_prefix, bool delete_old_dirs) {
  odsState.addOperands(checkpoint_prefixes);
  odsState.addOperands(destination_prefix);
  odsState.addAttribute("delete_old_dirs", odsBuilder.getBoolAttr(delete_old_dirs));
}

void MergeV2CheckpointsOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value checkpoint_prefixes, ::mlir::Value destination_prefix, bool delete_old_dirs) {
  odsState.addOperands(checkpoint_prefixes);
  odsState.addOperands(destination_prefix);
  odsState.addAttribute("delete_old_dirs", odsBuilder.getBoolAttr(delete_old_dirs));
  assert(resultTypes.size() == 0u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void MergeV2CheckpointsOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 0u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult MergeV2CheckpointsOp::verify() {
  if (failed(MergeV2CheckpointsOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::StringType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::StringRefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of string values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::StringType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::StringRefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of string values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
  }
  return ::mlir::success();
}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::MinOp definitions
//===----------------------------------------------------------------------===//

MinOpAdaptor::MinOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

MinOpAdaptor::MinOpAdaptor(MinOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> MinOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange MinOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value MinOpAdaptor::input() {
  return *getODSOperands(0).begin();
}

::mlir::Value MinOpAdaptor::reduction_indices() {
  return *getODSOperands(1).begin();
}

::mlir::BoolAttr MinOpAdaptor::keep_dims() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::BoolAttr attr = odsAttrs.get("keep_dims").dyn_cast_or_null<::mlir::BoolAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getBoolAttr(false);
  return attr;
}

::mlir::LogicalResult MinOpAdaptor::verify(::mlir::Location loc) {
  {
  auto tblgen_keep_dims = odsAttrs.get("keep_dims");
  if (tblgen_keep_dims) {
    if (!((tblgen_keep_dims.isa<::mlir::BoolAttr>()))) return emitError(loc, "'tf.Min' op ""attribute 'keep_dims' failed to satisfy constraint: bool attribute");
  }
  }
  return ::mlir::success();
}

::llvm::StringRef MinOp::getOperationName() {
  return "tf.Min";
}

std::pair<unsigned, unsigned> MinOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range MinOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value MinOp::input() {
  return *getODSOperands(0).begin();
}

::mlir::Value MinOp::reduction_indices() {
  return *getODSOperands(1).begin();
}

::mlir::MutableOperandRange MinOp::inputMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange MinOp::reduction_indicesMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> MinOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range MinOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value MinOp::output() {
  return *getODSResults(0).begin();
}

::mlir::BoolAttr MinOp::keep_dimsAttr() {
  return this->getAttr("keep_dims").dyn_cast_or_null<::mlir::BoolAttr>();
}

bool MinOp::keep_dims() {
  auto attr = keep_dimsAttr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getBoolAttr(false).getValue();
  return attr.getValue();
}

Type MinOp::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

Type MinOp::Tidx() {
  return mlir::getElementTypeOrSelf(*getODSOperands(1).begin());
}

bool MinOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "T") return true;
  if (name == "Tidx") return true;
 return false;
}

::mlir::DictionaryAttr MinOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())},
    {::mlir::Identifier::get("Tidx", ctx),
::mlir::TypeAttr::get(Tidx())}
    }, ctx);
}

void MinOp::keep_dimsAttr(::mlir::BoolAttr attr) {
  this->getOperation()->setAttr("keep_dims", attr);
}

void MinOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value input, ::mlir::Value reduction_indices, ::mlir::BoolAttr keep_dims) {
  odsState.addOperands(input);
  odsState.addOperands(reduction_indices);
  odsState.addAttribute("keep_dims", keep_dims);
  odsState.addTypes(output);
}

void MinOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input, ::mlir::Value reduction_indices, ::mlir::BoolAttr keep_dims) {
  odsState.addOperands(input);
  odsState.addOperands(reduction_indices);
  odsState.addAttribute("keep_dims", keep_dims);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void MinOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value input, ::mlir::Value reduction_indices, bool keep_dims) {
  odsState.addOperands(input);
  odsState.addOperands(reduction_indices);
  odsState.addAttribute("keep_dims", odsBuilder.getBoolAttr(keep_dims));
  odsState.addTypes(output);
}

void MinOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input, ::mlir::Value reduction_indices, bool keep_dims) {
  odsState.addOperands(input);
  odsState.addOperands(reduction_indices);
  odsState.addAttribute("keep_dims", odsBuilder.getBoolAttr(keep_dims));
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void MinOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult MinOp::verify() {
  if (failed(MinOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint16Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint16Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of bfloat16 or 16-bit float or 32-bit float or 64-bit float or 16-bit integer or 32-bit integer or 64-bit integer or 8-bit integer or 16-bit quantized integer or 32-bit quantized integer or 8-bit quantized integer or 16-bit quantized unsigned integer or 8-bit quantized unsigned integer or 16-bit unsigned integer or 32-bit unsigned integer or 64-bit unsigned integer or 8-bit unsigned integer values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of 32/64-bit signed integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint16Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint16Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>())))))) {
        return emitOpError("result #") << index << " must be tensor of bfloat16 or 16-bit float or 32-bit float or 64-bit float or 16-bit integer or 32-bit integer or 64-bit integer or 8-bit integer or 16-bit quantized integer or 32-bit quantized integer or 8-bit quantized integer or 16-bit quantized unsigned integer or 8-bit quantized unsigned integer or 16-bit unsigned integer or 32-bit unsigned integer or 64-bit unsigned integer or 8-bit unsigned integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void MinOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::MinimumOp definitions
//===----------------------------------------------------------------------===//

MinimumOpAdaptor::MinimumOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

MinimumOpAdaptor::MinimumOpAdaptor(MinimumOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> MinimumOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange MinimumOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value MinimumOpAdaptor::x() {
  return *getODSOperands(0).begin();
}

::mlir::Value MinimumOpAdaptor::y() {
  return *getODSOperands(1).begin();
}

::mlir::LogicalResult MinimumOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

::llvm::StringRef MinimumOp::getOperationName() {
  return "tf.Minimum";
}

std::pair<unsigned, unsigned> MinimumOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range MinimumOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value MinimumOp::x() {
  return *getODSOperands(0).begin();
}

::mlir::Value MinimumOp::y() {
  return *getODSOperands(1).begin();
}

::mlir::MutableOperandRange MinimumOp::xMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange MinimumOp::yMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> MinimumOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range MinimumOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value MinimumOp::z() {
  return *getODSResults(0).begin();
}

Type MinimumOp::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

bool MinimumOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "T") return true;
 return false;
}

::mlir::DictionaryAttr MinimumOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())}
    }, ctx);
}

void MinimumOp::build(OpBuilder &builder, OperationState &result, Value  x, Value  y) {
  auto resultType =
      OpTrait::util::getBroadcastedType(x.getType(), y.getType());
  if (!resultType)
    mlir::emitError(result.location, "non-broadcastable operands");
  return build(builder, result, resultType, x, y);
}

void MinimumOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type z, ::mlir::Value x, ::mlir::Value y) {
  odsState.addOperands(x);
  odsState.addOperands(y);
  odsState.addTypes(z);
}

void MinimumOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value x, ::mlir::Value y) {
  odsState.addOperands(x);
  odsState.addOperands(y);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void MinimumOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult MinimumOp::verify() {
  if (failed(MinimumOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of bfloat16 or 16-bit float or 32-bit float or 64-bit float or 16-bit integer or 32-bit integer or 64-bit integer or 8-bit unsigned integer values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of bfloat16 or 16-bit float or 32-bit float or 64-bit float or 16-bit integer or 32-bit integer or 64-bit integer or 8-bit unsigned integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>())))))) {
        return emitOpError("result #") << index << " must be tensor of bfloat16 or 16-bit float or 32-bit float or 64-bit float or 16-bit integer or 32-bit integer or 64-bit integer or 8-bit unsigned integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void MinimumOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::MirrorPadOp definitions
//===----------------------------------------------------------------------===//

MirrorPadOpAdaptor::MirrorPadOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

MirrorPadOpAdaptor::MirrorPadOpAdaptor(MirrorPadOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> MirrorPadOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange MirrorPadOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value MirrorPadOpAdaptor::input() {
  return *getODSOperands(0).begin();
}

::mlir::Value MirrorPadOpAdaptor::paddings() {
  return *getODSOperands(1).begin();
}

::mlir::StringAttr MirrorPadOpAdaptor::mode() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::StringAttr attr = odsAttrs.get("mode").cast<::mlir::StringAttr>();
  return attr;
}

::mlir::LogicalResult MirrorPadOpAdaptor::verify(::mlir::Location loc) {
  {
  auto tblgen_mode = odsAttrs.get("mode");
  if (!tblgen_mode) return emitError(loc, "'tf.MirrorPad' op ""requires attribute 'mode'");
    if (!((tblgen_mode.cast<StringAttr>().getValue() == "REFLECT" || tblgen_mode.cast<StringAttr>().getValue() == "SYMMETRIC"))) return emitError(loc, "'tf.MirrorPad' op ""attribute 'mode' failed to satisfy constraint: string attribute whose value is REFLECT, or SYMMETRIC");
  }
  return ::mlir::success();
}

::llvm::StringRef MirrorPadOp::getOperationName() {
  return "tf.MirrorPad";
}

std::pair<unsigned, unsigned> MirrorPadOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range MirrorPadOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value MirrorPadOp::input() {
  return *getODSOperands(0).begin();
}

::mlir::Value MirrorPadOp::paddings() {
  return *getODSOperands(1).begin();
}

::mlir::MutableOperandRange MirrorPadOp::inputMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange MirrorPadOp::paddingsMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> MirrorPadOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range MirrorPadOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value MirrorPadOp::output() {
  return *getODSResults(0).begin();
}

::mlir::StringAttr MirrorPadOp::modeAttr() {
  return this->getAttr("mode").cast<::mlir::StringAttr>();
}

::llvm::StringRef MirrorPadOp::mode() {
  auto attr = modeAttr();
  return attr.getValue();
}

Type MirrorPadOp::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

Type MirrorPadOp::Tpaddings() {
  return mlir::getElementTypeOrSelf(*getODSOperands(1).begin());
}

bool MirrorPadOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "T") return true;
  if (name == "Tpaddings") return true;
 return false;
}

::mlir::DictionaryAttr MirrorPadOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())},
    {::mlir::Identifier::get("Tpaddings", ctx),
::mlir::TypeAttr::get(Tpaddings())}
    }, ctx);
}

void MirrorPadOp::modeAttr(::mlir::StringAttr attr) {
  this->getOperation()->setAttr("mode", attr);
}

void MirrorPadOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value input, ::mlir::Value paddings, ::mlir::StringAttr mode) {
  odsState.addOperands(input);
  odsState.addOperands(paddings);
  odsState.addAttribute("mode", mode);
  odsState.addTypes(output);
}

void MirrorPadOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input, ::mlir::Value paddings, ::mlir::StringAttr mode) {
  odsState.addOperands(input);
  odsState.addOperands(paddings);
  odsState.addAttribute("mode", mode);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void MirrorPadOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value input, ::mlir::Value paddings, ::llvm::StringRef mode) {
  odsState.addOperands(input);
  odsState.addOperands(paddings);
  odsState.addAttribute("mode", odsBuilder.getStringAttr(mode));
  odsState.addTypes(output);
}

void MirrorPadOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input, ::mlir::Value paddings, ::llvm::StringRef mode) {
  odsState.addOperands(input);
  odsState.addOperands(paddings);
  odsState.addAttribute("mode", odsBuilder.getStringAttr(mode));
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void MirrorPadOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult MirrorPadOp::verify() {
  if (failed(MirrorPadOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>())))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::TensorFlowType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of tf.dtype values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of 32/64-bit signed integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>())))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::TensorFlowType>()))))) {
        return emitOpError("result #") << index << " must be tensor of tf.dtype values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void MirrorPadOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::MlirLocalVarOp definitions
//===----------------------------------------------------------------------===//

MlirLocalVarOpAdaptor::MlirLocalVarOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

MlirLocalVarOpAdaptor::MlirLocalVarOpAdaptor(MlirLocalVarOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> MlirLocalVarOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange MlirLocalVarOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::LogicalResult MlirLocalVarOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

::llvm::StringRef MlirLocalVarOp::getOperationName() {
  return "tf.MlirLocalVarOp";
}

std::pair<unsigned, unsigned> MlirLocalVarOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range MlirLocalVarOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

std::pair<unsigned, unsigned> MlirLocalVarOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range MlirLocalVarOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value MlirLocalVarOp::resource() {
  return *getODSResults(0).begin();
}

void MlirLocalVarOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type resource) {
  odsState.addTypes(resource);
}

void MlirLocalVarOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes) {
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void MlirLocalVarOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 0u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult MlirLocalVarOp::verify() {
  if (failed(MlirLocalVarOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::ResourceType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::ResourceRefType>()))))) {
        return emitOpError("result #") << index << " must be tensor of resource values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void MlirLocalVarOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
  for (::mlir::Value value : getODSResults(0))
    effects.emplace_back(MemoryEffects::Allocate::get(), value, ::mlir::TF::ResourceEffects::Variable::get());
}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::MlirPassthroughOp definitions
//===----------------------------------------------------------------------===//

MlirPassthroughOpAdaptor::MlirPassthroughOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

MlirPassthroughOpAdaptor::MlirPassthroughOpAdaptor(MlirPassthroughOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> MlirPassthroughOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  bool isVariadic[] = {true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (odsOperands.size() - 0) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::mlir::ValueRange MlirPassthroughOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::ValueRange MlirPassthroughOpAdaptor::inputs() {
  return getODSOperands(0);
}

::mlir::StringAttr MlirPassthroughOpAdaptor::mlir_module() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::StringAttr attr = odsAttrs.get("mlir_module").cast<::mlir::StringAttr>();
  return attr;
}

::mlir::LogicalResult MlirPassthroughOpAdaptor::verify(::mlir::Location loc) {
  {
  auto tblgen_mlir_module = odsAttrs.get("mlir_module");
  if (!tblgen_mlir_module) return emitError(loc, "'tf.MlirPassthroughOp' op ""requires attribute 'mlir_module'");
    if (!((tblgen_mlir_module.isa<::mlir::StringAttr>()))) return emitError(loc, "'tf.MlirPassthroughOp' op ""attribute 'mlir_module' failed to satisfy constraint: string attribute");
  }
  return ::mlir::success();
}

::llvm::StringRef MlirPassthroughOp::getOperationName() {
  return "tf.MlirPassthroughOp";
}

std::pair<unsigned, unsigned> MlirPassthroughOp::getODSOperandIndexAndLength(unsigned index) {
  bool isVariadic[] = {true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (getOperation()->getNumOperands() - 0) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::mlir::Operation::operand_range MlirPassthroughOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Operation::operand_range MlirPassthroughOp::inputs() {
  return getODSOperands(0);
}

::mlir::MutableOperandRange MlirPassthroughOp::inputsMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> MlirPassthroughOp::getODSResultIndexAndLength(unsigned index) {
  bool isVariadic[] = {true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (getOperation()->getNumResults() - 0) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::mlir::Operation::result_range MlirPassthroughOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Operation::result_range MlirPassthroughOp::outputs() {
  return getODSResults(0);
}

::mlir::StringAttr MlirPassthroughOp::mlir_moduleAttr() {
  return this->getAttr("mlir_module").cast<::mlir::StringAttr>();
}

::llvm::StringRef MlirPassthroughOp::mlir_module() {
  auto attr = mlir_moduleAttr();
  return attr.getValue();
}

mlir::OperandElementTypeRange MlirPassthroughOp::Tinputs() {
  auto values = getODSOperands(0);
return {mlir::OperandElementTypeIterator(values.begin()), mlir::OperandElementTypeIterator(values.end())};
}

mlir::ResultElementTypeRange MlirPassthroughOp::Toutputs() {
  auto values = getODSResults(0);
return {mlir::ResultElementTypeIterator(values.begin()), mlir::ResultElementTypeIterator(values.end())};
}

bool MlirPassthroughOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "Tinputs") return true;
  if (name == "Toutputs") return true;
 return false;
}

::mlir::DictionaryAttr MlirPassthroughOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("Tinputs", ctx),
ArrayAttr::get(
    [&]() {
      llvm::SmallVector<Attribute, 4> ret;
      for (auto t : Tinputs())
        ret.push_back(TypeAttr::get(t));
      return ret;
    }(), ctx)},
    {::mlir::Identifier::get("Toutputs", ctx),
ArrayAttr::get(
    [&]() {
      llvm::SmallVector<Attribute, 4> ret;
      for (auto t : Toutputs())
        ret.push_back(TypeAttr::get(t));
      return ret;
    }(), ctx)}
    }, ctx);
}

void MlirPassthroughOp::mlir_moduleAttr(::mlir::StringAttr attr) {
  this->getOperation()->setAttr("mlir_module", attr);
}

void MlirPassthroughOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange outputs, ::mlir::ValueRange inputs, ::mlir::StringAttr mlir_module) {
  odsState.addOperands(inputs);
  odsState.addAttribute("mlir_module", mlir_module);
  odsState.addTypes(outputs);
}

void MlirPassthroughOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange outputs, ::mlir::ValueRange inputs, ::llvm::StringRef mlir_module) {
  odsState.addOperands(inputs);
  odsState.addAttribute("mlir_module", odsBuilder.getStringAttr(mlir_module));
  odsState.addTypes(outputs);
}

void MlirPassthroughOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult MlirPassthroughOp::verify() {
  if (failed(MlirPassthroughOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>())))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::TensorFlowType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of tf.dtype values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>())))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::TensorFlowType>()))))) {
        return emitOpError("result #") << index << " must be tensor of tf.dtype values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void MlirPassthroughOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::ModOp definitions
//===----------------------------------------------------------------------===//

ModOpAdaptor::ModOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

ModOpAdaptor::ModOpAdaptor(ModOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> ModOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange ModOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value ModOpAdaptor::x() {
  return *getODSOperands(0).begin();
}

::mlir::Value ModOpAdaptor::y() {
  return *getODSOperands(1).begin();
}

::mlir::LogicalResult ModOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

::llvm::StringRef ModOp::getOperationName() {
  return "tf.Mod";
}

std::pair<unsigned, unsigned> ModOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range ModOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value ModOp::x() {
  return *getODSOperands(0).begin();
}

::mlir::Value ModOp::y() {
  return *getODSOperands(1).begin();
}

::mlir::MutableOperandRange ModOp::xMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange ModOp::yMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> ModOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range ModOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value ModOp::z() {
  return *getODSResults(0).begin();
}

Type ModOp::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

bool ModOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "T") return true;
 return false;
}

::mlir::DictionaryAttr ModOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())}
    }, ctx);
}

void ModOp::build(OpBuilder &builder, OperationState &result, Value  x, Value  y) {
  auto resultType =
      OpTrait::util::getBroadcastedType(x.getType(), y.getType());
  if (!resultType)
    mlir::emitError(result.location, "non-broadcastable operands");
  return build(builder, result, resultType, x, y);
}

void ModOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type z, ::mlir::Value x, ::mlir::Value y) {
  odsState.addOperands(x);
  odsState.addOperands(y);
  odsState.addTypes(z);
}

void ModOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value x, ::mlir::Value y) {
  odsState.addOperands(x);
  odsState.addOperands(y);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void ModOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult ModOp::verify() {
  if (failed(ModOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of floating-point or 32/64-bit signed integer values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of floating-point or 32/64-bit signed integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))))) {
        return emitOpError("result #") << index << " must be tensor of floating-point or 32/64-bit signed integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void ModOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::MulNoNanOp definitions
//===----------------------------------------------------------------------===//

MulNoNanOpAdaptor::MulNoNanOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

MulNoNanOpAdaptor::MulNoNanOpAdaptor(MulNoNanOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> MulNoNanOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange MulNoNanOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value MulNoNanOpAdaptor::x() {
  return *getODSOperands(0).begin();
}

::mlir::Value MulNoNanOpAdaptor::y() {
  return *getODSOperands(1).begin();
}

::mlir::LogicalResult MulNoNanOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

::llvm::StringRef MulNoNanOp::getOperationName() {
  return "tf.MulNoNan";
}

std::pair<unsigned, unsigned> MulNoNanOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range MulNoNanOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value MulNoNanOp::x() {
  return *getODSOperands(0).begin();
}

::mlir::Value MulNoNanOp::y() {
  return *getODSOperands(1).begin();
}

::mlir::MutableOperandRange MulNoNanOp::xMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange MulNoNanOp::yMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> MulNoNanOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range MulNoNanOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value MulNoNanOp::z() {
  return *getODSResults(0).begin();
}

Type MulNoNanOp::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

bool MulNoNanOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "T") return true;
 return false;
}

::mlir::DictionaryAttr MulNoNanOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())}
    }, ctx);
}

void MulNoNanOp::build(OpBuilder &builder, OperationState &result, Value  x, Value  y) {
  auto resultType =
      OpTrait::util::getBroadcastedType(x.getType(), y.getType());
  if (!resultType)
    mlir::emitError(result.location, "non-broadcastable operands");
  return build(builder, result, resultType, x, y);
}

void MulNoNanOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type z, ::mlir::Value x, ::mlir::Value y) {
  odsState.addOperands(x);
  odsState.addOperands(y);
  odsState.addTypes(z);
}

void MulNoNanOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value x, ::mlir::Value y) {
  odsState.addOperands(x);
  odsState.addOperands(y);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void MulNoNanOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult MulNoNanOp::verify() {
  if (failed(MulNoNanOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))))))) {
        return emitOpError("operand #") << index << " must be tensor of floating-point or complex values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))))))) {
        return emitOpError("operand #") << index << " must be tensor of floating-point or complex values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))))))) {
        return emitOpError("result #") << index << " must be tensor of floating-point or complex values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void MulNoNanOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::MulOp definitions
//===----------------------------------------------------------------------===//

MulOpAdaptor::MulOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

MulOpAdaptor::MulOpAdaptor(MulOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> MulOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange MulOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value MulOpAdaptor::x() {
  return *getODSOperands(0).begin();
}

::mlir::Value MulOpAdaptor::y() {
  return *getODSOperands(1).begin();
}

::mlir::LogicalResult MulOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

::llvm::StringRef MulOp::getOperationName() {
  return "tf.Mul";
}

std::pair<unsigned, unsigned> MulOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range MulOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value MulOp::x() {
  return *getODSOperands(0).begin();
}

::mlir::Value MulOp::y() {
  return *getODSOperands(1).begin();
}

::mlir::MutableOperandRange MulOp::xMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange MulOp::yMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> MulOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range MulOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value MulOp::z() {
  return *getODSResults(0).begin();
}

Type MulOp::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

bool MulOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "T") return true;
 return false;
}

::mlir::DictionaryAttr MulOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())}
    }, ctx);
}

void MulOp::build(OpBuilder &builder, OperationState &result, Value  x, Value  y) {
  auto resultType =
      OpTrait::util::getBroadcastedType(x.getType(), y.getType());
  if (!resultType)
    mlir::emitError(result.location, "non-broadcastable operands");
  return build(builder, result, resultType, x, y);
}

void MulOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type z, ::mlir::Value x, ::mlir::Value y) {
  odsState.addOperands(x);
  odsState.addOperands(y);
  odsState.addTypes(z);
}

void MulOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value x, ::mlir::Value y) {
  odsState.addOperands(x);
  odsState.addOperands(y);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void MulOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult MulOp::verify() {
  if (failed(MulOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of bfloat16 or 128-bit complex or 64-bit complex or 16-bit float or 32-bit float or 64-bit float or 16-bit integer or 32-bit integer or 64-bit integer or 8-bit integer or 16-bit unsigned integer or 8-bit unsigned integer values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of bfloat16 or 128-bit complex or 64-bit complex or 16-bit float or 32-bit float or 64-bit float or 16-bit integer or 32-bit integer or 64-bit integer or 8-bit integer or 16-bit unsigned integer or 8-bit unsigned integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>())))))) {
        return emitOpError("result #") << index << " must be tensor of bfloat16 or 128-bit complex or 64-bit complex or 16-bit float or 32-bit float or 64-bit float or 16-bit integer or 32-bit integer or 64-bit integer or 8-bit integer or 16-bit unsigned integer or 8-bit unsigned integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}



void MulOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::MultiDeviceIteratorFromStringHandleOp definitions
//===----------------------------------------------------------------------===//

MultiDeviceIteratorFromStringHandleOpAdaptor::MultiDeviceIteratorFromStringHandleOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

MultiDeviceIteratorFromStringHandleOpAdaptor::MultiDeviceIteratorFromStringHandleOpAdaptor(MultiDeviceIteratorFromStringHandleOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> MultiDeviceIteratorFromStringHandleOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange MultiDeviceIteratorFromStringHandleOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value MultiDeviceIteratorFromStringHandleOpAdaptor::string_handle() {
  return *getODSOperands(0).begin();
}

::mlir::ArrayAttr MultiDeviceIteratorFromStringHandleOpAdaptor::output_types() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::ArrayAttr attr = odsAttrs.get("output_types").dyn_cast_or_null<::mlir::ArrayAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getTypeArrayAttr({});
  return attr;
}

::mlir::ArrayAttr MultiDeviceIteratorFromStringHandleOpAdaptor::output_shapes() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::ArrayAttr attr = odsAttrs.get("output_shapes").dyn_cast_or_null<::mlir::ArrayAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getArrayAttr({});
  return attr;
}

::mlir::LogicalResult MultiDeviceIteratorFromStringHandleOpAdaptor::verify(::mlir::Location loc) {
  {
  auto tblgen_output_types = odsAttrs.get("output_types");
  if (tblgen_output_types) {
    if (!(((tblgen_output_types.isa<::mlir::ArrayAttr>())) && (::llvm::all_of(tblgen_output_types.cast<::mlir::ArrayAttr>(), [](::mlir::Attribute attr) { return ((attr.isa<::mlir::TypeAttr>())) && ((attr.cast<::mlir::TypeAttr>().getValue().isa<::mlir::Type>())); })))) return emitError(loc, "'tf.MultiDeviceIteratorFromStringHandle' op ""attribute 'output_types' failed to satisfy constraint: type array attribute");
  }
  }
  {
  auto tblgen_output_shapes = odsAttrs.get("output_shapes");
  if (tblgen_output_shapes) {
    if (!(((tblgen_output_shapes.isa<::mlir::ArrayAttr>())) && (::llvm::all_of(tblgen_output_shapes.cast<::mlir::ArrayAttr>(), [](::mlir::Attribute attr) { return (attr.isa<mlir::TF::ShapeAttr>()); })))) return emitError(loc, "'tf.MultiDeviceIteratorFromStringHandle' op ""attribute 'output_shapes' failed to satisfy constraint: tensorflow shape attribute array");
  }
  }
  return ::mlir::success();
}

::llvm::StringRef MultiDeviceIteratorFromStringHandleOp::getOperationName() {
  return "tf.MultiDeviceIteratorFromStringHandle";
}

std::pair<unsigned, unsigned> MultiDeviceIteratorFromStringHandleOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range MultiDeviceIteratorFromStringHandleOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value MultiDeviceIteratorFromStringHandleOp::string_handle() {
  return *getODSOperands(0).begin();
}

::mlir::MutableOperandRange MultiDeviceIteratorFromStringHandleOp::string_handleMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> MultiDeviceIteratorFromStringHandleOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range MultiDeviceIteratorFromStringHandleOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value MultiDeviceIteratorFromStringHandleOp::multi_device_iterator() {
  return *getODSResults(0).begin();
}

::mlir::ArrayAttr MultiDeviceIteratorFromStringHandleOp::output_typesAttr() {
  return this->getAttr("output_types").dyn_cast_or_null<::mlir::ArrayAttr>();
}

::mlir::ArrayAttr MultiDeviceIteratorFromStringHandleOp::output_types() {
  auto attr = output_typesAttr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getTypeArrayAttr({});
  return attr;
}

::mlir::ArrayAttr MultiDeviceIteratorFromStringHandleOp::output_shapesAttr() {
  return this->getAttr("output_shapes").dyn_cast_or_null<::mlir::ArrayAttr>();
}

::mlir::ArrayAttr MultiDeviceIteratorFromStringHandleOp::output_shapes() {
  auto attr = output_shapesAttr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getArrayAttr({});
  return attr;
}

void MultiDeviceIteratorFromStringHandleOp::output_typesAttr(::mlir::ArrayAttr attr) {
  this->getOperation()->setAttr("output_types", attr);
}

void MultiDeviceIteratorFromStringHandleOp::output_shapesAttr(::mlir::ArrayAttr attr) {
  this->getOperation()->setAttr("output_shapes", attr);
}

void MultiDeviceIteratorFromStringHandleOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type multi_device_iterator, ::mlir::Value string_handle, ::mlir::ArrayAttr output_types, ::mlir::ArrayAttr output_shapes) {
  odsState.addOperands(string_handle);
  odsState.addAttribute("output_types", output_types);
  odsState.addAttribute("output_shapes", output_shapes);
  odsState.addTypes(multi_device_iterator);
}

void MultiDeviceIteratorFromStringHandleOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value string_handle, ::mlir::ArrayAttr output_types, ::mlir::ArrayAttr output_shapes) {
  odsState.addOperands(string_handle);
  odsState.addAttribute("output_types", output_types);
  odsState.addAttribute("output_shapes", output_shapes);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void MultiDeviceIteratorFromStringHandleOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult MultiDeviceIteratorFromStringHandleOp::verify() {
  if (failed(MultiDeviceIteratorFromStringHandleOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::StringType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::StringRefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of string values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::ResourceType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::ResourceRefType>()))))) {
        return emitOpError("result #") << index << " must be tensor of resource values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void MultiDeviceIteratorFromStringHandleOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
  for (::mlir::Value value : getODSResults(0))
    effects.emplace_back(MemoryEffects::Allocate::get(), value, ::mlir::TF::ResourceEffects::DatasetIterator::get());
}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::MultiDeviceIteratorGetNextFromShardOp definitions
//===----------------------------------------------------------------------===//

MultiDeviceIteratorGetNextFromShardOpAdaptor::MultiDeviceIteratorGetNextFromShardOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

MultiDeviceIteratorGetNextFromShardOpAdaptor::MultiDeviceIteratorGetNextFromShardOpAdaptor(MultiDeviceIteratorGetNextFromShardOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> MultiDeviceIteratorGetNextFromShardOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange MultiDeviceIteratorGetNextFromShardOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value MultiDeviceIteratorGetNextFromShardOpAdaptor::multi_device_iterator() {
  return *getODSOperands(0).begin();
}

::mlir::Value MultiDeviceIteratorGetNextFromShardOpAdaptor::shard_num() {
  return *getODSOperands(1).begin();
}

::mlir::Value MultiDeviceIteratorGetNextFromShardOpAdaptor::incarnation_id() {
  return *getODSOperands(2).begin();
}

::mlir::LogicalResult MultiDeviceIteratorGetNextFromShardOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

::llvm::StringRef MultiDeviceIteratorGetNextFromShardOp::getOperationName() {
  return "tf.MultiDeviceIteratorGetNextFromShard";
}

std::pair<unsigned, unsigned> MultiDeviceIteratorGetNextFromShardOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range MultiDeviceIteratorGetNextFromShardOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value MultiDeviceIteratorGetNextFromShardOp::multi_device_iterator() {
  return *getODSOperands(0).begin();
}

::mlir::Value MultiDeviceIteratorGetNextFromShardOp::shard_num() {
  return *getODSOperands(1).begin();
}

::mlir::Value MultiDeviceIteratorGetNextFromShardOp::incarnation_id() {
  return *getODSOperands(2).begin();
}

::mlir::MutableOperandRange MultiDeviceIteratorGetNextFromShardOp::multi_device_iteratorMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange MultiDeviceIteratorGetNextFromShardOp::shard_numMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange MultiDeviceIteratorGetNextFromShardOp::incarnation_idMutable() {
  auto range = getODSOperandIndexAndLength(2);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> MultiDeviceIteratorGetNextFromShardOp::getODSResultIndexAndLength(unsigned index) {
  bool isVariadic[] = {true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (getOperation()->getNumResults() - 0) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::mlir::Operation::result_range MultiDeviceIteratorGetNextFromShardOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Operation::result_range MultiDeviceIteratorGetNextFromShardOp::components() {
  return getODSResults(0);
}

mlir::TF::ResultShapeRange MultiDeviceIteratorGetNextFromShardOp::output_shapes() {
  auto values = getODSResults(0);
return {mlir::TF::ResultShapeIterator(values.begin()), mlir::TF::ResultShapeIterator(values.end())};
}

mlir::ResultElementTypeRange MultiDeviceIteratorGetNextFromShardOp::output_types() {
  auto values = getODSResults(0);
return {mlir::ResultElementTypeIterator(values.begin()), mlir::ResultElementTypeIterator(values.end())};
}

bool MultiDeviceIteratorGetNextFromShardOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "output_shapes") return true;
  if (name == "output_types") return true;
 return false;
}

::mlir::DictionaryAttr MultiDeviceIteratorGetNextFromShardOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("output_shapes", ctx),
ArrayAttr::get(
      [&](){
        llvm::SmallVector<Attribute, 4> ret;
        for (auto shape : output_shapes())
          ret.push_back(mlir::TF::ShapeAttr::get(ctx, shape));
        return ret;
      }(), ctx)},
    {::mlir::Identifier::get("output_types", ctx),
ArrayAttr::get(
    [&]() {
      llvm::SmallVector<Attribute, 4> ret;
      for (auto t : output_types())
        ret.push_back(TypeAttr::get(t));
      return ret;
    }(), ctx)}
    }, ctx);
}

void MultiDeviceIteratorGetNextFromShardOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange components, ::mlir::Value multi_device_iterator, ::mlir::Value shard_num, ::mlir::Value incarnation_id) {
  odsState.addOperands(multi_device_iterator);
  odsState.addOperands(shard_num);
  odsState.addOperands(incarnation_id);
  odsState.addTypes(components);
}

void MultiDeviceIteratorGetNextFromShardOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 3u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult MultiDeviceIteratorGetNextFromShardOp::verify() {
  if (failed(MultiDeviceIteratorGetNextFromShardOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::ResourceType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::ResourceRefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of resource values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of 32-bit integer values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup2 = getODSOperands(2);
    for (::mlir::Value v : valueGroup2) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of 64-bit integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>())))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::TensorFlowType>()))))) {
        return emitOpError("result #") << index << " must be tensor of tf.dtype values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void MultiDeviceIteratorGetNextFromShardOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
  for (::mlir::Value value : getODSOperands(0))
    effects.emplace_back(MemoryEffects::Read::get(), value, ::mlir::TF::ResourceEffects::DatasetIterator::get());
  for (::mlir::Value value : getODSOperands(0))
    effects.emplace_back(MemoryEffects::Write::get(), value, ::mlir::TF::ResourceEffects::DatasetIterator::get());
}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::MultiDeviceIteratorInitOp definitions
//===----------------------------------------------------------------------===//

MultiDeviceIteratorInitOpAdaptor::MultiDeviceIteratorInitOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

MultiDeviceIteratorInitOpAdaptor::MultiDeviceIteratorInitOpAdaptor(MultiDeviceIteratorInitOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> MultiDeviceIteratorInitOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange MultiDeviceIteratorInitOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value MultiDeviceIteratorInitOpAdaptor::dataset() {
  return *getODSOperands(0).begin();
}

::mlir::Value MultiDeviceIteratorInitOpAdaptor::multi_device_iterator() {
  return *getODSOperands(1).begin();
}

::mlir::Value MultiDeviceIteratorInitOpAdaptor::max_buffer_size() {
  return *getODSOperands(2).begin();
}

::mlir::LogicalResult MultiDeviceIteratorInitOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

::llvm::StringRef MultiDeviceIteratorInitOp::getOperationName() {
  return "tf.MultiDeviceIteratorInit";
}

std::pair<unsigned, unsigned> MultiDeviceIteratorInitOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range MultiDeviceIteratorInitOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value MultiDeviceIteratorInitOp::dataset() {
  return *getODSOperands(0).begin();
}

::mlir::Value MultiDeviceIteratorInitOp::multi_device_iterator() {
  return *getODSOperands(1).begin();
}

::mlir::Value MultiDeviceIteratorInitOp::max_buffer_size() {
  return *getODSOperands(2).begin();
}

::mlir::MutableOperandRange MultiDeviceIteratorInitOp::datasetMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange MultiDeviceIteratorInitOp::multi_device_iteratorMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange MultiDeviceIteratorInitOp::max_buffer_sizeMutable() {
  auto range = getODSOperandIndexAndLength(2);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> MultiDeviceIteratorInitOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range MultiDeviceIteratorInitOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value MultiDeviceIteratorInitOp::incarnation_id() {
  return *getODSResults(0).begin();
}

void MultiDeviceIteratorInitOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type incarnation_id, ::mlir::Value dataset, ::mlir::Value multi_device_iterator, ::mlir::Value max_buffer_size) {
  odsState.addOperands(dataset);
  odsState.addOperands(multi_device_iterator);
  odsState.addOperands(max_buffer_size);
  odsState.addTypes(incarnation_id);
}

void MultiDeviceIteratorInitOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value dataset, ::mlir::Value multi_device_iterator, ::mlir::Value max_buffer_size) {
  odsState.addOperands(dataset);
  odsState.addOperands(multi_device_iterator);
  odsState.addOperands(max_buffer_size);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void MultiDeviceIteratorInitOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 3u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult MultiDeviceIteratorInitOp::verify() {
  if (failed(MultiDeviceIteratorInitOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::VariantType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::VariantRefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of variant values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::ResourceType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::ResourceRefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of resource values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup2 = getODSOperands(2);
    for (::mlir::Value v : valueGroup2) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of 64-bit integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))))) {
        return emitOpError("result #") << index << " must be tensor of 64-bit integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void MultiDeviceIteratorInitOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
  for (::mlir::Value value : getODSOperands(1))
    effects.emplace_back(MemoryEffects::Write::get(), value, ::mlir::TF::ResourceEffects::DatasetIterator::get());
}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::MultiDeviceIteratorOp definitions
//===----------------------------------------------------------------------===//

MultiDeviceIteratorOpAdaptor::MultiDeviceIteratorOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

MultiDeviceIteratorOpAdaptor::MultiDeviceIteratorOpAdaptor(MultiDeviceIteratorOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> MultiDeviceIteratorOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange MultiDeviceIteratorOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::ArrayAttr MultiDeviceIteratorOpAdaptor::devices() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::ArrayAttr attr = odsAttrs.get("devices").cast<::mlir::ArrayAttr>();
  return attr;
}

::mlir::StringAttr MultiDeviceIteratorOpAdaptor::shared_name() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::StringAttr attr = odsAttrs.get("shared_name").cast<::mlir::StringAttr>();
  return attr;
}

::mlir::StringAttr MultiDeviceIteratorOpAdaptor::container() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::StringAttr attr = odsAttrs.get("container").cast<::mlir::StringAttr>();
  return attr;
}

::mlir::ArrayAttr MultiDeviceIteratorOpAdaptor::output_types() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::ArrayAttr attr = odsAttrs.get("output_types").cast<::mlir::ArrayAttr>();
  return attr;
}

::mlir::ArrayAttr MultiDeviceIteratorOpAdaptor::output_shapes() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::ArrayAttr attr = odsAttrs.get("output_shapes").cast<::mlir::ArrayAttr>();
  return attr;
}

::mlir::LogicalResult MultiDeviceIteratorOpAdaptor::verify(::mlir::Location loc) {
  {
  auto tblgen_devices = odsAttrs.get("devices");
  if (!tblgen_devices) return emitError(loc, "'tf.MultiDeviceIterator' op ""requires attribute 'devices'");
    if (!((((tblgen_devices.isa<::mlir::ArrayAttr>())) && (::llvm::all_of(tblgen_devices.cast<::mlir::ArrayAttr>(), [](::mlir::Attribute attr) { return (attr.isa<::mlir::StringAttr>()); }))) && ((tblgen_devices.cast<::mlir::ArrayAttr>().size() >= 1)))) return emitError(loc, "'tf.MultiDeviceIterator' op ""attribute 'devices' failed to satisfy constraint: string array attribute with at least 1 elements");
  }
  {
  auto tblgen_shared_name = odsAttrs.get("shared_name");
  if (!tblgen_shared_name) return emitError(loc, "'tf.MultiDeviceIterator' op ""requires attribute 'shared_name'");
    if (!((tblgen_shared_name.isa<::mlir::StringAttr>()))) return emitError(loc, "'tf.MultiDeviceIterator' op ""attribute 'shared_name' failed to satisfy constraint: string attribute");
  }
  {
  auto tblgen_container = odsAttrs.get("container");
  if (!tblgen_container) return emitError(loc, "'tf.MultiDeviceIterator' op ""requires attribute 'container'");
    if (!((tblgen_container.isa<::mlir::StringAttr>()))) return emitError(loc, "'tf.MultiDeviceIterator' op ""attribute 'container' failed to satisfy constraint: string attribute");
  }
  {
  auto tblgen_output_types = odsAttrs.get("output_types");
  if (!tblgen_output_types) return emitError(loc, "'tf.MultiDeviceIterator' op ""requires attribute 'output_types'");
    if (!((((tblgen_output_types.isa<::mlir::ArrayAttr>())) && (::llvm::all_of(tblgen_output_types.cast<::mlir::ArrayAttr>(), [](::mlir::Attribute attr) { return ((attr.isa<::mlir::TypeAttr>())) && ((attr.cast<::mlir::TypeAttr>().getValue().isa<::mlir::Type>())); }))) && ((tblgen_output_types.cast<::mlir::ArrayAttr>().size() >= 1)))) return emitError(loc, "'tf.MultiDeviceIterator' op ""attribute 'output_types' failed to satisfy constraint: type array attribute with at least 1 elements");
  }
  {
  auto tblgen_output_shapes = odsAttrs.get("output_shapes");
  if (!tblgen_output_shapes) return emitError(loc, "'tf.MultiDeviceIterator' op ""requires attribute 'output_shapes'");
    if (!((((tblgen_output_shapes.isa<::mlir::ArrayAttr>())) && (::llvm::all_of(tblgen_output_shapes.cast<::mlir::ArrayAttr>(), [](::mlir::Attribute attr) { return (attr.isa<mlir::TF::ShapeAttr>()); }))) && ((tblgen_output_shapes.cast<::mlir::ArrayAttr>().size() >= 1)))) return emitError(loc, "'tf.MultiDeviceIterator' op ""attribute 'output_shapes' failed to satisfy constraint: tensorflow shape attribute array with at least 1 elements");
  }
  return ::mlir::success();
}

::llvm::StringRef MultiDeviceIteratorOp::getOperationName() {
  return "tf.MultiDeviceIterator";
}

std::pair<unsigned, unsigned> MultiDeviceIteratorOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range MultiDeviceIteratorOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

std::pair<unsigned, unsigned> MultiDeviceIteratorOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range MultiDeviceIteratorOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value MultiDeviceIteratorOp::handle() {
  return *getODSResults(0).begin();
}

::mlir::ArrayAttr MultiDeviceIteratorOp::devicesAttr() {
  return this->getAttr("devices").cast<::mlir::ArrayAttr>();
}

::mlir::ArrayAttr MultiDeviceIteratorOp::devices() {
  auto attr = devicesAttr();
  return attr;
}

::mlir::StringAttr MultiDeviceIteratorOp::shared_nameAttr() {
  return this->getAttr("shared_name").cast<::mlir::StringAttr>();
}

::llvm::StringRef MultiDeviceIteratorOp::shared_name() {
  auto attr = shared_nameAttr();
  return attr.getValue();
}

::mlir::StringAttr MultiDeviceIteratorOp::containerAttr() {
  return this->getAttr("container").cast<::mlir::StringAttr>();
}

::llvm::StringRef MultiDeviceIteratorOp::container() {
  auto attr = containerAttr();
  return attr.getValue();
}

::mlir::ArrayAttr MultiDeviceIteratorOp::output_typesAttr() {
  return this->getAttr("output_types").cast<::mlir::ArrayAttr>();
}

::mlir::ArrayAttr MultiDeviceIteratorOp::output_types() {
  auto attr = output_typesAttr();
  return attr;
}

::mlir::ArrayAttr MultiDeviceIteratorOp::output_shapesAttr() {
  return this->getAttr("output_shapes").cast<::mlir::ArrayAttr>();
}

::mlir::ArrayAttr MultiDeviceIteratorOp::output_shapes() {
  auto attr = output_shapesAttr();
  return attr;
}

void MultiDeviceIteratorOp::devicesAttr(::mlir::ArrayAttr attr) {
  this->getOperation()->setAttr("devices", attr);
}

void MultiDeviceIteratorOp::shared_nameAttr(::mlir::StringAttr attr) {
  this->getOperation()->setAttr("shared_name", attr);
}

void MultiDeviceIteratorOp::containerAttr(::mlir::StringAttr attr) {
  this->getOperation()->setAttr("container", attr);
}

void MultiDeviceIteratorOp::output_typesAttr(::mlir::ArrayAttr attr) {
  this->getOperation()->setAttr("output_types", attr);
}

void MultiDeviceIteratorOp::output_shapesAttr(::mlir::ArrayAttr attr) {
  this->getOperation()->setAttr("output_shapes", attr);
}

void MultiDeviceIteratorOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type handle, ::mlir::ArrayAttr devices, ::mlir::StringAttr shared_name, ::mlir::StringAttr container, ::mlir::ArrayAttr output_types, ::mlir::ArrayAttr output_shapes) {
  odsState.addAttribute("devices", devices);
  odsState.addAttribute("shared_name", shared_name);
  odsState.addAttribute("container", container);
  odsState.addAttribute("output_types", output_types);
  odsState.addAttribute("output_shapes", output_shapes);
  odsState.addTypes(handle);
}

void MultiDeviceIteratorOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ArrayAttr devices, ::mlir::StringAttr shared_name, ::mlir::StringAttr container, ::mlir::ArrayAttr output_types, ::mlir::ArrayAttr output_shapes) {
  odsState.addAttribute("devices", devices);
  odsState.addAttribute("shared_name", shared_name);
  odsState.addAttribute("container", container);
  odsState.addAttribute("output_types", output_types);
  odsState.addAttribute("output_shapes", output_shapes);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void MultiDeviceIteratorOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type handle, ::mlir::ArrayAttr devices, ::llvm::StringRef shared_name, ::llvm::StringRef container, ::mlir::ArrayAttr output_types, ::mlir::ArrayAttr output_shapes) {
  odsState.addAttribute("devices", devices);
  odsState.addAttribute("shared_name", odsBuilder.getStringAttr(shared_name));
  odsState.addAttribute("container", odsBuilder.getStringAttr(container));
  odsState.addAttribute("output_types", output_types);
  odsState.addAttribute("output_shapes", output_shapes);
  odsState.addTypes(handle);
}

void MultiDeviceIteratorOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ArrayAttr devices, ::llvm::StringRef shared_name, ::llvm::StringRef container, ::mlir::ArrayAttr output_types, ::mlir::ArrayAttr output_shapes) {
  odsState.addAttribute("devices", devices);
  odsState.addAttribute("shared_name", odsBuilder.getStringAttr(shared_name));
  odsState.addAttribute("container", odsBuilder.getStringAttr(container));
  odsState.addAttribute("output_types", output_types);
  odsState.addAttribute("output_shapes", output_shapes);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void MultiDeviceIteratorOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 0u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult MultiDeviceIteratorOp::verify() {
  if (failed(MultiDeviceIteratorOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::ResourceType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::ResourceRefType>()))))) {
        return emitOpError("result #") << index << " must be tensor of resource values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void MultiDeviceIteratorOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
  for (::mlir::Value value : getODSResults(0))
    effects.emplace_back(MemoryEffects::Allocate::get(), value, ::mlir::TF::ResourceEffects::DatasetIterator::get());
}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::MultiDeviceIteratorToStringHandleOp definitions
//===----------------------------------------------------------------------===//

MultiDeviceIteratorToStringHandleOpAdaptor::MultiDeviceIteratorToStringHandleOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

MultiDeviceIteratorToStringHandleOpAdaptor::MultiDeviceIteratorToStringHandleOpAdaptor(MultiDeviceIteratorToStringHandleOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> MultiDeviceIteratorToStringHandleOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange MultiDeviceIteratorToStringHandleOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value MultiDeviceIteratorToStringHandleOpAdaptor::multi_device_iterator() {
  return *getODSOperands(0).begin();
}

::mlir::LogicalResult MultiDeviceIteratorToStringHandleOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

::llvm::StringRef MultiDeviceIteratorToStringHandleOp::getOperationName() {
  return "tf.MultiDeviceIteratorToStringHandle";
}

std::pair<unsigned, unsigned> MultiDeviceIteratorToStringHandleOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range MultiDeviceIteratorToStringHandleOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value MultiDeviceIteratorToStringHandleOp::multi_device_iterator() {
  return *getODSOperands(0).begin();
}

::mlir::MutableOperandRange MultiDeviceIteratorToStringHandleOp::multi_device_iteratorMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> MultiDeviceIteratorToStringHandleOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range MultiDeviceIteratorToStringHandleOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value MultiDeviceIteratorToStringHandleOp::string_handle() {
  return *getODSResults(0).begin();
}

void MultiDeviceIteratorToStringHandleOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type string_handle, ::mlir::Value multi_device_iterator) {
  odsState.addOperands(multi_device_iterator);
  odsState.addTypes(string_handle);
}

void MultiDeviceIteratorToStringHandleOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value multi_device_iterator) {
  odsState.addOperands(multi_device_iterator);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void MultiDeviceIteratorToStringHandleOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult MultiDeviceIteratorToStringHandleOp::verify() {
  if (failed(MultiDeviceIteratorToStringHandleOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::ResourceType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::ResourceRefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of resource values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::StringType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::StringRefType>()))))) {
        return emitOpError("result #") << index << " must be tensor of string values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void MultiDeviceIteratorToStringHandleOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
  for (::mlir::Value value : getODSOperands(0))
    effects.emplace_back(MemoryEffects::Read::get(), value, ::mlir::TF::ResourceEffects::DatasetIterator::get());
}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::MultinomialOp definitions
//===----------------------------------------------------------------------===//

MultinomialOpAdaptor::MultinomialOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

MultinomialOpAdaptor::MultinomialOpAdaptor(MultinomialOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> MultinomialOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange MultinomialOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value MultinomialOpAdaptor::logits() {
  return *getODSOperands(0).begin();
}

::mlir::Value MultinomialOpAdaptor::num_samples() {
  return *getODSOperands(1).begin();
}

::mlir::IntegerAttr MultinomialOpAdaptor::seed() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::IntegerAttr attr = odsAttrs.get("seed").dyn_cast_or_null<::mlir::IntegerAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getIntegerAttr(::mlir::Builder(odsAttrs.getContext()).getIntegerType(64), 0);
  return attr;
}

::mlir::IntegerAttr MultinomialOpAdaptor::seed2() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::IntegerAttr attr = odsAttrs.get("seed2").dyn_cast_or_null<::mlir::IntegerAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getIntegerAttr(::mlir::Builder(odsAttrs.getContext()).getIntegerType(64), 0);
  return attr;
}

::mlir::LogicalResult MultinomialOpAdaptor::verify(::mlir::Location loc) {
  {
  auto tblgen_seed = odsAttrs.get("seed");
  if (tblgen_seed) {
    if (!(((tblgen_seed.isa<::mlir::IntegerAttr>())) && ((tblgen_seed.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(64))))) return emitError(loc, "'tf.Multinomial' op ""attribute 'seed' failed to satisfy constraint: 64-bit signless integer attribute");
  }
  }
  {
  auto tblgen_seed2 = odsAttrs.get("seed2");
  if (tblgen_seed2) {
    if (!(((tblgen_seed2.isa<::mlir::IntegerAttr>())) && ((tblgen_seed2.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(64))))) return emitError(loc, "'tf.Multinomial' op ""attribute 'seed2' failed to satisfy constraint: 64-bit signless integer attribute");
  }
  }
  return ::mlir::success();
}

::llvm::StringRef MultinomialOp::getOperationName() {
  return "tf.Multinomial";
}

std::pair<unsigned, unsigned> MultinomialOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range MultinomialOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value MultinomialOp::logits() {
  return *getODSOperands(0).begin();
}

::mlir::Value MultinomialOp::num_samples() {
  return *getODSOperands(1).begin();
}

::mlir::MutableOperandRange MultinomialOp::logitsMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange MultinomialOp::num_samplesMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> MultinomialOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range MultinomialOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value MultinomialOp::output() {
  return *getODSResults(0).begin();
}

::mlir::IntegerAttr MultinomialOp::seedAttr() {
  return this->getAttr("seed").dyn_cast_or_null<::mlir::IntegerAttr>();
}

uint64_t MultinomialOp::seed() {
  auto attr = seedAttr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getIntegerAttr(::mlir::Builder(this->getContext()).getIntegerType(64), 0).getValue().getZExtValue();
  return attr.getValue().getZExtValue();
}

::mlir::IntegerAttr MultinomialOp::seed2Attr() {
  return this->getAttr("seed2").dyn_cast_or_null<::mlir::IntegerAttr>();
}

uint64_t MultinomialOp::seed2() {
  auto attr = seed2Attr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getIntegerAttr(::mlir::Builder(this->getContext()).getIntegerType(64), 0).getValue().getZExtValue();
  return attr.getValue().getZExtValue();
}

Type MultinomialOp::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

Type MultinomialOp::output_dtype() {
  return mlir::getElementTypeOrSelf(*getODSResults(0).begin());
}

bool MultinomialOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "T") return true;
  if (name == "output_dtype") return true;
 return false;
}

::mlir::DictionaryAttr MultinomialOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())},
    {::mlir::Identifier::get("output_dtype", ctx),
::mlir::TypeAttr::get(output_dtype())}
    }, ctx);
}

void MultinomialOp::seedAttr(::mlir::IntegerAttr attr) {
  this->getOperation()->setAttr("seed", attr);
}

void MultinomialOp::seed2Attr(::mlir::IntegerAttr attr) {
  this->getOperation()->setAttr("seed2", attr);
}

void MultinomialOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value logits, ::mlir::Value num_samples, ::mlir::IntegerAttr seed, ::mlir::IntegerAttr seed2) {
  odsState.addOperands(logits);
  odsState.addOperands(num_samples);
  odsState.addAttribute("seed", seed);
  odsState.addAttribute("seed2", seed2);
  odsState.addTypes(output);
}

void MultinomialOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value logits, ::mlir::Value num_samples, ::mlir::IntegerAttr seed, ::mlir::IntegerAttr seed2) {
  odsState.addOperands(logits);
  odsState.addOperands(num_samples);
  odsState.addAttribute("seed", seed);
  odsState.addAttribute("seed2", seed2);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void MultinomialOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value logits, ::mlir::Value num_samples, uint64_t seed, uint64_t seed2) {
  odsState.addOperands(logits);
  odsState.addOperands(num_samples);
  odsState.addAttribute("seed", odsBuilder.getIntegerAttr(odsBuilder.getIntegerType(64), seed));
  odsState.addAttribute("seed2", odsBuilder.getIntegerAttr(odsBuilder.getIntegerType(64), seed2));
  odsState.addTypes(output);
}

void MultinomialOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value logits, ::mlir::Value num_samples, uint64_t seed, uint64_t seed2) {
  odsState.addOperands(logits);
  odsState.addOperands(num_samples);
  odsState.addAttribute("seed", odsBuilder.getIntegerAttr(odsBuilder.getIntegerType(64), seed));
  odsState.addAttribute("seed2", odsBuilder.getIntegerAttr(odsBuilder.getIntegerType(64), seed2));
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void MultinomialOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult MultinomialOp::verify() {
  if (failed(MultinomialOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of integer or floating-point values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of 32-bit integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))))) {
        return emitOpError("result #") << index << " must be tensor of 32/64-bit signed integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::MutableDenseHashTableV2Op definitions
//===----------------------------------------------------------------------===//

MutableDenseHashTableV2OpAdaptor::MutableDenseHashTableV2OpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

MutableDenseHashTableV2OpAdaptor::MutableDenseHashTableV2OpAdaptor(MutableDenseHashTableV2Op&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> MutableDenseHashTableV2OpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange MutableDenseHashTableV2OpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value MutableDenseHashTableV2OpAdaptor::empty_key() {
  return *getODSOperands(0).begin();
}

::mlir::Value MutableDenseHashTableV2OpAdaptor::deleted_key() {
  return *getODSOperands(1).begin();
}

::mlir::StringAttr MutableDenseHashTableV2OpAdaptor::container() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::StringAttr attr = odsAttrs.get("container").cast<::mlir::StringAttr>();
  return attr;
}

::mlir::StringAttr MutableDenseHashTableV2OpAdaptor::shared_name() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::StringAttr attr = odsAttrs.get("shared_name").cast<::mlir::StringAttr>();
  return attr;
}

::mlir::BoolAttr MutableDenseHashTableV2OpAdaptor::use_node_name_sharing() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::BoolAttr attr = odsAttrs.get("use_node_name_sharing").dyn_cast_or_null<::mlir::BoolAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getBoolAttr(false);
  return attr;
}

::mlir::TypeAttr MutableDenseHashTableV2OpAdaptor::value_dtype() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::TypeAttr attr = odsAttrs.get("value_dtype").cast<::mlir::TypeAttr>();
  return attr;
}

Attribute MutableDenseHashTableV2OpAdaptor::value_shape() {
  assert(odsAttrs && "no attributes when constructing adapter");
  Attribute attr = odsAttrs.get("value_shape").dyn_cast_or_null<Attribute>();
  if (!attr)
    attr = mlir::TF::ShapeAttr::get(::mlir::Builder(odsAttrs.getContext()).getContext(), llvm::ArrayRef<int64_t>({}));
  return attr;
}

::mlir::IntegerAttr MutableDenseHashTableV2OpAdaptor::initial_num_buckets() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::IntegerAttr attr = odsAttrs.get("initial_num_buckets").dyn_cast_or_null<::mlir::IntegerAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getIntegerAttr(::mlir::Builder(odsAttrs.getContext()).getIntegerType(64), 131072);
  return attr;
}

::mlir::FloatAttr MutableDenseHashTableV2OpAdaptor::max_load_factor() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::FloatAttr attr = odsAttrs.get("max_load_factor").dyn_cast_or_null<::mlir::FloatAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getFloatAttr(::mlir::Builder(odsAttrs.getContext()).getF32Type(), 0.8f);
  return attr;
}

::mlir::LogicalResult MutableDenseHashTableV2OpAdaptor::verify(::mlir::Location loc) {
  {
  auto tblgen_container = odsAttrs.get("container");
  if (!tblgen_container) return emitError(loc, "'tf.MutableDenseHashTableV2' op ""requires attribute 'container'");
    if (!((tblgen_container.isa<::mlir::StringAttr>()))) return emitError(loc, "'tf.MutableDenseHashTableV2' op ""attribute 'container' failed to satisfy constraint: string attribute");
  }
  {
  auto tblgen_shared_name = odsAttrs.get("shared_name");
  if (!tblgen_shared_name) return emitError(loc, "'tf.MutableDenseHashTableV2' op ""requires attribute 'shared_name'");
    if (!((tblgen_shared_name.isa<::mlir::StringAttr>()))) return emitError(loc, "'tf.MutableDenseHashTableV2' op ""attribute 'shared_name' failed to satisfy constraint: string attribute");
  }
  {
  auto tblgen_use_node_name_sharing = odsAttrs.get("use_node_name_sharing");
  if (tblgen_use_node_name_sharing) {
    if (!((tblgen_use_node_name_sharing.isa<::mlir::BoolAttr>()))) return emitError(loc, "'tf.MutableDenseHashTableV2' op ""attribute 'use_node_name_sharing' failed to satisfy constraint: bool attribute");
  }
  }
  {
  auto tblgen_value_dtype = odsAttrs.get("value_dtype");
  if (!tblgen_value_dtype) return emitError(loc, "'tf.MutableDenseHashTableV2' op ""requires attribute 'value_dtype'");
    if (!(((tblgen_value_dtype.isa<::mlir::TypeAttr>())) && ((tblgen_value_dtype.cast<::mlir::TypeAttr>().getValue().isa<::mlir::Type>())))) return emitError(loc, "'tf.MutableDenseHashTableV2' op ""attribute 'value_dtype' failed to satisfy constraint: any type attribute");
  }
  {
  auto tblgen_value_shape = odsAttrs.get("value_shape");
  if (tblgen_value_shape) {
    if (!((tblgen_value_shape.isa<mlir::TF::ShapeAttr>()))) return emitError(loc, "'tf.MutableDenseHashTableV2' op ""attribute 'value_shape' failed to satisfy constraint: TensorFlow shape attribute");
  }
  }
  {
  auto tblgen_initial_num_buckets = odsAttrs.get("initial_num_buckets");
  if (tblgen_initial_num_buckets) {
    if (!(((tblgen_initial_num_buckets.isa<::mlir::IntegerAttr>())) && ((tblgen_initial_num_buckets.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(64))))) return emitError(loc, "'tf.MutableDenseHashTableV2' op ""attribute 'initial_num_buckets' failed to satisfy constraint: 64-bit signless integer attribute");
  }
  }
  {
  auto tblgen_max_load_factor = odsAttrs.get("max_load_factor");
  if (tblgen_max_load_factor) {
    if (!(((tblgen_max_load_factor.isa<::mlir::FloatAttr>())) && ((tblgen_max_load_factor.cast<::mlir::FloatAttr>().getType().isF32())))) return emitError(loc, "'tf.MutableDenseHashTableV2' op ""attribute 'max_load_factor' failed to satisfy constraint: 32-bit float attribute");
  }
  }
  return ::mlir::success();
}

::llvm::StringRef MutableDenseHashTableV2Op::getOperationName() {
  return "tf.MutableDenseHashTableV2";
}

std::pair<unsigned, unsigned> MutableDenseHashTableV2Op::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range MutableDenseHashTableV2Op::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value MutableDenseHashTableV2Op::empty_key() {
  return *getODSOperands(0).begin();
}

::mlir::Value MutableDenseHashTableV2Op::deleted_key() {
  return *getODSOperands(1).begin();
}

::mlir::MutableOperandRange MutableDenseHashTableV2Op::empty_keyMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange MutableDenseHashTableV2Op::deleted_keyMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> MutableDenseHashTableV2Op::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range MutableDenseHashTableV2Op::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value MutableDenseHashTableV2Op::table_handle() {
  return *getODSResults(0).begin();
}

::mlir::StringAttr MutableDenseHashTableV2Op::containerAttr() {
  return this->getAttr("container").cast<::mlir::StringAttr>();
}

::llvm::StringRef MutableDenseHashTableV2Op::container() {
  auto attr = containerAttr();
  return attr.getValue();
}

::mlir::StringAttr MutableDenseHashTableV2Op::shared_nameAttr() {
  return this->getAttr("shared_name").cast<::mlir::StringAttr>();
}

::llvm::StringRef MutableDenseHashTableV2Op::shared_name() {
  auto attr = shared_nameAttr();
  return attr.getValue();
}

::mlir::BoolAttr MutableDenseHashTableV2Op::use_node_name_sharingAttr() {
  return this->getAttr("use_node_name_sharing").dyn_cast_or_null<::mlir::BoolAttr>();
}

bool MutableDenseHashTableV2Op::use_node_name_sharing() {
  auto attr = use_node_name_sharingAttr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getBoolAttr(false).getValue();
  return attr.getValue();
}

::mlir::TypeAttr MutableDenseHashTableV2Op::value_dtypeAttr() {
  return this->getAttr("value_dtype").cast<::mlir::TypeAttr>();
}

::mlir::Type MutableDenseHashTableV2Op::value_dtype() {
  auto attr = value_dtypeAttr();
  return attr.getValue().cast<::mlir::Type>();
}

Attribute MutableDenseHashTableV2Op::value_shapeAttr() {
  return this->getAttr("value_shape").dyn_cast_or_null<Attribute>();
}

llvm::Optional<llvm::ArrayRef<int64_t>> MutableDenseHashTableV2Op::value_shape() {
  auto attr = value_shapeAttr();
    if (!attr)
      return mlir::TF::ShapeAttr::get(::mlir::Builder(this->getContext()).getContext(), llvm::ArrayRef<int64_t>({})).cast<mlir::TF::ShapeAttr>().getValue();
  return attr.cast<mlir::TF::ShapeAttr>().getValue();
}

::mlir::IntegerAttr MutableDenseHashTableV2Op::initial_num_bucketsAttr() {
  return this->getAttr("initial_num_buckets").dyn_cast_or_null<::mlir::IntegerAttr>();
}

uint64_t MutableDenseHashTableV2Op::initial_num_buckets() {
  auto attr = initial_num_bucketsAttr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getIntegerAttr(::mlir::Builder(this->getContext()).getIntegerType(64), 131072).getValue().getZExtValue();
  return attr.getValue().getZExtValue();
}

::mlir::FloatAttr MutableDenseHashTableV2Op::max_load_factorAttr() {
  return this->getAttr("max_load_factor").dyn_cast_or_null<::mlir::FloatAttr>();
}

::llvm::APFloat MutableDenseHashTableV2Op::max_load_factor() {
  auto attr = max_load_factorAttr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getFloatAttr(::mlir::Builder(this->getContext()).getF32Type(), 0.8f).getValue();
  return attr.getValue();
}

Type MutableDenseHashTableV2Op::key_dtype() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

bool MutableDenseHashTableV2Op::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "key_dtype") return true;
 return false;
}

::mlir::DictionaryAttr MutableDenseHashTableV2Op::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("key_dtype", ctx),
::mlir::TypeAttr::get(key_dtype())}
    }, ctx);
}

void MutableDenseHashTableV2Op::containerAttr(::mlir::StringAttr attr) {
  this->getOperation()->setAttr("container", attr);
}

void MutableDenseHashTableV2Op::shared_nameAttr(::mlir::StringAttr attr) {
  this->getOperation()->setAttr("shared_name", attr);
}

void MutableDenseHashTableV2Op::use_node_name_sharingAttr(::mlir::BoolAttr attr) {
  this->getOperation()->setAttr("use_node_name_sharing", attr);
}

void MutableDenseHashTableV2Op::value_dtypeAttr(::mlir::TypeAttr attr) {
  this->getOperation()->setAttr("value_dtype", attr);
}

void MutableDenseHashTableV2Op::value_shapeAttr(Attribute attr) {
  this->getOperation()->setAttr("value_shape", attr);
}

void MutableDenseHashTableV2Op::initial_num_bucketsAttr(::mlir::IntegerAttr attr) {
  this->getOperation()->setAttr("initial_num_buckets", attr);
}

void MutableDenseHashTableV2Op::max_load_factorAttr(::mlir::FloatAttr attr) {
  this->getOperation()->setAttr("max_load_factor", attr);
}

void MutableDenseHashTableV2Op::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type table_handle, ::mlir::Value empty_key, ::mlir::Value deleted_key, ::mlir::StringAttr container, ::mlir::StringAttr shared_name, ::mlir::BoolAttr use_node_name_sharing, ::mlir::TypeAttr value_dtype, Attribute value_shape, ::mlir::IntegerAttr initial_num_buckets, ::mlir::FloatAttr max_load_factor) {
  odsState.addOperands(empty_key);
  odsState.addOperands(deleted_key);
  odsState.addAttribute("container", container);
  odsState.addAttribute("shared_name", shared_name);
  odsState.addAttribute("use_node_name_sharing", use_node_name_sharing);
  odsState.addAttribute("value_dtype", value_dtype);
  odsState.addAttribute("value_shape", value_shape);
  odsState.addAttribute("initial_num_buckets", initial_num_buckets);
  odsState.addAttribute("max_load_factor", max_load_factor);
  odsState.addTypes(table_handle);
}

void MutableDenseHashTableV2Op::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value empty_key, ::mlir::Value deleted_key, ::mlir::StringAttr container, ::mlir::StringAttr shared_name, ::mlir::BoolAttr use_node_name_sharing, ::mlir::TypeAttr value_dtype, Attribute value_shape, ::mlir::IntegerAttr initial_num_buckets, ::mlir::FloatAttr max_load_factor) {
  odsState.addOperands(empty_key);
  odsState.addOperands(deleted_key);
  odsState.addAttribute("container", container);
  odsState.addAttribute("shared_name", shared_name);
  odsState.addAttribute("use_node_name_sharing", use_node_name_sharing);
  odsState.addAttribute("value_dtype", value_dtype);
  odsState.addAttribute("value_shape", value_shape);
  odsState.addAttribute("initial_num_buckets", initial_num_buckets);
  odsState.addAttribute("max_load_factor", max_load_factor);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void MutableDenseHashTableV2Op::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type table_handle, ::mlir::Value empty_key, ::mlir::Value deleted_key, ::llvm::StringRef container, ::llvm::StringRef shared_name, bool use_node_name_sharing, ::mlir::TypeAttr value_dtype, llvm::Optional<llvm::ArrayRef<int64_t>> value_shape, uint64_t initial_num_buckets, ::llvm::APFloat max_load_factor) {
  odsState.addOperands(empty_key);
  odsState.addOperands(deleted_key);
  odsState.addAttribute("container", odsBuilder.getStringAttr(container));
  odsState.addAttribute("shared_name", odsBuilder.getStringAttr(shared_name));
  odsState.addAttribute("use_node_name_sharing", odsBuilder.getBoolAttr(use_node_name_sharing));
  odsState.addAttribute("value_dtype", value_dtype);
  odsState.addAttribute("value_shape", mlir::TF::ShapeAttr::get(odsBuilder.getContext(), value_shape));
  odsState.addAttribute("initial_num_buckets", odsBuilder.getIntegerAttr(odsBuilder.getIntegerType(64), initial_num_buckets));
  odsState.addAttribute("max_load_factor", odsBuilder.getFloatAttr(odsBuilder.getF32Type(), max_load_factor));
  odsState.addTypes(table_handle);
}

void MutableDenseHashTableV2Op::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value empty_key, ::mlir::Value deleted_key, ::llvm::StringRef container, ::llvm::StringRef shared_name, bool use_node_name_sharing, ::mlir::TypeAttr value_dtype, llvm::Optional<llvm::ArrayRef<int64_t>> value_shape, uint64_t initial_num_buckets, ::llvm::APFloat max_load_factor) {
  odsState.addOperands(empty_key);
  odsState.addOperands(deleted_key);
  odsState.addAttribute("container", odsBuilder.getStringAttr(container));
  odsState.addAttribute("shared_name", odsBuilder.getStringAttr(shared_name));
  odsState.addAttribute("use_node_name_sharing", odsBuilder.getBoolAttr(use_node_name_sharing));
  odsState.addAttribute("value_dtype", value_dtype);
  odsState.addAttribute("value_shape", mlir::TF::ShapeAttr::get(odsBuilder.getContext(), value_shape));
  odsState.addAttribute("initial_num_buckets", odsBuilder.getIntegerAttr(odsBuilder.getIntegerType(64), initial_num_buckets));
  odsState.addAttribute("max_load_factor", odsBuilder.getFloatAttr(odsBuilder.getF32Type(), max_load_factor));
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void MutableDenseHashTableV2Op::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult MutableDenseHashTableV2Op::verify() {
  if (failed(MutableDenseHashTableV2OpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>())))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::TensorFlowType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of tf.dtype values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>())))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::TensorFlowType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of tf.dtype values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::ResourceType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::ResourceRefType>()))))) {
        return emitOpError("result #") << index << " must be tensor of resource values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void MutableDenseHashTableV2Op::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
  for (::mlir::Value value : getODSResults(0))
    effects.emplace_back(MemoryEffects::Allocate::get(), value, ::mlir::TF::ResourceEffects::LookupTable::get());
}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::MutableHashTableOfTensorsV2Op definitions
//===----------------------------------------------------------------------===//

MutableHashTableOfTensorsV2OpAdaptor::MutableHashTableOfTensorsV2OpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

MutableHashTableOfTensorsV2OpAdaptor::MutableHashTableOfTensorsV2OpAdaptor(MutableHashTableOfTensorsV2Op&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> MutableHashTableOfTensorsV2OpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange MutableHashTableOfTensorsV2OpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::StringAttr MutableHashTableOfTensorsV2OpAdaptor::container() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::StringAttr attr = odsAttrs.get("container").cast<::mlir::StringAttr>();
  return attr;
}

::mlir::StringAttr MutableHashTableOfTensorsV2OpAdaptor::shared_name() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::StringAttr attr = odsAttrs.get("shared_name").cast<::mlir::StringAttr>();
  return attr;
}

::mlir::BoolAttr MutableHashTableOfTensorsV2OpAdaptor::use_node_name_sharing() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::BoolAttr attr = odsAttrs.get("use_node_name_sharing").dyn_cast_or_null<::mlir::BoolAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getBoolAttr(false);
  return attr;
}

::mlir::TypeAttr MutableHashTableOfTensorsV2OpAdaptor::key_dtype() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::TypeAttr attr = odsAttrs.get("key_dtype").cast<::mlir::TypeAttr>();
  return attr;
}

::mlir::TypeAttr MutableHashTableOfTensorsV2OpAdaptor::value_dtype() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::TypeAttr attr = odsAttrs.get("value_dtype").cast<::mlir::TypeAttr>();
  return attr;
}

Attribute MutableHashTableOfTensorsV2OpAdaptor::value_shape() {
  assert(odsAttrs && "no attributes when constructing adapter");
  Attribute attr = odsAttrs.get("value_shape").dyn_cast_or_null<Attribute>();
  if (!attr)
    attr = mlir::TF::ShapeAttr::get(::mlir::Builder(odsAttrs.getContext()).getContext(), llvm::ArrayRef<int64_t>({}));
  return attr;
}

::mlir::LogicalResult MutableHashTableOfTensorsV2OpAdaptor::verify(::mlir::Location loc) {
  {
  auto tblgen_container = odsAttrs.get("container");
  if (!tblgen_container) return emitError(loc, "'tf.MutableHashTableOfTensorsV2' op ""requires attribute 'container'");
    if (!((tblgen_container.isa<::mlir::StringAttr>()))) return emitError(loc, "'tf.MutableHashTableOfTensorsV2' op ""attribute 'container' failed to satisfy constraint: string attribute");
  }
  {
  auto tblgen_shared_name = odsAttrs.get("shared_name");
  if (!tblgen_shared_name) return emitError(loc, "'tf.MutableHashTableOfTensorsV2' op ""requires attribute 'shared_name'");
    if (!((tblgen_shared_name.isa<::mlir::StringAttr>()))) return emitError(loc, "'tf.MutableHashTableOfTensorsV2' op ""attribute 'shared_name' failed to satisfy constraint: string attribute");
  }
  {
  auto tblgen_use_node_name_sharing = odsAttrs.get("use_node_name_sharing");
  if (tblgen_use_node_name_sharing) {
    if (!((tblgen_use_node_name_sharing.isa<::mlir::BoolAttr>()))) return emitError(loc, "'tf.MutableHashTableOfTensorsV2' op ""attribute 'use_node_name_sharing' failed to satisfy constraint: bool attribute");
  }
  }
  {
  auto tblgen_key_dtype = odsAttrs.get("key_dtype");
  if (!tblgen_key_dtype) return emitError(loc, "'tf.MutableHashTableOfTensorsV2' op ""requires attribute 'key_dtype'");
    if (!(((tblgen_key_dtype.isa<::mlir::TypeAttr>())) && ((tblgen_key_dtype.cast<::mlir::TypeAttr>().getValue().isa<::mlir::Type>())))) return emitError(loc, "'tf.MutableHashTableOfTensorsV2' op ""attribute 'key_dtype' failed to satisfy constraint: any type attribute");
  }
  {
  auto tblgen_value_dtype = odsAttrs.get("value_dtype");
  if (!tblgen_value_dtype) return emitError(loc, "'tf.MutableHashTableOfTensorsV2' op ""requires attribute 'value_dtype'");
    if (!(((tblgen_value_dtype.isa<::mlir::TypeAttr>())) && ((tblgen_value_dtype.cast<::mlir::TypeAttr>().getValue().isa<::mlir::Type>())))) return emitError(loc, "'tf.MutableHashTableOfTensorsV2' op ""attribute 'value_dtype' failed to satisfy constraint: any type attribute");
  }
  {
  auto tblgen_value_shape = odsAttrs.get("value_shape");
  if (tblgen_value_shape) {
    if (!((tblgen_value_shape.isa<mlir::TF::ShapeAttr>()))) return emitError(loc, "'tf.MutableHashTableOfTensorsV2' op ""attribute 'value_shape' failed to satisfy constraint: TensorFlow shape attribute");
  }
  }
  return ::mlir::success();
}

::llvm::StringRef MutableHashTableOfTensorsV2Op::getOperationName() {
  return "tf.MutableHashTableOfTensorsV2";
}

std::pair<unsigned, unsigned> MutableHashTableOfTensorsV2Op::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range MutableHashTableOfTensorsV2Op::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

std::pair<unsigned, unsigned> MutableHashTableOfTensorsV2Op::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range MutableHashTableOfTensorsV2Op::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value MutableHashTableOfTensorsV2Op::table_handle() {
  return *getODSResults(0).begin();
}

::mlir::StringAttr MutableHashTableOfTensorsV2Op::containerAttr() {
  return this->getAttr("container").cast<::mlir::StringAttr>();
}

::llvm::StringRef MutableHashTableOfTensorsV2Op::container() {
  auto attr = containerAttr();
  return attr.getValue();
}

::mlir::StringAttr MutableHashTableOfTensorsV2Op::shared_nameAttr() {
  return this->getAttr("shared_name").cast<::mlir::StringAttr>();
}

::llvm::StringRef MutableHashTableOfTensorsV2Op::shared_name() {
  auto attr = shared_nameAttr();
  return attr.getValue();
}

::mlir::BoolAttr MutableHashTableOfTensorsV2Op::use_node_name_sharingAttr() {
  return this->getAttr("use_node_name_sharing").dyn_cast_or_null<::mlir::BoolAttr>();
}

bool MutableHashTableOfTensorsV2Op::use_node_name_sharing() {
  auto attr = use_node_name_sharingAttr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getBoolAttr(false).getValue();
  return attr.getValue();
}

::mlir::TypeAttr MutableHashTableOfTensorsV2Op::key_dtypeAttr() {
  return this->getAttr("key_dtype").cast<::mlir::TypeAttr>();
}

::mlir::Type MutableHashTableOfTensorsV2Op::key_dtype() {
  auto attr = key_dtypeAttr();
  return attr.getValue().cast<::mlir::Type>();
}

::mlir::TypeAttr MutableHashTableOfTensorsV2Op::value_dtypeAttr() {
  return this->getAttr("value_dtype").cast<::mlir::TypeAttr>();
}

::mlir::Type MutableHashTableOfTensorsV2Op::value_dtype() {
  auto attr = value_dtypeAttr();
  return attr.getValue().cast<::mlir::Type>();
}

Attribute MutableHashTableOfTensorsV2Op::value_shapeAttr() {
  return this->getAttr("value_shape").dyn_cast_or_null<Attribute>();
}

llvm::Optional<llvm::ArrayRef<int64_t>> MutableHashTableOfTensorsV2Op::value_shape() {
  auto attr = value_shapeAttr();
    if (!attr)
      return mlir::TF::ShapeAttr::get(::mlir::Builder(this->getContext()).getContext(), llvm::ArrayRef<int64_t>({})).cast<mlir::TF::ShapeAttr>().getValue();
  return attr.cast<mlir::TF::ShapeAttr>().getValue();
}

void MutableHashTableOfTensorsV2Op::containerAttr(::mlir::StringAttr attr) {
  this->getOperation()->setAttr("container", attr);
}

void MutableHashTableOfTensorsV2Op::shared_nameAttr(::mlir::StringAttr attr) {
  this->getOperation()->setAttr("shared_name", attr);
}

void MutableHashTableOfTensorsV2Op::use_node_name_sharingAttr(::mlir::BoolAttr attr) {
  this->getOperation()->setAttr("use_node_name_sharing", attr);
}

void MutableHashTableOfTensorsV2Op::key_dtypeAttr(::mlir::TypeAttr attr) {
  this->getOperation()->setAttr("key_dtype", attr);
}

void MutableHashTableOfTensorsV2Op::value_dtypeAttr(::mlir::TypeAttr attr) {
  this->getOperation()->setAttr("value_dtype", attr);
}

void MutableHashTableOfTensorsV2Op::value_shapeAttr(Attribute attr) {
  this->getOperation()->setAttr("value_shape", attr);
}

void MutableHashTableOfTensorsV2Op::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type table_handle, ::mlir::StringAttr container, ::mlir::StringAttr shared_name, ::mlir::BoolAttr use_node_name_sharing, ::mlir::TypeAttr key_dtype, ::mlir::TypeAttr value_dtype, Attribute value_shape) {
  odsState.addAttribute("container", container);
  odsState.addAttribute("shared_name", shared_name);
  odsState.addAttribute("use_node_name_sharing", use_node_name_sharing);
  odsState.addAttribute("key_dtype", key_dtype);
  odsState.addAttribute("value_dtype", value_dtype);
  odsState.addAttribute("value_shape", value_shape);
  odsState.addTypes(table_handle);
}

void MutableHashTableOfTensorsV2Op::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::StringAttr container, ::mlir::StringAttr shared_name, ::mlir::BoolAttr use_node_name_sharing, ::mlir::TypeAttr key_dtype, ::mlir::TypeAttr value_dtype, Attribute value_shape) {
  odsState.addAttribute("container", container);
  odsState.addAttribute("shared_name", shared_name);
  odsState.addAttribute("use_node_name_sharing", use_node_name_sharing);
  odsState.addAttribute("key_dtype", key_dtype);
  odsState.addAttribute("value_dtype", value_dtype);
  odsState.addAttribute("value_shape", value_shape);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void MutableHashTableOfTensorsV2Op::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type table_handle, ::llvm::StringRef container, ::llvm::StringRef shared_name, bool use_node_name_sharing, ::mlir::TypeAttr key_dtype, ::mlir::TypeAttr value_dtype, llvm::Optional<llvm::ArrayRef<int64_t>> value_shape) {
  odsState.addAttribute("container", odsBuilder.getStringAttr(container));
  odsState.addAttribute("shared_name", odsBuilder.getStringAttr(shared_name));
  odsState.addAttribute("use_node_name_sharing", odsBuilder.getBoolAttr(use_node_name_sharing));
  odsState.addAttribute("key_dtype", key_dtype);
  odsState.addAttribute("value_dtype", value_dtype);
  odsState.addAttribute("value_shape", mlir::TF::ShapeAttr::get(odsBuilder.getContext(), value_shape));
  odsState.addTypes(table_handle);
}

void MutableHashTableOfTensorsV2Op::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::llvm::StringRef container, ::llvm::StringRef shared_name, bool use_node_name_sharing, ::mlir::TypeAttr key_dtype, ::mlir::TypeAttr value_dtype, llvm::Optional<llvm::ArrayRef<int64_t>> value_shape) {
  odsState.addAttribute("container", odsBuilder.getStringAttr(container));
  odsState.addAttribute("shared_name", odsBuilder.getStringAttr(shared_name));
  odsState.addAttribute("use_node_name_sharing", odsBuilder.getBoolAttr(use_node_name_sharing));
  odsState.addAttribute("key_dtype", key_dtype);
  odsState.addAttribute("value_dtype", value_dtype);
  odsState.addAttribute("value_shape", mlir::TF::ShapeAttr::get(odsBuilder.getContext(), value_shape));
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void MutableHashTableOfTensorsV2Op::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 0u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult MutableHashTableOfTensorsV2Op::verify() {
  if (failed(MutableHashTableOfTensorsV2OpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::ResourceType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::ResourceRefType>()))))) {
        return emitOpError("result #") << index << " must be tensor of resource values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void MutableHashTableOfTensorsV2Op::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
  for (::mlir::Value value : getODSResults(0))
    effects.emplace_back(MemoryEffects::Allocate::get(), value, ::mlir::TF::ResourceEffects::LookupTable::get());
}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::MutableHashTableV2Op definitions
//===----------------------------------------------------------------------===//

MutableHashTableV2OpAdaptor::MutableHashTableV2OpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

MutableHashTableV2OpAdaptor::MutableHashTableV2OpAdaptor(MutableHashTableV2Op&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> MutableHashTableV2OpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange MutableHashTableV2OpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::StringAttr MutableHashTableV2OpAdaptor::container() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::StringAttr attr = odsAttrs.get("container").cast<::mlir::StringAttr>();
  return attr;
}

::mlir::StringAttr MutableHashTableV2OpAdaptor::shared_name() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::StringAttr attr = odsAttrs.get("shared_name").cast<::mlir::StringAttr>();
  return attr;
}

::mlir::BoolAttr MutableHashTableV2OpAdaptor::use_node_name_sharing() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::BoolAttr attr = odsAttrs.get("use_node_name_sharing").dyn_cast_or_null<::mlir::BoolAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getBoolAttr(false);
  return attr;
}

::mlir::TypeAttr MutableHashTableV2OpAdaptor::key_dtype() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::TypeAttr attr = odsAttrs.get("key_dtype").cast<::mlir::TypeAttr>();
  return attr;
}

::mlir::TypeAttr MutableHashTableV2OpAdaptor::value_dtype() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::TypeAttr attr = odsAttrs.get("value_dtype").cast<::mlir::TypeAttr>();
  return attr;
}

::mlir::LogicalResult MutableHashTableV2OpAdaptor::verify(::mlir::Location loc) {
  {
  auto tblgen_container = odsAttrs.get("container");
  if (!tblgen_container) return emitError(loc, "'tf.MutableHashTableV2' op ""requires attribute 'container'");
    if (!((tblgen_container.isa<::mlir::StringAttr>()))) return emitError(loc, "'tf.MutableHashTableV2' op ""attribute 'container' failed to satisfy constraint: string attribute");
  }
  {
  auto tblgen_shared_name = odsAttrs.get("shared_name");
  if (!tblgen_shared_name) return emitError(loc, "'tf.MutableHashTableV2' op ""requires attribute 'shared_name'");
    if (!((tblgen_shared_name.isa<::mlir::StringAttr>()))) return emitError(loc, "'tf.MutableHashTableV2' op ""attribute 'shared_name' failed to satisfy constraint: string attribute");
  }
  {
  auto tblgen_use_node_name_sharing = odsAttrs.get("use_node_name_sharing");
  if (tblgen_use_node_name_sharing) {
    if (!((tblgen_use_node_name_sharing.isa<::mlir::BoolAttr>()))) return emitError(loc, "'tf.MutableHashTableV2' op ""attribute 'use_node_name_sharing' failed to satisfy constraint: bool attribute");
  }
  }
  {
  auto tblgen_key_dtype = odsAttrs.get("key_dtype");
  if (!tblgen_key_dtype) return emitError(loc, "'tf.MutableHashTableV2' op ""requires attribute 'key_dtype'");
    if (!(((tblgen_key_dtype.isa<::mlir::TypeAttr>())) && ((tblgen_key_dtype.cast<::mlir::TypeAttr>().getValue().isa<::mlir::Type>())))) return emitError(loc, "'tf.MutableHashTableV2' op ""attribute 'key_dtype' failed to satisfy constraint: any type attribute");
  }
  {
  auto tblgen_value_dtype = odsAttrs.get("value_dtype");
  if (!tblgen_value_dtype) return emitError(loc, "'tf.MutableHashTableV2' op ""requires attribute 'value_dtype'");
    if (!(((tblgen_value_dtype.isa<::mlir::TypeAttr>())) && ((tblgen_value_dtype.cast<::mlir::TypeAttr>().getValue().isa<::mlir::Type>())))) return emitError(loc, "'tf.MutableHashTableV2' op ""attribute 'value_dtype' failed to satisfy constraint: any type attribute");
  }
  return ::mlir::success();
}

::llvm::StringRef MutableHashTableV2Op::getOperationName() {
  return "tf.MutableHashTableV2";
}

std::pair<unsigned, unsigned> MutableHashTableV2Op::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range MutableHashTableV2Op::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

std::pair<unsigned, unsigned> MutableHashTableV2Op::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range MutableHashTableV2Op::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value MutableHashTableV2Op::table_handle() {
  return *getODSResults(0).begin();
}

::mlir::StringAttr MutableHashTableV2Op::containerAttr() {
  return this->getAttr("container").cast<::mlir::StringAttr>();
}

::llvm::StringRef MutableHashTableV2Op::container() {
  auto attr = containerAttr();
  return attr.getValue();
}

::mlir::StringAttr MutableHashTableV2Op::shared_nameAttr() {
  return this->getAttr("shared_name").cast<::mlir::StringAttr>();
}

::llvm::StringRef MutableHashTableV2Op::shared_name() {
  auto attr = shared_nameAttr();
  return attr.getValue();
}

::mlir::BoolAttr MutableHashTableV2Op::use_node_name_sharingAttr() {
  return this->getAttr("use_node_name_sharing").dyn_cast_or_null<::mlir::BoolAttr>();
}

bool MutableHashTableV2Op::use_node_name_sharing() {
  auto attr = use_node_name_sharingAttr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getBoolAttr(false).getValue();
  return attr.getValue();
}

::mlir::TypeAttr MutableHashTableV2Op::key_dtypeAttr() {
  return this->getAttr("key_dtype").cast<::mlir::TypeAttr>();
}

::mlir::Type MutableHashTableV2Op::key_dtype() {
  auto attr = key_dtypeAttr();
  return attr.getValue().cast<::mlir::Type>();
}

::mlir::TypeAttr MutableHashTableV2Op::value_dtypeAttr() {
  return this->getAttr("value_dtype").cast<::mlir::TypeAttr>();
}

::mlir::Type MutableHashTableV2Op::value_dtype() {
  auto attr = value_dtypeAttr();
  return attr.getValue().cast<::mlir::Type>();
}

void MutableHashTableV2Op::containerAttr(::mlir::StringAttr attr) {
  this->getOperation()->setAttr("container", attr);
}

void MutableHashTableV2Op::shared_nameAttr(::mlir::StringAttr attr) {
  this->getOperation()->setAttr("shared_name", attr);
}

void MutableHashTableV2Op::use_node_name_sharingAttr(::mlir::BoolAttr attr) {
  this->getOperation()->setAttr("use_node_name_sharing", attr);
}

void MutableHashTableV2Op::key_dtypeAttr(::mlir::TypeAttr attr) {
  this->getOperation()->setAttr("key_dtype", attr);
}

void MutableHashTableV2Op::value_dtypeAttr(::mlir::TypeAttr attr) {
  this->getOperation()->setAttr("value_dtype", attr);
}

void MutableHashTableV2Op::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type table_handle, ::mlir::StringAttr container, ::mlir::StringAttr shared_name, ::mlir::BoolAttr use_node_name_sharing, ::mlir::TypeAttr key_dtype, ::mlir::TypeAttr value_dtype) {
  odsState.addAttribute("container", container);
  odsState.addAttribute("shared_name", shared_name);
  odsState.addAttribute("use_node_name_sharing", use_node_name_sharing);
  odsState.addAttribute("key_dtype", key_dtype);
  odsState.addAttribute("value_dtype", value_dtype);
  odsState.addTypes(table_handle);
}

void MutableHashTableV2Op::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::StringAttr container, ::mlir::StringAttr shared_name, ::mlir::BoolAttr use_node_name_sharing, ::mlir::TypeAttr key_dtype, ::mlir::TypeAttr value_dtype) {
  odsState.addAttribute("container", container);
  odsState.addAttribute("shared_name", shared_name);
  odsState.addAttribute("use_node_name_sharing", use_node_name_sharing);
  odsState.addAttribute("key_dtype", key_dtype);
  odsState.addAttribute("value_dtype", value_dtype);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void MutableHashTableV2Op::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type table_handle, ::llvm::StringRef container, ::llvm::StringRef shared_name, bool use_node_name_sharing, ::mlir::TypeAttr key_dtype, ::mlir::TypeAttr value_dtype) {
  odsState.addAttribute("container", odsBuilder.getStringAttr(container));
  odsState.addAttribute("shared_name", odsBuilder.getStringAttr(shared_name));
  odsState.addAttribute("use_node_name_sharing", odsBuilder.getBoolAttr(use_node_name_sharing));
  odsState.addAttribute("key_dtype", key_dtype);
  odsState.addAttribute("value_dtype", value_dtype);
  odsState.addTypes(table_handle);
}

void MutableHashTableV2Op::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::llvm::StringRef container, ::llvm::StringRef shared_name, bool use_node_name_sharing, ::mlir::TypeAttr key_dtype, ::mlir::TypeAttr value_dtype) {
  odsState.addAttribute("container", odsBuilder.getStringAttr(container));
  odsState.addAttribute("shared_name", odsBuilder.getStringAttr(shared_name));
  odsState.addAttribute("use_node_name_sharing", odsBuilder.getBoolAttr(use_node_name_sharing));
  odsState.addAttribute("key_dtype", key_dtype);
  odsState.addAttribute("value_dtype", value_dtype);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void MutableHashTableV2Op::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 0u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult MutableHashTableV2Op::verify() {
  if (failed(MutableHashTableV2OpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::ResourceType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::ResourceRefType>()))))) {
        return emitOpError("result #") << index << " must be tensor of resource values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void MutableHashTableV2Op::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
  for (::mlir::Value value : getODSResults(0))
    effects.emplace_back(MemoryEffects::Allocate::get(), value, ::mlir::TF::ResourceEffects::LookupTable::get());
}

} // namespace TF
} // namespace mlir

#endif  // GET_OP_CLASSES

