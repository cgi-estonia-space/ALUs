/*===- TableGen'erated file -------------------------------------*- C++ -*-===*\
|*                                                                            *|
|* Op Definitions                                                             *|
|*                                                                            *|
|* Automatically generated file, do not edit!                                 *|
|*                                                                            *|
\*===----------------------------------------------------------------------===*/

#ifdef GET_OP_LIST
#undef GET_OP_LIST

::mlir::TF::NdtriOp,
::mlir::TF::NegOp,
::mlir::TF::NextAfterOp,
::mlir::TF::NoOp,
::mlir::TF::NonMaxSuppressionV3Op,
::mlir::TF::NonMaxSuppressionV4Op,
::mlir::TF::NonMaxSuppressionV5Op,
::mlir::TF::NotEqualOp,
::mlir::TF::OneHotOp,
::mlir::TF::OneShotIteratorOp,
::mlir::TF::OutfeedEnqueueTupleOp,
::mlir::TF::PackOp,
::mlir::TF::PadOp,
::mlir::TF::PadV2Op,
::mlir::TF::ParallelMapDatasetOp,
::mlir::TF::ParameterizedTruncatedNormalOp,
::mlir::TF::ParseExampleOp,
::mlir::TF::ParseExampleV2Op,
::mlir::TF::PartitionedCallOp,
::mlir::TF::PlaceholderOp,
::mlir::TF::PlaceholderWithDefaultOp,
::mlir::TF::PowOp,
::mlir::TF::PreventGradientOp,
::mlir::TF::PrintV2Op,
::mlir::TF::ProdOp,
::mlir::TF::QrOp,
::mlir::TF::QuantizeAndDequantizeOp,
::mlir::TF::QuantizeAndDequantizeV2Op,
::mlir::TF::QuantizeAndDequantizeV3Op,
::mlir::TF::RFFT2DOp,
::mlir::TF::RFFT3DOp,
::mlir::TF::RFFTOp,
::mlir::TF::RGBToHSVOp,
::mlir::TF::RandomGammaGradOp,
::mlir::TF::RandomGammaOp,
::mlir::TF::RandomPoissonOp,
::mlir::TF::RandomPoissonV2Op,
::mlir::TF::RandomShuffleOp,
::mlir::TF::RandomStandardNormalOp,
::mlir::TF::RandomUniformIntOp,
::mlir::TF::RandomUniformOp,
::mlir::TF::RangeDatasetOp,
::mlir::TF::RangeOp,
::mlir::TF::RankOp,
::mlir::TF::ReadVariableOp,
::mlir::TF::RealDivOp,
::mlir::TF::RealOp,
::mlir::TF::ReciprocalGradOp,
::mlir::TF::ReciprocalOp,
::mlir::TF::RecvTPUEmbeddingActivationsOp,
::mlir::TF::Relu6GradOp,
::mlir::TF::Relu6Op,
::mlir::TF::ReluGradOp,
::mlir::TF::ReluOp,
::mlir::TF::ReshapeOp,
::mlir::TF::ResizeBilinearGradOp,
::mlir::TF::ResizeBilinearOp,
::mlir::TF::ResizeNearestNeighborGradOp,
::mlir::TF::ResizeNearestNeighborOp,
::mlir::TF::ResourceApplyAdaMaxOp,
::mlir::TF::ResourceApplyAdadeltaOp,
::mlir::TF::ResourceApplyAdagradDAOp,
::mlir::TF::ResourceApplyAdagradOp,
::mlir::TF::ResourceApplyAdagradV2Op,
::mlir::TF::ResourceApplyAdamOp,
::mlir::TF::ResourceApplyAddSignOp,
::mlir::TF::ResourceApplyCenteredRMSPropOp,
::mlir::TF::ResourceApplyFtrlOp,
::mlir::TF::ResourceApplyFtrlV2Op,
::mlir::TF::ResourceApplyGradientDescentOp,
::mlir::TF::ResourceApplyKerasMomentumOp,
::mlir::TF::ResourceApplyMomentumOp,
::mlir::TF::ResourceApplyPowerSignOp,
::mlir::TF::ResourceApplyProximalAdagradOp,
::mlir::TF::ResourceApplyProximalGradientDescentOp,
::mlir::TF::ResourceApplyRMSPropOp,
::mlir::TF::ResourceGatherOp,
::mlir::TF::ResourceScatterAddOp,
::mlir::TF::ResourceScatterDivOp,
::mlir::TF::ResourceScatterMaxOp,
::mlir::TF::ResourceScatterMinOp,
::mlir::TF::ResourceScatterMulOp,
::mlir::TF::ResourceScatterNdAddOp,
::mlir::TF::ResourceScatterNdSubOp,
::mlir::TF::ResourceScatterNdUpdateOp,
::mlir::TF::ResourceScatterSubOp,
::mlir::TF::ResourceScatterUpdateOp,
::mlir::TF::ResourceStridedSliceAssignOp,
::mlir::TF::RestoreV2Op,
::mlir::TF::ReverseSequenceOp,
::mlir::TF::ReverseV2Op,
::mlir::TF::RightShiftOp,
::mlir::TF::RintOp,
::mlir::TF::RollOp,
::mlir::TF::RoundOp,
::mlir::TF::RsqrtGradOp,
::mlir::TF::RsqrtOp,
::mlir::TF::ScatterNdOp,
::mlir::TF::SegmentMaxOp,
::mlir::TF::SegmentMeanOp,
::mlir::TF::SegmentMinOp,
::mlir::TF::SegmentProdOp,
::mlir::TF::SegmentSumOp,
::mlir::TF::SelectOp,
::mlir::TF::SelectV2Op,
::mlir::TF::SelfAdjointEigV2Op,
::mlir::TF::SeluGradOp,
::mlir::TF::SeluOp,
::mlir::TF::SendTPUEmbeddingGradientsOp,
::mlir::TF::SerializeIteratorOp,
::mlir::TF::ShapeNOp,
::mlir::TF::ShapeOp,
::mlir::TF::ShardedFilenameOp,
::mlir::TF::ShuffleAndRepeatDatasetV2Op,
::mlir::TF::ShuffleDatasetV2Op,
::mlir::TF::ShuffleDatasetV3Op,
::mlir::TF::ShutdownDistributedTPUOp,
::mlir::TF::SigmoidGradOp,
::mlir::TF::SigmoidOp,
::mlir::TF::SignOp,
::mlir::TF::SinOp,
::mlir::TF::SinhOp,
::mlir::TF::SizeOp,
::mlir::TF::SliceOp,
::mlir::TF::SnapshotOp,
::mlir::TF::SoftmaxCrossEntropyWithLogitsOp,
::mlir::TF::SoftmaxOp,
::mlir::TF::SoftplusGradOp,
::mlir::TF::SoftplusOp,
::mlir::TF::SoftsignGradOp,
::mlir::TF::SoftsignOp,
::mlir::TF::SpaceToBatchNDOp,
::mlir::TF::SpaceToBatchOp,
::mlir::TF::SpaceToDepthOp,
::mlir::TF::SparseFillEmptyRowsOp,
::mlir::TF::SparseMatMulOp,
::mlir::TF::SparseReshapeOp,
::mlir::TF::SparseSegmentSqrtNOp,
::mlir::TF::SparseSoftmaxCrossEntropyWithLogitsOp,
::mlir::TF::SparseToDenseOp,
::mlir::TF::SplitOp,
::mlir::TF::SplitVOp,
::mlir::TF::SqrtGradOp,
::mlir::TF::SqrtOp,
::mlir::TF::SquareOp,
::mlir::TF::SquaredDifferenceOp,
::mlir::TF::SqueezeOp,
::mlir::TF::StackCloseV2Op,
::mlir::TF::StackPopV2Op,
::mlir::TF::StackPushV2Op,
::mlir::TF::StackV2Op,
::mlir::TF::StatefulPartitionedCallOp,
::mlir::TF::StatefulStandardNormalV2Op,
::mlir::TF::StatefulTruncatedNormalOp,
::mlir::TF::StatefulUniformFullIntOp,
::mlir::TF::StatefulUniformIntOp,
::mlir::TF::StatefulUniformOp,
::mlir::TF::StatelessMultinomialOp,
::mlir::TF::StatelessParameterizedTruncatedNormalOp,
::mlir::TF::StatelessRandomBinomialOp,
::mlir::TF::StatelessRandomGammaV2Op,
::mlir::TF::StatelessRandomNormalOp,
::mlir::TF::StatelessRandomPoissonOp,
::mlir::TF::StatelessRandomUniformFullIntOp,
::mlir::TF::StatelessRandomUniformIntOp,
::mlir::TF::StatelessRandomUniformOp,
::mlir::TF::StatelessTruncatedNormalOp,
::mlir::TF::StopGradientOp,
::mlir::TF::StridedSliceGradOp,
::mlir::TF::StridedSliceOp,
::mlir::TF::StringFormatOp,
::mlir::TF::StringJoinOp,
::mlir::TF::StringToHashBucketFastOp,
::mlir::TF::SubOp,
::mlir::TF::SumOp,
::mlir::TF::SummaryWriterOp,
::mlir::TF::SymbolicGradientOp,
::mlir::TF::TPUCompilationResultOp,
::mlir::TF::TPUCompileSucceededAssertOp,
::mlir::TF::TPUCopyWithLayoutOp,
::mlir::TF::TPUEmbeddingActivationsOp,
::mlir::TF::TPUExecuteAndUpdateVariablesOp,
::mlir::TF::TPUExecuteOp,
::mlir::TF::TPUGetLayoutOp,
::mlir::TF::TPUOrdinalSelectorOp,
::mlir::TF::TPUPartitionedCallOp,
::mlir::TF::TPUReplicateMetadataOp,
::mlir::TF::TPUReplicatedInputOp,
::mlir::TF::TPUReplicatedOutputOp,
::mlir::TF::TPUReshardVariablesOp,
::mlir::TF::TanOp,
::mlir::TF::TanhGradOp,
::mlir::TF::TanhOp,
::mlir::TF::TensorArrayCloseV3Op,
::mlir::TF::TensorArrayConcatV3Op,
::mlir::TF::TensorArrayGatherV3Op,
::mlir::TF::TensorArrayGradV3Op,
::mlir::TF::TensorArrayReadV3Op,
::mlir::TF::TensorArrayScatterV3Op,
::mlir::TF::TensorArraySizeV3Op,
::mlir::TF::TensorArraySplitV3Op,
::mlir::TF::TensorArrayV3Op,
::mlir::TF::TensorArrayWriteV3Op,
::mlir::TF::TensorListConcatV2Op,
::mlir::TF::TensorListElementShapeOp,
::mlir::TF::TensorListFromTensorOp,
::mlir::TF::TensorListGatherOp,
::mlir::TF::TensorListGetItemOp,
::mlir::TF::TensorListLengthOp,
::mlir::TF::TensorListPopBackOp,
::mlir::TF::TensorListPushBackOp,
::mlir::TF::TensorListReserveOp,
::mlir::TF::TensorListResizeOp,
::mlir::TF::TensorListScatterIntoExistingListOp,
::mlir::TF::TensorListSetItemOp,
::mlir::TF::TensorListStackOp,
::mlir::TF::TensorScatterAddOp,
::mlir::TF::TensorScatterSubOp,
::mlir::TF::TensorScatterUpdateOp,
::mlir::TF::TensorSliceDatasetOp,
::mlir::TF::TensorStridedSliceUpdateOp,
::mlir::TF::TileOp,
::mlir::TF::ToBoolOp,
::mlir::TF::TopKV2Op,
::mlir::TF::TransposeOp,
::mlir::TF::TridiagonalSolveOp,
::mlir::TF::TruncateDivOp,
::mlir::TF::TruncateModOp,
::mlir::TF::TruncatedNormalOp,
::mlir::TF::UniqueOp,
::mlir::TF::UnpackOp,
::mlir::TF::UnsortedSegmentMaxOp,
::mlir::TF::UnsortedSegmentMinOp,
::mlir::TF::UnsortedSegmentProdOp,
::mlir::TF::UnsortedSegmentSumOp,
::mlir::TF::UpperBoundOp,
::mlir::TF::VarHandleOp,
::mlir::TF::VarIsInitializedOp,
::mlir::TF::VariableShapeOp,
::mlir::TF::VariableV2Op,
::mlir::TF::WhereOp,
::mlir::TF::WhileOp,
::mlir::TF::WhileRegionOp,
::mlir::TF::WriteAudioSummaryOp,
::mlir::TF::WriteGraphSummaryOp,
::mlir::TF::WriteHistogramSummaryOp,
::mlir::TF::WriteImageSummaryOp,
::mlir::TF::WriteRawProtoSummaryOp,
::mlir::TF::WriteScalarSummaryOp,
::mlir::TF::WriteSummaryOp,
::mlir::TF::XdivyOp,
::mlir::TF::XlaBroadcastHelperOp,
::mlir::TF::XlaConvOp,
::mlir::TF::XlaDotOp,
::mlir::TF::XlaDynamicSliceOp,
::mlir::TF::XlaDynamicUpdateSliceOp,
::mlir::TF::XlaEinsumOp,
::mlir::TF::XlaGatherOp,
::mlir::TF::XlaHostComputeOp,
::mlir::TF::XlaKeyValueSortOp,
::mlir::TF::XlaPadOp,
::mlir::TF::XlaRecvFromHostOp,
::mlir::TF::XlaReduceOp,
::mlir::TF::XlaReplicaIdOp,
::mlir::TF::XlaScatterOp,
::mlir::TF::XlaSelfAdjointEigOp,
::mlir::TF::XlaSendToHostOp,
::mlir::TF::XlaShardingOp,
::mlir::TF::XlaSortOp,
::mlir::TF::XlaSvdOp,
::mlir::TF::Xlog1pyOp,
::mlir::TF::XlogyOp,
::mlir::TF::YieldOp,
::mlir::TF::ZerosLikeOp
#endif  // GET_OP_LIST

#ifdef GET_OP_CLASSES
#undef GET_OP_CLASSES

namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::NdtriOp definitions
//===----------------------------------------------------------------------===//

NdtriOpAdaptor::NdtriOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

NdtriOpAdaptor::NdtriOpAdaptor(NdtriOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> NdtriOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange NdtriOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value NdtriOpAdaptor::x() {
  return *getODSOperands(0).begin();
}

::mlir::LogicalResult NdtriOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

::llvm::StringRef NdtriOp::getOperationName() {
  return "tf.Ndtri";
}

std::pair<unsigned, unsigned> NdtriOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range NdtriOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value NdtriOp::x() {
  return *getODSOperands(0).begin();
}

::mlir::MutableOperandRange NdtriOp::xMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> NdtriOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range NdtriOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value NdtriOp::y() {
  return *getODSResults(0).begin();
}

Type NdtriOp::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

bool NdtriOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "T") return true;
 return false;
}

::mlir::DictionaryAttr NdtriOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())}
    }, ctx);
}

void NdtriOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type y, ::mlir::Value x) {
  odsState.addOperands(x);
  odsState.addTypes(y);
}

void NdtriOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value x) {
  odsState.addOperands(x);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void NdtriOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult NdtriOp::verify() {
  if (failed(NdtriOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of floating-point values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))))) {
        return emitOpError("result #") << index << " must be tensor of floating-point values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void NdtriOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::NegOp definitions
//===----------------------------------------------------------------------===//

NegOpAdaptor::NegOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

NegOpAdaptor::NegOpAdaptor(NegOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> NegOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange NegOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value NegOpAdaptor::x() {
  return *getODSOperands(0).begin();
}

::mlir::LogicalResult NegOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

::llvm::StringRef NegOp::getOperationName() {
  return "tf.Neg";
}

std::pair<unsigned, unsigned> NegOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range NegOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value NegOp::x() {
  return *getODSOperands(0).begin();
}

::mlir::MutableOperandRange NegOp::xMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> NegOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range NegOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value NegOp::y() {
  return *getODSResults(0).begin();
}

Type NegOp::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

bool NegOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "T") return true;
 return false;
}

::mlir::DictionaryAttr NegOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())}
    }, ctx);
}

void NegOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type y, ::mlir::Value x) {
  odsState.addOperands(x);
  odsState.addTypes(y);
}

void NegOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value x) {
  odsState.addOperands(x);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void NegOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

void NegOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value x) {
  odsState.addOperands(x);
  odsState.addTypes({x.getType()});

}

void NegOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  odsState.addTypes({operands[0].getType()});

}

::mlir::LogicalResult NegOp::verify() {
  if (failed(NegOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of bfloat16 or 128-bit complex or 64-bit complex or 16-bit float or 32-bit float or 64-bit float or 16-bit integer or 32-bit integer or 64-bit integer or 8-bit integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>())))))) {
        return emitOpError("result #") << index << " must be tensor of bfloat16 or 128-bit complex or 64-bit complex or 16-bit float or 32-bit float or 64-bit float or 16-bit integer or 32-bit integer or 64-bit integer or 8-bit integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}



void NegOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::NextAfterOp definitions
//===----------------------------------------------------------------------===//

NextAfterOpAdaptor::NextAfterOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

NextAfterOpAdaptor::NextAfterOpAdaptor(NextAfterOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> NextAfterOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange NextAfterOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value NextAfterOpAdaptor::x1() {
  return *getODSOperands(0).begin();
}

::mlir::Value NextAfterOpAdaptor::x2() {
  return *getODSOperands(1).begin();
}

::mlir::LogicalResult NextAfterOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

::llvm::StringRef NextAfterOp::getOperationName() {
  return "tf.NextAfter";
}

std::pair<unsigned, unsigned> NextAfterOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range NextAfterOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value NextAfterOp::x1() {
  return *getODSOperands(0).begin();
}

::mlir::Value NextAfterOp::x2() {
  return *getODSOperands(1).begin();
}

::mlir::MutableOperandRange NextAfterOp::x1Mutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange NextAfterOp::x2Mutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> NextAfterOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range NextAfterOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value NextAfterOp::output() {
  return *getODSResults(0).begin();
}

Type NextAfterOp::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

bool NextAfterOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "T") return true;
 return false;
}

::mlir::DictionaryAttr NextAfterOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())}
    }, ctx);
}

void NextAfterOp::build(OpBuilder &builder, OperationState &result, Value  x, Value  y) {
  auto resultType =
      OpTrait::util::getBroadcastedType(x.getType(), y.getType());
  if (!resultType)
    mlir::emitError(result.location, "non-broadcastable operands");
  return build(builder, result, resultType, x, y);
}

void NextAfterOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value x1, ::mlir::Value x2) {
  odsState.addOperands(x1);
  odsState.addOperands(x2);
  odsState.addTypes(output);
}

void NextAfterOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value x1, ::mlir::Value x2) {
  odsState.addOperands(x1);
  odsState.addOperands(x2);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void NextAfterOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult NextAfterOp::verify() {
  if (failed(NextAfterOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of 32/64-bit float values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of 32/64-bit float values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())))))) {
        return emitOpError("result #") << index << " must be tensor of 32/64-bit float values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void NextAfterOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::NoOp definitions
//===----------------------------------------------------------------------===//

NoOpAdaptor::NoOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

NoOpAdaptor::NoOpAdaptor(NoOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> NoOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange NoOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::LogicalResult NoOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

::llvm::StringRef NoOp::getOperationName() {
  return "tf.NoOp";
}

std::pair<unsigned, unsigned> NoOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range NoOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

std::pair<unsigned, unsigned> NoOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range NoOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

void NoOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState) {

}

void NoOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes) {
  assert(resultTypes.size() == 0u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void NoOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 0u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 0u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult NoOp::verify() {
  if (failed(NoOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
  }
  {
    unsigned index = 0; (void)index;
  }
  return ::mlir::success();
}

void NoOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::NonMaxSuppressionV3Op definitions
//===----------------------------------------------------------------------===//

NonMaxSuppressionV3OpAdaptor::NonMaxSuppressionV3OpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

NonMaxSuppressionV3OpAdaptor::NonMaxSuppressionV3OpAdaptor(NonMaxSuppressionV3Op&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> NonMaxSuppressionV3OpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange NonMaxSuppressionV3OpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value NonMaxSuppressionV3OpAdaptor::boxes() {
  return *getODSOperands(0).begin();
}

::mlir::Value NonMaxSuppressionV3OpAdaptor::scores() {
  return *getODSOperands(1).begin();
}

::mlir::Value NonMaxSuppressionV3OpAdaptor::max_output_size() {
  return *getODSOperands(2).begin();
}

::mlir::Value NonMaxSuppressionV3OpAdaptor::iou_threshold() {
  return *getODSOperands(3).begin();
}

::mlir::Value NonMaxSuppressionV3OpAdaptor::score_threshold() {
  return *getODSOperands(4).begin();
}

::mlir::LogicalResult NonMaxSuppressionV3OpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

::llvm::StringRef NonMaxSuppressionV3Op::getOperationName() {
  return "tf.NonMaxSuppressionV3";
}

std::pair<unsigned, unsigned> NonMaxSuppressionV3Op::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range NonMaxSuppressionV3Op::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value NonMaxSuppressionV3Op::boxes() {
  return *getODSOperands(0).begin();
}

::mlir::Value NonMaxSuppressionV3Op::scores() {
  return *getODSOperands(1).begin();
}

::mlir::Value NonMaxSuppressionV3Op::max_output_size() {
  return *getODSOperands(2).begin();
}

::mlir::Value NonMaxSuppressionV3Op::iou_threshold() {
  return *getODSOperands(3).begin();
}

::mlir::Value NonMaxSuppressionV3Op::score_threshold() {
  return *getODSOperands(4).begin();
}

::mlir::MutableOperandRange NonMaxSuppressionV3Op::boxesMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange NonMaxSuppressionV3Op::scoresMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange NonMaxSuppressionV3Op::max_output_sizeMutable() {
  auto range = getODSOperandIndexAndLength(2);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange NonMaxSuppressionV3Op::iou_thresholdMutable() {
  auto range = getODSOperandIndexAndLength(3);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange NonMaxSuppressionV3Op::score_thresholdMutable() {
  auto range = getODSOperandIndexAndLength(4);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> NonMaxSuppressionV3Op::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range NonMaxSuppressionV3Op::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value NonMaxSuppressionV3Op::selected_indices() {
  return *getODSResults(0).begin();
}

Type NonMaxSuppressionV3Op::T_threshold() {
  return mlir::getElementTypeOrSelf(*getODSOperands(3).begin());
}

Type NonMaxSuppressionV3Op::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

bool NonMaxSuppressionV3Op::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "T_threshold") return true;
  if (name == "T") return true;
 return false;
}

::mlir::DictionaryAttr NonMaxSuppressionV3Op::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("T_threshold", ctx),
::mlir::TypeAttr::get(T_threshold())},
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())}
    }, ctx);
}

void NonMaxSuppressionV3Op::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type selected_indices, ::mlir::Value boxes, ::mlir::Value scores, ::mlir::Value max_output_size, ::mlir::Value iou_threshold, ::mlir::Value score_threshold) {
  odsState.addOperands(boxes);
  odsState.addOperands(scores);
  odsState.addOperands(max_output_size);
  odsState.addOperands(iou_threshold);
  odsState.addOperands(score_threshold);
  odsState.addTypes(selected_indices);
}

void NonMaxSuppressionV3Op::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value boxes, ::mlir::Value scores, ::mlir::Value max_output_size, ::mlir::Value iou_threshold, ::mlir::Value score_threshold) {
  odsState.addOperands(boxes);
  odsState.addOperands(scores);
  odsState.addOperands(max_output_size);
  odsState.addOperands(iou_threshold);
  odsState.addOperands(score_threshold);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void NonMaxSuppressionV3Op::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 5u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult NonMaxSuppressionV3Op::verify() {
  if (failed(NonMaxSuppressionV3OpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of 16-bit float or 32-bit float values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of 16-bit float or 32-bit float values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup2 = getODSOperands(2);
    for (::mlir::Value v : valueGroup2) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of 32-bit integer values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup3 = getODSOperands(3);
    for (::mlir::Value v : valueGroup3) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of 16-bit float or 32-bit float values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup4 = getODSOperands(4);
    for (::mlir::Value v : valueGroup4) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of 16-bit float or 32-bit float values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))))) {
        return emitOpError("result #") << index << " must be tensor of 32-bit integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}



void NonMaxSuppressionV3Op::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::NonMaxSuppressionV4Op definitions
//===----------------------------------------------------------------------===//

NonMaxSuppressionV4OpAdaptor::NonMaxSuppressionV4OpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

NonMaxSuppressionV4OpAdaptor::NonMaxSuppressionV4OpAdaptor(NonMaxSuppressionV4Op&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> NonMaxSuppressionV4OpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange NonMaxSuppressionV4OpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value NonMaxSuppressionV4OpAdaptor::boxes() {
  return *getODSOperands(0).begin();
}

::mlir::Value NonMaxSuppressionV4OpAdaptor::scores() {
  return *getODSOperands(1).begin();
}

::mlir::Value NonMaxSuppressionV4OpAdaptor::max_output_size() {
  return *getODSOperands(2).begin();
}

::mlir::Value NonMaxSuppressionV4OpAdaptor::iou_threshold() {
  return *getODSOperands(3).begin();
}

::mlir::Value NonMaxSuppressionV4OpAdaptor::score_threshold() {
  return *getODSOperands(4).begin();
}

::mlir::BoolAttr NonMaxSuppressionV4OpAdaptor::pad_to_max_output_size() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::BoolAttr attr = odsAttrs.get("pad_to_max_output_size").dyn_cast_or_null<::mlir::BoolAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getBoolAttr(false);
  return attr;
}

::mlir::LogicalResult NonMaxSuppressionV4OpAdaptor::verify(::mlir::Location loc) {
  {
  auto tblgen_pad_to_max_output_size = odsAttrs.get("pad_to_max_output_size");
  if (tblgen_pad_to_max_output_size) {
    if (!((tblgen_pad_to_max_output_size.isa<::mlir::BoolAttr>()))) return emitError(loc, "'tf.NonMaxSuppressionV4' op ""attribute 'pad_to_max_output_size' failed to satisfy constraint: bool attribute");
  }
  }
  return ::mlir::success();
}

void NonMaxSuppressionV4Op::getAsmResultNames(::mlir::OpAsmSetValueNameFn setNameFn) {
  auto resultGroup0 = getODSResults(0);
  if (!llvm::empty(resultGroup0))
    setNameFn(*resultGroup0.begin(), "selected_indices");
  auto resultGroup1 = getODSResults(1);
  if (!llvm::empty(resultGroup1))
    setNameFn(*resultGroup1.begin(), "valid_outputs");
}

::llvm::StringRef NonMaxSuppressionV4Op::getOperationName() {
  return "tf.NonMaxSuppressionV4";
}

std::pair<unsigned, unsigned> NonMaxSuppressionV4Op::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range NonMaxSuppressionV4Op::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value NonMaxSuppressionV4Op::boxes() {
  return *getODSOperands(0).begin();
}

::mlir::Value NonMaxSuppressionV4Op::scores() {
  return *getODSOperands(1).begin();
}

::mlir::Value NonMaxSuppressionV4Op::max_output_size() {
  return *getODSOperands(2).begin();
}

::mlir::Value NonMaxSuppressionV4Op::iou_threshold() {
  return *getODSOperands(3).begin();
}

::mlir::Value NonMaxSuppressionV4Op::score_threshold() {
  return *getODSOperands(4).begin();
}

::mlir::MutableOperandRange NonMaxSuppressionV4Op::boxesMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange NonMaxSuppressionV4Op::scoresMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange NonMaxSuppressionV4Op::max_output_sizeMutable() {
  auto range = getODSOperandIndexAndLength(2);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange NonMaxSuppressionV4Op::iou_thresholdMutable() {
  auto range = getODSOperandIndexAndLength(3);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange NonMaxSuppressionV4Op::score_thresholdMutable() {
  auto range = getODSOperandIndexAndLength(4);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> NonMaxSuppressionV4Op::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range NonMaxSuppressionV4Op::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value NonMaxSuppressionV4Op::selected_indices() {
  return *getODSResults(0).begin();
}

::mlir::Value NonMaxSuppressionV4Op::valid_outputs() {
  return *getODSResults(1).begin();
}

::mlir::BoolAttr NonMaxSuppressionV4Op::pad_to_max_output_sizeAttr() {
  return this->getAttr("pad_to_max_output_size").dyn_cast_or_null<::mlir::BoolAttr>();
}

bool NonMaxSuppressionV4Op::pad_to_max_output_size() {
  auto attr = pad_to_max_output_sizeAttr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getBoolAttr(false).getValue();
  return attr.getValue();
}

Type NonMaxSuppressionV4Op::T_threshold() {
  return mlir::getElementTypeOrSelf(*getODSOperands(3).begin());
}

Type NonMaxSuppressionV4Op::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

bool NonMaxSuppressionV4Op::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "T_threshold") return true;
  if (name == "T") return true;
 return false;
}

::mlir::DictionaryAttr NonMaxSuppressionV4Op::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("T_threshold", ctx),
::mlir::TypeAttr::get(T_threshold())},
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())}
    }, ctx);
}

void NonMaxSuppressionV4Op::pad_to_max_output_sizeAttr(::mlir::BoolAttr attr) {
  this->getOperation()->setAttr("pad_to_max_output_size", attr);
}

void NonMaxSuppressionV4Op::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type selected_indices, ::mlir::Type valid_outputs, ::mlir::Value boxes, ::mlir::Value scores, ::mlir::Value max_output_size, ::mlir::Value iou_threshold, ::mlir::Value score_threshold, ::mlir::BoolAttr pad_to_max_output_size) {
  odsState.addOperands(boxes);
  odsState.addOperands(scores);
  odsState.addOperands(max_output_size);
  odsState.addOperands(iou_threshold);
  odsState.addOperands(score_threshold);
  odsState.addAttribute("pad_to_max_output_size", pad_to_max_output_size);
  odsState.addTypes(selected_indices);
  odsState.addTypes(valid_outputs);
}

void NonMaxSuppressionV4Op::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value boxes, ::mlir::Value scores, ::mlir::Value max_output_size, ::mlir::Value iou_threshold, ::mlir::Value score_threshold, ::mlir::BoolAttr pad_to_max_output_size) {
  odsState.addOperands(boxes);
  odsState.addOperands(scores);
  odsState.addOperands(max_output_size);
  odsState.addOperands(iou_threshold);
  odsState.addOperands(score_threshold);
  odsState.addAttribute("pad_to_max_output_size", pad_to_max_output_size);
  assert(resultTypes.size() == 2u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void NonMaxSuppressionV4Op::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type selected_indices, ::mlir::Type valid_outputs, ::mlir::Value boxes, ::mlir::Value scores, ::mlir::Value max_output_size, ::mlir::Value iou_threshold, ::mlir::Value score_threshold, bool pad_to_max_output_size) {
  odsState.addOperands(boxes);
  odsState.addOperands(scores);
  odsState.addOperands(max_output_size);
  odsState.addOperands(iou_threshold);
  odsState.addOperands(score_threshold);
  odsState.addAttribute("pad_to_max_output_size", odsBuilder.getBoolAttr(pad_to_max_output_size));
  odsState.addTypes(selected_indices);
  odsState.addTypes(valid_outputs);
}

void NonMaxSuppressionV4Op::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value boxes, ::mlir::Value scores, ::mlir::Value max_output_size, ::mlir::Value iou_threshold, ::mlir::Value score_threshold, bool pad_to_max_output_size) {
  odsState.addOperands(boxes);
  odsState.addOperands(scores);
  odsState.addOperands(max_output_size);
  odsState.addOperands(iou_threshold);
  odsState.addOperands(score_threshold);
  odsState.addAttribute("pad_to_max_output_size", odsBuilder.getBoolAttr(pad_to_max_output_size));
  assert(resultTypes.size() == 2u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void NonMaxSuppressionV4Op::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 5u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 2u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult NonMaxSuppressionV4Op::verify() {
  if (failed(NonMaxSuppressionV4OpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of 16-bit float or 32-bit float values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of 16-bit float or 32-bit float values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup2 = getODSOperands(2);
    for (::mlir::Value v : valueGroup2) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of 32-bit integer values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup3 = getODSOperands(3);
    for (::mlir::Value v : valueGroup3) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of 16-bit float or 32-bit float values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup4 = getODSOperands(4);
    for (::mlir::Value v : valueGroup4) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of 16-bit float or 32-bit float values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))))) {
        return emitOpError("result #") << index << " must be tensor of 32-bit integer values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSResults(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))))) {
        return emitOpError("result #") << index << " must be tensor of 32-bit integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void NonMaxSuppressionV4Op::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::NonMaxSuppressionV5Op definitions
//===----------------------------------------------------------------------===//

NonMaxSuppressionV5OpAdaptor::NonMaxSuppressionV5OpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

NonMaxSuppressionV5OpAdaptor::NonMaxSuppressionV5OpAdaptor(NonMaxSuppressionV5Op&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> NonMaxSuppressionV5OpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange NonMaxSuppressionV5OpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value NonMaxSuppressionV5OpAdaptor::boxes() {
  return *getODSOperands(0).begin();
}

::mlir::Value NonMaxSuppressionV5OpAdaptor::scores() {
  return *getODSOperands(1).begin();
}

::mlir::Value NonMaxSuppressionV5OpAdaptor::max_output_size() {
  return *getODSOperands(2).begin();
}

::mlir::Value NonMaxSuppressionV5OpAdaptor::iou_threshold() {
  return *getODSOperands(3).begin();
}

::mlir::Value NonMaxSuppressionV5OpAdaptor::score_threshold() {
  return *getODSOperands(4).begin();
}

::mlir::Value NonMaxSuppressionV5OpAdaptor::soft_nms_sigma() {
  return *getODSOperands(5).begin();
}

::mlir::BoolAttr NonMaxSuppressionV5OpAdaptor::pad_to_max_output_size() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::BoolAttr attr = odsAttrs.get("pad_to_max_output_size").dyn_cast_or_null<::mlir::BoolAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getBoolAttr(false);
  return attr;
}

::mlir::LogicalResult NonMaxSuppressionV5OpAdaptor::verify(::mlir::Location loc) {
  {
  auto tblgen_pad_to_max_output_size = odsAttrs.get("pad_to_max_output_size");
  if (tblgen_pad_to_max_output_size) {
    if (!((tblgen_pad_to_max_output_size.isa<::mlir::BoolAttr>()))) return emitError(loc, "'tf.NonMaxSuppressionV5' op ""attribute 'pad_to_max_output_size' failed to satisfy constraint: bool attribute");
  }
  }
  return ::mlir::success();
}

void NonMaxSuppressionV5Op::getAsmResultNames(::mlir::OpAsmSetValueNameFn setNameFn) {
  auto resultGroup0 = getODSResults(0);
  if (!llvm::empty(resultGroup0))
    setNameFn(*resultGroup0.begin(), "selected_indices");
  auto resultGroup1 = getODSResults(1);
  if (!llvm::empty(resultGroup1))
    setNameFn(*resultGroup1.begin(), "selected_scores");
  auto resultGroup2 = getODSResults(2);
  if (!llvm::empty(resultGroup2))
    setNameFn(*resultGroup2.begin(), "valid_outputs");
}

::llvm::StringRef NonMaxSuppressionV5Op::getOperationName() {
  return "tf.NonMaxSuppressionV5";
}

std::pair<unsigned, unsigned> NonMaxSuppressionV5Op::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range NonMaxSuppressionV5Op::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value NonMaxSuppressionV5Op::boxes() {
  return *getODSOperands(0).begin();
}

::mlir::Value NonMaxSuppressionV5Op::scores() {
  return *getODSOperands(1).begin();
}

::mlir::Value NonMaxSuppressionV5Op::max_output_size() {
  return *getODSOperands(2).begin();
}

::mlir::Value NonMaxSuppressionV5Op::iou_threshold() {
  return *getODSOperands(3).begin();
}

::mlir::Value NonMaxSuppressionV5Op::score_threshold() {
  return *getODSOperands(4).begin();
}

::mlir::Value NonMaxSuppressionV5Op::soft_nms_sigma() {
  return *getODSOperands(5).begin();
}

::mlir::MutableOperandRange NonMaxSuppressionV5Op::boxesMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange NonMaxSuppressionV5Op::scoresMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange NonMaxSuppressionV5Op::max_output_sizeMutable() {
  auto range = getODSOperandIndexAndLength(2);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange NonMaxSuppressionV5Op::iou_thresholdMutable() {
  auto range = getODSOperandIndexAndLength(3);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange NonMaxSuppressionV5Op::score_thresholdMutable() {
  auto range = getODSOperandIndexAndLength(4);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange NonMaxSuppressionV5Op::soft_nms_sigmaMutable() {
  auto range = getODSOperandIndexAndLength(5);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> NonMaxSuppressionV5Op::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range NonMaxSuppressionV5Op::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value NonMaxSuppressionV5Op::selected_indices() {
  return *getODSResults(0).begin();
}

::mlir::Value NonMaxSuppressionV5Op::selected_scores() {
  return *getODSResults(1).begin();
}

::mlir::Value NonMaxSuppressionV5Op::valid_outputs() {
  return *getODSResults(2).begin();
}

::mlir::BoolAttr NonMaxSuppressionV5Op::pad_to_max_output_sizeAttr() {
  return this->getAttr("pad_to_max_output_size").dyn_cast_or_null<::mlir::BoolAttr>();
}

bool NonMaxSuppressionV5Op::pad_to_max_output_size() {
  auto attr = pad_to_max_output_sizeAttr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getBoolAttr(false).getValue();
  return attr.getValue();
}

Type NonMaxSuppressionV5Op::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

bool NonMaxSuppressionV5Op::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "T") return true;
 return false;
}

::mlir::DictionaryAttr NonMaxSuppressionV5Op::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())}
    }, ctx);
}

void NonMaxSuppressionV5Op::pad_to_max_output_sizeAttr(::mlir::BoolAttr attr) {
  this->getOperation()->setAttr("pad_to_max_output_size", attr);
}

void NonMaxSuppressionV5Op::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type selected_indices, ::mlir::Type selected_scores, ::mlir::Type valid_outputs, ::mlir::Value boxes, ::mlir::Value scores, ::mlir::Value max_output_size, ::mlir::Value iou_threshold, ::mlir::Value score_threshold, ::mlir::Value soft_nms_sigma, ::mlir::BoolAttr pad_to_max_output_size) {
  odsState.addOperands(boxes);
  odsState.addOperands(scores);
  odsState.addOperands(max_output_size);
  odsState.addOperands(iou_threshold);
  odsState.addOperands(score_threshold);
  odsState.addOperands(soft_nms_sigma);
  odsState.addAttribute("pad_to_max_output_size", pad_to_max_output_size);
  odsState.addTypes(selected_indices);
  odsState.addTypes(selected_scores);
  odsState.addTypes(valid_outputs);
}

void NonMaxSuppressionV5Op::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value boxes, ::mlir::Value scores, ::mlir::Value max_output_size, ::mlir::Value iou_threshold, ::mlir::Value score_threshold, ::mlir::Value soft_nms_sigma, ::mlir::BoolAttr pad_to_max_output_size) {
  odsState.addOperands(boxes);
  odsState.addOperands(scores);
  odsState.addOperands(max_output_size);
  odsState.addOperands(iou_threshold);
  odsState.addOperands(score_threshold);
  odsState.addOperands(soft_nms_sigma);
  odsState.addAttribute("pad_to_max_output_size", pad_to_max_output_size);
  assert(resultTypes.size() == 3u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void NonMaxSuppressionV5Op::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type selected_indices, ::mlir::Type selected_scores, ::mlir::Type valid_outputs, ::mlir::Value boxes, ::mlir::Value scores, ::mlir::Value max_output_size, ::mlir::Value iou_threshold, ::mlir::Value score_threshold, ::mlir::Value soft_nms_sigma, bool pad_to_max_output_size) {
  odsState.addOperands(boxes);
  odsState.addOperands(scores);
  odsState.addOperands(max_output_size);
  odsState.addOperands(iou_threshold);
  odsState.addOperands(score_threshold);
  odsState.addOperands(soft_nms_sigma);
  odsState.addAttribute("pad_to_max_output_size", odsBuilder.getBoolAttr(pad_to_max_output_size));
  odsState.addTypes(selected_indices);
  odsState.addTypes(selected_scores);
  odsState.addTypes(valid_outputs);
}

void NonMaxSuppressionV5Op::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value boxes, ::mlir::Value scores, ::mlir::Value max_output_size, ::mlir::Value iou_threshold, ::mlir::Value score_threshold, ::mlir::Value soft_nms_sigma, bool pad_to_max_output_size) {
  odsState.addOperands(boxes);
  odsState.addOperands(scores);
  odsState.addOperands(max_output_size);
  odsState.addOperands(iou_threshold);
  odsState.addOperands(score_threshold);
  odsState.addOperands(soft_nms_sigma);
  odsState.addAttribute("pad_to_max_output_size", odsBuilder.getBoolAttr(pad_to_max_output_size));
  assert(resultTypes.size() == 3u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void NonMaxSuppressionV5Op::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 6u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 3u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult NonMaxSuppressionV5Op::verify() {
  if (failed(NonMaxSuppressionV5OpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of 16-bit float or 32-bit float values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of 16-bit float or 32-bit float values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup2 = getODSOperands(2);
    for (::mlir::Value v : valueGroup2) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of 32-bit integer values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup3 = getODSOperands(3);
    for (::mlir::Value v : valueGroup3) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of 16-bit float or 32-bit float values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup4 = getODSOperands(4);
    for (::mlir::Value v : valueGroup4) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of 16-bit float or 32-bit float values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup5 = getODSOperands(5);
    for (::mlir::Value v : valueGroup5) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of 16-bit float or 32-bit float values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))))) {
        return emitOpError("result #") << index << " must be tensor of 32-bit integer values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSResults(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())))))) {
        return emitOpError("result #") << index << " must be tensor of 16-bit float or 32-bit float values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup2 = getODSResults(2);
    for (::mlir::Value v : valueGroup2) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))))) {
        return emitOpError("result #") << index << " must be tensor of 32-bit integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void NonMaxSuppressionV5Op::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::NotEqualOp definitions
//===----------------------------------------------------------------------===//

NotEqualOpAdaptor::NotEqualOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

NotEqualOpAdaptor::NotEqualOpAdaptor(NotEqualOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> NotEqualOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange NotEqualOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value NotEqualOpAdaptor::x() {
  return *getODSOperands(0).begin();
}

::mlir::Value NotEqualOpAdaptor::y() {
  return *getODSOperands(1).begin();
}

::mlir::BoolAttr NotEqualOpAdaptor::incompatible_shape_error() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::BoolAttr attr = odsAttrs.get("incompatible_shape_error").dyn_cast_or_null<::mlir::BoolAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getBoolAttr(true);
  return attr;
}

::mlir::LogicalResult NotEqualOpAdaptor::verify(::mlir::Location loc) {
  {
  auto tblgen_incompatible_shape_error = odsAttrs.get("incompatible_shape_error");
  if (tblgen_incompatible_shape_error) {
    if (!((tblgen_incompatible_shape_error.isa<::mlir::BoolAttr>()))) return emitError(loc, "'tf.NotEqual' op ""attribute 'incompatible_shape_error' failed to satisfy constraint: bool attribute");
  }
  }
  return ::mlir::success();
}

::llvm::StringRef NotEqualOp::getOperationName() {
  return "tf.NotEqual";
}

std::pair<unsigned, unsigned> NotEqualOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range NotEqualOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value NotEqualOp::x() {
  return *getODSOperands(0).begin();
}

::mlir::Value NotEqualOp::y() {
  return *getODSOperands(1).begin();
}

::mlir::MutableOperandRange NotEqualOp::xMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange NotEqualOp::yMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> NotEqualOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range NotEqualOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value NotEqualOp::z() {
  return *getODSResults(0).begin();
}

::mlir::BoolAttr NotEqualOp::incompatible_shape_errorAttr() {
  return this->getAttr("incompatible_shape_error").dyn_cast_or_null<::mlir::BoolAttr>();
}

bool NotEqualOp::incompatible_shape_error() {
  auto attr = incompatible_shape_errorAttr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getBoolAttr(true).getValue();
  return attr.getValue();
}

Type NotEqualOp::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

bool NotEqualOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "T") return true;
 return false;
}

::mlir::DictionaryAttr NotEqualOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())}
    }, ctx);
}

void NotEqualOp::incompatible_shape_errorAttr(::mlir::BoolAttr attr) {
  this->getOperation()->setAttr("incompatible_shape_error", attr);
}



void NotEqualOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type z, ::mlir::Value x, ::mlir::Value y, ::mlir::BoolAttr incompatible_shape_error) {
  odsState.addOperands(x);
  odsState.addOperands(y);
  odsState.addAttribute("incompatible_shape_error", incompatible_shape_error);
  odsState.addTypes(z);
}

void NotEqualOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value x, ::mlir::Value y, ::mlir::BoolAttr incompatible_shape_error) {
  odsState.addOperands(x);
  odsState.addOperands(y);
  odsState.addAttribute("incompatible_shape_error", incompatible_shape_error);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void NotEqualOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type z, ::mlir::Value x, ::mlir::Value y, bool incompatible_shape_error) {
  odsState.addOperands(x);
  odsState.addOperands(y);
  odsState.addAttribute("incompatible_shape_error", odsBuilder.getBoolAttr(incompatible_shape_error));
  odsState.addTypes(z);
}

void NotEqualOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value x, ::mlir::Value y, bool incompatible_shape_error) {
  odsState.addOperands(x);
  odsState.addOperands(y);
  odsState.addAttribute("incompatible_shape_error", odsBuilder.getBoolAttr(incompatible_shape_error));
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void NotEqualOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult NotEqualOp::verify() {
  if (failed(NotEqualOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint16Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint16Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::StringType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::StringRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of bfloat16 or bool or 128-bit complex or 64-bit complex or 16-bit float or 32-bit float or 64-bit float or 16-bit integer or 32-bit integer or 64-bit integer or 8-bit integer or 16-bit quantized integer or 16-bit quantized unsigned integer or 32-bit quantized integer or 8-bit quantized integer or 8-bit quantized unsigned integer or string or 16-bit unsigned integer or 32-bit unsigned integer or 64-bit unsigned integer or 8-bit unsigned integer values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint16Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint16Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::StringType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::StringRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of bfloat16 or bool or 128-bit complex or 64-bit complex or 16-bit float or 32-bit float or 64-bit float or 16-bit integer or 32-bit integer or 64-bit integer or 8-bit integer or 16-bit quantized integer or 16-bit quantized unsigned integer or 32-bit quantized integer or 8-bit quantized integer or 8-bit quantized unsigned integer or string or 16-bit unsigned integer or 32-bit unsigned integer or 64-bit unsigned integer or 8-bit unsigned integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))))) {
        return emitOpError("result #") << index << " must be tensor of bool values, but got " << v.getType();
      }
      ++index;
    }
  }
  return Verify(*this);
}

void NotEqualOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::OneHotOp definitions
//===----------------------------------------------------------------------===//

OneHotOpAdaptor::OneHotOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

OneHotOpAdaptor::OneHotOpAdaptor(OneHotOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> OneHotOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange OneHotOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value OneHotOpAdaptor::indices() {
  return *getODSOperands(0).begin();
}

::mlir::Value OneHotOpAdaptor::depth() {
  return *getODSOperands(1).begin();
}

::mlir::Value OneHotOpAdaptor::on_value() {
  return *getODSOperands(2).begin();
}

::mlir::Value OneHotOpAdaptor::off_value() {
  return *getODSOperands(3).begin();
}

::mlir::IntegerAttr OneHotOpAdaptor::axis() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::IntegerAttr attr = odsAttrs.get("axis").dyn_cast_or_null<::mlir::IntegerAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getIntegerAttr(::mlir::Builder(odsAttrs.getContext()).getIntegerType(64), -1);
  return attr;
}

::mlir::LogicalResult OneHotOpAdaptor::verify(::mlir::Location loc) {
  {
  auto tblgen_axis = odsAttrs.get("axis");
  if (tblgen_axis) {
    if (!(((tblgen_axis.isa<::mlir::IntegerAttr>())) && ((tblgen_axis.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(64))))) return emitError(loc, "'tf.OneHot' op ""attribute 'axis' failed to satisfy constraint: 64-bit signless integer attribute");
  }
  }
  return ::mlir::success();
}

::llvm::StringRef OneHotOp::getOperationName() {
  return "tf.OneHot";
}

std::pair<unsigned, unsigned> OneHotOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range OneHotOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value OneHotOp::indices() {
  return *getODSOperands(0).begin();
}

::mlir::Value OneHotOp::depth() {
  return *getODSOperands(1).begin();
}

::mlir::Value OneHotOp::on_value() {
  return *getODSOperands(2).begin();
}

::mlir::Value OneHotOp::off_value() {
  return *getODSOperands(3).begin();
}

::mlir::MutableOperandRange OneHotOp::indicesMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange OneHotOp::depthMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange OneHotOp::on_valueMutable() {
  auto range = getODSOperandIndexAndLength(2);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange OneHotOp::off_valueMutable() {
  auto range = getODSOperandIndexAndLength(3);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> OneHotOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range OneHotOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value OneHotOp::output() {
  return *getODSResults(0).begin();
}

::mlir::IntegerAttr OneHotOp::axisAttr() {
  return this->getAttr("axis").dyn_cast_or_null<::mlir::IntegerAttr>();
}

uint64_t OneHotOp::axis() {
  auto attr = axisAttr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getIntegerAttr(::mlir::Builder(this->getContext()).getIntegerType(64), -1).getValue().getZExtValue();
  return attr.getValue().getZExtValue();
}

Type OneHotOp::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(2).begin());
}

Type OneHotOp::TI() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

bool OneHotOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "T") return true;
  if (name == "TI") return true;
 return false;
}

::mlir::DictionaryAttr OneHotOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())},
    {::mlir::Identifier::get("TI", ctx),
::mlir::TypeAttr::get(TI())}
    }, ctx);
}

void OneHotOp::axisAttr(::mlir::IntegerAttr attr) {
  this->getOperation()->setAttr("axis", attr);
}



void OneHotOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value indices, ::mlir::Value depth, ::mlir::Value on_value, ::mlir::Value off_value, ::mlir::IntegerAttr axis) {
  odsState.addOperands(indices);
  odsState.addOperands(depth);
  odsState.addOperands(on_value);
  odsState.addOperands(off_value);
  odsState.addAttribute("axis", axis);
  odsState.addTypes(output);
}

void OneHotOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value indices, ::mlir::Value depth, ::mlir::Value on_value, ::mlir::Value off_value, ::mlir::IntegerAttr axis) {
  odsState.addOperands(indices);
  odsState.addOperands(depth);
  odsState.addOperands(on_value);
  odsState.addOperands(off_value);
  odsState.addAttribute("axis", axis);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void OneHotOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value indices, ::mlir::Value depth, ::mlir::Value on_value, ::mlir::Value off_value, uint64_t axis) {
  odsState.addOperands(indices);
  odsState.addOperands(depth);
  odsState.addOperands(on_value);
  odsState.addOperands(off_value);
  odsState.addAttribute("axis", odsBuilder.getIntegerAttr(odsBuilder.getIntegerType(64), axis));
  odsState.addTypes(output);
}

void OneHotOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value indices, ::mlir::Value depth, ::mlir::Value on_value, ::mlir::Value off_value, uint64_t axis) {
  odsState.addOperands(indices);
  odsState.addOperands(depth);
  odsState.addOperands(on_value);
  odsState.addOperands(off_value);
  odsState.addAttribute("axis", odsBuilder.getIntegerAttr(odsBuilder.getIntegerType(64), axis));
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void OneHotOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 4u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult OneHotOp::verify() {
  if (failed(OneHotOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of 32-bit integer or 64-bit integer or 8-bit unsigned integer values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of 32-bit integer values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup2 = getODSOperands(2);
    for (::mlir::Value v : valueGroup2) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>())))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::TensorFlowType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of tf.dtype values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup3 = getODSOperands(3);
    for (::mlir::Value v : valueGroup3) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>())))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::TensorFlowType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of tf.dtype values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>())))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::TensorFlowType>()))))) {
        return emitOpError("result #") << index << " must be tensor of tf.dtype values, but got " << v.getType();
      }
      ++index;
    }
  }
  return Verify(*this);
}

void OneHotOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::OneShotIteratorOp definitions
//===----------------------------------------------------------------------===//

OneShotIteratorOpAdaptor::OneShotIteratorOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

OneShotIteratorOpAdaptor::OneShotIteratorOpAdaptor(OneShotIteratorOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> OneShotIteratorOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange OneShotIteratorOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::SymbolRefAttr OneShotIteratorOpAdaptor::dataset_factory() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::SymbolRefAttr attr = odsAttrs.get("dataset_factory").cast<::mlir::SymbolRefAttr>();
  return attr;
}

::mlir::ArrayAttr OneShotIteratorOpAdaptor::output_types() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::ArrayAttr attr = odsAttrs.get("output_types").cast<::mlir::ArrayAttr>();
  return attr;
}

::mlir::ArrayAttr OneShotIteratorOpAdaptor::output_shapes() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::ArrayAttr attr = odsAttrs.get("output_shapes").cast<::mlir::ArrayAttr>();
  return attr;
}

::mlir::StringAttr OneShotIteratorOpAdaptor::container() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::StringAttr attr = odsAttrs.get("container").cast<::mlir::StringAttr>();
  return attr;
}

::mlir::StringAttr OneShotIteratorOpAdaptor::shared_name() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::StringAttr attr = odsAttrs.get("shared_name").cast<::mlir::StringAttr>();
  return attr;
}

::mlir::LogicalResult OneShotIteratorOpAdaptor::verify(::mlir::Location loc) {
  {
  auto tblgen_dataset_factory = odsAttrs.get("dataset_factory");
  if (!tblgen_dataset_factory) return emitError(loc, "'tf.OneShotIterator' op ""requires attribute 'dataset_factory'");
    if (!((tblgen_dataset_factory.isa<::mlir::SymbolRefAttr>()))) return emitError(loc, "'tf.OneShotIterator' op ""attribute 'dataset_factory' failed to satisfy constraint: symbol reference attribute");
  }
  {
  auto tblgen_output_types = odsAttrs.get("output_types");
  if (!tblgen_output_types) return emitError(loc, "'tf.OneShotIterator' op ""requires attribute 'output_types'");
    if (!((((tblgen_output_types.isa<::mlir::ArrayAttr>())) && (::llvm::all_of(tblgen_output_types.cast<::mlir::ArrayAttr>(), [](::mlir::Attribute attr) { return ((attr.isa<::mlir::TypeAttr>())) && ((attr.cast<::mlir::TypeAttr>().getValue().isa<::mlir::Type>())); }))) && ((tblgen_output_types.cast<::mlir::ArrayAttr>().size() >= 1)))) return emitError(loc, "'tf.OneShotIterator' op ""attribute 'output_types' failed to satisfy constraint: type array attribute with at least 1 elements");
  }
  {
  auto tblgen_output_shapes = odsAttrs.get("output_shapes");
  if (!tblgen_output_shapes) return emitError(loc, "'tf.OneShotIterator' op ""requires attribute 'output_shapes'");
    if (!((((tblgen_output_shapes.isa<::mlir::ArrayAttr>())) && (::llvm::all_of(tblgen_output_shapes.cast<::mlir::ArrayAttr>(), [](::mlir::Attribute attr) { return (attr.isa<mlir::TF::ShapeAttr>()); }))) && ((tblgen_output_shapes.cast<::mlir::ArrayAttr>().size() >= 1)))) return emitError(loc, "'tf.OneShotIterator' op ""attribute 'output_shapes' failed to satisfy constraint: tensorflow shape attribute array with at least 1 elements");
  }
  {
  auto tblgen_container = odsAttrs.get("container");
  if (!tblgen_container) return emitError(loc, "'tf.OneShotIterator' op ""requires attribute 'container'");
    if (!((tblgen_container.isa<::mlir::StringAttr>()))) return emitError(loc, "'tf.OneShotIterator' op ""attribute 'container' failed to satisfy constraint: string attribute");
  }
  {
  auto tblgen_shared_name = odsAttrs.get("shared_name");
  if (!tblgen_shared_name) return emitError(loc, "'tf.OneShotIterator' op ""requires attribute 'shared_name'");
    if (!((tblgen_shared_name.isa<::mlir::StringAttr>()))) return emitError(loc, "'tf.OneShotIterator' op ""attribute 'shared_name' failed to satisfy constraint: string attribute");
  }
  return ::mlir::success();
}

::llvm::StringRef OneShotIteratorOp::getOperationName() {
  return "tf.OneShotIterator";
}

std::pair<unsigned, unsigned> OneShotIteratorOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range OneShotIteratorOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

std::pair<unsigned, unsigned> OneShotIteratorOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range OneShotIteratorOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value OneShotIteratorOp::handle() {
  return *getODSResults(0).begin();
}

::mlir::SymbolRefAttr OneShotIteratorOp::dataset_factoryAttr() {
  return this->getAttr("dataset_factory").cast<::mlir::SymbolRefAttr>();
}

::mlir::SymbolRefAttr OneShotIteratorOp::dataset_factory() {
  auto attr = dataset_factoryAttr();
  return attr;
}

::mlir::ArrayAttr OneShotIteratorOp::output_typesAttr() {
  return this->getAttr("output_types").cast<::mlir::ArrayAttr>();
}

::mlir::ArrayAttr OneShotIteratorOp::output_types() {
  auto attr = output_typesAttr();
  return attr;
}

::mlir::ArrayAttr OneShotIteratorOp::output_shapesAttr() {
  return this->getAttr("output_shapes").cast<::mlir::ArrayAttr>();
}

::mlir::ArrayAttr OneShotIteratorOp::output_shapes() {
  auto attr = output_shapesAttr();
  return attr;
}

::mlir::StringAttr OneShotIteratorOp::containerAttr() {
  return this->getAttr("container").cast<::mlir::StringAttr>();
}

::llvm::StringRef OneShotIteratorOp::container() {
  auto attr = containerAttr();
  return attr.getValue();
}

::mlir::StringAttr OneShotIteratorOp::shared_nameAttr() {
  return this->getAttr("shared_name").cast<::mlir::StringAttr>();
}

::llvm::StringRef OneShotIteratorOp::shared_name() {
  auto attr = shared_nameAttr();
  return attr.getValue();
}

void OneShotIteratorOp::dataset_factoryAttr(::mlir::SymbolRefAttr attr) {
  this->getOperation()->setAttr("dataset_factory", attr);
}

void OneShotIteratorOp::output_typesAttr(::mlir::ArrayAttr attr) {
  this->getOperation()->setAttr("output_types", attr);
}

void OneShotIteratorOp::output_shapesAttr(::mlir::ArrayAttr attr) {
  this->getOperation()->setAttr("output_shapes", attr);
}

void OneShotIteratorOp::containerAttr(::mlir::StringAttr attr) {
  this->getOperation()->setAttr("container", attr);
}

void OneShotIteratorOp::shared_nameAttr(::mlir::StringAttr attr) {
  this->getOperation()->setAttr("shared_name", attr);
}

void OneShotIteratorOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type handle, ::mlir::SymbolRefAttr dataset_factory, ::mlir::ArrayAttr output_types, ::mlir::ArrayAttr output_shapes, ::mlir::StringAttr container, ::mlir::StringAttr shared_name) {
  odsState.addAttribute("dataset_factory", dataset_factory);
  odsState.addAttribute("output_types", output_types);
  odsState.addAttribute("output_shapes", output_shapes);
  odsState.addAttribute("container", container);
  odsState.addAttribute("shared_name", shared_name);
  odsState.addTypes(handle);
}

void OneShotIteratorOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::SymbolRefAttr dataset_factory, ::mlir::ArrayAttr output_types, ::mlir::ArrayAttr output_shapes, ::mlir::StringAttr container, ::mlir::StringAttr shared_name) {
  odsState.addAttribute("dataset_factory", dataset_factory);
  odsState.addAttribute("output_types", output_types);
  odsState.addAttribute("output_shapes", output_shapes);
  odsState.addAttribute("container", container);
  odsState.addAttribute("shared_name", shared_name);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void OneShotIteratorOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type handle, ::mlir::SymbolRefAttr dataset_factory, ::mlir::ArrayAttr output_types, ::mlir::ArrayAttr output_shapes, ::llvm::StringRef container, ::llvm::StringRef shared_name) {
  odsState.addAttribute("dataset_factory", dataset_factory);
  odsState.addAttribute("output_types", output_types);
  odsState.addAttribute("output_shapes", output_shapes);
  odsState.addAttribute("container", odsBuilder.getStringAttr(container));
  odsState.addAttribute("shared_name", odsBuilder.getStringAttr(shared_name));
  odsState.addTypes(handle);
}

void OneShotIteratorOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::SymbolRefAttr dataset_factory, ::mlir::ArrayAttr output_types, ::mlir::ArrayAttr output_shapes, ::llvm::StringRef container, ::llvm::StringRef shared_name) {
  odsState.addAttribute("dataset_factory", dataset_factory);
  odsState.addAttribute("output_types", output_types);
  odsState.addAttribute("output_shapes", output_shapes);
  odsState.addAttribute("container", odsBuilder.getStringAttr(container));
  odsState.addAttribute("shared_name", odsBuilder.getStringAttr(shared_name));
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void OneShotIteratorOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 0u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult OneShotIteratorOp::verify() {
  if (failed(OneShotIteratorOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::ResourceType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::ResourceRefType>()))))) {
        return emitOpError("result #") << index << " must be tensor of resource values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void OneShotIteratorOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
  for (::mlir::Value value : getODSResults(0))
    effects.emplace_back(MemoryEffects::Allocate::get(), value, ::mlir::TF::ResourceEffects::DatasetIterator::get());
}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::OutfeedEnqueueTupleOp definitions
//===----------------------------------------------------------------------===//

OutfeedEnqueueTupleOpAdaptor::OutfeedEnqueueTupleOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

OutfeedEnqueueTupleOpAdaptor::OutfeedEnqueueTupleOpAdaptor(OutfeedEnqueueTupleOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> OutfeedEnqueueTupleOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  bool isVariadic[] = {true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (odsOperands.size() - 0) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::mlir::ValueRange OutfeedEnqueueTupleOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::ValueRange OutfeedEnqueueTupleOpAdaptor::inputs() {
  return getODSOperands(0);
}

::mlir::LogicalResult OutfeedEnqueueTupleOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

::llvm::StringRef OutfeedEnqueueTupleOp::getOperationName() {
  return "tf.OutfeedEnqueueTuple";
}

std::pair<unsigned, unsigned> OutfeedEnqueueTupleOp::getODSOperandIndexAndLength(unsigned index) {
  bool isVariadic[] = {true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (getOperation()->getNumOperands() - 0) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::mlir::Operation::operand_range OutfeedEnqueueTupleOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Operation::operand_range OutfeedEnqueueTupleOp::inputs() {
  return getODSOperands(0);
}

::mlir::MutableOperandRange OutfeedEnqueueTupleOp::inputsMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> OutfeedEnqueueTupleOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range OutfeedEnqueueTupleOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

mlir::OperandElementTypeRange OutfeedEnqueueTupleOp::dtypes() {
  auto values = getODSOperands(0);
return {mlir::OperandElementTypeIterator(values.begin()), mlir::OperandElementTypeIterator(values.end())};
}

bool OutfeedEnqueueTupleOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "dtypes") return true;
 return false;
}

::mlir::DictionaryAttr OutfeedEnqueueTupleOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("dtypes", ctx),
ArrayAttr::get(
    [&]() {
      llvm::SmallVector<Attribute, 4> ret;
      for (auto t : dtypes())
        ret.push_back(TypeAttr::get(t));
      return ret;
    }(), ctx)}
    }, ctx);
}

void OutfeedEnqueueTupleOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange inputs) {
  odsState.addOperands(inputs);
}

void OutfeedEnqueueTupleOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 0u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult OutfeedEnqueueTupleOp::verify() {
  if (failed(OutfeedEnqueueTupleOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>())))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::TensorFlowType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of tf.dtype values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
  }
  return ::mlir::success();
}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::PackOp definitions
//===----------------------------------------------------------------------===//

PackOpAdaptor::PackOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

PackOpAdaptor::PackOpAdaptor(PackOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> PackOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  bool isVariadic[] = {true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (odsOperands.size() - 0) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::mlir::ValueRange PackOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::ValueRange PackOpAdaptor::values() {
  return getODSOperands(0);
}

::mlir::IntegerAttr PackOpAdaptor::axis() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::IntegerAttr attr = odsAttrs.get("axis").dyn_cast_or_null<::mlir::IntegerAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getIntegerAttr(::mlir::Builder(odsAttrs.getContext()).getIntegerType(64), 0);
  return attr;
}

::mlir::LogicalResult PackOpAdaptor::verify(::mlir::Location loc) {
  {
  auto tblgen_axis = odsAttrs.get("axis");
  if (tblgen_axis) {
    if (!(((tblgen_axis.isa<::mlir::IntegerAttr>())) && ((tblgen_axis.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(64))))) return emitError(loc, "'tf.Pack' op ""attribute 'axis' failed to satisfy constraint: 64-bit signless integer attribute");
  }
  }
  return ::mlir::success();
}

::llvm::StringRef PackOp::getOperationName() {
  return "tf.Pack";
}

std::pair<unsigned, unsigned> PackOp::getODSOperandIndexAndLength(unsigned index) {
  bool isVariadic[] = {true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (getOperation()->getNumOperands() - 0) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::mlir::Operation::operand_range PackOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Operation::operand_range PackOp::values() {
  return getODSOperands(0);
}

::mlir::MutableOperandRange PackOp::valuesMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> PackOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range PackOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value PackOp::output() {
  return *getODSResults(0).begin();
}

::mlir::IntegerAttr PackOp::axisAttr() {
  return this->getAttr("axis").dyn_cast_or_null<::mlir::IntegerAttr>();
}

uint64_t PackOp::axis() {
  auto attr = axisAttr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getIntegerAttr(::mlir::Builder(this->getContext()).getIntegerType(64), 0).getValue().getZExtValue();
  return attr.getValue().getZExtValue();
}

Type PackOp::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

size_t PackOp::N() {
  auto range = getODSOperands(0);
return std::distance(range.begin(), range.end());
}

bool PackOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "T") return true;
  if (name == "N") return true;
 return false;
}

::mlir::DictionaryAttr PackOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())},
    {::mlir::Identifier::get("N", ctx),
odsBuilder.getI64IntegerAttr(N())}
    }, ctx);
}

void PackOp::axisAttr(::mlir::IntegerAttr attr) {
  this->getOperation()->setAttr("axis", attr);
}

void PackOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::ValueRange values, ::mlir::IntegerAttr axis) {
  odsState.addOperands(values);
  odsState.addAttribute("axis", axis);
  odsState.addTypes(output);
}

void PackOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange values, ::mlir::IntegerAttr axis) {
  odsState.addOperands(values);
  odsState.addAttribute("axis", axis);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void PackOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::ValueRange values, uint64_t axis) {
  odsState.addOperands(values);
  odsState.addAttribute("axis", odsBuilder.getIntegerAttr(odsBuilder.getIntegerType(64), axis));
  odsState.addTypes(output);
}

void PackOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange values, uint64_t axis) {
  odsState.addOperands(values);
  odsState.addAttribute("axis", odsBuilder.getIntegerAttr(odsBuilder.getIntegerType(64), axis));
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void PackOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult PackOp::verify() {
  if (failed(PackOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>())))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::TensorFlowType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of tf.dtype values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>())))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::TensorFlowType>()))))) {
        return emitOpError("result #") << index << " must be tensor of tf.dtype values, but got " << v.getType();
      }
      ++index;
    }
  }
  return Verify(*this);
}



void PackOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::PadOp definitions
//===----------------------------------------------------------------------===//

PadOpAdaptor::PadOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

PadOpAdaptor::PadOpAdaptor(PadOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> PadOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange PadOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value PadOpAdaptor::input() {
  return *getODSOperands(0).begin();
}

::mlir::Value PadOpAdaptor::paddings() {
  return *getODSOperands(1).begin();
}

::mlir::LogicalResult PadOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

::llvm::StringRef PadOp::getOperationName() {
  return "tf.Pad";
}

std::pair<unsigned, unsigned> PadOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range PadOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value PadOp::input() {
  return *getODSOperands(0).begin();
}

::mlir::Value PadOp::paddings() {
  return *getODSOperands(1).begin();
}

::mlir::MutableOperandRange PadOp::inputMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange PadOp::paddingsMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> PadOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range PadOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value PadOp::output() {
  return *getODSResults(0).begin();
}

Type PadOp::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

Type PadOp::Tpaddings() {
  return mlir::getElementTypeOrSelf(*getODSOperands(1).begin());
}

bool PadOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "T") return true;
  if (name == "Tpaddings") return true;
 return false;
}

::mlir::DictionaryAttr PadOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())},
    {::mlir::Identifier::get("Tpaddings", ctx),
::mlir::TypeAttr::get(Tpaddings())}
    }, ctx);
}

void PadOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value input, ::mlir::Value paddings) {
  odsState.addOperands(input);
  odsState.addOperands(paddings);
  odsState.addTypes(output);
}

void PadOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input, ::mlir::Value paddings) {
  odsState.addOperands(input);
  odsState.addOperands(paddings);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void PadOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult PadOp::verify() {
  if (failed(PadOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>())))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::TensorFlowType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of tf.dtype values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of 32/64-bit signed integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>())))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::TensorFlowType>()))))) {
        return emitOpError("result #") << index << " must be tensor of tf.dtype values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void PadOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::PadV2Op definitions
//===----------------------------------------------------------------------===//

PadV2OpAdaptor::PadV2OpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

PadV2OpAdaptor::PadV2OpAdaptor(PadV2Op&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> PadV2OpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange PadV2OpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value PadV2OpAdaptor::input() {
  return *getODSOperands(0).begin();
}

::mlir::Value PadV2OpAdaptor::paddings() {
  return *getODSOperands(1).begin();
}

::mlir::Value PadV2OpAdaptor::constant_values() {
  return *getODSOperands(2).begin();
}

::mlir::LogicalResult PadV2OpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

::llvm::StringRef PadV2Op::getOperationName() {
  return "tf.PadV2";
}

std::pair<unsigned, unsigned> PadV2Op::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range PadV2Op::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value PadV2Op::input() {
  return *getODSOperands(0).begin();
}

::mlir::Value PadV2Op::paddings() {
  return *getODSOperands(1).begin();
}

::mlir::Value PadV2Op::constant_values() {
  return *getODSOperands(2).begin();
}

::mlir::MutableOperandRange PadV2Op::inputMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange PadV2Op::paddingsMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange PadV2Op::constant_valuesMutable() {
  auto range = getODSOperandIndexAndLength(2);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> PadV2Op::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range PadV2Op::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value PadV2Op::output() {
  return *getODSResults(0).begin();
}

Type PadV2Op::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

Type PadV2Op::Tpaddings() {
  return mlir::getElementTypeOrSelf(*getODSOperands(1).begin());
}

bool PadV2Op::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "T") return true;
  if (name == "Tpaddings") return true;
 return false;
}

::mlir::DictionaryAttr PadV2Op::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())},
    {::mlir::Identifier::get("Tpaddings", ctx),
::mlir::TypeAttr::get(Tpaddings())}
    }, ctx);
}

void PadV2Op::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value input, ::mlir::Value paddings, ::mlir::Value constant_values) {
  odsState.addOperands(input);
  odsState.addOperands(paddings);
  odsState.addOperands(constant_values);
  odsState.addTypes(output);
}

void PadV2Op::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input, ::mlir::Value paddings, ::mlir::Value constant_values) {
  odsState.addOperands(input);
  odsState.addOperands(paddings);
  odsState.addOperands(constant_values);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void PadV2Op::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 3u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult PadV2Op::verify() {
  if (failed(PadV2OpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>())))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::TensorFlowType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of tf.dtype values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of 32/64-bit signed integer values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup2 = getODSOperands(2);
    for (::mlir::Value v : valueGroup2) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>())))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::TensorFlowType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of tf.dtype values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>())))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::TensorFlowType>()))))) {
        return emitOpError("result #") << index << " must be tensor of tf.dtype values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void PadV2Op::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::ParallelMapDatasetOp definitions
//===----------------------------------------------------------------------===//

ParallelMapDatasetOpAdaptor::ParallelMapDatasetOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

ParallelMapDatasetOpAdaptor::ParallelMapDatasetOpAdaptor(ParallelMapDatasetOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> ParallelMapDatasetOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  bool isVariadic[] = {false, true, false};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (odsOperands.size() - 2) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::mlir::ValueRange ParallelMapDatasetOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value ParallelMapDatasetOpAdaptor::input_dataset() {
  return *getODSOperands(0).begin();
}

::mlir::ValueRange ParallelMapDatasetOpAdaptor::other_arguments() {
  return getODSOperands(1);
}

::mlir::Value ParallelMapDatasetOpAdaptor::num_parallel_calls() {
  return *getODSOperands(2).begin();
}

::mlir::SymbolRefAttr ParallelMapDatasetOpAdaptor::f() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::SymbolRefAttr attr = odsAttrs.get("f").cast<::mlir::SymbolRefAttr>();
  return attr;
}

::mlir::ArrayAttr ParallelMapDatasetOpAdaptor::output_types() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::ArrayAttr attr = odsAttrs.get("output_types").cast<::mlir::ArrayAttr>();
  return attr;
}

::mlir::ArrayAttr ParallelMapDatasetOpAdaptor::output_shapes() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::ArrayAttr attr = odsAttrs.get("output_shapes").cast<::mlir::ArrayAttr>();
  return attr;
}

::mlir::BoolAttr ParallelMapDatasetOpAdaptor::use_inter_op_parallelism() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::BoolAttr attr = odsAttrs.get("use_inter_op_parallelism").dyn_cast_or_null<::mlir::BoolAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getBoolAttr(true);
  return attr;
}

::mlir::BoolAttr ParallelMapDatasetOpAdaptor::sloppy() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::BoolAttr attr = odsAttrs.get("sloppy").dyn_cast_or_null<::mlir::BoolAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getBoolAttr(false);
  return attr;
}

::mlir::BoolAttr ParallelMapDatasetOpAdaptor::preserve_cardinality() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::BoolAttr attr = odsAttrs.get("preserve_cardinality").dyn_cast_or_null<::mlir::BoolAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getBoolAttr(false);
  return attr;
}

::mlir::LogicalResult ParallelMapDatasetOpAdaptor::verify(::mlir::Location loc) {
  {
  auto tblgen_f = odsAttrs.get("f");
  if (!tblgen_f) return emitError(loc, "'tf.ParallelMapDataset' op ""requires attribute 'f'");
    if (!((tblgen_f.isa<::mlir::SymbolRefAttr>()))) return emitError(loc, "'tf.ParallelMapDataset' op ""attribute 'f' failed to satisfy constraint: symbol reference attribute");
  }
  {
  auto tblgen_output_types = odsAttrs.get("output_types");
  if (!tblgen_output_types) return emitError(loc, "'tf.ParallelMapDataset' op ""requires attribute 'output_types'");
    if (!((((tblgen_output_types.isa<::mlir::ArrayAttr>())) && (::llvm::all_of(tblgen_output_types.cast<::mlir::ArrayAttr>(), [](::mlir::Attribute attr) { return ((attr.isa<::mlir::TypeAttr>())) && ((attr.cast<::mlir::TypeAttr>().getValue().isa<::mlir::Type>())); }))) && ((tblgen_output_types.cast<::mlir::ArrayAttr>().size() >= 1)))) return emitError(loc, "'tf.ParallelMapDataset' op ""attribute 'output_types' failed to satisfy constraint: type array attribute with at least 1 elements");
  }
  {
  auto tblgen_output_shapes = odsAttrs.get("output_shapes");
  if (!tblgen_output_shapes) return emitError(loc, "'tf.ParallelMapDataset' op ""requires attribute 'output_shapes'");
    if (!((((tblgen_output_shapes.isa<::mlir::ArrayAttr>())) && (::llvm::all_of(tblgen_output_shapes.cast<::mlir::ArrayAttr>(), [](::mlir::Attribute attr) { return (attr.isa<mlir::TF::ShapeAttr>()); }))) && ((tblgen_output_shapes.cast<::mlir::ArrayAttr>().size() >= 1)))) return emitError(loc, "'tf.ParallelMapDataset' op ""attribute 'output_shapes' failed to satisfy constraint: tensorflow shape attribute array with at least 1 elements");
  }
  {
  auto tblgen_use_inter_op_parallelism = odsAttrs.get("use_inter_op_parallelism");
  if (tblgen_use_inter_op_parallelism) {
    if (!((tblgen_use_inter_op_parallelism.isa<::mlir::BoolAttr>()))) return emitError(loc, "'tf.ParallelMapDataset' op ""attribute 'use_inter_op_parallelism' failed to satisfy constraint: bool attribute");
  }
  }
  {
  auto tblgen_sloppy = odsAttrs.get("sloppy");
  if (tblgen_sloppy) {
    if (!((tblgen_sloppy.isa<::mlir::BoolAttr>()))) return emitError(loc, "'tf.ParallelMapDataset' op ""attribute 'sloppy' failed to satisfy constraint: bool attribute");
  }
  }
  {
  auto tblgen_preserve_cardinality = odsAttrs.get("preserve_cardinality");
  if (tblgen_preserve_cardinality) {
    if (!((tblgen_preserve_cardinality.isa<::mlir::BoolAttr>()))) return emitError(loc, "'tf.ParallelMapDataset' op ""attribute 'preserve_cardinality' failed to satisfy constraint: bool attribute");
  }
  }
  return ::mlir::success();
}

::llvm::StringRef ParallelMapDatasetOp::getOperationName() {
  return "tf.ParallelMapDataset";
}

std::pair<unsigned, unsigned> ParallelMapDatasetOp::getODSOperandIndexAndLength(unsigned index) {
  bool isVariadic[] = {false, true, false};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (getOperation()->getNumOperands() - 2) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::mlir::Operation::operand_range ParallelMapDatasetOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value ParallelMapDatasetOp::input_dataset() {
  return *getODSOperands(0).begin();
}

::mlir::Operation::operand_range ParallelMapDatasetOp::other_arguments() {
  return getODSOperands(1);
}

::mlir::Value ParallelMapDatasetOp::num_parallel_calls() {
  return *getODSOperands(2).begin();
}

::mlir::MutableOperandRange ParallelMapDatasetOp::input_datasetMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange ParallelMapDatasetOp::other_argumentsMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange ParallelMapDatasetOp::num_parallel_callsMutable() {
  auto range = getODSOperandIndexAndLength(2);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> ParallelMapDatasetOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range ParallelMapDatasetOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value ParallelMapDatasetOp::handle() {
  return *getODSResults(0).begin();
}

::mlir::SymbolRefAttr ParallelMapDatasetOp::fAttr() {
  return this->getAttr("f").cast<::mlir::SymbolRefAttr>();
}

::mlir::SymbolRefAttr ParallelMapDatasetOp::f() {
  auto attr = fAttr();
  return attr;
}

::mlir::ArrayAttr ParallelMapDatasetOp::output_typesAttr() {
  return this->getAttr("output_types").cast<::mlir::ArrayAttr>();
}

::mlir::ArrayAttr ParallelMapDatasetOp::output_types() {
  auto attr = output_typesAttr();
  return attr;
}

::mlir::ArrayAttr ParallelMapDatasetOp::output_shapesAttr() {
  return this->getAttr("output_shapes").cast<::mlir::ArrayAttr>();
}

::mlir::ArrayAttr ParallelMapDatasetOp::output_shapes() {
  auto attr = output_shapesAttr();
  return attr;
}

::mlir::BoolAttr ParallelMapDatasetOp::use_inter_op_parallelismAttr() {
  return this->getAttr("use_inter_op_parallelism").dyn_cast_or_null<::mlir::BoolAttr>();
}

bool ParallelMapDatasetOp::use_inter_op_parallelism() {
  auto attr = use_inter_op_parallelismAttr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getBoolAttr(true).getValue();
  return attr.getValue();
}

::mlir::BoolAttr ParallelMapDatasetOp::sloppyAttr() {
  return this->getAttr("sloppy").dyn_cast_or_null<::mlir::BoolAttr>();
}

bool ParallelMapDatasetOp::sloppy() {
  auto attr = sloppyAttr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getBoolAttr(false).getValue();
  return attr.getValue();
}

::mlir::BoolAttr ParallelMapDatasetOp::preserve_cardinalityAttr() {
  return this->getAttr("preserve_cardinality").dyn_cast_or_null<::mlir::BoolAttr>();
}

bool ParallelMapDatasetOp::preserve_cardinality() {
  auto attr = preserve_cardinalityAttr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getBoolAttr(false).getValue();
  return attr.getValue();
}

mlir::OperandElementTypeRange ParallelMapDatasetOp::Targuments() {
  auto values = getODSOperands(1);
return {mlir::OperandElementTypeIterator(values.begin()), mlir::OperandElementTypeIterator(values.end())};
}

bool ParallelMapDatasetOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "Targuments") return true;
 return false;
}

::mlir::DictionaryAttr ParallelMapDatasetOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("Targuments", ctx),
ArrayAttr::get(
    [&]() {
      llvm::SmallVector<Attribute, 4> ret;
      for (auto t : Targuments())
        ret.push_back(TypeAttr::get(t));
      return ret;
    }(), ctx)}
    }, ctx);
}

void ParallelMapDatasetOp::fAttr(::mlir::SymbolRefAttr attr) {
  this->getOperation()->setAttr("f", attr);
}

void ParallelMapDatasetOp::output_typesAttr(::mlir::ArrayAttr attr) {
  this->getOperation()->setAttr("output_types", attr);
}

void ParallelMapDatasetOp::output_shapesAttr(::mlir::ArrayAttr attr) {
  this->getOperation()->setAttr("output_shapes", attr);
}

void ParallelMapDatasetOp::use_inter_op_parallelismAttr(::mlir::BoolAttr attr) {
  this->getOperation()->setAttr("use_inter_op_parallelism", attr);
}

void ParallelMapDatasetOp::sloppyAttr(::mlir::BoolAttr attr) {
  this->getOperation()->setAttr("sloppy", attr);
}

void ParallelMapDatasetOp::preserve_cardinalityAttr(::mlir::BoolAttr attr) {
  this->getOperation()->setAttr("preserve_cardinality", attr);
}

void ParallelMapDatasetOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type handle, ::mlir::Value input_dataset, ::mlir::ValueRange other_arguments, ::mlir::Value num_parallel_calls, ::mlir::SymbolRefAttr f, ::mlir::ArrayAttr output_types, ::mlir::ArrayAttr output_shapes, ::mlir::BoolAttr use_inter_op_parallelism, ::mlir::BoolAttr sloppy, ::mlir::BoolAttr preserve_cardinality) {
  odsState.addOperands(input_dataset);
  odsState.addOperands(other_arguments);
  odsState.addOperands(num_parallel_calls);
  odsState.addAttribute("f", f);
  odsState.addAttribute("output_types", output_types);
  odsState.addAttribute("output_shapes", output_shapes);
  odsState.addAttribute("use_inter_op_parallelism", use_inter_op_parallelism);
  odsState.addAttribute("sloppy", sloppy);
  odsState.addAttribute("preserve_cardinality", preserve_cardinality);
  odsState.addTypes(handle);
}

void ParallelMapDatasetOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input_dataset, ::mlir::ValueRange other_arguments, ::mlir::Value num_parallel_calls, ::mlir::SymbolRefAttr f, ::mlir::ArrayAttr output_types, ::mlir::ArrayAttr output_shapes, ::mlir::BoolAttr use_inter_op_parallelism, ::mlir::BoolAttr sloppy, ::mlir::BoolAttr preserve_cardinality) {
  odsState.addOperands(input_dataset);
  odsState.addOperands(other_arguments);
  odsState.addOperands(num_parallel_calls);
  odsState.addAttribute("f", f);
  odsState.addAttribute("output_types", output_types);
  odsState.addAttribute("output_shapes", output_shapes);
  odsState.addAttribute("use_inter_op_parallelism", use_inter_op_parallelism);
  odsState.addAttribute("sloppy", sloppy);
  odsState.addAttribute("preserve_cardinality", preserve_cardinality);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void ParallelMapDatasetOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type handle, ::mlir::Value input_dataset, ::mlir::ValueRange other_arguments, ::mlir::Value num_parallel_calls, ::mlir::SymbolRefAttr f, ::mlir::ArrayAttr output_types, ::mlir::ArrayAttr output_shapes, bool use_inter_op_parallelism, bool sloppy, bool preserve_cardinality) {
  odsState.addOperands(input_dataset);
  odsState.addOperands(other_arguments);
  odsState.addOperands(num_parallel_calls);
  odsState.addAttribute("f", f);
  odsState.addAttribute("output_types", output_types);
  odsState.addAttribute("output_shapes", output_shapes);
  odsState.addAttribute("use_inter_op_parallelism", odsBuilder.getBoolAttr(use_inter_op_parallelism));
  odsState.addAttribute("sloppy", odsBuilder.getBoolAttr(sloppy));
  odsState.addAttribute("preserve_cardinality", odsBuilder.getBoolAttr(preserve_cardinality));
  odsState.addTypes(handle);
}

void ParallelMapDatasetOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input_dataset, ::mlir::ValueRange other_arguments, ::mlir::Value num_parallel_calls, ::mlir::SymbolRefAttr f, ::mlir::ArrayAttr output_types, ::mlir::ArrayAttr output_shapes, bool use_inter_op_parallelism, bool sloppy, bool preserve_cardinality) {
  odsState.addOperands(input_dataset);
  odsState.addOperands(other_arguments);
  odsState.addOperands(num_parallel_calls);
  odsState.addAttribute("f", f);
  odsState.addAttribute("output_types", output_types);
  odsState.addAttribute("output_shapes", output_shapes);
  odsState.addAttribute("use_inter_op_parallelism", odsBuilder.getBoolAttr(use_inter_op_parallelism));
  odsState.addAttribute("sloppy", odsBuilder.getBoolAttr(sloppy));
  odsState.addAttribute("preserve_cardinality", odsBuilder.getBoolAttr(preserve_cardinality));
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void ParallelMapDatasetOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() >= 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult ParallelMapDatasetOp::verify() {
  if (failed(ParallelMapDatasetOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::VariantType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::VariantRefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of variant values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>())))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::TensorFlowType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of tf.dtype values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup2 = getODSOperands(2);
    for (::mlir::Value v : valueGroup2) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of 32-bit integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::VariantType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::VariantRefType>()))))) {
        return emitOpError("result #") << index << " must be tensor of variant values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void ParallelMapDatasetOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::ParameterizedTruncatedNormalOp definitions
//===----------------------------------------------------------------------===//

ParameterizedTruncatedNormalOpAdaptor::ParameterizedTruncatedNormalOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

ParameterizedTruncatedNormalOpAdaptor::ParameterizedTruncatedNormalOpAdaptor(ParameterizedTruncatedNormalOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> ParameterizedTruncatedNormalOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange ParameterizedTruncatedNormalOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value ParameterizedTruncatedNormalOpAdaptor::shape() {
  return *getODSOperands(0).begin();
}

::mlir::Value ParameterizedTruncatedNormalOpAdaptor::means() {
  return *getODSOperands(1).begin();
}

::mlir::Value ParameterizedTruncatedNormalOpAdaptor::stdevs() {
  return *getODSOperands(2).begin();
}

::mlir::Value ParameterizedTruncatedNormalOpAdaptor::minvals() {
  return *getODSOperands(3).begin();
}

::mlir::Value ParameterizedTruncatedNormalOpAdaptor::maxvals() {
  return *getODSOperands(4).begin();
}

::mlir::IntegerAttr ParameterizedTruncatedNormalOpAdaptor::seed() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::IntegerAttr attr = odsAttrs.get("seed").dyn_cast_or_null<::mlir::IntegerAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getIntegerAttr(::mlir::Builder(odsAttrs.getContext()).getIntegerType(64), 0);
  return attr;
}

::mlir::IntegerAttr ParameterizedTruncatedNormalOpAdaptor::seed2() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::IntegerAttr attr = odsAttrs.get("seed2").dyn_cast_or_null<::mlir::IntegerAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getIntegerAttr(::mlir::Builder(odsAttrs.getContext()).getIntegerType(64), 0);
  return attr;
}

::mlir::LogicalResult ParameterizedTruncatedNormalOpAdaptor::verify(::mlir::Location loc) {
  {
  auto tblgen_seed = odsAttrs.get("seed");
  if (tblgen_seed) {
    if (!(((tblgen_seed.isa<::mlir::IntegerAttr>())) && ((tblgen_seed.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(64))))) return emitError(loc, "'tf.ParameterizedTruncatedNormal' op ""attribute 'seed' failed to satisfy constraint: 64-bit signless integer attribute");
  }
  }
  {
  auto tblgen_seed2 = odsAttrs.get("seed2");
  if (tblgen_seed2) {
    if (!(((tblgen_seed2.isa<::mlir::IntegerAttr>())) && ((tblgen_seed2.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(64))))) return emitError(loc, "'tf.ParameterizedTruncatedNormal' op ""attribute 'seed2' failed to satisfy constraint: 64-bit signless integer attribute");
  }
  }
  return ::mlir::success();
}

::llvm::StringRef ParameterizedTruncatedNormalOp::getOperationName() {
  return "tf.ParameterizedTruncatedNormal";
}

std::pair<unsigned, unsigned> ParameterizedTruncatedNormalOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range ParameterizedTruncatedNormalOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value ParameterizedTruncatedNormalOp::shape() {
  return *getODSOperands(0).begin();
}

::mlir::Value ParameterizedTruncatedNormalOp::means() {
  return *getODSOperands(1).begin();
}

::mlir::Value ParameterizedTruncatedNormalOp::stdevs() {
  return *getODSOperands(2).begin();
}

::mlir::Value ParameterizedTruncatedNormalOp::minvals() {
  return *getODSOperands(3).begin();
}

::mlir::Value ParameterizedTruncatedNormalOp::maxvals() {
  return *getODSOperands(4).begin();
}

::mlir::MutableOperandRange ParameterizedTruncatedNormalOp::shapeMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange ParameterizedTruncatedNormalOp::meansMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange ParameterizedTruncatedNormalOp::stdevsMutable() {
  auto range = getODSOperandIndexAndLength(2);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange ParameterizedTruncatedNormalOp::minvalsMutable() {
  auto range = getODSOperandIndexAndLength(3);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange ParameterizedTruncatedNormalOp::maxvalsMutable() {
  auto range = getODSOperandIndexAndLength(4);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> ParameterizedTruncatedNormalOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range ParameterizedTruncatedNormalOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value ParameterizedTruncatedNormalOp::output() {
  return *getODSResults(0).begin();
}

::mlir::IntegerAttr ParameterizedTruncatedNormalOp::seedAttr() {
  return this->getAttr("seed").dyn_cast_or_null<::mlir::IntegerAttr>();
}

uint64_t ParameterizedTruncatedNormalOp::seed() {
  auto attr = seedAttr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getIntegerAttr(::mlir::Builder(this->getContext()).getIntegerType(64), 0).getValue().getZExtValue();
  return attr.getValue().getZExtValue();
}

::mlir::IntegerAttr ParameterizedTruncatedNormalOp::seed2Attr() {
  return this->getAttr("seed2").dyn_cast_or_null<::mlir::IntegerAttr>();
}

uint64_t ParameterizedTruncatedNormalOp::seed2() {
  auto attr = seed2Attr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getIntegerAttr(::mlir::Builder(this->getContext()).getIntegerType(64), 0).getValue().getZExtValue();
  return attr.getValue().getZExtValue();
}

Type ParameterizedTruncatedNormalOp::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

Type ParameterizedTruncatedNormalOp::dtype() {
  return mlir::getElementTypeOrSelf(*getODSOperands(1).begin());
}

bool ParameterizedTruncatedNormalOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "T") return true;
  if (name == "dtype") return true;
 return false;
}

::mlir::DictionaryAttr ParameterizedTruncatedNormalOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())},
    {::mlir::Identifier::get("dtype", ctx),
::mlir::TypeAttr::get(dtype())}
    }, ctx);
}

void ParameterizedTruncatedNormalOp::seedAttr(::mlir::IntegerAttr attr) {
  this->getOperation()->setAttr("seed", attr);
}

void ParameterizedTruncatedNormalOp::seed2Attr(::mlir::IntegerAttr attr) {
  this->getOperation()->setAttr("seed2", attr);
}

void ParameterizedTruncatedNormalOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value shape, ::mlir::Value means, ::mlir::Value stdevs, ::mlir::Value minvals, ::mlir::Value maxvals, ::mlir::IntegerAttr seed, ::mlir::IntegerAttr seed2) {
  odsState.addOperands(shape);
  odsState.addOperands(means);
  odsState.addOperands(stdevs);
  odsState.addOperands(minvals);
  odsState.addOperands(maxvals);
  odsState.addAttribute("seed", seed);
  odsState.addAttribute("seed2", seed2);
  odsState.addTypes(output);
}

void ParameterizedTruncatedNormalOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value shape, ::mlir::Value means, ::mlir::Value stdevs, ::mlir::Value minvals, ::mlir::Value maxvals, ::mlir::IntegerAttr seed, ::mlir::IntegerAttr seed2) {
  odsState.addOperands(shape);
  odsState.addOperands(means);
  odsState.addOperands(stdevs);
  odsState.addOperands(minvals);
  odsState.addOperands(maxvals);
  odsState.addAttribute("seed", seed);
  odsState.addAttribute("seed2", seed2);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void ParameterizedTruncatedNormalOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value shape, ::mlir::Value means, ::mlir::Value stdevs, ::mlir::Value minvals, ::mlir::Value maxvals, uint64_t seed, uint64_t seed2) {
  odsState.addOperands(shape);
  odsState.addOperands(means);
  odsState.addOperands(stdevs);
  odsState.addOperands(minvals);
  odsState.addOperands(maxvals);
  odsState.addAttribute("seed", odsBuilder.getIntegerAttr(odsBuilder.getIntegerType(64), seed));
  odsState.addAttribute("seed2", odsBuilder.getIntegerAttr(odsBuilder.getIntegerType(64), seed2));
  odsState.addTypes(output);
}

void ParameterizedTruncatedNormalOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value shape, ::mlir::Value means, ::mlir::Value stdevs, ::mlir::Value minvals, ::mlir::Value maxvals, uint64_t seed, uint64_t seed2) {
  odsState.addOperands(shape);
  odsState.addOperands(means);
  odsState.addOperands(stdevs);
  odsState.addOperands(minvals);
  odsState.addOperands(maxvals);
  odsState.addAttribute("seed", odsBuilder.getIntegerAttr(odsBuilder.getIntegerType(64), seed));
  odsState.addAttribute("seed2", odsBuilder.getIntegerAttr(odsBuilder.getIntegerType(64), seed2));
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void ParameterizedTruncatedNormalOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 5u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult ParameterizedTruncatedNormalOp::verify() {
  if (failed(ParameterizedTruncatedNormalOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of 32/64-bit signed integer values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of floating-point values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup2 = getODSOperands(2);
    for (::mlir::Value v : valueGroup2) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of floating-point values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup3 = getODSOperands(3);
    for (::mlir::Value v : valueGroup3) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of floating-point values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup4 = getODSOperands(4);
    for (::mlir::Value v : valueGroup4) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of floating-point values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))))) {
        return emitOpError("result #") << index << " must be tensor of floating-point values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::ParseExampleOp definitions
//===----------------------------------------------------------------------===//

ParseExampleOpAdaptor::ParseExampleOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

ParseExampleOpAdaptor::ParseExampleOpAdaptor(ParseExampleOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> ParseExampleOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  assert(odsAttrs && "missing segment size attribute for op");
  auto sizeAttr = odsAttrs.get("operand_segment_sizes").cast<::mlir::DenseIntElementsAttr>();

  unsigned start = 0;
  for (unsigned i = 0; i < index; ++i)
    start += (*(sizeAttr.begin() + i)).getZExtValue();
  unsigned size = (*(sizeAttr.begin() + index)).getZExtValue();
  return {start, size};
}

::mlir::ValueRange ParseExampleOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value ParseExampleOpAdaptor::serialized() {
  return *getODSOperands(0).begin();
}

::mlir::Value ParseExampleOpAdaptor::names() {
  return *getODSOperands(1).begin();
}

::mlir::ValueRange ParseExampleOpAdaptor::sparse_keys() {
  return getODSOperands(2);
}

::mlir::ValueRange ParseExampleOpAdaptor::dense_keys() {
  return getODSOperands(3);
}

::mlir::ValueRange ParseExampleOpAdaptor::dense_defaults() {
  return getODSOperands(4);
}

::mlir::ArrayAttr ParseExampleOpAdaptor::dense_shapes() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::ArrayAttr attr = odsAttrs.get("dense_shapes").cast<::mlir::ArrayAttr>();
  return attr;
}

::mlir::DenseIntElementsAttr ParseExampleOpAdaptor::result_segment_sizes() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::DenseIntElementsAttr attr = odsAttrs.get("result_segment_sizes").cast<::mlir::DenseIntElementsAttr>();
  return attr;
}

::mlir::DenseIntElementsAttr ParseExampleOpAdaptor::operand_segment_sizes() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::DenseIntElementsAttr attr = odsAttrs.get("operand_segment_sizes").cast<::mlir::DenseIntElementsAttr>();
  return attr;
}

::mlir::LogicalResult ParseExampleOpAdaptor::verify(::mlir::Location loc) {
  {
    auto sizeAttr = odsAttrs.get("result_segment_sizes").cast<::mlir::DenseIntElementsAttr>();
    auto numElements = sizeAttr.getType().cast<::mlir::ShapedType>().getNumElements();
    if (numElements != 4)
      return emitError(loc, "'result_segment_sizes' attribute for specifying result segments "
                       "must have 4 elements");
  }
  
  {
    auto sizeAttr = odsAttrs.get("operand_segment_sizes").cast<::mlir::DenseIntElementsAttr>();
    auto numElements = sizeAttr.getType().cast<::mlir::ShapedType>().getNumElements();
    if (numElements != 5)
      return emitError(loc, "'operand_segment_sizes' attribute for specifying operand segments "
                       "must have 5 elements");
  }
    {
  auto tblgen_dense_shapes = odsAttrs.get("dense_shapes");
  if (!tblgen_dense_shapes) return emitError(loc, "'tf.ParseExample' op ""requires attribute 'dense_shapes'");
    if (!(((tblgen_dense_shapes.isa<::mlir::ArrayAttr>())) && (::llvm::all_of(tblgen_dense_shapes.cast<::mlir::ArrayAttr>(), [](::mlir::Attribute attr) { return (attr.isa<mlir::TF::ShapeAttr>()); })))) return emitError(loc, "'tf.ParseExample' op ""attribute 'dense_shapes' failed to satisfy constraint: tensorflow shape attribute array");
  }
  {
  auto tblgen_result_segment_sizes = odsAttrs.get("result_segment_sizes");
  if (!tblgen_result_segment_sizes) return emitError(loc, "'tf.ParseExample' op ""requires attribute 'result_segment_sizes'");
    if (!(((tblgen_result_segment_sizes.isa<::mlir::DenseIntElementsAttr>())) && ((tblgen_result_segment_sizes.cast<::mlir::DenseIntElementsAttr>().getType().getElementType().isSignlessInteger(32))))) return emitError(loc, "'tf.ParseExample' op ""attribute 'result_segment_sizes' failed to satisfy constraint: 32-bit signless integer elements attribute");
  }
  {
  auto tblgen_operand_segment_sizes = odsAttrs.get("operand_segment_sizes");
  if (!tblgen_operand_segment_sizes) return emitError(loc, "'tf.ParseExample' op ""requires attribute 'operand_segment_sizes'");
    if (!(((tblgen_operand_segment_sizes.isa<::mlir::DenseIntElementsAttr>())) && ((tblgen_operand_segment_sizes.cast<::mlir::DenseIntElementsAttr>().getType().getElementType().isSignlessInteger(32))))) return emitError(loc, "'tf.ParseExample' op ""attribute 'operand_segment_sizes' failed to satisfy constraint: 32-bit signless integer elements attribute");
  }
  return ::mlir::success();
}

void ParseExampleOp::getAsmResultNames(::mlir::OpAsmSetValueNameFn setNameFn) {
  auto resultGroup0 = getODSResults(0);
  if (!llvm::empty(resultGroup0))
    setNameFn(*resultGroup0.begin(), "sparse_indices");
  auto resultGroup1 = getODSResults(1);
  if (!llvm::empty(resultGroup1))
    setNameFn(*resultGroup1.begin(), "sparse_values");
  auto resultGroup2 = getODSResults(2);
  if (!llvm::empty(resultGroup2))
    setNameFn(*resultGroup2.begin(), "sparse_shapes");
  auto resultGroup3 = getODSResults(3);
  if (!llvm::empty(resultGroup3))
    setNameFn(*resultGroup3.begin(), "dense_values");
}

::llvm::StringRef ParseExampleOp::getOperationName() {
  return "tf.ParseExample";
}

std::pair<unsigned, unsigned> ParseExampleOp::getODSOperandIndexAndLength(unsigned index) {
  auto sizeAttr = getAttrOfType<::mlir::DenseIntElementsAttr>("operand_segment_sizes");

  unsigned start = 0;
  for (unsigned i = 0; i < index; ++i)
    start += (*(sizeAttr.begin() + i)).getZExtValue();
  unsigned size = (*(sizeAttr.begin() + index)).getZExtValue();
  return {start, size};
}

::mlir::Operation::operand_range ParseExampleOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value ParseExampleOp::serialized() {
  return *getODSOperands(0).begin();
}

::mlir::Value ParseExampleOp::names() {
  return *getODSOperands(1).begin();
}

::mlir::Operation::operand_range ParseExampleOp::sparse_keys() {
  return getODSOperands(2);
}

::mlir::Operation::operand_range ParseExampleOp::dense_keys() {
  return getODSOperands(3);
}

::mlir::Operation::operand_range ParseExampleOp::dense_defaults() {
  return getODSOperands(4);
}

::mlir::MutableOperandRange ParseExampleOp::serializedMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second, ::mlir::MutableOperandRange::OperandSegment(0u, *getOperation()->getMutableAttrDict().getNamed("operand_segment_sizes")));
}

::mlir::MutableOperandRange ParseExampleOp::namesMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second, ::mlir::MutableOperandRange::OperandSegment(1u, *getOperation()->getMutableAttrDict().getNamed("operand_segment_sizes")));
}

::mlir::MutableOperandRange ParseExampleOp::sparse_keysMutable() {
  auto range = getODSOperandIndexAndLength(2);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second, ::mlir::MutableOperandRange::OperandSegment(2u, *getOperation()->getMutableAttrDict().getNamed("operand_segment_sizes")));
}

::mlir::MutableOperandRange ParseExampleOp::dense_keysMutable() {
  auto range = getODSOperandIndexAndLength(3);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second, ::mlir::MutableOperandRange::OperandSegment(3u, *getOperation()->getMutableAttrDict().getNamed("operand_segment_sizes")));
}

::mlir::MutableOperandRange ParseExampleOp::dense_defaultsMutable() {
  auto range = getODSOperandIndexAndLength(4);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second, ::mlir::MutableOperandRange::OperandSegment(4u, *getOperation()->getMutableAttrDict().getNamed("operand_segment_sizes")));
}

std::pair<unsigned, unsigned> ParseExampleOp::getODSResultIndexAndLength(unsigned index) {
  auto sizeAttr = getAttrOfType<::mlir::DenseIntElementsAttr>("result_segment_sizes");

  unsigned start = 0;
  for (unsigned i = 0; i < index; ++i)
    start += (*(sizeAttr.begin() + i)).getZExtValue();
  unsigned size = (*(sizeAttr.begin() + index)).getZExtValue();
  return {start, size};
}

::mlir::Operation::result_range ParseExampleOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Operation::result_range ParseExampleOp::sparse_indices() {
  return getODSResults(0);
}

::mlir::Operation::result_range ParseExampleOp::sparse_values() {
  return getODSResults(1);
}

::mlir::Operation::result_range ParseExampleOp::sparse_shapes() {
  return getODSResults(2);
}

::mlir::Operation::result_range ParseExampleOp::dense_values() {
  return getODSResults(3);
}

::mlir::ArrayAttr ParseExampleOp::dense_shapesAttr() {
  return this->getAttr("dense_shapes").cast<::mlir::ArrayAttr>();
}

::mlir::ArrayAttr ParseExampleOp::dense_shapes() {
  auto attr = dense_shapesAttr();
  return attr;
}

::mlir::DenseIntElementsAttr ParseExampleOp::result_segment_sizesAttr() {
  return this->getAttr("result_segment_sizes").cast<::mlir::DenseIntElementsAttr>();
}

::mlir::DenseIntElementsAttr ParseExampleOp::result_segment_sizes() {
  auto attr = result_segment_sizesAttr();
  return attr;
}

::mlir::DenseIntElementsAttr ParseExampleOp::operand_segment_sizesAttr() {
  return this->getAttr("operand_segment_sizes").cast<::mlir::DenseIntElementsAttr>();
}

::mlir::DenseIntElementsAttr ParseExampleOp::operand_segment_sizes() {
  auto attr = operand_segment_sizesAttr();
  return attr;
}

size_t ParseExampleOp::Nsparse() {
  auto range = getODSOperands(2);
return std::distance(range.begin(), range.end());
}

size_t ParseExampleOp::Ndense() {
  auto range = getODSOperands(3);
return std::distance(range.begin(), range.end());
}

mlir::OperandElementTypeRange ParseExampleOp::Tdense() {
  auto values = getODSOperands(4);
return {mlir::OperandElementTypeIterator(values.begin()), mlir::OperandElementTypeIterator(values.end())};
}

mlir::ResultElementTypeRange ParseExampleOp::sparse_types() {
  auto values = getODSResults(1);
return {mlir::ResultElementTypeIterator(values.begin()), mlir::ResultElementTypeIterator(values.end())};
}

bool ParseExampleOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "Nsparse") return true;
  if (name == "Ndense") return true;
  if (name == "Tdense") return true;
  if (name == "sparse_types") return true;
 return false;
}

::mlir::DictionaryAttr ParseExampleOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("Nsparse", ctx),
odsBuilder.getI64IntegerAttr(Nsparse())},
    {::mlir::Identifier::get("Ndense", ctx),
odsBuilder.getI64IntegerAttr(Ndense())},
    {::mlir::Identifier::get("Tdense", ctx),
ArrayAttr::get(
    [&]() {
      llvm::SmallVector<Attribute, 4> ret;
      for (auto t : Tdense())
        ret.push_back(TypeAttr::get(t));
      return ret;
    }(), ctx)},
    {::mlir::Identifier::get("sparse_types", ctx),
ArrayAttr::get(
    [&]() {
      llvm::SmallVector<Attribute, 4> ret;
      for (auto t : sparse_types())
        ret.push_back(TypeAttr::get(t));
      return ret;
    }(), ctx)}
    }, ctx);
}

void ParseExampleOp::dense_shapesAttr(::mlir::ArrayAttr attr) {
  this->getOperation()->setAttr("dense_shapes", attr);
}

void ParseExampleOp::result_segment_sizesAttr(::mlir::DenseIntElementsAttr attr) {
  this->getOperation()->setAttr("result_segment_sizes", attr);
}

void ParseExampleOp::operand_segment_sizesAttr(::mlir::DenseIntElementsAttr attr) {
  this->getOperation()->setAttr("operand_segment_sizes", attr);
}

void ParseExampleOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange sparse_indices, ::mlir::TypeRange sparse_values, ::mlir::TypeRange sparse_shapes, ::mlir::TypeRange dense_values, ::mlir::Value serialized, ::mlir::Value names, ::mlir::ValueRange sparse_keys, ::mlir::ValueRange dense_keys, ::mlir::ValueRange dense_defaults, ::mlir::ArrayAttr dense_shapes, ::mlir::DenseIntElementsAttr result_segment_sizes, ::mlir::DenseIntElementsAttr operand_segment_sizes) {
  odsState.addOperands(serialized);
  odsState.addOperands(names);
  odsState.addOperands(sparse_keys);
  odsState.addOperands(dense_keys);
  odsState.addOperands(dense_defaults);
  odsState.addAttribute("operand_segment_sizes", odsBuilder.getI32VectorAttr({1, 1, static_cast<int32_t>(sparse_keys.size()), static_cast<int32_t>(dense_keys.size()), static_cast<int32_t>(dense_defaults.size())}));
  odsState.addAttribute("dense_shapes", dense_shapes);
  odsState.addAttribute("result_segment_sizes", result_segment_sizes);
  odsState.addAttribute("operand_segment_sizes", operand_segment_sizes);
  odsState.addTypes(sparse_indices);
  odsState.addTypes(sparse_values);
  odsState.addTypes(sparse_shapes);
  odsState.addTypes(dense_values);
}

void ParseExampleOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value serialized, ::mlir::Value names, ::mlir::ValueRange sparse_keys, ::mlir::ValueRange dense_keys, ::mlir::ValueRange dense_defaults, ::mlir::ArrayAttr dense_shapes, ::mlir::DenseIntElementsAttr result_segment_sizes, ::mlir::DenseIntElementsAttr operand_segment_sizes) {
  odsState.addOperands(serialized);
  odsState.addOperands(names);
  odsState.addOperands(sparse_keys);
  odsState.addOperands(dense_keys);
  odsState.addOperands(dense_defaults);
  odsState.addAttribute("operand_segment_sizes", odsBuilder.getI32VectorAttr({1, 1, static_cast<int32_t>(sparse_keys.size()), static_cast<int32_t>(dense_keys.size()), static_cast<int32_t>(dense_defaults.size())}));
  odsState.addAttribute("dense_shapes", dense_shapes);
  odsState.addAttribute("result_segment_sizes", result_segment_sizes);
  odsState.addAttribute("operand_segment_sizes", operand_segment_sizes);
  odsState.addTypes(resultTypes);
}

void ParseExampleOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() >= 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult ParseExampleOp::verify() {
  if (failed(ParseExampleOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::StringType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::StringRefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of string values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::StringType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::StringRefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of string values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup2 = getODSOperands(2);
    for (::mlir::Value v : valueGroup2) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::StringType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::StringRefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of string values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup3 = getODSOperands(3);
    for (::mlir::Value v : valueGroup3) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::StringType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::StringRefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of string values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup4 = getODSOperands(4);
    for (::mlir::Value v : valueGroup4) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::StringType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::StringRefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of 32-bit float or 64-bit integer or string values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))))) {
        return emitOpError("result #") << index << " must be tensor of 64-bit integer values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSResults(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::StringType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::StringRefType>())))))) {
        return emitOpError("result #") << index << " must be tensor of 32-bit float or 64-bit integer or string values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup2 = getODSResults(2);
    for (::mlir::Value v : valueGroup2) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))))) {
        return emitOpError("result #") << index << " must be tensor of 64-bit integer values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup3 = getODSResults(3);
    for (::mlir::Value v : valueGroup3) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::StringType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::StringRefType>())))))) {
        return emitOpError("result #") << index << " must be tensor of 32-bit float or 64-bit integer or string values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void ParseExampleOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::ParseExampleV2Op definitions
//===----------------------------------------------------------------------===//

ParseExampleV2OpAdaptor::ParseExampleV2OpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

ParseExampleV2OpAdaptor::ParseExampleV2OpAdaptor(ParseExampleV2Op&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> ParseExampleV2OpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  bool isVariadic[] = {false, false, false, false, false, true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (odsOperands.size() - 5) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::mlir::ValueRange ParseExampleV2OpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value ParseExampleV2OpAdaptor::serialized() {
  return *getODSOperands(0).begin();
}

::mlir::Value ParseExampleV2OpAdaptor::names() {
  return *getODSOperands(1).begin();
}

::mlir::Value ParseExampleV2OpAdaptor::sparse_keys() {
  return *getODSOperands(2).begin();
}

::mlir::Value ParseExampleV2OpAdaptor::dense_keys() {
  return *getODSOperands(3).begin();
}

::mlir::Value ParseExampleV2OpAdaptor::ragged_keys() {
  return *getODSOperands(4).begin();
}

::mlir::ValueRange ParseExampleV2OpAdaptor::dense_defaults() {
  return getODSOperands(5);
}

::mlir::IntegerAttr ParseExampleV2OpAdaptor::num_sparse() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::IntegerAttr attr = odsAttrs.get("num_sparse").cast<::mlir::IntegerAttr>();
  return attr;
}

::mlir::ArrayAttr ParseExampleV2OpAdaptor::dense_shapes() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::ArrayAttr attr = odsAttrs.get("dense_shapes").cast<::mlir::ArrayAttr>();
  return attr;
}

::mlir::DenseIntElementsAttr ParseExampleV2OpAdaptor::result_segment_sizes() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::DenseIntElementsAttr attr = odsAttrs.get("result_segment_sizes").cast<::mlir::DenseIntElementsAttr>();
  return attr;
}

::mlir::LogicalResult ParseExampleV2OpAdaptor::verify(::mlir::Location loc) {
  {
    auto sizeAttr = odsAttrs.get("result_segment_sizes").cast<::mlir::DenseIntElementsAttr>();
    auto numElements = sizeAttr.getType().cast<::mlir::ShapedType>().getNumElements();
    if (numElements != 6)
      return emitError(loc, "'result_segment_sizes' attribute for specifying result segments "
                       "must have 6 elements");
  }
    {
  auto tblgen_num_sparse = odsAttrs.get("num_sparse");
  if (!tblgen_num_sparse) return emitError(loc, "'tf.ParseExampleV2' op ""requires attribute 'num_sparse'");
    if (!((((tblgen_num_sparse.isa<::mlir::IntegerAttr>())) && ((tblgen_num_sparse.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(64)))) && ((tblgen_num_sparse.cast<::mlir::IntegerAttr>().getInt() >= 0)))) return emitError(loc, "'tf.ParseExampleV2' op ""attribute 'num_sparse' failed to satisfy constraint: 64-bit signless integer attribute whose minimum value is 0");
  }
  {
  auto tblgen_dense_shapes = odsAttrs.get("dense_shapes");
  if (!tblgen_dense_shapes) return emitError(loc, "'tf.ParseExampleV2' op ""requires attribute 'dense_shapes'");
    if (!(((tblgen_dense_shapes.isa<::mlir::ArrayAttr>())) && (::llvm::all_of(tblgen_dense_shapes.cast<::mlir::ArrayAttr>(), [](::mlir::Attribute attr) { return (attr.isa<mlir::TF::ShapeAttr>()); })))) return emitError(loc, "'tf.ParseExampleV2' op ""attribute 'dense_shapes' failed to satisfy constraint: tensorflow shape attribute array");
  }
  {
  auto tblgen_result_segment_sizes = odsAttrs.get("result_segment_sizes");
  if (!tblgen_result_segment_sizes) return emitError(loc, "'tf.ParseExampleV2' op ""requires attribute 'result_segment_sizes'");
    if (!(((tblgen_result_segment_sizes.isa<::mlir::DenseIntElementsAttr>())) && ((tblgen_result_segment_sizes.cast<::mlir::DenseIntElementsAttr>().getType().getElementType().isSignlessInteger(32))))) return emitError(loc, "'tf.ParseExampleV2' op ""attribute 'result_segment_sizes' failed to satisfy constraint: 32-bit signless integer elements attribute");
  }
  return ::mlir::success();
}

void ParseExampleV2Op::getAsmResultNames(::mlir::OpAsmSetValueNameFn setNameFn) {
  auto resultGroup0 = getODSResults(0);
  if (!llvm::empty(resultGroup0))
    setNameFn(*resultGroup0.begin(), "sparse_indices");
  auto resultGroup1 = getODSResults(1);
  if (!llvm::empty(resultGroup1))
    setNameFn(*resultGroup1.begin(), "sparse_values");
  auto resultGroup2 = getODSResults(2);
  if (!llvm::empty(resultGroup2))
    setNameFn(*resultGroup2.begin(), "sparse_shapes");
  auto resultGroup3 = getODSResults(3);
  if (!llvm::empty(resultGroup3))
    setNameFn(*resultGroup3.begin(), "dense_values");
  auto resultGroup4 = getODSResults(4);
  if (!llvm::empty(resultGroup4))
    setNameFn(*resultGroup4.begin(), "ragged_values");
  auto resultGroup5 = getODSResults(5);
  if (!llvm::empty(resultGroup5))
    setNameFn(*resultGroup5.begin(), "ragged_row_splits");
}

::llvm::StringRef ParseExampleV2Op::getOperationName() {
  return "tf.ParseExampleV2";
}

std::pair<unsigned, unsigned> ParseExampleV2Op::getODSOperandIndexAndLength(unsigned index) {
  bool isVariadic[] = {false, false, false, false, false, true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (getOperation()->getNumOperands() - 5) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::mlir::Operation::operand_range ParseExampleV2Op::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value ParseExampleV2Op::serialized() {
  return *getODSOperands(0).begin();
}

::mlir::Value ParseExampleV2Op::names() {
  return *getODSOperands(1).begin();
}

::mlir::Value ParseExampleV2Op::sparse_keys() {
  return *getODSOperands(2).begin();
}

::mlir::Value ParseExampleV2Op::dense_keys() {
  return *getODSOperands(3).begin();
}

::mlir::Value ParseExampleV2Op::ragged_keys() {
  return *getODSOperands(4).begin();
}

::mlir::Operation::operand_range ParseExampleV2Op::dense_defaults() {
  return getODSOperands(5);
}

::mlir::MutableOperandRange ParseExampleV2Op::serializedMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange ParseExampleV2Op::namesMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange ParseExampleV2Op::sparse_keysMutable() {
  auto range = getODSOperandIndexAndLength(2);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange ParseExampleV2Op::dense_keysMutable() {
  auto range = getODSOperandIndexAndLength(3);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange ParseExampleV2Op::ragged_keysMutable() {
  auto range = getODSOperandIndexAndLength(4);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange ParseExampleV2Op::dense_defaultsMutable() {
  auto range = getODSOperandIndexAndLength(5);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> ParseExampleV2Op::getODSResultIndexAndLength(unsigned index) {
  auto sizeAttr = getAttrOfType<::mlir::DenseIntElementsAttr>("result_segment_sizes");

  unsigned start = 0;
  for (unsigned i = 0; i < index; ++i)
    start += (*(sizeAttr.begin() + i)).getZExtValue();
  unsigned size = (*(sizeAttr.begin() + index)).getZExtValue();
  return {start, size};
}

::mlir::Operation::result_range ParseExampleV2Op::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Operation::result_range ParseExampleV2Op::sparse_indices() {
  return getODSResults(0);
}

::mlir::Operation::result_range ParseExampleV2Op::sparse_values() {
  return getODSResults(1);
}

::mlir::Operation::result_range ParseExampleV2Op::sparse_shapes() {
  return getODSResults(2);
}

::mlir::Operation::result_range ParseExampleV2Op::dense_values() {
  return getODSResults(3);
}

::mlir::Operation::result_range ParseExampleV2Op::ragged_values() {
  return getODSResults(4);
}

::mlir::Operation::result_range ParseExampleV2Op::ragged_row_splits() {
  return getODSResults(5);
}

::mlir::IntegerAttr ParseExampleV2Op::num_sparseAttr() {
  return this->getAttr("num_sparse").cast<::mlir::IntegerAttr>();
}

uint64_t ParseExampleV2Op::num_sparse() {
  auto attr = num_sparseAttr();
  return attr.getValue().getZExtValue();
}

::mlir::ArrayAttr ParseExampleV2Op::dense_shapesAttr() {
  return this->getAttr("dense_shapes").cast<::mlir::ArrayAttr>();
}

::mlir::ArrayAttr ParseExampleV2Op::dense_shapes() {
  auto attr = dense_shapesAttr();
  return attr;
}

::mlir::DenseIntElementsAttr ParseExampleV2Op::result_segment_sizesAttr() {
  return this->getAttr("result_segment_sizes").cast<::mlir::DenseIntElementsAttr>();
}

::mlir::DenseIntElementsAttr ParseExampleV2Op::result_segment_sizes() {
  auto attr = result_segment_sizesAttr();
  return attr;
}

mlir::OperandElementTypeRange ParseExampleV2Op::Tdense() {
  auto values = getODSOperands(5);
return {mlir::OperandElementTypeIterator(values.begin()), mlir::OperandElementTypeIterator(values.end())};
}

mlir::ResultElementTypeRange ParseExampleV2Op::sparse_types() {
  auto values = getODSResults(1);
return {mlir::ResultElementTypeIterator(values.begin()), mlir::ResultElementTypeIterator(values.end())};
}

mlir::ResultElementTypeRange ParseExampleV2Op::ragged_value_types() {
  auto values = getODSResults(4);
return {mlir::ResultElementTypeIterator(values.begin()), mlir::ResultElementTypeIterator(values.end())};
}

mlir::ResultElementTypeRange ParseExampleV2Op::ragged_split_types() {
  auto values = getODSResults(5);
return {mlir::ResultElementTypeIterator(values.begin()), mlir::ResultElementTypeIterator(values.end())};
}

bool ParseExampleV2Op::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "Tdense") return true;
  if (name == "sparse_types") return true;
  if (name == "ragged_value_types") return true;
  if (name == "ragged_split_types") return true;
 return false;
}

::mlir::DictionaryAttr ParseExampleV2Op::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("Tdense", ctx),
ArrayAttr::get(
    [&]() {
      llvm::SmallVector<Attribute, 4> ret;
      for (auto t : Tdense())
        ret.push_back(TypeAttr::get(t));
      return ret;
    }(), ctx)},
    {::mlir::Identifier::get("sparse_types", ctx),
ArrayAttr::get(
    [&]() {
      llvm::SmallVector<Attribute, 4> ret;
      for (auto t : sparse_types())
        ret.push_back(TypeAttr::get(t));
      return ret;
    }(), ctx)},
    {::mlir::Identifier::get("ragged_value_types", ctx),
ArrayAttr::get(
    [&]() {
      llvm::SmallVector<Attribute, 4> ret;
      for (auto t : ragged_value_types())
        ret.push_back(TypeAttr::get(t));
      return ret;
    }(), ctx)},
    {::mlir::Identifier::get("ragged_split_types", ctx),
ArrayAttr::get(
    [&]() {
      llvm::SmallVector<Attribute, 4> ret;
      for (auto t : ragged_split_types())
        ret.push_back(TypeAttr::get(t));
      return ret;
    }(), ctx)}
    }, ctx);
}

void ParseExampleV2Op::num_sparseAttr(::mlir::IntegerAttr attr) {
  this->getOperation()->setAttr("num_sparse", attr);
}

void ParseExampleV2Op::dense_shapesAttr(::mlir::ArrayAttr attr) {
  this->getOperation()->setAttr("dense_shapes", attr);
}

void ParseExampleV2Op::result_segment_sizesAttr(::mlir::DenseIntElementsAttr attr) {
  this->getOperation()->setAttr("result_segment_sizes", attr);
}

void ParseExampleV2Op::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange sparse_indices, ::mlir::TypeRange sparse_values, ::mlir::TypeRange sparse_shapes, ::mlir::TypeRange dense_values, ::mlir::TypeRange ragged_values, ::mlir::TypeRange ragged_row_splits, ::mlir::Value serialized, ::mlir::Value names, ::mlir::Value sparse_keys, ::mlir::Value dense_keys, ::mlir::Value ragged_keys, ::mlir::ValueRange dense_defaults, ::mlir::IntegerAttr num_sparse, ::mlir::ArrayAttr dense_shapes, ::mlir::DenseIntElementsAttr result_segment_sizes) {
  odsState.addOperands(serialized);
  odsState.addOperands(names);
  odsState.addOperands(sparse_keys);
  odsState.addOperands(dense_keys);
  odsState.addOperands(ragged_keys);
  odsState.addOperands(dense_defaults);
  odsState.addAttribute("num_sparse", num_sparse);
  odsState.addAttribute("dense_shapes", dense_shapes);
  odsState.addAttribute("result_segment_sizes", result_segment_sizes);
  odsState.addTypes(sparse_indices);
  odsState.addTypes(sparse_values);
  odsState.addTypes(sparse_shapes);
  odsState.addTypes(dense_values);
  odsState.addTypes(ragged_values);
  odsState.addTypes(ragged_row_splits);
}

void ParseExampleV2Op::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value serialized, ::mlir::Value names, ::mlir::Value sparse_keys, ::mlir::Value dense_keys, ::mlir::Value ragged_keys, ::mlir::ValueRange dense_defaults, ::mlir::IntegerAttr num_sparse, ::mlir::ArrayAttr dense_shapes, ::mlir::DenseIntElementsAttr result_segment_sizes) {
  odsState.addOperands(serialized);
  odsState.addOperands(names);
  odsState.addOperands(sparse_keys);
  odsState.addOperands(dense_keys);
  odsState.addOperands(ragged_keys);
  odsState.addOperands(dense_defaults);
  odsState.addAttribute("num_sparse", num_sparse);
  odsState.addAttribute("dense_shapes", dense_shapes);
  odsState.addAttribute("result_segment_sizes", result_segment_sizes);
  odsState.addTypes(resultTypes);
}

void ParseExampleV2Op::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange sparse_indices, ::mlir::TypeRange sparse_values, ::mlir::TypeRange sparse_shapes, ::mlir::TypeRange dense_values, ::mlir::TypeRange ragged_values, ::mlir::TypeRange ragged_row_splits, ::mlir::Value serialized, ::mlir::Value names, ::mlir::Value sparse_keys, ::mlir::Value dense_keys, ::mlir::Value ragged_keys, ::mlir::ValueRange dense_defaults, uint64_t num_sparse, ::mlir::ArrayAttr dense_shapes, ::mlir::DenseIntElementsAttr result_segment_sizes) {
  odsState.addOperands(serialized);
  odsState.addOperands(names);
  odsState.addOperands(sparse_keys);
  odsState.addOperands(dense_keys);
  odsState.addOperands(ragged_keys);
  odsState.addOperands(dense_defaults);
  odsState.addAttribute("num_sparse", odsBuilder.getIntegerAttr(odsBuilder.getIntegerType(64), num_sparse));
  odsState.addAttribute("dense_shapes", dense_shapes);
  odsState.addAttribute("result_segment_sizes", result_segment_sizes);
  odsState.addTypes(sparse_indices);
  odsState.addTypes(sparse_values);
  odsState.addTypes(sparse_shapes);
  odsState.addTypes(dense_values);
  odsState.addTypes(ragged_values);
  odsState.addTypes(ragged_row_splits);
}

void ParseExampleV2Op::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value serialized, ::mlir::Value names, ::mlir::Value sparse_keys, ::mlir::Value dense_keys, ::mlir::Value ragged_keys, ::mlir::ValueRange dense_defaults, uint64_t num_sparse, ::mlir::ArrayAttr dense_shapes, ::mlir::DenseIntElementsAttr result_segment_sizes) {
  odsState.addOperands(serialized);
  odsState.addOperands(names);
  odsState.addOperands(sparse_keys);
  odsState.addOperands(dense_keys);
  odsState.addOperands(ragged_keys);
  odsState.addOperands(dense_defaults);
  odsState.addAttribute("num_sparse", odsBuilder.getIntegerAttr(odsBuilder.getIntegerType(64), num_sparse));
  odsState.addAttribute("dense_shapes", dense_shapes);
  odsState.addAttribute("result_segment_sizes", result_segment_sizes);
  odsState.addTypes(resultTypes);
}

void ParseExampleV2Op::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() >= 5u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult ParseExampleV2Op::verify() {
  if (failed(ParseExampleV2OpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::StringType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::StringRefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of string values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::StringType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::StringRefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of string values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup2 = getODSOperands(2);
    for (::mlir::Value v : valueGroup2) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::StringType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::StringRefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of string values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup3 = getODSOperands(3);
    for (::mlir::Value v : valueGroup3) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::StringType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::StringRefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of string values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup4 = getODSOperands(4);
    for (::mlir::Value v : valueGroup4) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::StringType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::StringRefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of string values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup5 = getODSOperands(5);
    for (::mlir::Value v : valueGroup5) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::StringType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::StringRefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of 32-bit float or 64-bit integer or string values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))))) {
        return emitOpError("result #") << index << " must be tensor of 64-bit integer values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSResults(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::StringType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::StringRefType>())))))) {
        return emitOpError("result #") << index << " must be tensor of 32-bit float or 64-bit integer or string values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup2 = getODSResults(2);
    for (::mlir::Value v : valueGroup2) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))))) {
        return emitOpError("result #") << index << " must be tensor of 64-bit integer values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup3 = getODSResults(3);
    for (::mlir::Value v : valueGroup3) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::StringType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::StringRefType>())))))) {
        return emitOpError("result #") << index << " must be tensor of 32-bit float or 64-bit integer or string values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup4 = getODSResults(4);
    for (::mlir::Value v : valueGroup4) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::StringType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::StringRefType>())))))) {
        return emitOpError("result #") << index << " must be tensor of 32-bit float or 64-bit integer or string values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup5 = getODSResults(5);
    for (::mlir::Value v : valueGroup5) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))))) {
        return emitOpError("result #") << index << " must be tensor of 32-bit integer or 64-bit integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  return Verify(*this);
}

void ParseExampleV2Op::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::PartitionedCallOp definitions
//===----------------------------------------------------------------------===//

PartitionedCallOpAdaptor::PartitionedCallOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

PartitionedCallOpAdaptor::PartitionedCallOpAdaptor(PartitionedCallOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> PartitionedCallOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  bool isVariadic[] = {true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (odsOperands.size() - 0) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::mlir::ValueRange PartitionedCallOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::ValueRange PartitionedCallOpAdaptor::args() {
  return getODSOperands(0);
}

::mlir::SymbolRefAttr PartitionedCallOpAdaptor::f() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::SymbolRefAttr attr = odsAttrs.get("f").cast<::mlir::SymbolRefAttr>();
  return attr;
}

::mlir::StringAttr PartitionedCallOpAdaptor::config() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::StringAttr attr = odsAttrs.get("config").cast<::mlir::StringAttr>();
  return attr;
}

::mlir::StringAttr PartitionedCallOpAdaptor::config_proto() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::StringAttr attr = odsAttrs.get("config_proto").cast<::mlir::StringAttr>();
  return attr;
}

::mlir::StringAttr PartitionedCallOpAdaptor::executor_type() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::StringAttr attr = odsAttrs.get("executor_type").cast<::mlir::StringAttr>();
  return attr;
}

::mlir::LogicalResult PartitionedCallOpAdaptor::verify(::mlir::Location loc) {
  {
  auto tblgen_f = odsAttrs.get("f");
  if (!tblgen_f) return emitError(loc, "'tf.PartitionedCall' op ""requires attribute 'f'");
    if (!((tblgen_f.isa<::mlir::SymbolRefAttr>()))) return emitError(loc, "'tf.PartitionedCall' op ""attribute 'f' failed to satisfy constraint: symbol reference attribute");
  }
  {
  auto tblgen_config = odsAttrs.get("config");
  if (!tblgen_config) return emitError(loc, "'tf.PartitionedCall' op ""requires attribute 'config'");
    if (!((tblgen_config.isa<::mlir::StringAttr>()))) return emitError(loc, "'tf.PartitionedCall' op ""attribute 'config' failed to satisfy constraint: string attribute");
  }
  {
  auto tblgen_config_proto = odsAttrs.get("config_proto");
  if (!tblgen_config_proto) return emitError(loc, "'tf.PartitionedCall' op ""requires attribute 'config_proto'");
    if (!((tblgen_config_proto.isa<::mlir::StringAttr>()))) return emitError(loc, "'tf.PartitionedCall' op ""attribute 'config_proto' failed to satisfy constraint: string attribute");
  }
  {
  auto tblgen_executor_type = odsAttrs.get("executor_type");
  if (!tblgen_executor_type) return emitError(loc, "'tf.PartitionedCall' op ""requires attribute 'executor_type'");
    if (!((tblgen_executor_type.isa<::mlir::StringAttr>()))) return emitError(loc, "'tf.PartitionedCall' op ""attribute 'executor_type' failed to satisfy constraint: string attribute");
  }
  return ::mlir::success();
}

::llvm::StringRef PartitionedCallOp::getOperationName() {
  return "tf.PartitionedCall";
}

std::pair<unsigned, unsigned> PartitionedCallOp::getODSOperandIndexAndLength(unsigned index) {
  bool isVariadic[] = {true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (getOperation()->getNumOperands() - 0) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::mlir::Operation::operand_range PartitionedCallOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Operation::operand_range PartitionedCallOp::args() {
  return getODSOperands(0);
}

::mlir::MutableOperandRange PartitionedCallOp::argsMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> PartitionedCallOp::getODSResultIndexAndLength(unsigned index) {
  bool isVariadic[] = {true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (getOperation()->getNumResults() - 0) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::mlir::Operation::result_range PartitionedCallOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Operation::result_range PartitionedCallOp::output() {
  return getODSResults(0);
}

::mlir::SymbolRefAttr PartitionedCallOp::fAttr() {
  return this->getAttr("f").cast<::mlir::SymbolRefAttr>();
}

::mlir::SymbolRefAttr PartitionedCallOp::f() {
  auto attr = fAttr();
  return attr;
}

::mlir::StringAttr PartitionedCallOp::configAttr() {
  return this->getAttr("config").cast<::mlir::StringAttr>();
}

::llvm::StringRef PartitionedCallOp::config() {
  auto attr = configAttr();
  return attr.getValue();
}

::mlir::StringAttr PartitionedCallOp::config_protoAttr() {
  return this->getAttr("config_proto").cast<::mlir::StringAttr>();
}

::llvm::StringRef PartitionedCallOp::config_proto() {
  auto attr = config_protoAttr();
  return attr.getValue();
}

::mlir::StringAttr PartitionedCallOp::executor_typeAttr() {
  return this->getAttr("executor_type").cast<::mlir::StringAttr>();
}

::llvm::StringRef PartitionedCallOp::executor_type() {
  auto attr = executor_typeAttr();
  return attr.getValue();
}

mlir::OperandElementTypeRange PartitionedCallOp::Tin() {
  auto values = getODSOperands(0);
return {mlir::OperandElementTypeIterator(values.begin()), mlir::OperandElementTypeIterator(values.end())};
}

mlir::ResultElementTypeRange PartitionedCallOp::Tout() {
  auto values = getODSResults(0);
return {mlir::ResultElementTypeIterator(values.begin()), mlir::ResultElementTypeIterator(values.end())};
}

bool PartitionedCallOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "Tin") return true;
  if (name == "Tout") return true;
 return false;
}

::mlir::DictionaryAttr PartitionedCallOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("Tin", ctx),
ArrayAttr::get(
    [&]() {
      llvm::SmallVector<Attribute, 4> ret;
      for (auto t : Tin())
        ret.push_back(TypeAttr::get(t));
      return ret;
    }(), ctx)},
    {::mlir::Identifier::get("Tout", ctx),
ArrayAttr::get(
    [&]() {
      llvm::SmallVector<Attribute, 4> ret;
      for (auto t : Tout())
        ret.push_back(TypeAttr::get(t));
      return ret;
    }(), ctx)}
    }, ctx);
}

void PartitionedCallOp::fAttr(::mlir::SymbolRefAttr attr) {
  this->getOperation()->setAttr("f", attr);
}

void PartitionedCallOp::configAttr(::mlir::StringAttr attr) {
  this->getOperation()->setAttr("config", attr);
}

void PartitionedCallOp::config_protoAttr(::mlir::StringAttr attr) {
  this->getOperation()->setAttr("config_proto", attr);
}

void PartitionedCallOp::executor_typeAttr(::mlir::StringAttr attr) {
  this->getOperation()->setAttr("executor_type", attr);
}

void PartitionedCallOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange output, ::mlir::ValueRange args, ::mlir::SymbolRefAttr f, ::mlir::StringAttr config, ::mlir::StringAttr config_proto, ::mlir::StringAttr executor_type) {
  odsState.addOperands(args);
  odsState.addAttribute("f", f);
  odsState.addAttribute("config", config);
  odsState.addAttribute("config_proto", config_proto);
  odsState.addAttribute("executor_type", executor_type);
  odsState.addTypes(output);
}

void PartitionedCallOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange output, ::mlir::ValueRange args, ::mlir::SymbolRefAttr f, ::llvm::StringRef config, ::llvm::StringRef config_proto, ::llvm::StringRef executor_type) {
  odsState.addOperands(args);
  odsState.addAttribute("f", f);
  odsState.addAttribute("config", odsBuilder.getStringAttr(config));
  odsState.addAttribute("config_proto", odsBuilder.getStringAttr(config_proto));
  odsState.addAttribute("executor_type", odsBuilder.getStringAttr(executor_type));
  odsState.addTypes(output);
}

void PartitionedCallOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult PartitionedCallOp::verify() {
  if (failed(PartitionedCallOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>())))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::TensorFlowType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of tf.dtype values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>())))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::TensorFlowType>()))))) {
        return emitOpError("result #") << index << " must be tensor of tf.dtype values, but got " << v.getType();
      }
      ++index;
    }
  }
  return VerifyPartitionedCall(*this);
}

void PartitionedCallOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::PlaceholderOp definitions
//===----------------------------------------------------------------------===//

PlaceholderOpAdaptor::PlaceholderOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

PlaceholderOpAdaptor::PlaceholderOpAdaptor(PlaceholderOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> PlaceholderOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange PlaceholderOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::LogicalResult PlaceholderOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

::llvm::StringRef PlaceholderOp::getOperationName() {
  return "tf.Placeholder";
}

std::pair<unsigned, unsigned> PlaceholderOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range PlaceholderOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

std::pair<unsigned, unsigned> PlaceholderOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range PlaceholderOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value PlaceholderOp::output() {
  return *getODSResults(0).begin();
}

Type PlaceholderOp::dtype() {
  return mlir::getElementTypeOrSelf(*getODSResults(0).begin());
}

bool PlaceholderOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "dtype") return true;
 return false;
}

::mlir::DictionaryAttr PlaceholderOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("dtype", ctx),
::mlir::TypeAttr::get(dtype())}
    }, ctx);
}

void PlaceholderOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output) {
  odsState.addTypes(output);
}

void PlaceholderOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes) {
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void PlaceholderOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 0u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult PlaceholderOp::verify() {
  if (failed(PlaceholderOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>())))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::TensorFlowType>()))))) {
        return emitOpError("result #") << index << " must be tensor of tf.dtype values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void PlaceholderOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::PlaceholderWithDefaultOp definitions
//===----------------------------------------------------------------------===//

PlaceholderWithDefaultOpAdaptor::PlaceholderWithDefaultOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

PlaceholderWithDefaultOpAdaptor::PlaceholderWithDefaultOpAdaptor(PlaceholderWithDefaultOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> PlaceholderWithDefaultOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange PlaceholderWithDefaultOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value PlaceholderWithDefaultOpAdaptor::input() {
  return *getODSOperands(0).begin();
}

::mlir::LogicalResult PlaceholderWithDefaultOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

::llvm::StringRef PlaceholderWithDefaultOp::getOperationName() {
  return "tf.PlaceholderWithDefault";
}

std::pair<unsigned, unsigned> PlaceholderWithDefaultOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range PlaceholderWithDefaultOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value PlaceholderWithDefaultOp::input() {
  return *getODSOperands(0).begin();
}

::mlir::MutableOperandRange PlaceholderWithDefaultOp::inputMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> PlaceholderWithDefaultOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range PlaceholderWithDefaultOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value PlaceholderWithDefaultOp::output() {
  return *getODSResults(0).begin();
}

Type PlaceholderWithDefaultOp::dtype() {
  return mlir::getElementTypeOrSelf(*getODSResults(0).begin());
}

ShapedType PlaceholderWithDefaultOp::shape() {
  return (*getOperation()->result_type_begin()).cast<ShapedType>();
}

bool PlaceholderWithDefaultOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "dtype") return true;
  if (name == "shape") return true;
 return false;
}

::mlir::DictionaryAttr PlaceholderWithDefaultOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("dtype", ctx),
::mlir::TypeAttr::get(dtype())},
    {::mlir::Identifier::get("shape", ctx),
mlir::TF::ShapeAttr::get(ctx, shape())}
    }, ctx);
}

void PlaceholderWithDefaultOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value input) {
  odsState.addOperands(input);
  odsState.addTypes(output);
}

void PlaceholderWithDefaultOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input) {
  odsState.addOperands(input);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void PlaceholderWithDefaultOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult PlaceholderWithDefaultOp::verify() {
  if (failed(PlaceholderWithDefaultOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>())))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::TensorFlowType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of tf.dtype values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>())))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::TensorFlowType>()))))) {
        return emitOpError("result #") << index << " must be tensor of tf.dtype values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void PlaceholderWithDefaultOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::PowOp definitions
//===----------------------------------------------------------------------===//

PowOpAdaptor::PowOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

PowOpAdaptor::PowOpAdaptor(PowOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> PowOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange PowOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value PowOpAdaptor::x() {
  return *getODSOperands(0).begin();
}

::mlir::Value PowOpAdaptor::y() {
  return *getODSOperands(1).begin();
}

::mlir::LogicalResult PowOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

::llvm::StringRef PowOp::getOperationName() {
  return "tf.Pow";
}

std::pair<unsigned, unsigned> PowOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range PowOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value PowOp::x() {
  return *getODSOperands(0).begin();
}

::mlir::Value PowOp::y() {
  return *getODSOperands(1).begin();
}

::mlir::MutableOperandRange PowOp::xMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange PowOp::yMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> PowOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range PowOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value PowOp::z() {
  return *getODSResults(0).begin();
}

Type PowOp::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

bool PowOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "T") return true;
 return false;
}

::mlir::DictionaryAttr PowOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())}
    }, ctx);
}

void PowOp::build(OpBuilder &builder, OperationState &result, Value  x, Value  y) {
  auto resultType =
      OpTrait::util::getBroadcastedType(x.getType(), y.getType());
  if (!resultType)
    mlir::emitError(result.location, "non-broadcastable operands");
  return build(builder, result, resultType, x, y);
}

void PowOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type z, ::mlir::Value x, ::mlir::Value y) {
  odsState.addOperands(x);
  odsState.addOperands(y);
  odsState.addTypes(z);
}

void PowOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value x, ::mlir::Value y) {
  odsState.addOperands(x);
  odsState.addOperands(y);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void PowOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult PowOp::verify() {
  if (failed(PowOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of bfloat16 or 128-bit complex or 64-bit complex or 16-bit float or 32-bit float or 64-bit float or 32-bit integer or 64-bit integer values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of bfloat16 or 128-bit complex or 64-bit complex or 16-bit float or 32-bit float or 64-bit float or 32-bit integer or 64-bit integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))))) {
        return emitOpError("result #") << index << " must be tensor of bfloat16 or 128-bit complex or 64-bit complex or 16-bit float or 32-bit float or 64-bit float or 32-bit integer or 64-bit integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}



void PowOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::PreventGradientOp definitions
//===----------------------------------------------------------------------===//

PreventGradientOpAdaptor::PreventGradientOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

PreventGradientOpAdaptor::PreventGradientOpAdaptor(PreventGradientOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> PreventGradientOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange PreventGradientOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value PreventGradientOpAdaptor::input() {
  return *getODSOperands(0).begin();
}

::mlir::StringAttr PreventGradientOpAdaptor::message() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::StringAttr attr = odsAttrs.get("message").cast<::mlir::StringAttr>();
  return attr;
}

::mlir::LogicalResult PreventGradientOpAdaptor::verify(::mlir::Location loc) {
  {
  auto tblgen_message = odsAttrs.get("message");
  if (!tblgen_message) return emitError(loc, "'tf.PreventGradient' op ""requires attribute 'message'");
    if (!((tblgen_message.isa<::mlir::StringAttr>()))) return emitError(loc, "'tf.PreventGradient' op ""attribute 'message' failed to satisfy constraint: string attribute");
  }
  return ::mlir::success();
}

::llvm::StringRef PreventGradientOp::getOperationName() {
  return "tf.PreventGradient";
}

std::pair<unsigned, unsigned> PreventGradientOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range PreventGradientOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value PreventGradientOp::input() {
  return *getODSOperands(0).begin();
}

::mlir::MutableOperandRange PreventGradientOp::inputMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> PreventGradientOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range PreventGradientOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value PreventGradientOp::output() {
  return *getODSResults(0).begin();
}

::mlir::StringAttr PreventGradientOp::messageAttr() {
  return this->getAttr("message").cast<::mlir::StringAttr>();
}

::llvm::StringRef PreventGradientOp::message() {
  auto attr = messageAttr();
  return attr.getValue();
}

Type PreventGradientOp::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

bool PreventGradientOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "T") return true;
 return false;
}

::mlir::DictionaryAttr PreventGradientOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())}
    }, ctx);
}

void PreventGradientOp::messageAttr(::mlir::StringAttr attr) {
  this->getOperation()->setAttr("message", attr);
}

void PreventGradientOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value input, ::mlir::StringAttr message) {
  odsState.addOperands(input);
  odsState.addAttribute("message", message);
  odsState.addTypes(output);
}

void PreventGradientOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input, ::mlir::StringAttr message) {
  odsState.addOperands(input);
  odsState.addAttribute("message", message);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void PreventGradientOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value input, ::llvm::StringRef message) {
  odsState.addOperands(input);
  odsState.addAttribute("message", odsBuilder.getStringAttr(message));
  odsState.addTypes(output);
}

void PreventGradientOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input, ::llvm::StringRef message) {
  odsState.addOperands(input);
  odsState.addAttribute("message", odsBuilder.getStringAttr(message));
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void PreventGradientOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

void PreventGradientOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value input, ::mlir::StringAttr message) {
  odsState.addOperands(input);
  odsState.addAttribute("message", message);
  odsState.addTypes({input.getType()});

}

void PreventGradientOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  odsState.addTypes({operands[0].getType()});

}

::mlir::LogicalResult PreventGradientOp::verify() {
  if (failed(PreventGradientOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>())))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::TensorFlowType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of tf.dtype values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>())))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::TensorFlowType>()))))) {
        return emitOpError("result #") << index << " must be tensor of tf.dtype values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void PreventGradientOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::PrintV2Op definitions
//===----------------------------------------------------------------------===//

PrintV2OpAdaptor::PrintV2OpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

PrintV2OpAdaptor::PrintV2OpAdaptor(PrintV2Op&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> PrintV2OpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange PrintV2OpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value PrintV2OpAdaptor::input() {
  return *getODSOperands(0).begin();
}

::mlir::StringAttr PrintV2OpAdaptor::output_stream() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::StringAttr attr = odsAttrs.get("output_stream").dyn_cast_or_null<::mlir::StringAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getStringAttr("stderr");
  return attr;
}

::mlir::StringAttr PrintV2OpAdaptor::end() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::StringAttr attr = odsAttrs.get("end").cast<::mlir::StringAttr>();
  return attr;
}

::mlir::LogicalResult PrintV2OpAdaptor::verify(::mlir::Location loc) {
  {
  auto tblgen_output_stream = odsAttrs.get("output_stream");
  if (tblgen_output_stream) {
    if (!((tblgen_output_stream.isa<::mlir::StringAttr>()))) return emitError(loc, "'tf.PrintV2' op ""attribute 'output_stream' failed to satisfy constraint: string attribute");
  }
  }
  {
  auto tblgen_end = odsAttrs.get("end");
  if (!tblgen_end) return emitError(loc, "'tf.PrintV2' op ""requires attribute 'end'");
    if (!((tblgen_end.isa<::mlir::StringAttr>()))) return emitError(loc, "'tf.PrintV2' op ""attribute 'end' failed to satisfy constraint: string attribute");
  }
  return ::mlir::success();
}

::llvm::StringRef PrintV2Op::getOperationName() {
  return "tf.PrintV2";
}

std::pair<unsigned, unsigned> PrintV2Op::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range PrintV2Op::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value PrintV2Op::input() {
  return *getODSOperands(0).begin();
}

::mlir::MutableOperandRange PrintV2Op::inputMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> PrintV2Op::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range PrintV2Op::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::StringAttr PrintV2Op::output_streamAttr() {
  return this->getAttr("output_stream").dyn_cast_or_null<::mlir::StringAttr>();
}

::llvm::StringRef PrintV2Op::output_stream() {
  auto attr = output_streamAttr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getStringAttr("stderr").getValue();
  return attr.getValue();
}

::mlir::StringAttr PrintV2Op::endAttr() {
  return this->getAttr("end").cast<::mlir::StringAttr>();
}

::llvm::StringRef PrintV2Op::end() {
  auto attr = endAttr();
  return attr.getValue();
}

void PrintV2Op::output_streamAttr(::mlir::StringAttr attr) {
  this->getOperation()->setAttr("output_stream", attr);
}

void PrintV2Op::endAttr(::mlir::StringAttr attr) {
  this->getOperation()->setAttr("end", attr);
}

void PrintV2Op::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value input, ::mlir::StringAttr output_stream, ::mlir::StringAttr end) {
  odsState.addOperands(input);
  odsState.addAttribute("output_stream", output_stream);
  odsState.addAttribute("end", end);
}

void PrintV2Op::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input, ::mlir::StringAttr output_stream, ::mlir::StringAttr end) {
  odsState.addOperands(input);
  odsState.addAttribute("output_stream", output_stream);
  odsState.addAttribute("end", end);
  assert(resultTypes.size() == 0u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void PrintV2Op::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value input, ::llvm::StringRef output_stream, ::llvm::StringRef end) {
  odsState.addOperands(input);
  odsState.addAttribute("output_stream", odsBuilder.getStringAttr(output_stream));
  odsState.addAttribute("end", odsBuilder.getStringAttr(end));
}

void PrintV2Op::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input, ::llvm::StringRef output_stream, ::llvm::StringRef end) {
  odsState.addOperands(input);
  odsState.addAttribute("output_stream", odsBuilder.getStringAttr(output_stream));
  odsState.addAttribute("end", odsBuilder.getStringAttr(end));
  assert(resultTypes.size() == 0u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void PrintV2Op::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 0u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult PrintV2Op::verify() {
  if (failed(PrintV2OpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::StringType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::StringRefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of string values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
  }
  return ::mlir::success();
}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::ProdOp definitions
//===----------------------------------------------------------------------===//

ProdOpAdaptor::ProdOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

ProdOpAdaptor::ProdOpAdaptor(ProdOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> ProdOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange ProdOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value ProdOpAdaptor::input() {
  return *getODSOperands(0).begin();
}

::mlir::Value ProdOpAdaptor::reduction_indices() {
  return *getODSOperands(1).begin();
}

::mlir::BoolAttr ProdOpAdaptor::keep_dims() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::BoolAttr attr = odsAttrs.get("keep_dims").dyn_cast_or_null<::mlir::BoolAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getBoolAttr(false);
  return attr;
}

::mlir::LogicalResult ProdOpAdaptor::verify(::mlir::Location loc) {
  {
  auto tblgen_keep_dims = odsAttrs.get("keep_dims");
  if (tblgen_keep_dims) {
    if (!((tblgen_keep_dims.isa<::mlir::BoolAttr>()))) return emitError(loc, "'tf.Prod' op ""attribute 'keep_dims' failed to satisfy constraint: bool attribute");
  }
  }
  return ::mlir::success();
}

::llvm::StringRef ProdOp::getOperationName() {
  return "tf.Prod";
}

std::pair<unsigned, unsigned> ProdOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range ProdOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value ProdOp::input() {
  return *getODSOperands(0).begin();
}

::mlir::Value ProdOp::reduction_indices() {
  return *getODSOperands(1).begin();
}

::mlir::MutableOperandRange ProdOp::inputMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange ProdOp::reduction_indicesMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> ProdOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range ProdOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value ProdOp::output() {
  return *getODSResults(0).begin();
}

::mlir::BoolAttr ProdOp::keep_dimsAttr() {
  return this->getAttr("keep_dims").dyn_cast_or_null<::mlir::BoolAttr>();
}

bool ProdOp::keep_dims() {
  auto attr = keep_dimsAttr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getBoolAttr(false).getValue();
  return attr.getValue();
}

Type ProdOp::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

Type ProdOp::Tidx() {
  return mlir::getElementTypeOrSelf(*getODSOperands(1).begin());
}

bool ProdOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "T") return true;
  if (name == "Tidx") return true;
 return false;
}

::mlir::DictionaryAttr ProdOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())},
    {::mlir::Identifier::get("Tidx", ctx),
::mlir::TypeAttr::get(Tidx())}
    }, ctx);
}

void ProdOp::keep_dimsAttr(::mlir::BoolAttr attr) {
  this->getOperation()->setAttr("keep_dims", attr);
}

void ProdOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value input, ::mlir::Value reduction_indices, ::mlir::BoolAttr keep_dims) {
  odsState.addOperands(input);
  odsState.addOperands(reduction_indices);
  odsState.addAttribute("keep_dims", keep_dims);
  odsState.addTypes(output);
}

void ProdOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input, ::mlir::Value reduction_indices, ::mlir::BoolAttr keep_dims) {
  odsState.addOperands(input);
  odsState.addOperands(reduction_indices);
  odsState.addAttribute("keep_dims", keep_dims);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void ProdOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value input, ::mlir::Value reduction_indices, bool keep_dims) {
  odsState.addOperands(input);
  odsState.addOperands(reduction_indices);
  odsState.addAttribute("keep_dims", odsBuilder.getBoolAttr(keep_dims));
  odsState.addTypes(output);
}

void ProdOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input, ::mlir::Value reduction_indices, bool keep_dims) {
  odsState.addOperands(input);
  odsState.addOperands(reduction_indices);
  odsState.addAttribute("keep_dims", odsBuilder.getBoolAttr(keep_dims));
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void ProdOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult ProdOp::verify() {
  if (failed(ProdOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of bfloat16 or 128-bit complex or 64-bit complex or 16-bit float or 32-bit float or 64-bit float or 16-bit integer or 32-bit integer or 64-bit integer or 8-bit integer or 32-bit quantized integer or 8-bit quantized integer or 8-bit quantized unsigned integer or 16-bit unsigned integer or 32-bit unsigned integer or 64-bit unsigned integer or 8-bit unsigned integer values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of 32/64-bit signed integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>())))))) {
        return emitOpError("result #") << index << " must be tensor of bfloat16 or 128-bit complex or 64-bit complex or 16-bit float or 32-bit float or 64-bit float or 16-bit integer or 32-bit integer or 64-bit integer or 8-bit integer or 32-bit quantized integer or 8-bit quantized integer or 8-bit quantized unsigned integer or 16-bit unsigned integer or 32-bit unsigned integer or 64-bit unsigned integer or 8-bit unsigned integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void ProdOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::QrOp definitions
//===----------------------------------------------------------------------===//

QrOpAdaptor::QrOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

QrOpAdaptor::QrOpAdaptor(QrOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> QrOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange QrOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value QrOpAdaptor::input() {
  return *getODSOperands(0).begin();
}

::mlir::BoolAttr QrOpAdaptor::full_matrices() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::BoolAttr attr = odsAttrs.get("full_matrices").dyn_cast_or_null<::mlir::BoolAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getBoolAttr(false);
  return attr;
}

::mlir::LogicalResult QrOpAdaptor::verify(::mlir::Location loc) {
  {
  auto tblgen_full_matrices = odsAttrs.get("full_matrices");
  if (tblgen_full_matrices) {
    if (!((tblgen_full_matrices.isa<::mlir::BoolAttr>()))) return emitError(loc, "'tf.Qr' op ""attribute 'full_matrices' failed to satisfy constraint: bool attribute");
  }
  }
  return ::mlir::success();
}

void QrOp::getAsmResultNames(::mlir::OpAsmSetValueNameFn setNameFn) {
  auto resultGroup0 = getODSResults(0);
  if (!llvm::empty(resultGroup0))
    setNameFn(*resultGroup0.begin(), "q");
  auto resultGroup1 = getODSResults(1);
  if (!llvm::empty(resultGroup1))
    setNameFn(*resultGroup1.begin(), "r");
}

::llvm::StringRef QrOp::getOperationName() {
  return "tf.Qr";
}

std::pair<unsigned, unsigned> QrOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range QrOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value QrOp::input() {
  return *getODSOperands(0).begin();
}

::mlir::MutableOperandRange QrOp::inputMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> QrOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range QrOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value QrOp::q() {
  return *getODSResults(0).begin();
}

::mlir::Value QrOp::r() {
  return *getODSResults(1).begin();
}

::mlir::BoolAttr QrOp::full_matricesAttr() {
  return this->getAttr("full_matrices").dyn_cast_or_null<::mlir::BoolAttr>();
}

bool QrOp::full_matrices() {
  auto attr = full_matricesAttr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getBoolAttr(false).getValue();
  return attr.getValue();
}

Type QrOp::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

bool QrOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "T") return true;
 return false;
}

::mlir::DictionaryAttr QrOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())}
    }, ctx);
}

void QrOp::full_matricesAttr(::mlir::BoolAttr attr) {
  this->getOperation()->setAttr("full_matrices", attr);
}

void QrOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type q, ::mlir::Type r, ::mlir::Value input, ::mlir::BoolAttr full_matrices) {
  odsState.addOperands(input);
  odsState.addAttribute("full_matrices", full_matrices);
  odsState.addTypes(q);
  odsState.addTypes(r);
}

void QrOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input, ::mlir::BoolAttr full_matrices) {
  odsState.addOperands(input);
  odsState.addAttribute("full_matrices", full_matrices);
  assert(resultTypes.size() == 2u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void QrOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type q, ::mlir::Type r, ::mlir::Value input, bool full_matrices) {
  odsState.addOperands(input);
  odsState.addAttribute("full_matrices", odsBuilder.getBoolAttr(full_matrices));
  odsState.addTypes(q);
  odsState.addTypes(r);
}

void QrOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input, bool full_matrices) {
  odsState.addOperands(input);
  odsState.addAttribute("full_matrices", odsBuilder.getBoolAttr(full_matrices));
  assert(resultTypes.size() == 2u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void QrOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 2u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult QrOp::verify() {
  if (failed(QrOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of 128-bit complex or 64-bit complex or 16-bit float or 32-bit float or 64-bit float values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())))))) {
        return emitOpError("result #") << index << " must be tensor of 128-bit complex or 64-bit complex or 16-bit float or 32-bit float or 64-bit float values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSResults(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())))))) {
        return emitOpError("result #") << index << " must be tensor of 128-bit complex or 64-bit complex or 16-bit float or 32-bit float or 64-bit float values, but got " << v.getType();
      }
      ++index;
    }
  }
  return Verify(*this);
}

void QrOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::QuantizeAndDequantizeOp definitions
//===----------------------------------------------------------------------===//

QuantizeAndDequantizeOpAdaptor::QuantizeAndDequantizeOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

QuantizeAndDequantizeOpAdaptor::QuantizeAndDequantizeOpAdaptor(QuantizeAndDequantizeOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> QuantizeAndDequantizeOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange QuantizeAndDequantizeOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value QuantizeAndDequantizeOpAdaptor::input() {
  return *getODSOperands(0).begin();
}

::mlir::BoolAttr QuantizeAndDequantizeOpAdaptor::signed_input() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::BoolAttr attr = odsAttrs.get("signed_input").dyn_cast_or_null<::mlir::BoolAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getBoolAttr(true);
  return attr;
}

::mlir::IntegerAttr QuantizeAndDequantizeOpAdaptor::num_bits() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::IntegerAttr attr = odsAttrs.get("num_bits").dyn_cast_or_null<::mlir::IntegerAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getIntegerAttr(::mlir::Builder(odsAttrs.getContext()).getIntegerType(64), 8);
  return attr;
}

::mlir::BoolAttr QuantizeAndDequantizeOpAdaptor::range_given() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::BoolAttr attr = odsAttrs.get("range_given").dyn_cast_or_null<::mlir::BoolAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getBoolAttr(false);
  return attr;
}

::mlir::FloatAttr QuantizeAndDequantizeOpAdaptor::input_min() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::FloatAttr attr = odsAttrs.get("input_min").dyn_cast_or_null<::mlir::FloatAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getFloatAttr(::mlir::Builder(odsAttrs.getContext()).getF32Type(), 0.0f);
  return attr;
}

::mlir::FloatAttr QuantizeAndDequantizeOpAdaptor::input_max() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::FloatAttr attr = odsAttrs.get("input_max").dyn_cast_or_null<::mlir::FloatAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getFloatAttr(::mlir::Builder(odsAttrs.getContext()).getF32Type(), 0.0f);
  return attr;
}

::mlir::LogicalResult QuantizeAndDequantizeOpAdaptor::verify(::mlir::Location loc) {
  {
  auto tblgen_signed_input = odsAttrs.get("signed_input");
  if (tblgen_signed_input) {
    if (!((tblgen_signed_input.isa<::mlir::BoolAttr>()))) return emitError(loc, "'tf.QuantizeAndDequantize' op ""attribute 'signed_input' failed to satisfy constraint: bool attribute");
  }
  }
  {
  auto tblgen_num_bits = odsAttrs.get("num_bits");
  if (tblgen_num_bits) {
    if (!(((tblgen_num_bits.isa<::mlir::IntegerAttr>())) && ((tblgen_num_bits.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(64))))) return emitError(loc, "'tf.QuantizeAndDequantize' op ""attribute 'num_bits' failed to satisfy constraint: 64-bit signless integer attribute");
  }
  }
  {
  auto tblgen_range_given = odsAttrs.get("range_given");
  if (tblgen_range_given) {
    if (!((tblgen_range_given.isa<::mlir::BoolAttr>()))) return emitError(loc, "'tf.QuantizeAndDequantize' op ""attribute 'range_given' failed to satisfy constraint: bool attribute");
  }
  }
  {
  auto tblgen_input_min = odsAttrs.get("input_min");
  if (tblgen_input_min) {
    if (!(((tblgen_input_min.isa<::mlir::FloatAttr>())) && ((tblgen_input_min.cast<::mlir::FloatAttr>().getType().isF32())))) return emitError(loc, "'tf.QuantizeAndDequantize' op ""attribute 'input_min' failed to satisfy constraint: 32-bit float attribute");
  }
  }
  {
  auto tblgen_input_max = odsAttrs.get("input_max");
  if (tblgen_input_max) {
    if (!(((tblgen_input_max.isa<::mlir::FloatAttr>())) && ((tblgen_input_max.cast<::mlir::FloatAttr>().getType().isF32())))) return emitError(loc, "'tf.QuantizeAndDequantize' op ""attribute 'input_max' failed to satisfy constraint: 32-bit float attribute");
  }
  }
  return ::mlir::success();
}

::llvm::StringRef QuantizeAndDequantizeOp::getOperationName() {
  return "tf.QuantizeAndDequantize";
}

std::pair<unsigned, unsigned> QuantizeAndDequantizeOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range QuantizeAndDequantizeOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value QuantizeAndDequantizeOp::input() {
  return *getODSOperands(0).begin();
}

::mlir::MutableOperandRange QuantizeAndDequantizeOp::inputMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> QuantizeAndDequantizeOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range QuantizeAndDequantizeOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value QuantizeAndDequantizeOp::output() {
  return *getODSResults(0).begin();
}

::mlir::BoolAttr QuantizeAndDequantizeOp::signed_inputAttr() {
  return this->getAttr("signed_input").dyn_cast_or_null<::mlir::BoolAttr>();
}

bool QuantizeAndDequantizeOp::signed_input() {
  auto attr = signed_inputAttr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getBoolAttr(true).getValue();
  return attr.getValue();
}

::mlir::IntegerAttr QuantizeAndDequantizeOp::num_bitsAttr() {
  return this->getAttr("num_bits").dyn_cast_or_null<::mlir::IntegerAttr>();
}

uint64_t QuantizeAndDequantizeOp::num_bits() {
  auto attr = num_bitsAttr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getIntegerAttr(::mlir::Builder(this->getContext()).getIntegerType(64), 8).getValue().getZExtValue();
  return attr.getValue().getZExtValue();
}

::mlir::BoolAttr QuantizeAndDequantizeOp::range_givenAttr() {
  return this->getAttr("range_given").dyn_cast_or_null<::mlir::BoolAttr>();
}

bool QuantizeAndDequantizeOp::range_given() {
  auto attr = range_givenAttr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getBoolAttr(false).getValue();
  return attr.getValue();
}

::mlir::FloatAttr QuantizeAndDequantizeOp::input_minAttr() {
  return this->getAttr("input_min").dyn_cast_or_null<::mlir::FloatAttr>();
}

::llvm::APFloat QuantizeAndDequantizeOp::input_min() {
  auto attr = input_minAttr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getFloatAttr(::mlir::Builder(this->getContext()).getF32Type(), 0.0f).getValue();
  return attr.getValue();
}

::mlir::FloatAttr QuantizeAndDequantizeOp::input_maxAttr() {
  return this->getAttr("input_max").dyn_cast_or_null<::mlir::FloatAttr>();
}

::llvm::APFloat QuantizeAndDequantizeOp::input_max() {
  auto attr = input_maxAttr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getFloatAttr(::mlir::Builder(this->getContext()).getF32Type(), 0.0f).getValue();
  return attr.getValue();
}

Type QuantizeAndDequantizeOp::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

bool QuantizeAndDequantizeOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "T") return true;
 return false;
}

::mlir::DictionaryAttr QuantizeAndDequantizeOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())}
    }, ctx);
}

void QuantizeAndDequantizeOp::signed_inputAttr(::mlir::BoolAttr attr) {
  this->getOperation()->setAttr("signed_input", attr);
}

void QuantizeAndDequantizeOp::num_bitsAttr(::mlir::IntegerAttr attr) {
  this->getOperation()->setAttr("num_bits", attr);
}

void QuantizeAndDequantizeOp::range_givenAttr(::mlir::BoolAttr attr) {
  this->getOperation()->setAttr("range_given", attr);
}

void QuantizeAndDequantizeOp::input_minAttr(::mlir::FloatAttr attr) {
  this->getOperation()->setAttr("input_min", attr);
}

void QuantizeAndDequantizeOp::input_maxAttr(::mlir::FloatAttr attr) {
  this->getOperation()->setAttr("input_max", attr);
}

void QuantizeAndDequantizeOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value input, ::mlir::BoolAttr signed_input, ::mlir::IntegerAttr num_bits, ::mlir::BoolAttr range_given, ::mlir::FloatAttr input_min, ::mlir::FloatAttr input_max) {
  odsState.addOperands(input);
  odsState.addAttribute("signed_input", signed_input);
  odsState.addAttribute("num_bits", num_bits);
  odsState.addAttribute("range_given", range_given);
  odsState.addAttribute("input_min", input_min);
  odsState.addAttribute("input_max", input_max);
  odsState.addTypes(output);
}

void QuantizeAndDequantizeOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input, ::mlir::BoolAttr signed_input, ::mlir::IntegerAttr num_bits, ::mlir::BoolAttr range_given, ::mlir::FloatAttr input_min, ::mlir::FloatAttr input_max) {
  odsState.addOperands(input);
  odsState.addAttribute("signed_input", signed_input);
  odsState.addAttribute("num_bits", num_bits);
  odsState.addAttribute("range_given", range_given);
  odsState.addAttribute("input_min", input_min);
  odsState.addAttribute("input_max", input_max);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void QuantizeAndDequantizeOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value input, bool signed_input, uint64_t num_bits, bool range_given, ::llvm::APFloat input_min, ::llvm::APFloat input_max) {
  odsState.addOperands(input);
  odsState.addAttribute("signed_input", odsBuilder.getBoolAttr(signed_input));
  odsState.addAttribute("num_bits", odsBuilder.getIntegerAttr(odsBuilder.getIntegerType(64), num_bits));
  odsState.addAttribute("range_given", odsBuilder.getBoolAttr(range_given));
  odsState.addAttribute("input_min", odsBuilder.getFloatAttr(odsBuilder.getF32Type(), input_min));
  odsState.addAttribute("input_max", odsBuilder.getFloatAttr(odsBuilder.getF32Type(), input_max));
  odsState.addTypes(output);
}

void QuantizeAndDequantizeOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input, bool signed_input, uint64_t num_bits, bool range_given, ::llvm::APFloat input_min, ::llvm::APFloat input_max) {
  odsState.addOperands(input);
  odsState.addAttribute("signed_input", odsBuilder.getBoolAttr(signed_input));
  odsState.addAttribute("num_bits", odsBuilder.getIntegerAttr(odsBuilder.getIntegerType(64), num_bits));
  odsState.addAttribute("range_given", odsBuilder.getBoolAttr(range_given));
  odsState.addAttribute("input_min", odsBuilder.getFloatAttr(odsBuilder.getF32Type(), input_min));
  odsState.addAttribute("input_max", odsBuilder.getFloatAttr(odsBuilder.getF32Type(), input_max));
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void QuantizeAndDequantizeOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

void QuantizeAndDequantizeOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value input, ::mlir::BoolAttr signed_input, ::mlir::IntegerAttr num_bits, ::mlir::BoolAttr range_given, ::mlir::FloatAttr input_min, ::mlir::FloatAttr input_max) {
  odsState.addOperands(input);
  odsState.addAttribute("signed_input", signed_input);
  odsState.addAttribute("num_bits", num_bits);
  odsState.addAttribute("range_given", range_given);
  odsState.addAttribute("input_min", input_min);
  odsState.addAttribute("input_max", input_max);
  odsState.addTypes({input.getType()});

}

void QuantizeAndDequantizeOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  odsState.addTypes({operands[0].getType()});

}

::mlir::LogicalResult QuantizeAndDequantizeOp::verify() {
  if (failed(QuantizeAndDequantizeOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of floating-point values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))))) {
        return emitOpError("result #") << index << " must be tensor of floating-point values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void QuantizeAndDequantizeOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::QuantizeAndDequantizeV2Op definitions
//===----------------------------------------------------------------------===//

QuantizeAndDequantizeV2OpAdaptor::QuantizeAndDequantizeV2OpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

QuantizeAndDequantizeV2OpAdaptor::QuantizeAndDequantizeV2OpAdaptor(QuantizeAndDequantizeV2Op&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> QuantizeAndDequantizeV2OpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange QuantizeAndDequantizeV2OpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value QuantizeAndDequantizeV2OpAdaptor::input() {
  return *getODSOperands(0).begin();
}

::mlir::Value QuantizeAndDequantizeV2OpAdaptor::input_min() {
  return *getODSOperands(1).begin();
}

::mlir::Value QuantizeAndDequantizeV2OpAdaptor::input_max() {
  return *getODSOperands(2).begin();
}

::mlir::BoolAttr QuantizeAndDequantizeV2OpAdaptor::signed_input() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::BoolAttr attr = odsAttrs.get("signed_input").dyn_cast_or_null<::mlir::BoolAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getBoolAttr(true);
  return attr;
}

::mlir::IntegerAttr QuantizeAndDequantizeV2OpAdaptor::num_bits() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::IntegerAttr attr = odsAttrs.get("num_bits").dyn_cast_or_null<::mlir::IntegerAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getIntegerAttr(::mlir::Builder(odsAttrs.getContext()).getIntegerType(64), 8);
  return attr;
}

::mlir::BoolAttr QuantizeAndDequantizeV2OpAdaptor::range_given() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::BoolAttr attr = odsAttrs.get("range_given").dyn_cast_or_null<::mlir::BoolAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getBoolAttr(false);
  return attr;
}

::mlir::StringAttr QuantizeAndDequantizeV2OpAdaptor::round_mode() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::StringAttr attr = odsAttrs.get("round_mode").dyn_cast_or_null<::mlir::StringAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getStringAttr("HALF_TO_EVEN");
  return attr;
}

::mlir::BoolAttr QuantizeAndDequantizeV2OpAdaptor::narrow_range() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::BoolAttr attr = odsAttrs.get("narrow_range").dyn_cast_or_null<::mlir::BoolAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getBoolAttr(false);
  return attr;
}

::mlir::IntegerAttr QuantizeAndDequantizeV2OpAdaptor::axis() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::IntegerAttr attr = odsAttrs.get("axis").dyn_cast_or_null<::mlir::IntegerAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getIntegerAttr(::mlir::Builder(odsAttrs.getContext()).getIntegerType(64), -1);
  return attr;
}

::mlir::LogicalResult QuantizeAndDequantizeV2OpAdaptor::verify(::mlir::Location loc) {
  {
  auto tblgen_signed_input = odsAttrs.get("signed_input");
  if (tblgen_signed_input) {
    if (!((tblgen_signed_input.isa<::mlir::BoolAttr>()))) return emitError(loc, "'tf.QuantizeAndDequantizeV2' op ""attribute 'signed_input' failed to satisfy constraint: bool attribute");
  }
  }
  {
  auto tblgen_num_bits = odsAttrs.get("num_bits");
  if (tblgen_num_bits) {
    if (!(((tblgen_num_bits.isa<::mlir::IntegerAttr>())) && ((tblgen_num_bits.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(64))))) return emitError(loc, "'tf.QuantizeAndDequantizeV2' op ""attribute 'num_bits' failed to satisfy constraint: 64-bit signless integer attribute");
  }
  }
  {
  auto tblgen_range_given = odsAttrs.get("range_given");
  if (tblgen_range_given) {
    if (!((tblgen_range_given.isa<::mlir::BoolAttr>()))) return emitError(loc, "'tf.QuantizeAndDequantizeV2' op ""attribute 'range_given' failed to satisfy constraint: bool attribute");
  }
  }
  {
  auto tblgen_round_mode = odsAttrs.get("round_mode");
  if (tblgen_round_mode) {
    if (!((tblgen_round_mode.cast<StringAttr>().getValue() == "HALF_TO_EVEN" || tblgen_round_mode.cast<StringAttr>().getValue() == "HALF_UP"))) return emitError(loc, "'tf.QuantizeAndDequantizeV2' op ""attribute 'round_mode' failed to satisfy constraint: string attribute whose value is HALF_TO_EVEN, or HALF_UP");
  }
  }
  {
  auto tblgen_narrow_range = odsAttrs.get("narrow_range");
  if (tblgen_narrow_range) {
    if (!((tblgen_narrow_range.isa<::mlir::BoolAttr>()))) return emitError(loc, "'tf.QuantizeAndDequantizeV2' op ""attribute 'narrow_range' failed to satisfy constraint: bool attribute");
  }
  }
  {
  auto tblgen_axis = odsAttrs.get("axis");
  if (tblgen_axis) {
    if (!(((tblgen_axis.isa<::mlir::IntegerAttr>())) && ((tblgen_axis.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(64))))) return emitError(loc, "'tf.QuantizeAndDequantizeV2' op ""attribute 'axis' failed to satisfy constraint: 64-bit signless integer attribute");
  }
  }
  return ::mlir::success();
}

::llvm::StringRef QuantizeAndDequantizeV2Op::getOperationName() {
  return "tf.QuantizeAndDequantizeV2";
}

std::pair<unsigned, unsigned> QuantizeAndDequantizeV2Op::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range QuantizeAndDequantizeV2Op::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value QuantizeAndDequantizeV2Op::input() {
  return *getODSOperands(0).begin();
}

::mlir::Value QuantizeAndDequantizeV2Op::input_min() {
  return *getODSOperands(1).begin();
}

::mlir::Value QuantizeAndDequantizeV2Op::input_max() {
  return *getODSOperands(2).begin();
}

::mlir::MutableOperandRange QuantizeAndDequantizeV2Op::inputMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange QuantizeAndDequantizeV2Op::input_minMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange QuantizeAndDequantizeV2Op::input_maxMutable() {
  auto range = getODSOperandIndexAndLength(2);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> QuantizeAndDequantizeV2Op::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range QuantizeAndDequantizeV2Op::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value QuantizeAndDequantizeV2Op::output() {
  return *getODSResults(0).begin();
}

::mlir::BoolAttr QuantizeAndDequantizeV2Op::signed_inputAttr() {
  return this->getAttr("signed_input").dyn_cast_or_null<::mlir::BoolAttr>();
}

bool QuantizeAndDequantizeV2Op::signed_input() {
  auto attr = signed_inputAttr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getBoolAttr(true).getValue();
  return attr.getValue();
}

::mlir::IntegerAttr QuantizeAndDequantizeV2Op::num_bitsAttr() {
  return this->getAttr("num_bits").dyn_cast_or_null<::mlir::IntegerAttr>();
}

uint64_t QuantizeAndDequantizeV2Op::num_bits() {
  auto attr = num_bitsAttr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getIntegerAttr(::mlir::Builder(this->getContext()).getIntegerType(64), 8).getValue().getZExtValue();
  return attr.getValue().getZExtValue();
}

::mlir::BoolAttr QuantizeAndDequantizeV2Op::range_givenAttr() {
  return this->getAttr("range_given").dyn_cast_or_null<::mlir::BoolAttr>();
}

bool QuantizeAndDequantizeV2Op::range_given() {
  auto attr = range_givenAttr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getBoolAttr(false).getValue();
  return attr.getValue();
}

::mlir::StringAttr QuantizeAndDequantizeV2Op::round_modeAttr() {
  return this->getAttr("round_mode").dyn_cast_or_null<::mlir::StringAttr>();
}

::llvm::StringRef QuantizeAndDequantizeV2Op::round_mode() {
  auto attr = round_modeAttr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getStringAttr("HALF_TO_EVEN").getValue();
  return attr.getValue();
}

::mlir::BoolAttr QuantizeAndDequantizeV2Op::narrow_rangeAttr() {
  return this->getAttr("narrow_range").dyn_cast_or_null<::mlir::BoolAttr>();
}

bool QuantizeAndDequantizeV2Op::narrow_range() {
  auto attr = narrow_rangeAttr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getBoolAttr(false).getValue();
  return attr.getValue();
}

::mlir::IntegerAttr QuantizeAndDequantizeV2Op::axisAttr() {
  return this->getAttr("axis").dyn_cast_or_null<::mlir::IntegerAttr>();
}

uint64_t QuantizeAndDequantizeV2Op::axis() {
  auto attr = axisAttr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getIntegerAttr(::mlir::Builder(this->getContext()).getIntegerType(64), -1).getValue().getZExtValue();
  return attr.getValue().getZExtValue();
}

Type QuantizeAndDequantizeV2Op::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

bool QuantizeAndDequantizeV2Op::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "T") return true;
 return false;
}

::mlir::DictionaryAttr QuantizeAndDequantizeV2Op::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())}
    }, ctx);
}

void QuantizeAndDequantizeV2Op::signed_inputAttr(::mlir::BoolAttr attr) {
  this->getOperation()->setAttr("signed_input", attr);
}

void QuantizeAndDequantizeV2Op::num_bitsAttr(::mlir::IntegerAttr attr) {
  this->getOperation()->setAttr("num_bits", attr);
}

void QuantizeAndDequantizeV2Op::range_givenAttr(::mlir::BoolAttr attr) {
  this->getOperation()->setAttr("range_given", attr);
}

void QuantizeAndDequantizeV2Op::round_modeAttr(::mlir::StringAttr attr) {
  this->getOperation()->setAttr("round_mode", attr);
}

void QuantizeAndDequantizeV2Op::narrow_rangeAttr(::mlir::BoolAttr attr) {
  this->getOperation()->setAttr("narrow_range", attr);
}

void QuantizeAndDequantizeV2Op::axisAttr(::mlir::IntegerAttr attr) {
  this->getOperation()->setAttr("axis", attr);
}

void QuantizeAndDequantizeV2Op::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value input, ::mlir::Value input_min, ::mlir::Value input_max, ::mlir::BoolAttr signed_input, ::mlir::IntegerAttr num_bits, ::mlir::BoolAttr range_given, ::mlir::StringAttr round_mode, ::mlir::BoolAttr narrow_range, ::mlir::IntegerAttr axis) {
  odsState.addOperands(input);
  odsState.addOperands(input_min);
  odsState.addOperands(input_max);
  odsState.addAttribute("signed_input", signed_input);
  odsState.addAttribute("num_bits", num_bits);
  odsState.addAttribute("range_given", range_given);
  odsState.addAttribute("round_mode", round_mode);
  odsState.addAttribute("narrow_range", narrow_range);
  odsState.addAttribute("axis", axis);
  odsState.addTypes(output);
}

void QuantizeAndDequantizeV2Op::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input, ::mlir::Value input_min, ::mlir::Value input_max, ::mlir::BoolAttr signed_input, ::mlir::IntegerAttr num_bits, ::mlir::BoolAttr range_given, ::mlir::StringAttr round_mode, ::mlir::BoolAttr narrow_range, ::mlir::IntegerAttr axis) {
  odsState.addOperands(input);
  odsState.addOperands(input_min);
  odsState.addOperands(input_max);
  odsState.addAttribute("signed_input", signed_input);
  odsState.addAttribute("num_bits", num_bits);
  odsState.addAttribute("range_given", range_given);
  odsState.addAttribute("round_mode", round_mode);
  odsState.addAttribute("narrow_range", narrow_range);
  odsState.addAttribute("axis", axis);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void QuantizeAndDequantizeV2Op::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value input, ::mlir::Value input_min, ::mlir::Value input_max, bool signed_input, uint64_t num_bits, bool range_given, ::llvm::StringRef round_mode, bool narrow_range, uint64_t axis) {
  odsState.addOperands(input);
  odsState.addOperands(input_min);
  odsState.addOperands(input_max);
  odsState.addAttribute("signed_input", odsBuilder.getBoolAttr(signed_input));
  odsState.addAttribute("num_bits", odsBuilder.getIntegerAttr(odsBuilder.getIntegerType(64), num_bits));
  odsState.addAttribute("range_given", odsBuilder.getBoolAttr(range_given));
  odsState.addAttribute("round_mode", odsBuilder.getStringAttr(round_mode));
  odsState.addAttribute("narrow_range", odsBuilder.getBoolAttr(narrow_range));
  odsState.addAttribute("axis", odsBuilder.getIntegerAttr(odsBuilder.getIntegerType(64), axis));
  odsState.addTypes(output);
}

void QuantizeAndDequantizeV2Op::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input, ::mlir::Value input_min, ::mlir::Value input_max, bool signed_input, uint64_t num_bits, bool range_given, ::llvm::StringRef round_mode, bool narrow_range, uint64_t axis) {
  odsState.addOperands(input);
  odsState.addOperands(input_min);
  odsState.addOperands(input_max);
  odsState.addAttribute("signed_input", odsBuilder.getBoolAttr(signed_input));
  odsState.addAttribute("num_bits", odsBuilder.getIntegerAttr(odsBuilder.getIntegerType(64), num_bits));
  odsState.addAttribute("range_given", odsBuilder.getBoolAttr(range_given));
  odsState.addAttribute("round_mode", odsBuilder.getStringAttr(round_mode));
  odsState.addAttribute("narrow_range", odsBuilder.getBoolAttr(narrow_range));
  odsState.addAttribute("axis", odsBuilder.getIntegerAttr(odsBuilder.getIntegerType(64), axis));
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void QuantizeAndDequantizeV2Op::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 3u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult QuantizeAndDequantizeV2Op::verify() {
  if (failed(QuantizeAndDequantizeV2OpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of floating-point values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of floating-point values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup2 = getODSOperands(2);
    for (::mlir::Value v : valueGroup2) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of floating-point values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))))) {
        return emitOpError("result #") << index << " must be tensor of floating-point values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void QuantizeAndDequantizeV2Op::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::QuantizeAndDequantizeV3Op definitions
//===----------------------------------------------------------------------===//

QuantizeAndDequantizeV3OpAdaptor::QuantizeAndDequantizeV3OpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

QuantizeAndDequantizeV3OpAdaptor::QuantizeAndDequantizeV3OpAdaptor(QuantizeAndDequantizeV3Op&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> QuantizeAndDequantizeV3OpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange QuantizeAndDequantizeV3OpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value QuantizeAndDequantizeV3OpAdaptor::input() {
  return *getODSOperands(0).begin();
}

::mlir::Value QuantizeAndDequantizeV3OpAdaptor::input_min() {
  return *getODSOperands(1).begin();
}

::mlir::Value QuantizeAndDequantizeV3OpAdaptor::input_max() {
  return *getODSOperands(2).begin();
}

::mlir::Value QuantizeAndDequantizeV3OpAdaptor::num_bits() {
  return *getODSOperands(3).begin();
}

::mlir::BoolAttr QuantizeAndDequantizeV3OpAdaptor::signed_input() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::BoolAttr attr = odsAttrs.get("signed_input").dyn_cast_or_null<::mlir::BoolAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getBoolAttr(true);
  return attr;
}

::mlir::BoolAttr QuantizeAndDequantizeV3OpAdaptor::range_given() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::BoolAttr attr = odsAttrs.get("range_given").dyn_cast_or_null<::mlir::BoolAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getBoolAttr(true);
  return attr;
}

::mlir::BoolAttr QuantizeAndDequantizeV3OpAdaptor::narrow_range() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::BoolAttr attr = odsAttrs.get("narrow_range").dyn_cast_or_null<::mlir::BoolAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getBoolAttr(false);
  return attr;
}

::mlir::IntegerAttr QuantizeAndDequantizeV3OpAdaptor::axis() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::IntegerAttr attr = odsAttrs.get("axis").dyn_cast_or_null<::mlir::IntegerAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getIntegerAttr(::mlir::Builder(odsAttrs.getContext()).getIntegerType(64), -1);
  return attr;
}

::mlir::LogicalResult QuantizeAndDequantizeV3OpAdaptor::verify(::mlir::Location loc) {
  {
  auto tblgen_signed_input = odsAttrs.get("signed_input");
  if (tblgen_signed_input) {
    if (!((tblgen_signed_input.isa<::mlir::BoolAttr>()))) return emitError(loc, "'tf.QuantizeAndDequantizeV3' op ""attribute 'signed_input' failed to satisfy constraint: bool attribute");
  }
  }
  {
  auto tblgen_range_given = odsAttrs.get("range_given");
  if (tblgen_range_given) {
    if (!((tblgen_range_given.isa<::mlir::BoolAttr>()))) return emitError(loc, "'tf.QuantizeAndDequantizeV3' op ""attribute 'range_given' failed to satisfy constraint: bool attribute");
  }
  }
  {
  auto tblgen_narrow_range = odsAttrs.get("narrow_range");
  if (tblgen_narrow_range) {
    if (!((tblgen_narrow_range.isa<::mlir::BoolAttr>()))) return emitError(loc, "'tf.QuantizeAndDequantizeV3' op ""attribute 'narrow_range' failed to satisfy constraint: bool attribute");
  }
  }
  {
  auto tblgen_axis = odsAttrs.get("axis");
  if (tblgen_axis) {
    if (!(((tblgen_axis.isa<::mlir::IntegerAttr>())) && ((tblgen_axis.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(64))))) return emitError(loc, "'tf.QuantizeAndDequantizeV3' op ""attribute 'axis' failed to satisfy constraint: 64-bit signless integer attribute");
  }
  }
  return ::mlir::success();
}

::llvm::StringRef QuantizeAndDequantizeV3Op::getOperationName() {
  return "tf.QuantizeAndDequantizeV3";
}

std::pair<unsigned, unsigned> QuantizeAndDequantizeV3Op::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range QuantizeAndDequantizeV3Op::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value QuantizeAndDequantizeV3Op::input() {
  return *getODSOperands(0).begin();
}

::mlir::Value QuantizeAndDequantizeV3Op::input_min() {
  return *getODSOperands(1).begin();
}

::mlir::Value QuantizeAndDequantizeV3Op::input_max() {
  return *getODSOperands(2).begin();
}

::mlir::Value QuantizeAndDequantizeV3Op::num_bits() {
  return *getODSOperands(3).begin();
}

::mlir::MutableOperandRange QuantizeAndDequantizeV3Op::inputMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange QuantizeAndDequantizeV3Op::input_minMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange QuantizeAndDequantizeV3Op::input_maxMutable() {
  auto range = getODSOperandIndexAndLength(2);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange QuantizeAndDequantizeV3Op::num_bitsMutable() {
  auto range = getODSOperandIndexAndLength(3);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> QuantizeAndDequantizeV3Op::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range QuantizeAndDequantizeV3Op::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value QuantizeAndDequantizeV3Op::output() {
  return *getODSResults(0).begin();
}

::mlir::BoolAttr QuantizeAndDequantizeV3Op::signed_inputAttr() {
  return this->getAttr("signed_input").dyn_cast_or_null<::mlir::BoolAttr>();
}

bool QuantizeAndDequantizeV3Op::signed_input() {
  auto attr = signed_inputAttr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getBoolAttr(true).getValue();
  return attr.getValue();
}

::mlir::BoolAttr QuantizeAndDequantizeV3Op::range_givenAttr() {
  return this->getAttr("range_given").dyn_cast_or_null<::mlir::BoolAttr>();
}

bool QuantizeAndDequantizeV3Op::range_given() {
  auto attr = range_givenAttr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getBoolAttr(true).getValue();
  return attr.getValue();
}

::mlir::BoolAttr QuantizeAndDequantizeV3Op::narrow_rangeAttr() {
  return this->getAttr("narrow_range").dyn_cast_or_null<::mlir::BoolAttr>();
}

bool QuantizeAndDequantizeV3Op::narrow_range() {
  auto attr = narrow_rangeAttr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getBoolAttr(false).getValue();
  return attr.getValue();
}

::mlir::IntegerAttr QuantizeAndDequantizeV3Op::axisAttr() {
  return this->getAttr("axis").dyn_cast_or_null<::mlir::IntegerAttr>();
}

uint64_t QuantizeAndDequantizeV3Op::axis() {
  auto attr = axisAttr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getIntegerAttr(::mlir::Builder(this->getContext()).getIntegerType(64), -1).getValue().getZExtValue();
  return attr.getValue().getZExtValue();
}

Type QuantizeAndDequantizeV3Op::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

bool QuantizeAndDequantizeV3Op::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "T") return true;
 return false;
}

::mlir::DictionaryAttr QuantizeAndDequantizeV3Op::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())}
    }, ctx);
}

void QuantizeAndDequantizeV3Op::signed_inputAttr(::mlir::BoolAttr attr) {
  this->getOperation()->setAttr("signed_input", attr);
}

void QuantizeAndDequantizeV3Op::range_givenAttr(::mlir::BoolAttr attr) {
  this->getOperation()->setAttr("range_given", attr);
}

void QuantizeAndDequantizeV3Op::narrow_rangeAttr(::mlir::BoolAttr attr) {
  this->getOperation()->setAttr("narrow_range", attr);
}

void QuantizeAndDequantizeV3Op::axisAttr(::mlir::IntegerAttr attr) {
  this->getOperation()->setAttr("axis", attr);
}

void QuantizeAndDequantizeV3Op::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value input, ::mlir::Value input_min, ::mlir::Value input_max, ::mlir::Value num_bits, ::mlir::BoolAttr signed_input, ::mlir::BoolAttr range_given, ::mlir::BoolAttr narrow_range, ::mlir::IntegerAttr axis) {
  odsState.addOperands(input);
  odsState.addOperands(input_min);
  odsState.addOperands(input_max);
  odsState.addOperands(num_bits);
  odsState.addAttribute("signed_input", signed_input);
  odsState.addAttribute("range_given", range_given);
  odsState.addAttribute("narrow_range", narrow_range);
  odsState.addAttribute("axis", axis);
  odsState.addTypes(output);
}

void QuantizeAndDequantizeV3Op::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input, ::mlir::Value input_min, ::mlir::Value input_max, ::mlir::Value num_bits, ::mlir::BoolAttr signed_input, ::mlir::BoolAttr range_given, ::mlir::BoolAttr narrow_range, ::mlir::IntegerAttr axis) {
  odsState.addOperands(input);
  odsState.addOperands(input_min);
  odsState.addOperands(input_max);
  odsState.addOperands(num_bits);
  odsState.addAttribute("signed_input", signed_input);
  odsState.addAttribute("range_given", range_given);
  odsState.addAttribute("narrow_range", narrow_range);
  odsState.addAttribute("axis", axis);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void QuantizeAndDequantizeV3Op::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value input, ::mlir::Value input_min, ::mlir::Value input_max, ::mlir::Value num_bits, bool signed_input, bool range_given, bool narrow_range, uint64_t axis) {
  odsState.addOperands(input);
  odsState.addOperands(input_min);
  odsState.addOperands(input_max);
  odsState.addOperands(num_bits);
  odsState.addAttribute("signed_input", odsBuilder.getBoolAttr(signed_input));
  odsState.addAttribute("range_given", odsBuilder.getBoolAttr(range_given));
  odsState.addAttribute("narrow_range", odsBuilder.getBoolAttr(narrow_range));
  odsState.addAttribute("axis", odsBuilder.getIntegerAttr(odsBuilder.getIntegerType(64), axis));
  odsState.addTypes(output);
}

void QuantizeAndDequantizeV3Op::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input, ::mlir::Value input_min, ::mlir::Value input_max, ::mlir::Value num_bits, bool signed_input, bool range_given, bool narrow_range, uint64_t axis) {
  odsState.addOperands(input);
  odsState.addOperands(input_min);
  odsState.addOperands(input_max);
  odsState.addOperands(num_bits);
  odsState.addAttribute("signed_input", odsBuilder.getBoolAttr(signed_input));
  odsState.addAttribute("range_given", odsBuilder.getBoolAttr(range_given));
  odsState.addAttribute("narrow_range", odsBuilder.getBoolAttr(narrow_range));
  odsState.addAttribute("axis", odsBuilder.getIntegerAttr(odsBuilder.getIntegerType(64), axis));
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void QuantizeAndDequantizeV3Op::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 4u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult QuantizeAndDequantizeV3Op::verify() {
  if (failed(QuantizeAndDequantizeV3OpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of floating-point values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of floating-point values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup2 = getODSOperands(2);
    for (::mlir::Value v : valueGroup2) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of floating-point values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup3 = getODSOperands(3);
    for (::mlir::Value v : valueGroup3) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of 32-bit integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))))) {
        return emitOpError("result #") << index << " must be tensor of floating-point values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void QuantizeAndDequantizeV3Op::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::RFFT2DOp definitions
//===----------------------------------------------------------------------===//

RFFT2DOpAdaptor::RFFT2DOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

RFFT2DOpAdaptor::RFFT2DOpAdaptor(RFFT2DOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> RFFT2DOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange RFFT2DOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value RFFT2DOpAdaptor::input() {
  return *getODSOperands(0).begin();
}

::mlir::Value RFFT2DOpAdaptor::fft_length() {
  return *getODSOperands(1).begin();
}

::mlir::LogicalResult RFFT2DOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

::llvm::StringRef RFFT2DOp::getOperationName() {
  return "tf.RFFT2D";
}

std::pair<unsigned, unsigned> RFFT2DOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range RFFT2DOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value RFFT2DOp::input() {
  return *getODSOperands(0).begin();
}

::mlir::Value RFFT2DOp::fft_length() {
  return *getODSOperands(1).begin();
}

::mlir::MutableOperandRange RFFT2DOp::inputMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange RFFT2DOp::fft_lengthMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> RFFT2DOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range RFFT2DOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value RFFT2DOp::output() {
  return *getODSResults(0).begin();
}

Type RFFT2DOp::Treal() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

Type RFFT2DOp::Tcomplex() {
  return mlir::getElementTypeOrSelf(*getODSResults(0).begin());
}

bool RFFT2DOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "Treal") return true;
  if (name == "Tcomplex") return true;
 return false;
}

::mlir::DictionaryAttr RFFT2DOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("Treal", ctx),
::mlir::TypeAttr::get(Treal())},
    {::mlir::Identifier::get("Tcomplex", ctx),
::mlir::TypeAttr::get(Tcomplex())}
    }, ctx);
}

void RFFT2DOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value input, ::mlir::Value fft_length) {
  odsState.addOperands(input);
  odsState.addOperands(fft_length);
  odsState.addTypes(output);
}

void RFFT2DOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input, ::mlir::Value fft_length) {
  odsState.addOperands(input);
  odsState.addOperands(fft_length);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void RFFT2DOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult RFFT2DOp::verify() {
  if (failed(RFFT2DOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of 32/64-bit float values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of 32-bit integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>())))))) {
        return emitOpError("result #") << index << " must be tensor of 128-bit complex or 64-bit complex values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void RFFT2DOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::RFFT3DOp definitions
//===----------------------------------------------------------------------===//

RFFT3DOpAdaptor::RFFT3DOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

RFFT3DOpAdaptor::RFFT3DOpAdaptor(RFFT3DOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> RFFT3DOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange RFFT3DOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value RFFT3DOpAdaptor::input() {
  return *getODSOperands(0).begin();
}

::mlir::Value RFFT3DOpAdaptor::fft_length() {
  return *getODSOperands(1).begin();
}

::mlir::LogicalResult RFFT3DOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

::llvm::StringRef RFFT3DOp::getOperationName() {
  return "tf.RFFT3D";
}

std::pair<unsigned, unsigned> RFFT3DOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range RFFT3DOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value RFFT3DOp::input() {
  return *getODSOperands(0).begin();
}

::mlir::Value RFFT3DOp::fft_length() {
  return *getODSOperands(1).begin();
}

::mlir::MutableOperandRange RFFT3DOp::inputMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange RFFT3DOp::fft_lengthMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> RFFT3DOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range RFFT3DOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value RFFT3DOp::output() {
  return *getODSResults(0).begin();
}

Type RFFT3DOp::Treal() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

Type RFFT3DOp::Tcomplex() {
  return mlir::getElementTypeOrSelf(*getODSResults(0).begin());
}

bool RFFT3DOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "Treal") return true;
  if (name == "Tcomplex") return true;
 return false;
}

::mlir::DictionaryAttr RFFT3DOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("Treal", ctx),
::mlir::TypeAttr::get(Treal())},
    {::mlir::Identifier::get("Tcomplex", ctx),
::mlir::TypeAttr::get(Tcomplex())}
    }, ctx);
}

void RFFT3DOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value input, ::mlir::Value fft_length) {
  odsState.addOperands(input);
  odsState.addOperands(fft_length);
  odsState.addTypes(output);
}

void RFFT3DOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input, ::mlir::Value fft_length) {
  odsState.addOperands(input);
  odsState.addOperands(fft_length);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void RFFT3DOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult RFFT3DOp::verify() {
  if (failed(RFFT3DOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of 32/64-bit float values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of 32-bit integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>())))))) {
        return emitOpError("result #") << index << " must be tensor of 128-bit complex or 64-bit complex values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void RFFT3DOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::RFFTOp definitions
//===----------------------------------------------------------------------===//

RFFTOpAdaptor::RFFTOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

RFFTOpAdaptor::RFFTOpAdaptor(RFFTOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> RFFTOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange RFFTOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value RFFTOpAdaptor::input() {
  return *getODSOperands(0).begin();
}

::mlir::Value RFFTOpAdaptor::fft_length() {
  return *getODSOperands(1).begin();
}

::mlir::LogicalResult RFFTOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

::llvm::StringRef RFFTOp::getOperationName() {
  return "tf.RFFT";
}

std::pair<unsigned, unsigned> RFFTOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range RFFTOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value RFFTOp::input() {
  return *getODSOperands(0).begin();
}

::mlir::Value RFFTOp::fft_length() {
  return *getODSOperands(1).begin();
}

::mlir::MutableOperandRange RFFTOp::inputMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange RFFTOp::fft_lengthMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> RFFTOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range RFFTOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value RFFTOp::output() {
  return *getODSResults(0).begin();
}

Type RFFTOp::Treal() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

Type RFFTOp::Tcomplex() {
  return mlir::getElementTypeOrSelf(*getODSResults(0).begin());
}

bool RFFTOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "Treal") return true;
  if (name == "Tcomplex") return true;
 return false;
}

::mlir::DictionaryAttr RFFTOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("Treal", ctx),
::mlir::TypeAttr::get(Treal())},
    {::mlir::Identifier::get("Tcomplex", ctx),
::mlir::TypeAttr::get(Tcomplex())}
    }, ctx);
}

void RFFTOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value input, ::mlir::Value fft_length) {
  odsState.addOperands(input);
  odsState.addOperands(fft_length);
  odsState.addTypes(output);
}

void RFFTOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input, ::mlir::Value fft_length) {
  odsState.addOperands(input);
  odsState.addOperands(fft_length);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void RFFTOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult RFFTOp::verify() {
  if (failed(RFFTOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of 32/64-bit float values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of 32-bit integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>())))))) {
        return emitOpError("result #") << index << " must be tensor of 128-bit complex or 64-bit complex values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void RFFTOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::RGBToHSVOp definitions
//===----------------------------------------------------------------------===//

RGBToHSVOpAdaptor::RGBToHSVOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

RGBToHSVOpAdaptor::RGBToHSVOpAdaptor(RGBToHSVOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> RGBToHSVOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange RGBToHSVOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value RGBToHSVOpAdaptor::images() {
  return *getODSOperands(0).begin();
}

::mlir::LogicalResult RGBToHSVOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

::llvm::StringRef RGBToHSVOp::getOperationName() {
  return "tf.RGBToHSV";
}

std::pair<unsigned, unsigned> RGBToHSVOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range RGBToHSVOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value RGBToHSVOp::images() {
  return *getODSOperands(0).begin();
}

::mlir::MutableOperandRange RGBToHSVOp::imagesMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> RGBToHSVOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range RGBToHSVOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value RGBToHSVOp::output() {
  return *getODSResults(0).begin();
}

Type RGBToHSVOp::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

bool RGBToHSVOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "T") return true;
 return false;
}

::mlir::DictionaryAttr RGBToHSVOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())}
    }, ctx);
}

void RGBToHSVOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value images) {
  odsState.addOperands(images);
  odsState.addTypes(output);
}

void RGBToHSVOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value images) {
  odsState.addOperands(images);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void RGBToHSVOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult RGBToHSVOp::verify() {
  if (failed(RGBToHSVOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of floating-point values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))))) {
        return emitOpError("result #") << index << " must be tensor of floating-point values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void RGBToHSVOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::RandomGammaGradOp definitions
//===----------------------------------------------------------------------===//

RandomGammaGradOpAdaptor::RandomGammaGradOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

RandomGammaGradOpAdaptor::RandomGammaGradOpAdaptor(RandomGammaGradOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> RandomGammaGradOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange RandomGammaGradOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value RandomGammaGradOpAdaptor::alpha() {
  return *getODSOperands(0).begin();
}

::mlir::Value RandomGammaGradOpAdaptor::sample() {
  return *getODSOperands(1).begin();
}

::mlir::LogicalResult RandomGammaGradOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

::llvm::StringRef RandomGammaGradOp::getOperationName() {
  return "tf.RandomGammaGrad";
}

std::pair<unsigned, unsigned> RandomGammaGradOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range RandomGammaGradOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value RandomGammaGradOp::alpha() {
  return *getODSOperands(0).begin();
}

::mlir::Value RandomGammaGradOp::sample() {
  return *getODSOperands(1).begin();
}

::mlir::MutableOperandRange RandomGammaGradOp::alphaMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange RandomGammaGradOp::sampleMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> RandomGammaGradOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range RandomGammaGradOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value RandomGammaGradOp::output() {
  return *getODSResults(0).begin();
}

Type RandomGammaGradOp::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

bool RandomGammaGradOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "T") return true;
 return false;
}

::mlir::DictionaryAttr RandomGammaGradOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())}
    }, ctx);
}

void RandomGammaGradOp::build(OpBuilder &builder, OperationState &result, Value  x, Value  y) {
  auto resultType =
      OpTrait::util::getBroadcastedType(x.getType(), y.getType());
  if (!resultType)
    mlir::emitError(result.location, "non-broadcastable operands");
  return build(builder, result, resultType, x, y);
}

void RandomGammaGradOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value alpha, ::mlir::Value sample) {
  odsState.addOperands(alpha);
  odsState.addOperands(sample);
  odsState.addTypes(output);
}

void RandomGammaGradOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value alpha, ::mlir::Value sample) {
  odsState.addOperands(alpha);
  odsState.addOperands(sample);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void RandomGammaGradOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult RandomGammaGradOp::verify() {
  if (failed(RandomGammaGradOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of 32/64-bit float values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of 32/64-bit float values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())))))) {
        return emitOpError("result #") << index << " must be tensor of 32/64-bit float values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void RandomGammaGradOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::RandomGammaOp definitions
//===----------------------------------------------------------------------===//

RandomGammaOpAdaptor::RandomGammaOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

RandomGammaOpAdaptor::RandomGammaOpAdaptor(RandomGammaOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> RandomGammaOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange RandomGammaOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value RandomGammaOpAdaptor::shape() {
  return *getODSOperands(0).begin();
}

::mlir::Value RandomGammaOpAdaptor::alpha() {
  return *getODSOperands(1).begin();
}

::mlir::IntegerAttr RandomGammaOpAdaptor::seed() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::IntegerAttr attr = odsAttrs.get("seed").dyn_cast_or_null<::mlir::IntegerAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getIntegerAttr(::mlir::Builder(odsAttrs.getContext()).getIntegerType(64), 0);
  return attr;
}

::mlir::IntegerAttr RandomGammaOpAdaptor::seed2() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::IntegerAttr attr = odsAttrs.get("seed2").dyn_cast_or_null<::mlir::IntegerAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getIntegerAttr(::mlir::Builder(odsAttrs.getContext()).getIntegerType(64), 0);
  return attr;
}

::mlir::LogicalResult RandomGammaOpAdaptor::verify(::mlir::Location loc) {
  {
  auto tblgen_seed = odsAttrs.get("seed");
  if (tblgen_seed) {
    if (!(((tblgen_seed.isa<::mlir::IntegerAttr>())) && ((tblgen_seed.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(64))))) return emitError(loc, "'tf.RandomGamma' op ""attribute 'seed' failed to satisfy constraint: 64-bit signless integer attribute");
  }
  }
  {
  auto tblgen_seed2 = odsAttrs.get("seed2");
  if (tblgen_seed2) {
    if (!(((tblgen_seed2.isa<::mlir::IntegerAttr>())) && ((tblgen_seed2.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(64))))) return emitError(loc, "'tf.RandomGamma' op ""attribute 'seed2' failed to satisfy constraint: 64-bit signless integer attribute");
  }
  }
  return ::mlir::success();
}

::llvm::StringRef RandomGammaOp::getOperationName() {
  return "tf.RandomGamma";
}

std::pair<unsigned, unsigned> RandomGammaOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range RandomGammaOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value RandomGammaOp::shape() {
  return *getODSOperands(0).begin();
}

::mlir::Value RandomGammaOp::alpha() {
  return *getODSOperands(1).begin();
}

::mlir::MutableOperandRange RandomGammaOp::shapeMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange RandomGammaOp::alphaMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> RandomGammaOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range RandomGammaOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value RandomGammaOp::output() {
  return *getODSResults(0).begin();
}

::mlir::IntegerAttr RandomGammaOp::seedAttr() {
  return this->getAttr("seed").dyn_cast_or_null<::mlir::IntegerAttr>();
}

uint64_t RandomGammaOp::seed() {
  auto attr = seedAttr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getIntegerAttr(::mlir::Builder(this->getContext()).getIntegerType(64), 0).getValue().getZExtValue();
  return attr.getValue().getZExtValue();
}

::mlir::IntegerAttr RandomGammaOp::seed2Attr() {
  return this->getAttr("seed2").dyn_cast_or_null<::mlir::IntegerAttr>();
}

uint64_t RandomGammaOp::seed2() {
  auto attr = seed2Attr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getIntegerAttr(::mlir::Builder(this->getContext()).getIntegerType(64), 0).getValue().getZExtValue();
  return attr.getValue().getZExtValue();
}

Type RandomGammaOp::S() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

Type RandomGammaOp::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(1).begin());
}

bool RandomGammaOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "S") return true;
  if (name == "T") return true;
 return false;
}

::mlir::DictionaryAttr RandomGammaOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("S", ctx),
::mlir::TypeAttr::get(S())},
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())}
    }, ctx);
}

void RandomGammaOp::seedAttr(::mlir::IntegerAttr attr) {
  this->getOperation()->setAttr("seed", attr);
}

void RandomGammaOp::seed2Attr(::mlir::IntegerAttr attr) {
  this->getOperation()->setAttr("seed2", attr);
}

void RandomGammaOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value shape, ::mlir::Value alpha, ::mlir::IntegerAttr seed, ::mlir::IntegerAttr seed2) {
  odsState.addOperands(shape);
  odsState.addOperands(alpha);
  odsState.addAttribute("seed", seed);
  odsState.addAttribute("seed2", seed2);
  odsState.addTypes(output);
}

void RandomGammaOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value shape, ::mlir::Value alpha, ::mlir::IntegerAttr seed, ::mlir::IntegerAttr seed2) {
  odsState.addOperands(shape);
  odsState.addOperands(alpha);
  odsState.addAttribute("seed", seed);
  odsState.addAttribute("seed2", seed2);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void RandomGammaOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value shape, ::mlir::Value alpha, uint64_t seed, uint64_t seed2) {
  odsState.addOperands(shape);
  odsState.addOperands(alpha);
  odsState.addAttribute("seed", odsBuilder.getIntegerAttr(odsBuilder.getIntegerType(64), seed));
  odsState.addAttribute("seed2", odsBuilder.getIntegerAttr(odsBuilder.getIntegerType(64), seed2));
  odsState.addTypes(output);
}

void RandomGammaOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value shape, ::mlir::Value alpha, uint64_t seed, uint64_t seed2) {
  odsState.addOperands(shape);
  odsState.addOperands(alpha);
  odsState.addAttribute("seed", odsBuilder.getIntegerAttr(odsBuilder.getIntegerType(64), seed));
  odsState.addAttribute("seed2", odsBuilder.getIntegerAttr(odsBuilder.getIntegerType(64), seed2));
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void RandomGammaOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult RandomGammaOp::verify() {
  if (failed(RandomGammaOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of 32/64-bit signed integer values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of 16-bit float or 32-bit float or 64-bit float values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())))))) {
        return emitOpError("result #") << index << " must be tensor of 16-bit float or 32-bit float or 64-bit float values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::RandomPoissonOp definitions
//===----------------------------------------------------------------------===//

RandomPoissonOpAdaptor::RandomPoissonOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

RandomPoissonOpAdaptor::RandomPoissonOpAdaptor(RandomPoissonOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> RandomPoissonOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange RandomPoissonOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value RandomPoissonOpAdaptor::shape() {
  return *getODSOperands(0).begin();
}

::mlir::Value RandomPoissonOpAdaptor::rate() {
  return *getODSOperands(1).begin();
}

::mlir::IntegerAttr RandomPoissonOpAdaptor::seed() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::IntegerAttr attr = odsAttrs.get("seed").dyn_cast_or_null<::mlir::IntegerAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getIntegerAttr(::mlir::Builder(odsAttrs.getContext()).getIntegerType(64), 0);
  return attr;
}

::mlir::IntegerAttr RandomPoissonOpAdaptor::seed2() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::IntegerAttr attr = odsAttrs.get("seed2").dyn_cast_or_null<::mlir::IntegerAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getIntegerAttr(::mlir::Builder(odsAttrs.getContext()).getIntegerType(64), 0);
  return attr;
}

::mlir::LogicalResult RandomPoissonOpAdaptor::verify(::mlir::Location loc) {
  {
  auto tblgen_seed = odsAttrs.get("seed");
  if (tblgen_seed) {
    if (!(((tblgen_seed.isa<::mlir::IntegerAttr>())) && ((tblgen_seed.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(64))))) return emitError(loc, "'tf.RandomPoisson' op ""attribute 'seed' failed to satisfy constraint: 64-bit signless integer attribute");
  }
  }
  {
  auto tblgen_seed2 = odsAttrs.get("seed2");
  if (tblgen_seed2) {
    if (!(((tblgen_seed2.isa<::mlir::IntegerAttr>())) && ((tblgen_seed2.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(64))))) return emitError(loc, "'tf.RandomPoisson' op ""attribute 'seed2' failed to satisfy constraint: 64-bit signless integer attribute");
  }
  }
  return ::mlir::success();
}

::llvm::StringRef RandomPoissonOp::getOperationName() {
  return "tf.RandomPoisson";
}

std::pair<unsigned, unsigned> RandomPoissonOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range RandomPoissonOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value RandomPoissonOp::shape() {
  return *getODSOperands(0).begin();
}

::mlir::Value RandomPoissonOp::rate() {
  return *getODSOperands(1).begin();
}

::mlir::MutableOperandRange RandomPoissonOp::shapeMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange RandomPoissonOp::rateMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> RandomPoissonOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range RandomPoissonOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value RandomPoissonOp::output() {
  return *getODSResults(0).begin();
}

::mlir::IntegerAttr RandomPoissonOp::seedAttr() {
  return this->getAttr("seed").dyn_cast_or_null<::mlir::IntegerAttr>();
}

uint64_t RandomPoissonOp::seed() {
  auto attr = seedAttr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getIntegerAttr(::mlir::Builder(this->getContext()).getIntegerType(64), 0).getValue().getZExtValue();
  return attr.getValue().getZExtValue();
}

::mlir::IntegerAttr RandomPoissonOp::seed2Attr() {
  return this->getAttr("seed2").dyn_cast_or_null<::mlir::IntegerAttr>();
}

uint64_t RandomPoissonOp::seed2() {
  auto attr = seed2Attr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getIntegerAttr(::mlir::Builder(this->getContext()).getIntegerType(64), 0).getValue().getZExtValue();
  return attr.getValue().getZExtValue();
}

Type RandomPoissonOp::S() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

Type RandomPoissonOp::dtype() {
  return mlir::getElementTypeOrSelf(*getODSOperands(1).begin());
}

bool RandomPoissonOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "S") return true;
  if (name == "dtype") return true;
 return false;
}

::mlir::DictionaryAttr RandomPoissonOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("S", ctx),
::mlir::TypeAttr::get(S())},
    {::mlir::Identifier::get("dtype", ctx),
::mlir::TypeAttr::get(dtype())}
    }, ctx);
}

void RandomPoissonOp::seedAttr(::mlir::IntegerAttr attr) {
  this->getOperation()->setAttr("seed", attr);
}

void RandomPoissonOp::seed2Attr(::mlir::IntegerAttr attr) {
  this->getOperation()->setAttr("seed2", attr);
}

void RandomPoissonOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value shape, ::mlir::Value rate, ::mlir::IntegerAttr seed, ::mlir::IntegerAttr seed2) {
  odsState.addOperands(shape);
  odsState.addOperands(rate);
  odsState.addAttribute("seed", seed);
  odsState.addAttribute("seed2", seed2);
  odsState.addTypes(output);
}

void RandomPoissonOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value shape, ::mlir::Value rate, ::mlir::IntegerAttr seed, ::mlir::IntegerAttr seed2) {
  odsState.addOperands(shape);
  odsState.addOperands(rate);
  odsState.addAttribute("seed", seed);
  odsState.addAttribute("seed2", seed2);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void RandomPoissonOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value shape, ::mlir::Value rate, uint64_t seed, uint64_t seed2) {
  odsState.addOperands(shape);
  odsState.addOperands(rate);
  odsState.addAttribute("seed", odsBuilder.getIntegerAttr(odsBuilder.getIntegerType(64), seed));
  odsState.addAttribute("seed2", odsBuilder.getIntegerAttr(odsBuilder.getIntegerType(64), seed2));
  odsState.addTypes(output);
}

void RandomPoissonOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value shape, ::mlir::Value rate, uint64_t seed, uint64_t seed2) {
  odsState.addOperands(shape);
  odsState.addOperands(rate);
  odsState.addAttribute("seed", odsBuilder.getIntegerAttr(odsBuilder.getIntegerType(64), seed));
  odsState.addAttribute("seed2", odsBuilder.getIntegerAttr(odsBuilder.getIntegerType(64), seed2));
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void RandomPoissonOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult RandomPoissonOp::verify() {
  if (failed(RandomPoissonOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of 32/64-bit signed integer values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of 16-bit float or 32-bit float or 64-bit float values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())))))) {
        return emitOpError("result #") << index << " must be tensor of 16-bit float or 32-bit float or 64-bit float values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::RandomPoissonV2Op definitions
//===----------------------------------------------------------------------===//

RandomPoissonV2OpAdaptor::RandomPoissonV2OpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

RandomPoissonV2OpAdaptor::RandomPoissonV2OpAdaptor(RandomPoissonV2Op&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> RandomPoissonV2OpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange RandomPoissonV2OpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value RandomPoissonV2OpAdaptor::shape() {
  return *getODSOperands(0).begin();
}

::mlir::Value RandomPoissonV2OpAdaptor::rate() {
  return *getODSOperands(1).begin();
}

::mlir::IntegerAttr RandomPoissonV2OpAdaptor::seed() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::IntegerAttr attr = odsAttrs.get("seed").dyn_cast_or_null<::mlir::IntegerAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getIntegerAttr(::mlir::Builder(odsAttrs.getContext()).getIntegerType(64), 0);
  return attr;
}

::mlir::IntegerAttr RandomPoissonV2OpAdaptor::seed2() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::IntegerAttr attr = odsAttrs.get("seed2").dyn_cast_or_null<::mlir::IntegerAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getIntegerAttr(::mlir::Builder(odsAttrs.getContext()).getIntegerType(64), 0);
  return attr;
}

::mlir::LogicalResult RandomPoissonV2OpAdaptor::verify(::mlir::Location loc) {
  {
  auto tblgen_seed = odsAttrs.get("seed");
  if (tblgen_seed) {
    if (!(((tblgen_seed.isa<::mlir::IntegerAttr>())) && ((tblgen_seed.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(64))))) return emitError(loc, "'tf.RandomPoissonV2' op ""attribute 'seed' failed to satisfy constraint: 64-bit signless integer attribute");
  }
  }
  {
  auto tblgen_seed2 = odsAttrs.get("seed2");
  if (tblgen_seed2) {
    if (!(((tblgen_seed2.isa<::mlir::IntegerAttr>())) && ((tblgen_seed2.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(64))))) return emitError(loc, "'tf.RandomPoissonV2' op ""attribute 'seed2' failed to satisfy constraint: 64-bit signless integer attribute");
  }
  }
  return ::mlir::success();
}

::llvm::StringRef RandomPoissonV2Op::getOperationName() {
  return "tf.RandomPoissonV2";
}

std::pair<unsigned, unsigned> RandomPoissonV2Op::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range RandomPoissonV2Op::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value RandomPoissonV2Op::shape() {
  return *getODSOperands(0).begin();
}

::mlir::Value RandomPoissonV2Op::rate() {
  return *getODSOperands(1).begin();
}

::mlir::MutableOperandRange RandomPoissonV2Op::shapeMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange RandomPoissonV2Op::rateMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> RandomPoissonV2Op::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range RandomPoissonV2Op::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value RandomPoissonV2Op::output() {
  return *getODSResults(0).begin();
}

::mlir::IntegerAttr RandomPoissonV2Op::seedAttr() {
  return this->getAttr("seed").dyn_cast_or_null<::mlir::IntegerAttr>();
}

uint64_t RandomPoissonV2Op::seed() {
  auto attr = seedAttr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getIntegerAttr(::mlir::Builder(this->getContext()).getIntegerType(64), 0).getValue().getZExtValue();
  return attr.getValue().getZExtValue();
}

::mlir::IntegerAttr RandomPoissonV2Op::seed2Attr() {
  return this->getAttr("seed2").dyn_cast_or_null<::mlir::IntegerAttr>();
}

uint64_t RandomPoissonV2Op::seed2() {
  auto attr = seed2Attr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getIntegerAttr(::mlir::Builder(this->getContext()).getIntegerType(64), 0).getValue().getZExtValue();
  return attr.getValue().getZExtValue();
}

Type RandomPoissonV2Op::R() {
  return mlir::getElementTypeOrSelf(*getODSOperands(1).begin());
}

Type RandomPoissonV2Op::S() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

Type RandomPoissonV2Op::dtype() {
  return mlir::getElementTypeOrSelf(*getODSResults(0).begin());
}

bool RandomPoissonV2Op::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "R") return true;
  if (name == "S") return true;
  if (name == "dtype") return true;
 return false;
}

::mlir::DictionaryAttr RandomPoissonV2Op::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("R", ctx),
::mlir::TypeAttr::get(R())},
    {::mlir::Identifier::get("S", ctx),
::mlir::TypeAttr::get(S())},
    {::mlir::Identifier::get("dtype", ctx),
::mlir::TypeAttr::get(dtype())}
    }, ctx);
}

void RandomPoissonV2Op::seedAttr(::mlir::IntegerAttr attr) {
  this->getOperation()->setAttr("seed", attr);
}

void RandomPoissonV2Op::seed2Attr(::mlir::IntegerAttr attr) {
  this->getOperation()->setAttr("seed2", attr);
}

void RandomPoissonV2Op::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value shape, ::mlir::Value rate, ::mlir::IntegerAttr seed, ::mlir::IntegerAttr seed2) {
  odsState.addOperands(shape);
  odsState.addOperands(rate);
  odsState.addAttribute("seed", seed);
  odsState.addAttribute("seed2", seed2);
  odsState.addTypes(output);
}

void RandomPoissonV2Op::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value shape, ::mlir::Value rate, ::mlir::IntegerAttr seed, ::mlir::IntegerAttr seed2) {
  odsState.addOperands(shape);
  odsState.addOperands(rate);
  odsState.addAttribute("seed", seed);
  odsState.addAttribute("seed2", seed2);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void RandomPoissonV2Op::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value shape, ::mlir::Value rate, uint64_t seed, uint64_t seed2) {
  odsState.addOperands(shape);
  odsState.addOperands(rate);
  odsState.addAttribute("seed", odsBuilder.getIntegerAttr(odsBuilder.getIntegerType(64), seed));
  odsState.addAttribute("seed2", odsBuilder.getIntegerAttr(odsBuilder.getIntegerType(64), seed2));
  odsState.addTypes(output);
}

void RandomPoissonV2Op::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value shape, ::mlir::Value rate, uint64_t seed, uint64_t seed2) {
  odsState.addOperands(shape);
  odsState.addOperands(rate);
  odsState.addAttribute("seed", odsBuilder.getIntegerAttr(odsBuilder.getIntegerType(64), seed));
  odsState.addAttribute("seed2", odsBuilder.getIntegerAttr(odsBuilder.getIntegerType(64), seed2));
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void RandomPoissonV2Op::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult RandomPoissonV2Op::verify() {
  if (failed(RandomPoissonV2OpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of 32/64-bit signed integer values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of 16-bit float or 32-bit float or 64-bit float or 32-bit integer or 64-bit integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))))) {
        return emitOpError("result #") << index << " must be tensor of 16-bit float or 32-bit float or 64-bit float or 32-bit integer or 64-bit integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::RandomShuffleOp definitions
//===----------------------------------------------------------------------===//

RandomShuffleOpAdaptor::RandomShuffleOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

RandomShuffleOpAdaptor::RandomShuffleOpAdaptor(RandomShuffleOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> RandomShuffleOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange RandomShuffleOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value RandomShuffleOpAdaptor::value() {
  return *getODSOperands(0).begin();
}

::mlir::IntegerAttr RandomShuffleOpAdaptor::seed() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::IntegerAttr attr = odsAttrs.get("seed").dyn_cast_or_null<::mlir::IntegerAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getIntegerAttr(::mlir::Builder(odsAttrs.getContext()).getIntegerType(64), 0);
  return attr;
}

::mlir::IntegerAttr RandomShuffleOpAdaptor::seed2() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::IntegerAttr attr = odsAttrs.get("seed2").dyn_cast_or_null<::mlir::IntegerAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getIntegerAttr(::mlir::Builder(odsAttrs.getContext()).getIntegerType(64), 0);
  return attr;
}

::mlir::LogicalResult RandomShuffleOpAdaptor::verify(::mlir::Location loc) {
  {
  auto tblgen_seed = odsAttrs.get("seed");
  if (tblgen_seed) {
    if (!(((tblgen_seed.isa<::mlir::IntegerAttr>())) && ((tblgen_seed.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(64))))) return emitError(loc, "'tf.RandomShuffle' op ""attribute 'seed' failed to satisfy constraint: 64-bit signless integer attribute");
  }
  }
  {
  auto tblgen_seed2 = odsAttrs.get("seed2");
  if (tblgen_seed2) {
    if (!(((tblgen_seed2.isa<::mlir::IntegerAttr>())) && ((tblgen_seed2.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(64))))) return emitError(loc, "'tf.RandomShuffle' op ""attribute 'seed2' failed to satisfy constraint: 64-bit signless integer attribute");
  }
  }
  return ::mlir::success();
}

::llvm::StringRef RandomShuffleOp::getOperationName() {
  return "tf.RandomShuffle";
}

std::pair<unsigned, unsigned> RandomShuffleOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range RandomShuffleOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value RandomShuffleOp::value() {
  return *getODSOperands(0).begin();
}

::mlir::MutableOperandRange RandomShuffleOp::valueMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> RandomShuffleOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range RandomShuffleOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value RandomShuffleOp::output() {
  return *getODSResults(0).begin();
}

::mlir::IntegerAttr RandomShuffleOp::seedAttr() {
  return this->getAttr("seed").dyn_cast_or_null<::mlir::IntegerAttr>();
}

uint64_t RandomShuffleOp::seed() {
  auto attr = seedAttr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getIntegerAttr(::mlir::Builder(this->getContext()).getIntegerType(64), 0).getValue().getZExtValue();
  return attr.getValue().getZExtValue();
}

::mlir::IntegerAttr RandomShuffleOp::seed2Attr() {
  return this->getAttr("seed2").dyn_cast_or_null<::mlir::IntegerAttr>();
}

uint64_t RandomShuffleOp::seed2() {
  auto attr = seed2Attr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getIntegerAttr(::mlir::Builder(this->getContext()).getIntegerType(64), 0).getValue().getZExtValue();
  return attr.getValue().getZExtValue();
}

Type RandomShuffleOp::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

bool RandomShuffleOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "T") return true;
 return false;
}

::mlir::DictionaryAttr RandomShuffleOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())}
    }, ctx);
}

void RandomShuffleOp::seedAttr(::mlir::IntegerAttr attr) {
  this->getOperation()->setAttr("seed", attr);
}

void RandomShuffleOp::seed2Attr(::mlir::IntegerAttr attr) {
  this->getOperation()->setAttr("seed2", attr);
}

void RandomShuffleOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value value, ::mlir::IntegerAttr seed, ::mlir::IntegerAttr seed2) {
  odsState.addOperands(value);
  odsState.addAttribute("seed", seed);
  odsState.addAttribute("seed2", seed2);
  odsState.addTypes(output);
}

void RandomShuffleOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value value, ::mlir::IntegerAttr seed, ::mlir::IntegerAttr seed2) {
  odsState.addOperands(value);
  odsState.addAttribute("seed", seed);
  odsState.addAttribute("seed2", seed2);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void RandomShuffleOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value value, uint64_t seed, uint64_t seed2) {
  odsState.addOperands(value);
  odsState.addAttribute("seed", odsBuilder.getIntegerAttr(odsBuilder.getIntegerType(64), seed));
  odsState.addAttribute("seed2", odsBuilder.getIntegerAttr(odsBuilder.getIntegerType(64), seed2));
  odsState.addTypes(output);
}

void RandomShuffleOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value value, uint64_t seed, uint64_t seed2) {
  odsState.addOperands(value);
  odsState.addAttribute("seed", odsBuilder.getIntegerAttr(odsBuilder.getIntegerType(64), seed));
  odsState.addAttribute("seed2", odsBuilder.getIntegerAttr(odsBuilder.getIntegerType(64), seed2));
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void RandomShuffleOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

void RandomShuffleOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value value, ::mlir::IntegerAttr seed, ::mlir::IntegerAttr seed2) {
  odsState.addOperands(value);
  odsState.addAttribute("seed", seed);
  odsState.addAttribute("seed2", seed2);
  odsState.addTypes({value.getType()});

}

void RandomShuffleOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  odsState.addTypes({operands[0].getType()});

}

::mlir::LogicalResult RandomShuffleOp::verify() {
  if (failed(RandomShuffleOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>())))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::TensorFlowType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of tf.dtype values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>())))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::TensorFlowType>()))))) {
        return emitOpError("result #") << index << " must be tensor of tf.dtype values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::RandomStandardNormalOp definitions
//===----------------------------------------------------------------------===//

RandomStandardNormalOpAdaptor::RandomStandardNormalOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

RandomStandardNormalOpAdaptor::RandomStandardNormalOpAdaptor(RandomStandardNormalOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> RandomStandardNormalOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange RandomStandardNormalOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value RandomStandardNormalOpAdaptor::shape() {
  return *getODSOperands(0).begin();
}

::mlir::IntegerAttr RandomStandardNormalOpAdaptor::seed() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::IntegerAttr attr = odsAttrs.get("seed").dyn_cast_or_null<::mlir::IntegerAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getIntegerAttr(::mlir::Builder(odsAttrs.getContext()).getIntegerType(64), 0);
  return attr;
}

::mlir::IntegerAttr RandomStandardNormalOpAdaptor::seed2() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::IntegerAttr attr = odsAttrs.get("seed2").dyn_cast_or_null<::mlir::IntegerAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getIntegerAttr(::mlir::Builder(odsAttrs.getContext()).getIntegerType(64), 0);
  return attr;
}

::mlir::LogicalResult RandomStandardNormalOpAdaptor::verify(::mlir::Location loc) {
  {
  auto tblgen_seed = odsAttrs.get("seed");
  if (tblgen_seed) {
    if (!(((tblgen_seed.isa<::mlir::IntegerAttr>())) && ((tblgen_seed.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(64))))) return emitError(loc, "'tf.RandomStandardNormal' op ""attribute 'seed' failed to satisfy constraint: 64-bit signless integer attribute");
  }
  }
  {
  auto tblgen_seed2 = odsAttrs.get("seed2");
  if (tblgen_seed2) {
    if (!(((tblgen_seed2.isa<::mlir::IntegerAttr>())) && ((tblgen_seed2.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(64))))) return emitError(loc, "'tf.RandomStandardNormal' op ""attribute 'seed2' failed to satisfy constraint: 64-bit signless integer attribute");
  }
  }
  return ::mlir::success();
}

::llvm::StringRef RandomStandardNormalOp::getOperationName() {
  return "tf.RandomStandardNormal";
}

std::pair<unsigned, unsigned> RandomStandardNormalOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range RandomStandardNormalOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value RandomStandardNormalOp::shape() {
  return *getODSOperands(0).begin();
}

::mlir::MutableOperandRange RandomStandardNormalOp::shapeMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> RandomStandardNormalOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range RandomStandardNormalOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value RandomStandardNormalOp::output() {
  return *getODSResults(0).begin();
}

::mlir::IntegerAttr RandomStandardNormalOp::seedAttr() {
  return this->getAttr("seed").dyn_cast_or_null<::mlir::IntegerAttr>();
}

uint64_t RandomStandardNormalOp::seed() {
  auto attr = seedAttr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getIntegerAttr(::mlir::Builder(this->getContext()).getIntegerType(64), 0).getValue().getZExtValue();
  return attr.getValue().getZExtValue();
}

::mlir::IntegerAttr RandomStandardNormalOp::seed2Attr() {
  return this->getAttr("seed2").dyn_cast_or_null<::mlir::IntegerAttr>();
}

uint64_t RandomStandardNormalOp::seed2() {
  auto attr = seed2Attr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getIntegerAttr(::mlir::Builder(this->getContext()).getIntegerType(64), 0).getValue().getZExtValue();
  return attr.getValue().getZExtValue();
}

Type RandomStandardNormalOp::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

Type RandomStandardNormalOp::dtype() {
  return mlir::getElementTypeOrSelf(*getODSResults(0).begin());
}

bool RandomStandardNormalOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "T") return true;
  if (name == "dtype") return true;
 return false;
}

::mlir::DictionaryAttr RandomStandardNormalOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())},
    {::mlir::Identifier::get("dtype", ctx),
::mlir::TypeAttr::get(dtype())}
    }, ctx);
}

void RandomStandardNormalOp::seedAttr(::mlir::IntegerAttr attr) {
  this->getOperation()->setAttr("seed", attr);
}

void RandomStandardNormalOp::seed2Attr(::mlir::IntegerAttr attr) {
  this->getOperation()->setAttr("seed2", attr);
}

void RandomStandardNormalOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value shape, ::mlir::IntegerAttr seed, ::mlir::IntegerAttr seed2) {
  odsState.addOperands(shape);
  odsState.addAttribute("seed", seed);
  odsState.addAttribute("seed2", seed2);
  odsState.addTypes(output);
}

void RandomStandardNormalOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value shape, ::mlir::IntegerAttr seed, ::mlir::IntegerAttr seed2) {
  odsState.addOperands(shape);
  odsState.addAttribute("seed", seed);
  odsState.addAttribute("seed2", seed2);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void RandomStandardNormalOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value shape, uint64_t seed, uint64_t seed2) {
  odsState.addOperands(shape);
  odsState.addAttribute("seed", odsBuilder.getIntegerAttr(odsBuilder.getIntegerType(64), seed));
  odsState.addAttribute("seed2", odsBuilder.getIntegerAttr(odsBuilder.getIntegerType(64), seed2));
  odsState.addTypes(output);
}

void RandomStandardNormalOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value shape, uint64_t seed, uint64_t seed2) {
  odsState.addOperands(shape);
  odsState.addAttribute("seed", odsBuilder.getIntegerAttr(odsBuilder.getIntegerType(64), seed));
  odsState.addAttribute("seed2", odsBuilder.getIntegerAttr(odsBuilder.getIntegerType(64), seed2));
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void RandomStandardNormalOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult RandomStandardNormalOp::verify() {
  if (failed(RandomStandardNormalOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of 32/64-bit signed integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))))) {
        return emitOpError("result #") << index << " must be tensor of floating-point values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::RandomUniformIntOp definitions
//===----------------------------------------------------------------------===//

RandomUniformIntOpAdaptor::RandomUniformIntOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

RandomUniformIntOpAdaptor::RandomUniformIntOpAdaptor(RandomUniformIntOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> RandomUniformIntOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange RandomUniformIntOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value RandomUniformIntOpAdaptor::shape() {
  return *getODSOperands(0).begin();
}

::mlir::Value RandomUniformIntOpAdaptor::minval() {
  return *getODSOperands(1).begin();
}

::mlir::Value RandomUniformIntOpAdaptor::maxval() {
  return *getODSOperands(2).begin();
}

::mlir::IntegerAttr RandomUniformIntOpAdaptor::seed() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::IntegerAttr attr = odsAttrs.get("seed").dyn_cast_or_null<::mlir::IntegerAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getIntegerAttr(::mlir::Builder(odsAttrs.getContext()).getIntegerType(64), 0);
  return attr;
}

::mlir::IntegerAttr RandomUniformIntOpAdaptor::seed2() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::IntegerAttr attr = odsAttrs.get("seed2").dyn_cast_or_null<::mlir::IntegerAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getIntegerAttr(::mlir::Builder(odsAttrs.getContext()).getIntegerType(64), 0);
  return attr;
}

::mlir::LogicalResult RandomUniformIntOpAdaptor::verify(::mlir::Location loc) {
  {
  auto tblgen_seed = odsAttrs.get("seed");
  if (tblgen_seed) {
    if (!(((tblgen_seed.isa<::mlir::IntegerAttr>())) && ((tblgen_seed.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(64))))) return emitError(loc, "'tf.RandomUniformInt' op ""attribute 'seed' failed to satisfy constraint: 64-bit signless integer attribute");
  }
  }
  {
  auto tblgen_seed2 = odsAttrs.get("seed2");
  if (tblgen_seed2) {
    if (!(((tblgen_seed2.isa<::mlir::IntegerAttr>())) && ((tblgen_seed2.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(64))))) return emitError(loc, "'tf.RandomUniformInt' op ""attribute 'seed2' failed to satisfy constraint: 64-bit signless integer attribute");
  }
  }
  return ::mlir::success();
}

::llvm::StringRef RandomUniformIntOp::getOperationName() {
  return "tf.RandomUniformInt";
}

std::pair<unsigned, unsigned> RandomUniformIntOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range RandomUniformIntOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value RandomUniformIntOp::shape() {
  return *getODSOperands(0).begin();
}

::mlir::Value RandomUniformIntOp::minval() {
  return *getODSOperands(1).begin();
}

::mlir::Value RandomUniformIntOp::maxval() {
  return *getODSOperands(2).begin();
}

::mlir::MutableOperandRange RandomUniformIntOp::shapeMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange RandomUniformIntOp::minvalMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange RandomUniformIntOp::maxvalMutable() {
  auto range = getODSOperandIndexAndLength(2);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> RandomUniformIntOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range RandomUniformIntOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value RandomUniformIntOp::output() {
  return *getODSResults(0).begin();
}

::mlir::IntegerAttr RandomUniformIntOp::seedAttr() {
  return this->getAttr("seed").dyn_cast_or_null<::mlir::IntegerAttr>();
}

uint64_t RandomUniformIntOp::seed() {
  auto attr = seedAttr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getIntegerAttr(::mlir::Builder(this->getContext()).getIntegerType(64), 0).getValue().getZExtValue();
  return attr.getValue().getZExtValue();
}

::mlir::IntegerAttr RandomUniformIntOp::seed2Attr() {
  return this->getAttr("seed2").dyn_cast_or_null<::mlir::IntegerAttr>();
}

uint64_t RandomUniformIntOp::seed2() {
  auto attr = seed2Attr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getIntegerAttr(::mlir::Builder(this->getContext()).getIntegerType(64), 0).getValue().getZExtValue();
  return attr.getValue().getZExtValue();
}

Type RandomUniformIntOp::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

Type RandomUniformIntOp::Tout() {
  return mlir::getElementTypeOrSelf(*getODSOperands(1).begin());
}

bool RandomUniformIntOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "T") return true;
  if (name == "Tout") return true;
 return false;
}

::mlir::DictionaryAttr RandomUniformIntOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())},
    {::mlir::Identifier::get("Tout", ctx),
::mlir::TypeAttr::get(Tout())}
    }, ctx);
}

void RandomUniformIntOp::seedAttr(::mlir::IntegerAttr attr) {
  this->getOperation()->setAttr("seed", attr);
}

void RandomUniformIntOp::seed2Attr(::mlir::IntegerAttr attr) {
  this->getOperation()->setAttr("seed2", attr);
}

void RandomUniformIntOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value shape, ::mlir::Value minval, ::mlir::Value maxval, ::mlir::IntegerAttr seed, ::mlir::IntegerAttr seed2) {
  odsState.addOperands(shape);
  odsState.addOperands(minval);
  odsState.addOperands(maxval);
  odsState.addAttribute("seed", seed);
  odsState.addAttribute("seed2", seed2);
  odsState.addTypes(output);
}

void RandomUniformIntOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value shape, ::mlir::Value minval, ::mlir::Value maxval, ::mlir::IntegerAttr seed, ::mlir::IntegerAttr seed2) {
  odsState.addOperands(shape);
  odsState.addOperands(minval);
  odsState.addOperands(maxval);
  odsState.addAttribute("seed", seed);
  odsState.addAttribute("seed2", seed2);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void RandomUniformIntOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value shape, ::mlir::Value minval, ::mlir::Value maxval, uint64_t seed, uint64_t seed2) {
  odsState.addOperands(shape);
  odsState.addOperands(minval);
  odsState.addOperands(maxval);
  odsState.addAttribute("seed", odsBuilder.getIntegerAttr(odsBuilder.getIntegerType(64), seed));
  odsState.addAttribute("seed2", odsBuilder.getIntegerAttr(odsBuilder.getIntegerType(64), seed2));
  odsState.addTypes(output);
}

void RandomUniformIntOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value shape, ::mlir::Value minval, ::mlir::Value maxval, uint64_t seed, uint64_t seed2) {
  odsState.addOperands(shape);
  odsState.addOperands(minval);
  odsState.addOperands(maxval);
  odsState.addAttribute("seed", odsBuilder.getIntegerAttr(odsBuilder.getIntegerType(64), seed));
  odsState.addAttribute("seed2", odsBuilder.getIntegerAttr(odsBuilder.getIntegerType(64), seed2));
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void RandomUniformIntOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 3u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult RandomUniformIntOp::verify() {
  if (failed(RandomUniformIntOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of 32/64-bit signed integer values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of 32/64-bit signed integer values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup2 = getODSOperands(2);
    for (::mlir::Value v : valueGroup2) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of 32/64-bit signed integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))))) {
        return emitOpError("result #") << index << " must be tensor of 32/64-bit signed integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::RandomUniformOp definitions
//===----------------------------------------------------------------------===//

RandomUniformOpAdaptor::RandomUniformOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

RandomUniformOpAdaptor::RandomUniformOpAdaptor(RandomUniformOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> RandomUniformOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange RandomUniformOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value RandomUniformOpAdaptor::shape() {
  return *getODSOperands(0).begin();
}

::mlir::IntegerAttr RandomUniformOpAdaptor::seed() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::IntegerAttr attr = odsAttrs.get("seed").dyn_cast_or_null<::mlir::IntegerAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getIntegerAttr(::mlir::Builder(odsAttrs.getContext()).getIntegerType(64), 0);
  return attr;
}

::mlir::IntegerAttr RandomUniformOpAdaptor::seed2() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::IntegerAttr attr = odsAttrs.get("seed2").dyn_cast_or_null<::mlir::IntegerAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getIntegerAttr(::mlir::Builder(odsAttrs.getContext()).getIntegerType(64), 0);
  return attr;
}

::mlir::LogicalResult RandomUniformOpAdaptor::verify(::mlir::Location loc) {
  {
  auto tblgen_seed = odsAttrs.get("seed");
  if (tblgen_seed) {
    if (!(((tblgen_seed.isa<::mlir::IntegerAttr>())) && ((tblgen_seed.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(64))))) return emitError(loc, "'tf.RandomUniform' op ""attribute 'seed' failed to satisfy constraint: 64-bit signless integer attribute");
  }
  }
  {
  auto tblgen_seed2 = odsAttrs.get("seed2");
  if (tblgen_seed2) {
    if (!(((tblgen_seed2.isa<::mlir::IntegerAttr>())) && ((tblgen_seed2.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(64))))) return emitError(loc, "'tf.RandomUniform' op ""attribute 'seed2' failed to satisfy constraint: 64-bit signless integer attribute");
  }
  }
  return ::mlir::success();
}

::llvm::StringRef RandomUniformOp::getOperationName() {
  return "tf.RandomUniform";
}

std::pair<unsigned, unsigned> RandomUniformOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range RandomUniformOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value RandomUniformOp::shape() {
  return *getODSOperands(0).begin();
}

::mlir::MutableOperandRange RandomUniformOp::shapeMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> RandomUniformOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range RandomUniformOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value RandomUniformOp::output() {
  return *getODSResults(0).begin();
}

::mlir::IntegerAttr RandomUniformOp::seedAttr() {
  return this->getAttr("seed").dyn_cast_or_null<::mlir::IntegerAttr>();
}

uint64_t RandomUniformOp::seed() {
  auto attr = seedAttr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getIntegerAttr(::mlir::Builder(this->getContext()).getIntegerType(64), 0).getValue().getZExtValue();
  return attr.getValue().getZExtValue();
}

::mlir::IntegerAttr RandomUniformOp::seed2Attr() {
  return this->getAttr("seed2").dyn_cast_or_null<::mlir::IntegerAttr>();
}

uint64_t RandomUniformOp::seed2() {
  auto attr = seed2Attr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getIntegerAttr(::mlir::Builder(this->getContext()).getIntegerType(64), 0).getValue().getZExtValue();
  return attr.getValue().getZExtValue();
}

Type RandomUniformOp::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

Type RandomUniformOp::dtype() {
  return mlir::getElementTypeOrSelf(*getODSResults(0).begin());
}

bool RandomUniformOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "T") return true;
  if (name == "dtype") return true;
 return false;
}

::mlir::DictionaryAttr RandomUniformOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())},
    {::mlir::Identifier::get("dtype", ctx),
::mlir::TypeAttr::get(dtype())}
    }, ctx);
}

void RandomUniformOp::seedAttr(::mlir::IntegerAttr attr) {
  this->getOperation()->setAttr("seed", attr);
}

void RandomUniformOp::seed2Attr(::mlir::IntegerAttr attr) {
  this->getOperation()->setAttr("seed2", attr);
}

void RandomUniformOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value shape, ::mlir::IntegerAttr seed, ::mlir::IntegerAttr seed2) {
  odsState.addOperands(shape);
  odsState.addAttribute("seed", seed);
  odsState.addAttribute("seed2", seed2);
  odsState.addTypes(output);
}

void RandomUniformOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value shape, ::mlir::IntegerAttr seed, ::mlir::IntegerAttr seed2) {
  odsState.addOperands(shape);
  odsState.addAttribute("seed", seed);
  odsState.addAttribute("seed2", seed2);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void RandomUniformOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value shape, uint64_t seed, uint64_t seed2) {
  odsState.addOperands(shape);
  odsState.addAttribute("seed", odsBuilder.getIntegerAttr(odsBuilder.getIntegerType(64), seed));
  odsState.addAttribute("seed2", odsBuilder.getIntegerAttr(odsBuilder.getIntegerType(64), seed2));
  odsState.addTypes(output);
}

void RandomUniformOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value shape, uint64_t seed, uint64_t seed2) {
  odsState.addOperands(shape);
  odsState.addAttribute("seed", odsBuilder.getIntegerAttr(odsBuilder.getIntegerType(64), seed));
  odsState.addAttribute("seed2", odsBuilder.getIntegerAttr(odsBuilder.getIntegerType(64), seed2));
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void RandomUniformOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult RandomUniformOp::verify() {
  if (failed(RandomUniformOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of 32/64-bit signed integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))))) {
        return emitOpError("result #") << index << " must be tensor of floating-point values, but got " << v.getType();
      }
      ++index;
    }
  }
  return Verify(*this);
}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::RangeDatasetOp definitions
//===----------------------------------------------------------------------===//

RangeDatasetOpAdaptor::RangeDatasetOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

RangeDatasetOpAdaptor::RangeDatasetOpAdaptor(RangeDatasetOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> RangeDatasetOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange RangeDatasetOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value RangeDatasetOpAdaptor::start() {
  return *getODSOperands(0).begin();
}

::mlir::Value RangeDatasetOpAdaptor::stop() {
  return *getODSOperands(1).begin();
}

::mlir::Value RangeDatasetOpAdaptor::step() {
  return *getODSOperands(2).begin();
}

::mlir::ArrayAttr RangeDatasetOpAdaptor::output_types() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::ArrayAttr attr = odsAttrs.get("output_types").cast<::mlir::ArrayAttr>();
  return attr;
}

::mlir::ArrayAttr RangeDatasetOpAdaptor::output_shapes() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::ArrayAttr attr = odsAttrs.get("output_shapes").cast<::mlir::ArrayAttr>();
  return attr;
}

::mlir::LogicalResult RangeDatasetOpAdaptor::verify(::mlir::Location loc) {
  {
  auto tblgen_output_types = odsAttrs.get("output_types");
  if (!tblgen_output_types) return emitError(loc, "'tf.RangeDataset' op ""requires attribute 'output_types'");
    if (!((((tblgen_output_types.isa<::mlir::ArrayAttr>())) && (::llvm::all_of(tblgen_output_types.cast<::mlir::ArrayAttr>(), [](::mlir::Attribute attr) { return ((attr.isa<::mlir::TypeAttr>())) && ((attr.cast<::mlir::TypeAttr>().getValue().isa<::mlir::Type>())); }))) && ((tblgen_output_types.cast<::mlir::ArrayAttr>().size() >= 1)))) return emitError(loc, "'tf.RangeDataset' op ""attribute 'output_types' failed to satisfy constraint: type array attribute with at least 1 elements");
  }
  {
  auto tblgen_output_shapes = odsAttrs.get("output_shapes");
  if (!tblgen_output_shapes) return emitError(loc, "'tf.RangeDataset' op ""requires attribute 'output_shapes'");
    if (!((((tblgen_output_shapes.isa<::mlir::ArrayAttr>())) && (::llvm::all_of(tblgen_output_shapes.cast<::mlir::ArrayAttr>(), [](::mlir::Attribute attr) { return (attr.isa<mlir::TF::ShapeAttr>()); }))) && ((tblgen_output_shapes.cast<::mlir::ArrayAttr>().size() >= 1)))) return emitError(loc, "'tf.RangeDataset' op ""attribute 'output_shapes' failed to satisfy constraint: tensorflow shape attribute array with at least 1 elements");
  }
  return ::mlir::success();
}

::llvm::StringRef RangeDatasetOp::getOperationName() {
  return "tf.RangeDataset";
}

std::pair<unsigned, unsigned> RangeDatasetOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range RangeDatasetOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value RangeDatasetOp::start() {
  return *getODSOperands(0).begin();
}

::mlir::Value RangeDatasetOp::stop() {
  return *getODSOperands(1).begin();
}

::mlir::Value RangeDatasetOp::step() {
  return *getODSOperands(2).begin();
}

::mlir::MutableOperandRange RangeDatasetOp::startMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange RangeDatasetOp::stopMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange RangeDatasetOp::stepMutable() {
  auto range = getODSOperandIndexAndLength(2);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> RangeDatasetOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range RangeDatasetOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value RangeDatasetOp::handle() {
  return *getODSResults(0).begin();
}

::mlir::ArrayAttr RangeDatasetOp::output_typesAttr() {
  return this->getAttr("output_types").cast<::mlir::ArrayAttr>();
}

::mlir::ArrayAttr RangeDatasetOp::output_types() {
  auto attr = output_typesAttr();
  return attr;
}

::mlir::ArrayAttr RangeDatasetOp::output_shapesAttr() {
  return this->getAttr("output_shapes").cast<::mlir::ArrayAttr>();
}

::mlir::ArrayAttr RangeDatasetOp::output_shapes() {
  auto attr = output_shapesAttr();
  return attr;
}

void RangeDatasetOp::output_typesAttr(::mlir::ArrayAttr attr) {
  this->getOperation()->setAttr("output_types", attr);
}

void RangeDatasetOp::output_shapesAttr(::mlir::ArrayAttr attr) {
  this->getOperation()->setAttr("output_shapes", attr);
}

void RangeDatasetOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type handle, ::mlir::Value start, ::mlir::Value stop, ::mlir::Value step, ::mlir::ArrayAttr output_types, ::mlir::ArrayAttr output_shapes) {
  odsState.addOperands(start);
  odsState.addOperands(stop);
  odsState.addOperands(step);
  odsState.addAttribute("output_types", output_types);
  odsState.addAttribute("output_shapes", output_shapes);
  odsState.addTypes(handle);
}

void RangeDatasetOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value start, ::mlir::Value stop, ::mlir::Value step, ::mlir::ArrayAttr output_types, ::mlir::ArrayAttr output_shapes) {
  odsState.addOperands(start);
  odsState.addOperands(stop);
  odsState.addOperands(step);
  odsState.addAttribute("output_types", output_types);
  odsState.addAttribute("output_shapes", output_shapes);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void RangeDatasetOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 3u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult RangeDatasetOp::verify() {
  if (failed(RangeDatasetOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of 64-bit integer values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of 64-bit integer values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup2 = getODSOperands(2);
    for (::mlir::Value v : valueGroup2) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of 64-bit integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::VariantType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::VariantRefType>()))))) {
        return emitOpError("result #") << index << " must be tensor of variant values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::RangeOp definitions
//===----------------------------------------------------------------------===//

RangeOpAdaptor::RangeOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

RangeOpAdaptor::RangeOpAdaptor(RangeOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> RangeOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange RangeOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value RangeOpAdaptor::start() {
  return *getODSOperands(0).begin();
}

::mlir::Value RangeOpAdaptor::limit() {
  return *getODSOperands(1).begin();
}

::mlir::Value RangeOpAdaptor::delta() {
  return *getODSOperands(2).begin();
}

::mlir::LogicalResult RangeOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

::llvm::StringRef RangeOp::getOperationName() {
  return "tf.Range";
}

std::pair<unsigned, unsigned> RangeOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range RangeOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value RangeOp::start() {
  return *getODSOperands(0).begin();
}

::mlir::Value RangeOp::limit() {
  return *getODSOperands(1).begin();
}

::mlir::Value RangeOp::delta() {
  return *getODSOperands(2).begin();
}

::mlir::MutableOperandRange RangeOp::startMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange RangeOp::limitMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange RangeOp::deltaMutable() {
  auto range = getODSOperandIndexAndLength(2);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> RangeOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range RangeOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value RangeOp::output() {
  return *getODSResults(0).begin();
}

Type RangeOp::Tidx() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

bool RangeOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "Tidx") return true;
 return false;
}

::mlir::DictionaryAttr RangeOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("Tidx", ctx),
::mlir::TypeAttr::get(Tidx())}
    }, ctx);
}



void RangeOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value start, ::mlir::Value limit, ::mlir::Value delta) {
  odsState.addOperands(start);
  odsState.addOperands(limit);
  odsState.addOperands(delta);
  odsState.addTypes(output);
}

void RangeOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value start, ::mlir::Value limit, ::mlir::Value delta) {
  odsState.addOperands(start);
  odsState.addOperands(limit);
  odsState.addOperands(delta);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void RangeOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 3u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult RangeOp::verify() {
  if (failed(RangeOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of floating-point or 32/64-bit signed integer values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of floating-point or 32/64-bit signed integer values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup2 = getODSOperands(2);
    for (::mlir::Value v : valueGroup2) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of floating-point or 32/64-bit signed integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))))) {
        return emitOpError("result #") << index << " must be tensor of floating-point or 32/64-bit signed integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void RangeOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::RankOp definitions
//===----------------------------------------------------------------------===//

RankOpAdaptor::RankOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

RankOpAdaptor::RankOpAdaptor(RankOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> RankOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange RankOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value RankOpAdaptor::input() {
  return *getODSOperands(0).begin();
}

::mlir::LogicalResult RankOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

::llvm::StringRef RankOp::getOperationName() {
  return "tf.Rank";
}

std::pair<unsigned, unsigned> RankOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range RankOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value RankOp::input() {
  return *getODSOperands(0).begin();
}

::mlir::MutableOperandRange RankOp::inputMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> RankOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range RankOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value RankOp::output() {
  return *getODSResults(0).begin();
}

Type RankOp::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

bool RankOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "T") return true;
 return false;
}

::mlir::DictionaryAttr RankOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())}
    }, ctx);
}



void RankOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value input) {
  odsState.addOperands(input);
  odsState.addTypes(output);
}

void RankOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input) {
  odsState.addOperands(input);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void RankOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult RankOp::verify() {
  if (failed(RankOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>())))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::TensorFlowType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of tf.dtype values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))))) {
        return emitOpError("result #") << index << " must be tensor of 32-bit integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}



void RankOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::ReadVariableOp definitions
//===----------------------------------------------------------------------===//

ReadVariableOpAdaptor::ReadVariableOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

ReadVariableOpAdaptor::ReadVariableOpAdaptor(ReadVariableOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> ReadVariableOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange ReadVariableOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value ReadVariableOpAdaptor::resource() {
  return *getODSOperands(0).begin();
}

::mlir::LogicalResult ReadVariableOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

::llvm::StringRef ReadVariableOp::getOperationName() {
  return "tf.ReadVariableOp";
}

std::pair<unsigned, unsigned> ReadVariableOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range ReadVariableOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value ReadVariableOp::resource() {
  return *getODSOperands(0).begin();
}

::mlir::MutableOperandRange ReadVariableOp::resourceMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> ReadVariableOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range ReadVariableOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value ReadVariableOp::value() {
  return *getODSResults(0).begin();
}

Type ReadVariableOp::dtype() {
  return mlir::getElementTypeOrSelf(*getODSResults(0).begin());
}

bool ReadVariableOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "dtype") return true;
 return false;
}

::mlir::DictionaryAttr ReadVariableOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("dtype", ctx),
::mlir::TypeAttr::get(dtype())}
    }, ctx);
}

void ReadVariableOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type value, ::mlir::Value resource) {
  odsState.addOperands(resource);
  odsState.addTypes(value);
}

void ReadVariableOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value resource) {
  odsState.addOperands(resource);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void ReadVariableOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult ReadVariableOp::verify() {
  if (failed(ReadVariableOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::ResourceType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::ResourceRefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of resource values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>())))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::TensorFlowType>()))))) {
        return emitOpError("result #") << index << " must be tensor of tf.dtype values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}



void ReadVariableOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
  for (::mlir::Value value : getODSOperands(0))
    effects.emplace_back(MemoryEffects::Read::get(), value, ::mlir::TF::ResourceEffects::Variable::get());
}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::RealDivOp definitions
//===----------------------------------------------------------------------===//

RealDivOpAdaptor::RealDivOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

RealDivOpAdaptor::RealDivOpAdaptor(RealDivOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> RealDivOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange RealDivOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value RealDivOpAdaptor::x() {
  return *getODSOperands(0).begin();
}

::mlir::Value RealDivOpAdaptor::y() {
  return *getODSOperands(1).begin();
}

::mlir::LogicalResult RealDivOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

::llvm::StringRef RealDivOp::getOperationName() {
  return "tf.RealDiv";
}

std::pair<unsigned, unsigned> RealDivOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range RealDivOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value RealDivOp::x() {
  return *getODSOperands(0).begin();
}

::mlir::Value RealDivOp::y() {
  return *getODSOperands(1).begin();
}

::mlir::MutableOperandRange RealDivOp::xMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange RealDivOp::yMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> RealDivOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range RealDivOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value RealDivOp::z() {
  return *getODSResults(0).begin();
}

Type RealDivOp::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

bool RealDivOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "T") return true;
 return false;
}

::mlir::DictionaryAttr RealDivOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())}
    }, ctx);
}

void RealDivOp::build(OpBuilder &builder, OperationState &result, Value  x, Value  y) {
  auto resultType =
      OpTrait::util::getBroadcastedType(x.getType(), y.getType());
  if (!resultType)
    mlir::emitError(result.location, "non-broadcastable operands");
  return build(builder, result, resultType, x, y);
}

void RealDivOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type z, ::mlir::Value x, ::mlir::Value y) {
  odsState.addOperands(x);
  odsState.addOperands(y);
  odsState.addTypes(z);
}

void RealDivOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value x, ::mlir::Value y) {
  odsState.addOperands(x);
  odsState.addOperands(y);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void RealDivOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult RealDivOp::verify() {
  if (failed(RealDivOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>())))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of floating-point or signed integer or complex or 16-bit unsigned integer or 8-bit unsigned integer values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>())))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of floating-point or signed integer or complex or 16-bit unsigned integer or 8-bit unsigned integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>())))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>())))))) {
        return emitOpError("result #") << index << " must be tensor of floating-point or signed integer or complex or 16-bit unsigned integer or 8-bit unsigned integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}





void RealDivOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::RealOp definitions
//===----------------------------------------------------------------------===//

RealOpAdaptor::RealOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

RealOpAdaptor::RealOpAdaptor(RealOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> RealOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange RealOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value RealOpAdaptor::input() {
  return *getODSOperands(0).begin();
}

::mlir::LogicalResult RealOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

::llvm::StringRef RealOp::getOperationName() {
  return "tf.Real";
}

std::pair<unsigned, unsigned> RealOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range RealOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value RealOp::input() {
  return *getODSOperands(0).begin();
}

::mlir::MutableOperandRange RealOp::inputMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> RealOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range RealOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value RealOp::output() {
  return *getODSResults(0).begin();
}

Type RealOp::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

Type RealOp::Tout() {
  return mlir::getElementTypeOrSelf(*getODSResults(0).begin());
}

bool RealOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "T") return true;
  if (name == "Tout") return true;
 return false;
}

::mlir::DictionaryAttr RealOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())},
    {::mlir::Identifier::get("Tout", ctx),
::mlir::TypeAttr::get(Tout())}
    }, ctx);
}

void RealOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value input) {
  odsState.addOperands(input);
  odsState.addTypes(output);
}

void RealOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input) {
  odsState.addOperands(input);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void RealOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult RealOp::verify() {
  if (failed(RealOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of 128-bit complex or 64-bit complex values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())))))) {
        return emitOpError("result #") << index << " must be tensor of 32/64-bit float values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void RealOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::ReciprocalGradOp definitions
//===----------------------------------------------------------------------===//

ReciprocalGradOpAdaptor::ReciprocalGradOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

ReciprocalGradOpAdaptor::ReciprocalGradOpAdaptor(ReciprocalGradOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> ReciprocalGradOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange ReciprocalGradOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value ReciprocalGradOpAdaptor::y() {
  return *getODSOperands(0).begin();
}

::mlir::Value ReciprocalGradOpAdaptor::dy() {
  return *getODSOperands(1).begin();
}

::mlir::LogicalResult ReciprocalGradOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

::llvm::StringRef ReciprocalGradOp::getOperationName() {
  return "tf.ReciprocalGrad";
}

std::pair<unsigned, unsigned> ReciprocalGradOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range ReciprocalGradOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value ReciprocalGradOp::y() {
  return *getODSOperands(0).begin();
}

::mlir::Value ReciprocalGradOp::dy() {
  return *getODSOperands(1).begin();
}

::mlir::MutableOperandRange ReciprocalGradOp::yMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange ReciprocalGradOp::dyMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> ReciprocalGradOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range ReciprocalGradOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value ReciprocalGradOp::z() {
  return *getODSResults(0).begin();
}

Type ReciprocalGradOp::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

bool ReciprocalGradOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "T") return true;
 return false;
}

::mlir::DictionaryAttr ReciprocalGradOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())}
    }, ctx);
}

void ReciprocalGradOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type z, ::mlir::Value y, ::mlir::Value dy) {
  odsState.addOperands(y);
  odsState.addOperands(dy);
  odsState.addTypes(z);
}

void ReciprocalGradOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value y, ::mlir::Value dy) {
  odsState.addOperands(y);
  odsState.addOperands(dy);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void ReciprocalGradOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

void ReciprocalGradOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value y, ::mlir::Value dy) {
  odsState.addOperands(y);
  odsState.addOperands(dy);
  odsState.addTypes({y.getType()});

}

void ReciprocalGradOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  odsState.addTypes({operands[0].getType()});

}

::mlir::LogicalResult ReciprocalGradOp::verify() {
  if (failed(ReciprocalGradOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))))))) {
        return emitOpError("operand #") << index << " must be tensor of floating-point or complex values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))))))) {
        return emitOpError("operand #") << index << " must be tensor of floating-point or complex values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))))))) {
        return emitOpError("result #") << index << " must be tensor of floating-point or complex values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void ReciprocalGradOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::ReciprocalOp definitions
//===----------------------------------------------------------------------===//

ReciprocalOpAdaptor::ReciprocalOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

ReciprocalOpAdaptor::ReciprocalOpAdaptor(ReciprocalOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> ReciprocalOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange ReciprocalOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value ReciprocalOpAdaptor::x() {
  return *getODSOperands(0).begin();
}

::mlir::LogicalResult ReciprocalOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

::llvm::StringRef ReciprocalOp::getOperationName() {
  return "tf.Reciprocal";
}

std::pair<unsigned, unsigned> ReciprocalOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range ReciprocalOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value ReciprocalOp::x() {
  return *getODSOperands(0).begin();
}

::mlir::MutableOperandRange ReciprocalOp::xMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> ReciprocalOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range ReciprocalOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value ReciprocalOp::y() {
  return *getODSResults(0).begin();
}

Type ReciprocalOp::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

bool ReciprocalOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "T") return true;
 return false;
}

::mlir::DictionaryAttr ReciprocalOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())}
    }, ctx);
}

void ReciprocalOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type y, ::mlir::Value x) {
  odsState.addOperands(x);
  odsState.addTypes(y);
}

void ReciprocalOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value x) {
  odsState.addOperands(x);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void ReciprocalOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

void ReciprocalOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value x) {
  odsState.addOperands(x);
  odsState.addTypes({x.getType()});

}

void ReciprocalOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  odsState.addTypes({operands[0].getType()});

}

::mlir::LogicalResult ReciprocalOp::verify() {
  if (failed(ReciprocalOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of bfloat16 or 128-bit complex or 64-bit complex or 16-bit float or 32-bit float or 64-bit float or 16-bit integer or 32-bit integer or 64-bit integer or 8-bit integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>())))))) {
        return emitOpError("result #") << index << " must be tensor of bfloat16 or 128-bit complex or 64-bit complex or 16-bit float or 32-bit float or 64-bit float or 16-bit integer or 32-bit integer or 64-bit integer or 8-bit integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}



void ReciprocalOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::RecvTPUEmbeddingActivationsOp definitions
//===----------------------------------------------------------------------===//

RecvTPUEmbeddingActivationsOpAdaptor::RecvTPUEmbeddingActivationsOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

RecvTPUEmbeddingActivationsOpAdaptor::RecvTPUEmbeddingActivationsOpAdaptor(RecvTPUEmbeddingActivationsOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> RecvTPUEmbeddingActivationsOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange RecvTPUEmbeddingActivationsOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::StringAttr RecvTPUEmbeddingActivationsOpAdaptor::config() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::StringAttr attr = odsAttrs.get("config").cast<::mlir::StringAttr>();
  return attr;
}

::mlir::LogicalResult RecvTPUEmbeddingActivationsOpAdaptor::verify(::mlir::Location loc) {
  {
  auto tblgen_config = odsAttrs.get("config");
  if (!tblgen_config) return emitError(loc, "'tf.RecvTPUEmbeddingActivations' op ""requires attribute 'config'");
    if (!((tblgen_config.isa<::mlir::StringAttr>()))) return emitError(loc, "'tf.RecvTPUEmbeddingActivations' op ""attribute 'config' failed to satisfy constraint: string attribute");
  }
  return ::mlir::success();
}

::llvm::StringRef RecvTPUEmbeddingActivationsOp::getOperationName() {
  return "tf.RecvTPUEmbeddingActivations";
}

std::pair<unsigned, unsigned> RecvTPUEmbeddingActivationsOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range RecvTPUEmbeddingActivationsOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

std::pair<unsigned, unsigned> RecvTPUEmbeddingActivationsOp::getODSResultIndexAndLength(unsigned index) {
  bool isVariadic[] = {true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (getOperation()->getNumResults() - 0) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::mlir::Operation::result_range RecvTPUEmbeddingActivationsOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Operation::result_range RecvTPUEmbeddingActivationsOp::outputs() {
  return getODSResults(0);
}

::mlir::StringAttr RecvTPUEmbeddingActivationsOp::configAttr() {
  return this->getAttr("config").cast<::mlir::StringAttr>();
}

::llvm::StringRef RecvTPUEmbeddingActivationsOp::config() {
  auto attr = configAttr();
  return attr.getValue();
}

size_t RecvTPUEmbeddingActivationsOp::num_outputs() {
  auto range = getODSResults(0);
return std::distance(range.begin(), range.end());
}

bool RecvTPUEmbeddingActivationsOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "num_outputs") return true;
 return false;
}

::mlir::DictionaryAttr RecvTPUEmbeddingActivationsOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("num_outputs", ctx),
odsBuilder.getI64IntegerAttr(num_outputs())}
    }, ctx);
}

void RecvTPUEmbeddingActivationsOp::configAttr(::mlir::StringAttr attr) {
  this->getOperation()->setAttr("config", attr);
}

void RecvTPUEmbeddingActivationsOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange outputs, ::mlir::StringAttr config) {
  odsState.addAttribute("config", config);
  odsState.addTypes(outputs);
}

void RecvTPUEmbeddingActivationsOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange outputs, ::llvm::StringRef config) {
  odsState.addAttribute("config", odsBuilder.getStringAttr(config));
  odsState.addTypes(outputs);
}

void RecvTPUEmbeddingActivationsOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 0u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult RecvTPUEmbeddingActivationsOp::verify() {
  if (failed(RecvTPUEmbeddingActivationsOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))))) {
        return emitOpError("result #") << index << " must be tensor of 32-bit float values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::Relu6GradOp definitions
//===----------------------------------------------------------------------===//

Relu6GradOpAdaptor::Relu6GradOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

Relu6GradOpAdaptor::Relu6GradOpAdaptor(Relu6GradOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> Relu6GradOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange Relu6GradOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value Relu6GradOpAdaptor::gradients() {
  return *getODSOperands(0).begin();
}

::mlir::Value Relu6GradOpAdaptor::features() {
  return *getODSOperands(1).begin();
}

::mlir::LogicalResult Relu6GradOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

::llvm::StringRef Relu6GradOp::getOperationName() {
  return "tf.Relu6Grad";
}

std::pair<unsigned, unsigned> Relu6GradOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range Relu6GradOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value Relu6GradOp::gradients() {
  return *getODSOperands(0).begin();
}

::mlir::Value Relu6GradOp::features() {
  return *getODSOperands(1).begin();
}

::mlir::MutableOperandRange Relu6GradOp::gradientsMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange Relu6GradOp::featuresMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> Relu6GradOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range Relu6GradOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value Relu6GradOp::backprops() {
  return *getODSResults(0).begin();
}

Type Relu6GradOp::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

bool Relu6GradOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "T") return true;
 return false;
}

::mlir::DictionaryAttr Relu6GradOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())}
    }, ctx);
}

void Relu6GradOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type backprops, ::mlir::Value gradients, ::mlir::Value features) {
  odsState.addOperands(gradients);
  odsState.addOperands(features);
  odsState.addTypes(backprops);
}

void Relu6GradOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value gradients, ::mlir::Value features) {
  odsState.addOperands(gradients);
  odsState.addOperands(features);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void Relu6GradOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

void Relu6GradOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value gradients, ::mlir::Value features) {
  odsState.addOperands(gradients);
  odsState.addOperands(features);
  odsState.addTypes({gradients.getType()});

}

void Relu6GradOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  odsState.addTypes({operands[0].getType()});

}

::mlir::LogicalResult Relu6GradOp::verify() {
  if (failed(Relu6GradOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of integer or floating-point values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of integer or floating-point values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>())))))) {
        return emitOpError("result #") << index << " must be tensor of integer or floating-point values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void Relu6GradOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::Relu6Op definitions
//===----------------------------------------------------------------------===//

Relu6OpAdaptor::Relu6OpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

Relu6OpAdaptor::Relu6OpAdaptor(Relu6Op&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> Relu6OpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange Relu6OpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value Relu6OpAdaptor::features() {
  return *getODSOperands(0).begin();
}

::mlir::LogicalResult Relu6OpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

::llvm::StringRef Relu6Op::getOperationName() {
  return "tf.Relu6";
}

std::pair<unsigned, unsigned> Relu6Op::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range Relu6Op::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value Relu6Op::features() {
  return *getODSOperands(0).begin();
}

::mlir::MutableOperandRange Relu6Op::featuresMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> Relu6Op::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range Relu6Op::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value Relu6Op::activations() {
  return *getODSResults(0).begin();
}

Type Relu6Op::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

bool Relu6Op::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "T") return true;
 return false;
}

::mlir::DictionaryAttr Relu6Op::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())}
    }, ctx);
}

void Relu6Op::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type activations, ::mlir::Value features) {
  odsState.addOperands(features);
  odsState.addTypes(activations);
}

void Relu6Op::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value features) {
  odsState.addOperands(features);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void Relu6Op::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

void Relu6Op::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value features) {
  odsState.addOperands(features);
  odsState.addTypes({features.getType()});

}

void Relu6Op::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  odsState.addTypes({operands[0].getType()});

}

::mlir::LogicalResult Relu6Op::verify() {
  if (failed(Relu6OpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of integer or floating-point values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>())))))) {
        return emitOpError("result #") << index << " must be tensor of integer or floating-point values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void Relu6Op::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::ReluGradOp definitions
//===----------------------------------------------------------------------===//

ReluGradOpAdaptor::ReluGradOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

ReluGradOpAdaptor::ReluGradOpAdaptor(ReluGradOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> ReluGradOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange ReluGradOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value ReluGradOpAdaptor::gradients() {
  return *getODSOperands(0).begin();
}

::mlir::Value ReluGradOpAdaptor::features() {
  return *getODSOperands(1).begin();
}

::mlir::LogicalResult ReluGradOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

::llvm::StringRef ReluGradOp::getOperationName() {
  return "tf.ReluGrad";
}

std::pair<unsigned, unsigned> ReluGradOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range ReluGradOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value ReluGradOp::gradients() {
  return *getODSOperands(0).begin();
}

::mlir::Value ReluGradOp::features() {
  return *getODSOperands(1).begin();
}

::mlir::MutableOperandRange ReluGradOp::gradientsMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange ReluGradOp::featuresMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> ReluGradOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range ReluGradOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value ReluGradOp::backprops() {
  return *getODSResults(0).begin();
}

Type ReluGradOp::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

bool ReluGradOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "T") return true;
 return false;
}

::mlir::DictionaryAttr ReluGradOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())}
    }, ctx);
}

void ReluGradOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type backprops, ::mlir::Value gradients, ::mlir::Value features) {
  odsState.addOperands(gradients);
  odsState.addOperands(features);
  odsState.addTypes(backprops);
}

void ReluGradOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value gradients, ::mlir::Value features) {
  odsState.addOperands(gradients);
  odsState.addOperands(features);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void ReluGradOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

void ReluGradOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value gradients, ::mlir::Value features) {
  odsState.addOperands(gradients);
  odsState.addOperands(features);
  odsState.addTypes({gradients.getType()});

}

void ReluGradOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  odsState.addTypes({operands[0].getType()});

}

::mlir::LogicalResult ReluGradOp::verify() {
  if (failed(ReluGradOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of integer or floating-point values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of integer or floating-point values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>())))))) {
        return emitOpError("result #") << index << " must be tensor of integer or floating-point values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void ReluGradOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::ReluOp definitions
//===----------------------------------------------------------------------===//

ReluOpAdaptor::ReluOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

ReluOpAdaptor::ReluOpAdaptor(ReluOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> ReluOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange ReluOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value ReluOpAdaptor::features() {
  return *getODSOperands(0).begin();
}

::mlir::LogicalResult ReluOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

::llvm::StringRef ReluOp::getOperationName() {
  return "tf.Relu";
}

std::pair<unsigned, unsigned> ReluOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range ReluOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value ReluOp::features() {
  return *getODSOperands(0).begin();
}

::mlir::MutableOperandRange ReluOp::featuresMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> ReluOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range ReluOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value ReluOp::activations() {
  return *getODSResults(0).begin();
}

Type ReluOp::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

bool ReluOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "T") return true;
 return false;
}

::mlir::DictionaryAttr ReluOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())}
    }, ctx);
}

void ReluOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type activations, ::mlir::Value features) {
  odsState.addOperands(features);
  odsState.addTypes(activations);
}

void ReluOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value features) {
  odsState.addOperands(features);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void ReluOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

void ReluOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value features) {
  odsState.addOperands(features);
  odsState.addTypes({features.getType()});

}

void ReluOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  odsState.addTypes({operands[0].getType()});

}

::mlir::LogicalResult ReluOp::verify() {
  if (failed(ReluOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of bfloat16 or 16-bit float or 32-bit float or 64-bit float or 16-bit integer or 32-bit integer or 64-bit integer or 8-bit integer or 8-bit quantized integer or 16-bit unsigned integer or 32-bit unsigned integer or 64-bit unsigned integer or 8-bit unsigned integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>())))))) {
        return emitOpError("result #") << index << " must be tensor of bfloat16 or 16-bit float or 32-bit float or 64-bit float or 16-bit integer or 32-bit integer or 64-bit integer or 8-bit integer or 8-bit quantized integer or 16-bit unsigned integer or 32-bit unsigned integer or 64-bit unsigned integer or 8-bit unsigned integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void ReluOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::ReshapeOp definitions
//===----------------------------------------------------------------------===//

ReshapeOpAdaptor::ReshapeOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

ReshapeOpAdaptor::ReshapeOpAdaptor(ReshapeOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> ReshapeOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange ReshapeOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value ReshapeOpAdaptor::tensor() {
  return *getODSOperands(0).begin();
}

::mlir::Value ReshapeOpAdaptor::shape() {
  return *getODSOperands(1).begin();
}

::mlir::LogicalResult ReshapeOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

::llvm::StringRef ReshapeOp::getOperationName() {
  return "tf.Reshape";
}

std::pair<unsigned, unsigned> ReshapeOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range ReshapeOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value ReshapeOp::tensor() {
  return *getODSOperands(0).begin();
}

::mlir::Value ReshapeOp::shape() {
  return *getODSOperands(1).begin();
}

::mlir::MutableOperandRange ReshapeOp::tensorMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange ReshapeOp::shapeMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> ReshapeOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range ReshapeOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value ReshapeOp::output() {
  return *getODSResults(0).begin();
}

Type ReshapeOp::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

Type ReshapeOp::Tshape() {
  return mlir::getElementTypeOrSelf(*getODSOperands(1).begin());
}

bool ReshapeOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "T") return true;
  if (name == "Tshape") return true;
 return false;
}

::mlir::DictionaryAttr ReshapeOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())},
    {::mlir::Identifier::get("Tshape", ctx),
::mlir::TypeAttr::get(Tshape())}
    }, ctx);
}



void ReshapeOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value tensor, ::mlir::Value shape) {
  odsState.addOperands(tensor);
  odsState.addOperands(shape);
  odsState.addTypes(output);
}

void ReshapeOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value tensor, ::mlir::Value shape) {
  odsState.addOperands(tensor);
  odsState.addOperands(shape);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void ReshapeOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult ReshapeOp::verify() {
  if (failed(ReshapeOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>())))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::TensorFlowType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of tf.dtype values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of 32/64-bit signed integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>())))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::TensorFlowType>()))))) {
        return emitOpError("result #") << index << " must be tensor of tf.dtype values, but got " << v.getType();
      }
      ++index;
    }
  }
  return Verify(*this);
}





void ReshapeOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::ResizeBilinearGradOp definitions
//===----------------------------------------------------------------------===//

ResizeBilinearGradOpAdaptor::ResizeBilinearGradOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

ResizeBilinearGradOpAdaptor::ResizeBilinearGradOpAdaptor(ResizeBilinearGradOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> ResizeBilinearGradOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange ResizeBilinearGradOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value ResizeBilinearGradOpAdaptor::grads() {
  return *getODSOperands(0).begin();
}

::mlir::Value ResizeBilinearGradOpAdaptor::original_image() {
  return *getODSOperands(1).begin();
}

::mlir::BoolAttr ResizeBilinearGradOpAdaptor::align_corners() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::BoolAttr attr = odsAttrs.get("align_corners").dyn_cast_or_null<::mlir::BoolAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getBoolAttr(false);
  return attr;
}

::mlir::BoolAttr ResizeBilinearGradOpAdaptor::half_pixel_centers() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::BoolAttr attr = odsAttrs.get("half_pixel_centers").dyn_cast_or_null<::mlir::BoolAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getBoolAttr(false);
  return attr;
}

::mlir::LogicalResult ResizeBilinearGradOpAdaptor::verify(::mlir::Location loc) {
  {
  auto tblgen_align_corners = odsAttrs.get("align_corners");
  if (tblgen_align_corners) {
    if (!((tblgen_align_corners.isa<::mlir::BoolAttr>()))) return emitError(loc, "'tf.ResizeBilinearGrad' op ""attribute 'align_corners' failed to satisfy constraint: bool attribute");
  }
  }
  {
  auto tblgen_half_pixel_centers = odsAttrs.get("half_pixel_centers");
  if (tblgen_half_pixel_centers) {
    if (!((tblgen_half_pixel_centers.isa<::mlir::BoolAttr>()))) return emitError(loc, "'tf.ResizeBilinearGrad' op ""attribute 'half_pixel_centers' failed to satisfy constraint: bool attribute");
  }
  }
  return ::mlir::success();
}

::llvm::StringRef ResizeBilinearGradOp::getOperationName() {
  return "tf.ResizeBilinearGrad";
}

std::pair<unsigned, unsigned> ResizeBilinearGradOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range ResizeBilinearGradOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value ResizeBilinearGradOp::grads() {
  return *getODSOperands(0).begin();
}

::mlir::Value ResizeBilinearGradOp::original_image() {
  return *getODSOperands(1).begin();
}

::mlir::MutableOperandRange ResizeBilinearGradOp::gradsMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange ResizeBilinearGradOp::original_imageMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> ResizeBilinearGradOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range ResizeBilinearGradOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value ResizeBilinearGradOp::output() {
  return *getODSResults(0).begin();
}

::mlir::BoolAttr ResizeBilinearGradOp::align_cornersAttr() {
  return this->getAttr("align_corners").dyn_cast_or_null<::mlir::BoolAttr>();
}

bool ResizeBilinearGradOp::align_corners() {
  auto attr = align_cornersAttr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getBoolAttr(false).getValue();
  return attr.getValue();
}

::mlir::BoolAttr ResizeBilinearGradOp::half_pixel_centersAttr() {
  return this->getAttr("half_pixel_centers").dyn_cast_or_null<::mlir::BoolAttr>();
}

bool ResizeBilinearGradOp::half_pixel_centers() {
  auto attr = half_pixel_centersAttr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getBoolAttr(false).getValue();
  return attr.getValue();
}

Type ResizeBilinearGradOp::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(1).begin());
}

bool ResizeBilinearGradOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "T") return true;
 return false;
}

::mlir::DictionaryAttr ResizeBilinearGradOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())}
    }, ctx);
}

void ResizeBilinearGradOp::align_cornersAttr(::mlir::BoolAttr attr) {
  this->getOperation()->setAttr("align_corners", attr);
}

void ResizeBilinearGradOp::half_pixel_centersAttr(::mlir::BoolAttr attr) {
  this->getOperation()->setAttr("half_pixel_centers", attr);
}

void ResizeBilinearGradOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value grads, ::mlir::Value original_image, ::mlir::BoolAttr align_corners, ::mlir::BoolAttr half_pixel_centers) {
  odsState.addOperands(grads);
  odsState.addOperands(original_image);
  odsState.addAttribute("align_corners", align_corners);
  odsState.addAttribute("half_pixel_centers", half_pixel_centers);
  odsState.addTypes(output);
}

void ResizeBilinearGradOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value grads, ::mlir::Value original_image, ::mlir::BoolAttr align_corners, ::mlir::BoolAttr half_pixel_centers) {
  odsState.addOperands(grads);
  odsState.addOperands(original_image);
  odsState.addAttribute("align_corners", align_corners);
  odsState.addAttribute("half_pixel_centers", half_pixel_centers);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void ResizeBilinearGradOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value grads, ::mlir::Value original_image, bool align_corners, bool half_pixel_centers) {
  odsState.addOperands(grads);
  odsState.addOperands(original_image);
  odsState.addAttribute("align_corners", odsBuilder.getBoolAttr(align_corners));
  odsState.addAttribute("half_pixel_centers", odsBuilder.getBoolAttr(half_pixel_centers));
  odsState.addTypes(output);
}

void ResizeBilinearGradOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value grads, ::mlir::Value original_image, bool align_corners, bool half_pixel_centers) {
  odsState.addOperands(grads);
  odsState.addOperands(original_image);
  odsState.addAttribute("align_corners", odsBuilder.getBoolAttr(align_corners));
  odsState.addAttribute("half_pixel_centers", odsBuilder.getBoolAttr(half_pixel_centers));
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void ResizeBilinearGradOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult ResizeBilinearGradOp::verify() {
  if (failed(ResizeBilinearGradOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of 32-bit float values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of floating-point values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))))) {
        return emitOpError("result #") << index << " must be tensor of floating-point values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void ResizeBilinearGradOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::ResizeBilinearOp definitions
//===----------------------------------------------------------------------===//

ResizeBilinearOpAdaptor::ResizeBilinearOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

ResizeBilinearOpAdaptor::ResizeBilinearOpAdaptor(ResizeBilinearOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> ResizeBilinearOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange ResizeBilinearOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value ResizeBilinearOpAdaptor::images() {
  return *getODSOperands(0).begin();
}

::mlir::Value ResizeBilinearOpAdaptor::size() {
  return *getODSOperands(1).begin();
}

::mlir::BoolAttr ResizeBilinearOpAdaptor::align_corners() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::BoolAttr attr = odsAttrs.get("align_corners").dyn_cast_or_null<::mlir::BoolAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getBoolAttr(false);
  return attr;
}

::mlir::BoolAttr ResizeBilinearOpAdaptor::half_pixel_centers() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::BoolAttr attr = odsAttrs.get("half_pixel_centers").dyn_cast_or_null<::mlir::BoolAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getBoolAttr(false);
  return attr;
}

::mlir::LogicalResult ResizeBilinearOpAdaptor::verify(::mlir::Location loc) {
  {
  auto tblgen_align_corners = odsAttrs.get("align_corners");
  if (tblgen_align_corners) {
    if (!((tblgen_align_corners.isa<::mlir::BoolAttr>()))) return emitError(loc, "'tf.ResizeBilinear' op ""attribute 'align_corners' failed to satisfy constraint: bool attribute");
  }
  }
  {
  auto tblgen_half_pixel_centers = odsAttrs.get("half_pixel_centers");
  if (tblgen_half_pixel_centers) {
    if (!((tblgen_half_pixel_centers.isa<::mlir::BoolAttr>()))) return emitError(loc, "'tf.ResizeBilinear' op ""attribute 'half_pixel_centers' failed to satisfy constraint: bool attribute");
  }
  }
  return ::mlir::success();
}

::llvm::StringRef ResizeBilinearOp::getOperationName() {
  return "tf.ResizeBilinear";
}

std::pair<unsigned, unsigned> ResizeBilinearOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range ResizeBilinearOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value ResizeBilinearOp::images() {
  return *getODSOperands(0).begin();
}

::mlir::Value ResizeBilinearOp::size() {
  return *getODSOperands(1).begin();
}

::mlir::MutableOperandRange ResizeBilinearOp::imagesMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange ResizeBilinearOp::sizeMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> ResizeBilinearOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range ResizeBilinearOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value ResizeBilinearOp::resized_images() {
  return *getODSResults(0).begin();
}

::mlir::BoolAttr ResizeBilinearOp::align_cornersAttr() {
  return this->getAttr("align_corners").dyn_cast_or_null<::mlir::BoolAttr>();
}

bool ResizeBilinearOp::align_corners() {
  auto attr = align_cornersAttr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getBoolAttr(false).getValue();
  return attr.getValue();
}

::mlir::BoolAttr ResizeBilinearOp::half_pixel_centersAttr() {
  return this->getAttr("half_pixel_centers").dyn_cast_or_null<::mlir::BoolAttr>();
}

bool ResizeBilinearOp::half_pixel_centers() {
  auto attr = half_pixel_centersAttr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getBoolAttr(false).getValue();
  return attr.getValue();
}

Type ResizeBilinearOp::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

bool ResizeBilinearOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "T") return true;
 return false;
}

::mlir::DictionaryAttr ResizeBilinearOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())}
    }, ctx);
}

void ResizeBilinearOp::align_cornersAttr(::mlir::BoolAttr attr) {
  this->getOperation()->setAttr("align_corners", attr);
}

void ResizeBilinearOp::half_pixel_centersAttr(::mlir::BoolAttr attr) {
  this->getOperation()->setAttr("half_pixel_centers", attr);
}

void ResizeBilinearOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type resized_images, ::mlir::Value images, ::mlir::Value size, ::mlir::BoolAttr align_corners, ::mlir::BoolAttr half_pixel_centers) {
  odsState.addOperands(images);
  odsState.addOperands(size);
  odsState.addAttribute("align_corners", align_corners);
  odsState.addAttribute("half_pixel_centers", half_pixel_centers);
  odsState.addTypes(resized_images);
}

void ResizeBilinearOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value images, ::mlir::Value size, ::mlir::BoolAttr align_corners, ::mlir::BoolAttr half_pixel_centers) {
  odsState.addOperands(images);
  odsState.addOperands(size);
  odsState.addAttribute("align_corners", align_corners);
  odsState.addAttribute("half_pixel_centers", half_pixel_centers);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void ResizeBilinearOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type resized_images, ::mlir::Value images, ::mlir::Value size, bool align_corners, bool half_pixel_centers) {
  odsState.addOperands(images);
  odsState.addOperands(size);
  odsState.addAttribute("align_corners", odsBuilder.getBoolAttr(align_corners));
  odsState.addAttribute("half_pixel_centers", odsBuilder.getBoolAttr(half_pixel_centers));
  odsState.addTypes(resized_images);
}

void ResizeBilinearOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value images, ::mlir::Value size, bool align_corners, bool half_pixel_centers) {
  odsState.addOperands(images);
  odsState.addOperands(size);
  odsState.addAttribute("align_corners", odsBuilder.getBoolAttr(align_corners));
  odsState.addAttribute("half_pixel_centers", odsBuilder.getBoolAttr(half_pixel_centers));
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void ResizeBilinearOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult ResizeBilinearOp::verify() {
  if (failed(ResizeBilinearOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of bfloat16 or 16-bit float or 32-bit float or 64-bit float or 16-bit integer or 32-bit integer or 64-bit integer or 8-bit integer or 16-bit unsigned integer or 8-bit unsigned integer values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of 32-bit integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))))) {
        return emitOpError("result #") << index << " must be tensor of 32-bit float values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void ResizeBilinearOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::ResizeNearestNeighborGradOp definitions
//===----------------------------------------------------------------------===//

ResizeNearestNeighborGradOpAdaptor::ResizeNearestNeighborGradOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

ResizeNearestNeighborGradOpAdaptor::ResizeNearestNeighborGradOpAdaptor(ResizeNearestNeighborGradOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> ResizeNearestNeighborGradOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange ResizeNearestNeighborGradOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value ResizeNearestNeighborGradOpAdaptor::grads() {
  return *getODSOperands(0).begin();
}

::mlir::Value ResizeNearestNeighborGradOpAdaptor::size() {
  return *getODSOperands(1).begin();
}

::mlir::BoolAttr ResizeNearestNeighborGradOpAdaptor::align_corners() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::BoolAttr attr = odsAttrs.get("align_corners").dyn_cast_or_null<::mlir::BoolAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getBoolAttr(false);
  return attr;
}

::mlir::BoolAttr ResizeNearestNeighborGradOpAdaptor::half_pixel_centers() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::BoolAttr attr = odsAttrs.get("half_pixel_centers").dyn_cast_or_null<::mlir::BoolAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getBoolAttr(false);
  return attr;
}

::mlir::LogicalResult ResizeNearestNeighborGradOpAdaptor::verify(::mlir::Location loc) {
  {
  auto tblgen_align_corners = odsAttrs.get("align_corners");
  if (tblgen_align_corners) {
    if (!((tblgen_align_corners.isa<::mlir::BoolAttr>()))) return emitError(loc, "'tf.ResizeNearestNeighborGrad' op ""attribute 'align_corners' failed to satisfy constraint: bool attribute");
  }
  }
  {
  auto tblgen_half_pixel_centers = odsAttrs.get("half_pixel_centers");
  if (tblgen_half_pixel_centers) {
    if (!((tblgen_half_pixel_centers.isa<::mlir::BoolAttr>()))) return emitError(loc, "'tf.ResizeNearestNeighborGrad' op ""attribute 'half_pixel_centers' failed to satisfy constraint: bool attribute");
  }
  }
  return ::mlir::success();
}

::llvm::StringRef ResizeNearestNeighborGradOp::getOperationName() {
  return "tf.ResizeNearestNeighborGrad";
}

std::pair<unsigned, unsigned> ResizeNearestNeighborGradOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range ResizeNearestNeighborGradOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value ResizeNearestNeighborGradOp::grads() {
  return *getODSOperands(0).begin();
}

::mlir::Value ResizeNearestNeighborGradOp::size() {
  return *getODSOperands(1).begin();
}

::mlir::MutableOperandRange ResizeNearestNeighborGradOp::gradsMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange ResizeNearestNeighborGradOp::sizeMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> ResizeNearestNeighborGradOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range ResizeNearestNeighborGradOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value ResizeNearestNeighborGradOp::output() {
  return *getODSResults(0).begin();
}

::mlir::BoolAttr ResizeNearestNeighborGradOp::align_cornersAttr() {
  return this->getAttr("align_corners").dyn_cast_or_null<::mlir::BoolAttr>();
}

bool ResizeNearestNeighborGradOp::align_corners() {
  auto attr = align_cornersAttr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getBoolAttr(false).getValue();
  return attr.getValue();
}

::mlir::BoolAttr ResizeNearestNeighborGradOp::half_pixel_centersAttr() {
  return this->getAttr("half_pixel_centers").dyn_cast_or_null<::mlir::BoolAttr>();
}

bool ResizeNearestNeighborGradOp::half_pixel_centers() {
  auto attr = half_pixel_centersAttr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getBoolAttr(false).getValue();
  return attr.getValue();
}

Type ResizeNearestNeighborGradOp::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

bool ResizeNearestNeighborGradOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "T") return true;
 return false;
}

::mlir::DictionaryAttr ResizeNearestNeighborGradOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())}
    }, ctx);
}

void ResizeNearestNeighborGradOp::align_cornersAttr(::mlir::BoolAttr attr) {
  this->getOperation()->setAttr("align_corners", attr);
}

void ResizeNearestNeighborGradOp::half_pixel_centersAttr(::mlir::BoolAttr attr) {
  this->getOperation()->setAttr("half_pixel_centers", attr);
}

void ResizeNearestNeighborGradOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value grads, ::mlir::Value size, ::mlir::BoolAttr align_corners, ::mlir::BoolAttr half_pixel_centers) {
  odsState.addOperands(grads);
  odsState.addOperands(size);
  odsState.addAttribute("align_corners", align_corners);
  odsState.addAttribute("half_pixel_centers", half_pixel_centers);
  odsState.addTypes(output);
}

void ResizeNearestNeighborGradOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value grads, ::mlir::Value size, ::mlir::BoolAttr align_corners, ::mlir::BoolAttr half_pixel_centers) {
  odsState.addOperands(grads);
  odsState.addOperands(size);
  odsState.addAttribute("align_corners", align_corners);
  odsState.addAttribute("half_pixel_centers", half_pixel_centers);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void ResizeNearestNeighborGradOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value grads, ::mlir::Value size, bool align_corners, bool half_pixel_centers) {
  odsState.addOperands(grads);
  odsState.addOperands(size);
  odsState.addAttribute("align_corners", odsBuilder.getBoolAttr(align_corners));
  odsState.addAttribute("half_pixel_centers", odsBuilder.getBoolAttr(half_pixel_centers));
  odsState.addTypes(output);
}

void ResizeNearestNeighborGradOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value grads, ::mlir::Value size, bool align_corners, bool half_pixel_centers) {
  odsState.addOperands(grads);
  odsState.addOperands(size);
  odsState.addAttribute("align_corners", odsBuilder.getBoolAttr(align_corners));
  odsState.addAttribute("half_pixel_centers", odsBuilder.getBoolAttr(half_pixel_centers));
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void ResizeNearestNeighborGradOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult ResizeNearestNeighborGradOp::verify() {
  if (failed(ResizeNearestNeighborGradOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of 16-bit float or 32-bit float or 64-bit float or 32-bit integer or 8-bit integer or 8-bit unsigned integer values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of 32-bit integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>())))))) {
        return emitOpError("result #") << index << " must be tensor of 16-bit float or 32-bit float or 64-bit float or 32-bit integer or 8-bit integer or 8-bit unsigned integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void ResizeNearestNeighborGradOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::ResizeNearestNeighborOp definitions
//===----------------------------------------------------------------------===//

ResizeNearestNeighborOpAdaptor::ResizeNearestNeighborOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

ResizeNearestNeighborOpAdaptor::ResizeNearestNeighborOpAdaptor(ResizeNearestNeighborOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> ResizeNearestNeighborOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange ResizeNearestNeighborOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value ResizeNearestNeighborOpAdaptor::images() {
  return *getODSOperands(0).begin();
}

::mlir::Value ResizeNearestNeighborOpAdaptor::size() {
  return *getODSOperands(1).begin();
}

::mlir::BoolAttr ResizeNearestNeighborOpAdaptor::align_corners() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::BoolAttr attr = odsAttrs.get("align_corners").dyn_cast_or_null<::mlir::BoolAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getBoolAttr(false);
  return attr;
}

::mlir::BoolAttr ResizeNearestNeighborOpAdaptor::half_pixel_centers() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::BoolAttr attr = odsAttrs.get("half_pixel_centers").dyn_cast_or_null<::mlir::BoolAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getBoolAttr(false);
  return attr;
}

::mlir::LogicalResult ResizeNearestNeighborOpAdaptor::verify(::mlir::Location loc) {
  {
  auto tblgen_align_corners = odsAttrs.get("align_corners");
  if (tblgen_align_corners) {
    if (!((tblgen_align_corners.isa<::mlir::BoolAttr>()))) return emitError(loc, "'tf.ResizeNearestNeighbor' op ""attribute 'align_corners' failed to satisfy constraint: bool attribute");
  }
  }
  {
  auto tblgen_half_pixel_centers = odsAttrs.get("half_pixel_centers");
  if (tblgen_half_pixel_centers) {
    if (!((tblgen_half_pixel_centers.isa<::mlir::BoolAttr>()))) return emitError(loc, "'tf.ResizeNearestNeighbor' op ""attribute 'half_pixel_centers' failed to satisfy constraint: bool attribute");
  }
  }
  return ::mlir::success();
}

::llvm::StringRef ResizeNearestNeighborOp::getOperationName() {
  return "tf.ResizeNearestNeighbor";
}

std::pair<unsigned, unsigned> ResizeNearestNeighborOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range ResizeNearestNeighborOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value ResizeNearestNeighborOp::images() {
  return *getODSOperands(0).begin();
}

::mlir::Value ResizeNearestNeighborOp::size() {
  return *getODSOperands(1).begin();
}

::mlir::MutableOperandRange ResizeNearestNeighborOp::imagesMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange ResizeNearestNeighborOp::sizeMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> ResizeNearestNeighborOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range ResizeNearestNeighborOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value ResizeNearestNeighborOp::resized_images() {
  return *getODSResults(0).begin();
}

::mlir::BoolAttr ResizeNearestNeighborOp::align_cornersAttr() {
  return this->getAttr("align_corners").dyn_cast_or_null<::mlir::BoolAttr>();
}

bool ResizeNearestNeighborOp::align_corners() {
  auto attr = align_cornersAttr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getBoolAttr(false).getValue();
  return attr.getValue();
}

::mlir::BoolAttr ResizeNearestNeighborOp::half_pixel_centersAttr() {
  return this->getAttr("half_pixel_centers").dyn_cast_or_null<::mlir::BoolAttr>();
}

bool ResizeNearestNeighborOp::half_pixel_centers() {
  auto attr = half_pixel_centersAttr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getBoolAttr(false).getValue();
  return attr.getValue();
}

Type ResizeNearestNeighborOp::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

bool ResizeNearestNeighborOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "T") return true;
 return false;
}

::mlir::DictionaryAttr ResizeNearestNeighborOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())}
    }, ctx);
}

void ResizeNearestNeighborOp::align_cornersAttr(::mlir::BoolAttr attr) {
  this->getOperation()->setAttr("align_corners", attr);
}

void ResizeNearestNeighborOp::half_pixel_centersAttr(::mlir::BoolAttr attr) {
  this->getOperation()->setAttr("half_pixel_centers", attr);
}

void ResizeNearestNeighborOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type resized_images, ::mlir::Value images, ::mlir::Value size, ::mlir::BoolAttr align_corners, ::mlir::BoolAttr half_pixel_centers) {
  odsState.addOperands(images);
  odsState.addOperands(size);
  odsState.addAttribute("align_corners", align_corners);
  odsState.addAttribute("half_pixel_centers", half_pixel_centers);
  odsState.addTypes(resized_images);
}

void ResizeNearestNeighborOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value images, ::mlir::Value size, ::mlir::BoolAttr align_corners, ::mlir::BoolAttr half_pixel_centers) {
  odsState.addOperands(images);
  odsState.addOperands(size);
  odsState.addAttribute("align_corners", align_corners);
  odsState.addAttribute("half_pixel_centers", half_pixel_centers);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void ResizeNearestNeighborOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type resized_images, ::mlir::Value images, ::mlir::Value size, bool align_corners, bool half_pixel_centers) {
  odsState.addOperands(images);
  odsState.addOperands(size);
  odsState.addAttribute("align_corners", odsBuilder.getBoolAttr(align_corners));
  odsState.addAttribute("half_pixel_centers", odsBuilder.getBoolAttr(half_pixel_centers));
  odsState.addTypes(resized_images);
}

void ResizeNearestNeighborOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value images, ::mlir::Value size, bool align_corners, bool half_pixel_centers) {
  odsState.addOperands(images);
  odsState.addOperands(size);
  odsState.addAttribute("align_corners", odsBuilder.getBoolAttr(align_corners));
  odsState.addAttribute("half_pixel_centers", odsBuilder.getBoolAttr(half_pixel_centers));
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void ResizeNearestNeighborOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult ResizeNearestNeighborOp::verify() {
  if (failed(ResizeNearestNeighborOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of bfloat16 or 16-bit float or 32-bit float or 64-bit float or 16-bit integer or 32-bit integer or 64-bit integer or 8-bit integer or 16-bit unsigned integer or 8-bit unsigned integer values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of 32-bit integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>())))))) {
        return emitOpError("result #") << index << " must be tensor of bfloat16 or 16-bit float or 32-bit float or 64-bit float or 16-bit integer or 32-bit integer or 64-bit integer or 8-bit integer or 16-bit unsigned integer or 8-bit unsigned integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void ResizeNearestNeighborOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::ResourceApplyAdaMaxOp definitions
//===----------------------------------------------------------------------===//

ResourceApplyAdaMaxOpAdaptor::ResourceApplyAdaMaxOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

ResourceApplyAdaMaxOpAdaptor::ResourceApplyAdaMaxOpAdaptor(ResourceApplyAdaMaxOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> ResourceApplyAdaMaxOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange ResourceApplyAdaMaxOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value ResourceApplyAdaMaxOpAdaptor::var() {
  return *getODSOperands(0).begin();
}

::mlir::Value ResourceApplyAdaMaxOpAdaptor::m() {
  return *getODSOperands(1).begin();
}

::mlir::Value ResourceApplyAdaMaxOpAdaptor::v() {
  return *getODSOperands(2).begin();
}

::mlir::Value ResourceApplyAdaMaxOpAdaptor::beta1_power() {
  return *getODSOperands(3).begin();
}

::mlir::Value ResourceApplyAdaMaxOpAdaptor::lr() {
  return *getODSOperands(4).begin();
}

::mlir::Value ResourceApplyAdaMaxOpAdaptor::beta1() {
  return *getODSOperands(5).begin();
}

::mlir::Value ResourceApplyAdaMaxOpAdaptor::beta2() {
  return *getODSOperands(6).begin();
}

::mlir::Value ResourceApplyAdaMaxOpAdaptor::epsilon() {
  return *getODSOperands(7).begin();
}

::mlir::Value ResourceApplyAdaMaxOpAdaptor::grad() {
  return *getODSOperands(8).begin();
}

::mlir::BoolAttr ResourceApplyAdaMaxOpAdaptor::use_locking() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::BoolAttr attr = odsAttrs.get("use_locking").dyn_cast_or_null<::mlir::BoolAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getBoolAttr(false);
  return attr;
}

::mlir::LogicalResult ResourceApplyAdaMaxOpAdaptor::verify(::mlir::Location loc) {
  {
  auto tblgen_use_locking = odsAttrs.get("use_locking");
  if (tblgen_use_locking) {
    if (!((tblgen_use_locking.isa<::mlir::BoolAttr>()))) return emitError(loc, "'tf.ResourceApplyAdaMax' op ""attribute 'use_locking' failed to satisfy constraint: bool attribute");
  }
  }
  return ::mlir::success();
}

::llvm::StringRef ResourceApplyAdaMaxOp::getOperationName() {
  return "tf.ResourceApplyAdaMax";
}

std::pair<unsigned, unsigned> ResourceApplyAdaMaxOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range ResourceApplyAdaMaxOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value ResourceApplyAdaMaxOp::var() {
  return *getODSOperands(0).begin();
}

::mlir::Value ResourceApplyAdaMaxOp::m() {
  return *getODSOperands(1).begin();
}

::mlir::Value ResourceApplyAdaMaxOp::v() {
  return *getODSOperands(2).begin();
}

::mlir::Value ResourceApplyAdaMaxOp::beta1_power() {
  return *getODSOperands(3).begin();
}

::mlir::Value ResourceApplyAdaMaxOp::lr() {
  return *getODSOperands(4).begin();
}

::mlir::Value ResourceApplyAdaMaxOp::beta1() {
  return *getODSOperands(5).begin();
}

::mlir::Value ResourceApplyAdaMaxOp::beta2() {
  return *getODSOperands(6).begin();
}

::mlir::Value ResourceApplyAdaMaxOp::epsilon() {
  return *getODSOperands(7).begin();
}

::mlir::Value ResourceApplyAdaMaxOp::grad() {
  return *getODSOperands(8).begin();
}

::mlir::MutableOperandRange ResourceApplyAdaMaxOp::varMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange ResourceApplyAdaMaxOp::mMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange ResourceApplyAdaMaxOp::vMutable() {
  auto range = getODSOperandIndexAndLength(2);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange ResourceApplyAdaMaxOp::beta1_powerMutable() {
  auto range = getODSOperandIndexAndLength(3);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange ResourceApplyAdaMaxOp::lrMutable() {
  auto range = getODSOperandIndexAndLength(4);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange ResourceApplyAdaMaxOp::beta1Mutable() {
  auto range = getODSOperandIndexAndLength(5);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange ResourceApplyAdaMaxOp::beta2Mutable() {
  auto range = getODSOperandIndexAndLength(6);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange ResourceApplyAdaMaxOp::epsilonMutable() {
  auto range = getODSOperandIndexAndLength(7);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange ResourceApplyAdaMaxOp::gradMutable() {
  auto range = getODSOperandIndexAndLength(8);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> ResourceApplyAdaMaxOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range ResourceApplyAdaMaxOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::BoolAttr ResourceApplyAdaMaxOp::use_lockingAttr() {
  return this->getAttr("use_locking").dyn_cast_or_null<::mlir::BoolAttr>();
}

bool ResourceApplyAdaMaxOp::use_locking() {
  auto attr = use_lockingAttr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getBoolAttr(false).getValue();
  return attr.getValue();
}

Type ResourceApplyAdaMaxOp::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(3).begin());
}

bool ResourceApplyAdaMaxOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "T") return true;
 return false;
}

::mlir::DictionaryAttr ResourceApplyAdaMaxOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())}
    }, ctx);
}

void ResourceApplyAdaMaxOp::use_lockingAttr(::mlir::BoolAttr attr) {
  this->getOperation()->setAttr("use_locking", attr);
}

void ResourceApplyAdaMaxOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value var, ::mlir::Value m, ::mlir::Value v, ::mlir::Value beta1_power, ::mlir::Value lr, ::mlir::Value beta1, ::mlir::Value beta2, ::mlir::Value epsilon, ::mlir::Value grad, ::mlir::BoolAttr use_locking) {
  odsState.addOperands(var);
  odsState.addOperands(m);
  odsState.addOperands(v);
  odsState.addOperands(beta1_power);
  odsState.addOperands(lr);
  odsState.addOperands(beta1);
  odsState.addOperands(beta2);
  odsState.addOperands(epsilon);
  odsState.addOperands(grad);
  odsState.addAttribute("use_locking", use_locking);
}

void ResourceApplyAdaMaxOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value var, ::mlir::Value m, ::mlir::Value v, ::mlir::Value beta1_power, ::mlir::Value lr, ::mlir::Value beta1, ::mlir::Value beta2, ::mlir::Value epsilon, ::mlir::Value grad, ::mlir::BoolAttr use_locking) {
  odsState.addOperands(var);
  odsState.addOperands(m);
  odsState.addOperands(v);
  odsState.addOperands(beta1_power);
  odsState.addOperands(lr);
  odsState.addOperands(beta1);
  odsState.addOperands(beta2);
  odsState.addOperands(epsilon);
  odsState.addOperands(grad);
  odsState.addAttribute("use_locking", use_locking);
  assert(resultTypes.size() == 0u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void ResourceApplyAdaMaxOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value var, ::mlir::Value m, ::mlir::Value v, ::mlir::Value beta1_power, ::mlir::Value lr, ::mlir::Value beta1, ::mlir::Value beta2, ::mlir::Value epsilon, ::mlir::Value grad, bool use_locking) {
  odsState.addOperands(var);
  odsState.addOperands(m);
  odsState.addOperands(v);
  odsState.addOperands(beta1_power);
  odsState.addOperands(lr);
  odsState.addOperands(beta1);
  odsState.addOperands(beta2);
  odsState.addOperands(epsilon);
  odsState.addOperands(grad);
  odsState.addAttribute("use_locking", odsBuilder.getBoolAttr(use_locking));
}

void ResourceApplyAdaMaxOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value var, ::mlir::Value m, ::mlir::Value v, ::mlir::Value beta1_power, ::mlir::Value lr, ::mlir::Value beta1, ::mlir::Value beta2, ::mlir::Value epsilon, ::mlir::Value grad, bool use_locking) {
  odsState.addOperands(var);
  odsState.addOperands(m);
  odsState.addOperands(v);
  odsState.addOperands(beta1_power);
  odsState.addOperands(lr);
  odsState.addOperands(beta1);
  odsState.addOperands(beta2);
  odsState.addOperands(epsilon);
  odsState.addOperands(grad);
  odsState.addAttribute("use_locking", odsBuilder.getBoolAttr(use_locking));
  assert(resultTypes.size() == 0u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void ResourceApplyAdaMaxOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 9u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 0u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult ResourceApplyAdaMaxOp::verify() {
  if (failed(ResourceApplyAdaMaxOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::ResourceType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::ResourceRefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of resource values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::ResourceType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::ResourceRefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of resource values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup2 = getODSOperands(2);
    for (::mlir::Value v : valueGroup2) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::ResourceType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::ResourceRefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of resource values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup3 = getODSOperands(3);
    for (::mlir::Value v : valueGroup3) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of bfloat16 or 128-bit complex or 64-bit complex or 16-bit float or 32-bit float or 64-bit float or 16-bit integer or 32-bit integer or 64-bit integer or 8-bit integer or 32-bit quantized integer or 8-bit quantized integer or 8-bit quantized unsigned integer or 16-bit unsigned integer or 32-bit unsigned integer or 64-bit unsigned integer or 8-bit unsigned integer values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup4 = getODSOperands(4);
    for (::mlir::Value v : valueGroup4) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of bfloat16 or 128-bit complex or 64-bit complex or 16-bit float or 32-bit float or 64-bit float or 16-bit integer or 32-bit integer or 64-bit integer or 8-bit integer or 32-bit quantized integer or 8-bit quantized integer or 8-bit quantized unsigned integer or 16-bit unsigned integer or 32-bit unsigned integer or 64-bit unsigned integer or 8-bit unsigned integer values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup5 = getODSOperands(5);
    for (::mlir::Value v : valueGroup5) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of bfloat16 or 128-bit complex or 64-bit complex or 16-bit float or 32-bit float or 64-bit float or 16-bit integer or 32-bit integer or 64-bit integer or 8-bit integer or 32-bit quantized integer or 8-bit quantized integer or 8-bit quantized unsigned integer or 16-bit unsigned integer or 32-bit unsigned integer or 64-bit unsigned integer or 8-bit unsigned integer values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup6 = getODSOperands(6);
    for (::mlir::Value v : valueGroup6) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of bfloat16 or 128-bit complex or 64-bit complex or 16-bit float or 32-bit float or 64-bit float or 16-bit integer or 32-bit integer or 64-bit integer or 8-bit integer or 32-bit quantized integer or 8-bit quantized integer or 8-bit quantized unsigned integer or 16-bit unsigned integer or 32-bit unsigned integer or 64-bit unsigned integer or 8-bit unsigned integer values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup7 = getODSOperands(7);
    for (::mlir::Value v : valueGroup7) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of bfloat16 or 128-bit complex or 64-bit complex or 16-bit float or 32-bit float or 64-bit float or 16-bit integer or 32-bit integer or 64-bit integer or 8-bit integer or 32-bit quantized integer or 8-bit quantized integer or 8-bit quantized unsigned integer or 16-bit unsigned integer or 32-bit unsigned integer or 64-bit unsigned integer or 8-bit unsigned integer values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup8 = getODSOperands(8);
    for (::mlir::Value v : valueGroup8) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of bfloat16 or 128-bit complex or 64-bit complex or 16-bit float or 32-bit float or 64-bit float or 16-bit integer or 32-bit integer or 64-bit integer or 8-bit integer or 32-bit quantized integer or 8-bit quantized integer or 8-bit quantized unsigned integer or 16-bit unsigned integer or 32-bit unsigned integer or 64-bit unsigned integer or 8-bit unsigned integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
  }
  return ::mlir::success();
}

void ResourceApplyAdaMaxOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
  for (::mlir::Value value : getODSOperands(0))
    effects.emplace_back(MemoryEffects::Read::get(), value, ::mlir::TF::ResourceEffects::Variable::get());
  for (::mlir::Value value : getODSOperands(0))
    effects.emplace_back(MemoryEffects::Write::get(), value, ::mlir::TF::ResourceEffects::Variable::get());
  for (::mlir::Value value : getODSOperands(1))
    effects.emplace_back(MemoryEffects::Read::get(), value, ::mlir::TF::ResourceEffects::Variable::get());
  for (::mlir::Value value : getODSOperands(1))
    effects.emplace_back(MemoryEffects::Write::get(), value, ::mlir::TF::ResourceEffects::Variable::get());
  for (::mlir::Value value : getODSOperands(2))
    effects.emplace_back(MemoryEffects::Read::get(), value, ::mlir::TF::ResourceEffects::Variable::get());
  for (::mlir::Value value : getODSOperands(2))
    effects.emplace_back(MemoryEffects::Write::get(), value, ::mlir::TF::ResourceEffects::Variable::get());
}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::ResourceApplyAdadeltaOp definitions
//===----------------------------------------------------------------------===//

ResourceApplyAdadeltaOpAdaptor::ResourceApplyAdadeltaOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

ResourceApplyAdadeltaOpAdaptor::ResourceApplyAdadeltaOpAdaptor(ResourceApplyAdadeltaOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> ResourceApplyAdadeltaOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange ResourceApplyAdadeltaOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value ResourceApplyAdadeltaOpAdaptor::var() {
  return *getODSOperands(0).begin();
}

::mlir::Value ResourceApplyAdadeltaOpAdaptor::accum() {
  return *getODSOperands(1).begin();
}

::mlir::Value ResourceApplyAdadeltaOpAdaptor::accum_update() {
  return *getODSOperands(2).begin();
}

::mlir::Value ResourceApplyAdadeltaOpAdaptor::lr() {
  return *getODSOperands(3).begin();
}

::mlir::Value ResourceApplyAdadeltaOpAdaptor::rho() {
  return *getODSOperands(4).begin();
}

::mlir::Value ResourceApplyAdadeltaOpAdaptor::epsilon() {
  return *getODSOperands(5).begin();
}

::mlir::Value ResourceApplyAdadeltaOpAdaptor::grad() {
  return *getODSOperands(6).begin();
}

::mlir::BoolAttr ResourceApplyAdadeltaOpAdaptor::use_locking() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::BoolAttr attr = odsAttrs.get("use_locking").dyn_cast_or_null<::mlir::BoolAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getBoolAttr(false);
  return attr;
}

::mlir::LogicalResult ResourceApplyAdadeltaOpAdaptor::verify(::mlir::Location loc) {
  {
  auto tblgen_use_locking = odsAttrs.get("use_locking");
  if (tblgen_use_locking) {
    if (!((tblgen_use_locking.isa<::mlir::BoolAttr>()))) return emitError(loc, "'tf.ResourceApplyAdadelta' op ""attribute 'use_locking' failed to satisfy constraint: bool attribute");
  }
  }
  return ::mlir::success();
}

::llvm::StringRef ResourceApplyAdadeltaOp::getOperationName() {
  return "tf.ResourceApplyAdadelta";
}

std::pair<unsigned, unsigned> ResourceApplyAdadeltaOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range ResourceApplyAdadeltaOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value ResourceApplyAdadeltaOp::var() {
  return *getODSOperands(0).begin();
}

::mlir::Value ResourceApplyAdadeltaOp::accum() {
  return *getODSOperands(1).begin();
}

::mlir::Value ResourceApplyAdadeltaOp::accum_update() {
  return *getODSOperands(2).begin();
}

::mlir::Value ResourceApplyAdadeltaOp::lr() {
  return *getODSOperands(3).begin();
}

::mlir::Value ResourceApplyAdadeltaOp::rho() {
  return *getODSOperands(4).begin();
}

::mlir::Value ResourceApplyAdadeltaOp::epsilon() {
  return *getODSOperands(5).begin();
}

::mlir::Value ResourceApplyAdadeltaOp::grad() {
  return *getODSOperands(6).begin();
}

::mlir::MutableOperandRange ResourceApplyAdadeltaOp::varMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange ResourceApplyAdadeltaOp::accumMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange ResourceApplyAdadeltaOp::accum_updateMutable() {
  auto range = getODSOperandIndexAndLength(2);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange ResourceApplyAdadeltaOp::lrMutable() {
  auto range = getODSOperandIndexAndLength(3);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange ResourceApplyAdadeltaOp::rhoMutable() {
  auto range = getODSOperandIndexAndLength(4);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange ResourceApplyAdadeltaOp::epsilonMutable() {
  auto range = getODSOperandIndexAndLength(5);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange ResourceApplyAdadeltaOp::gradMutable() {
  auto range = getODSOperandIndexAndLength(6);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> ResourceApplyAdadeltaOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range ResourceApplyAdadeltaOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::BoolAttr ResourceApplyAdadeltaOp::use_lockingAttr() {
  return this->getAttr("use_locking").dyn_cast_or_null<::mlir::BoolAttr>();
}

bool ResourceApplyAdadeltaOp::use_locking() {
  auto attr = use_lockingAttr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getBoolAttr(false).getValue();
  return attr.getValue();
}

Type ResourceApplyAdadeltaOp::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(3).begin());
}

bool ResourceApplyAdadeltaOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "T") return true;
 return false;
}

::mlir::DictionaryAttr ResourceApplyAdadeltaOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())}
    }, ctx);
}

void ResourceApplyAdadeltaOp::use_lockingAttr(::mlir::BoolAttr attr) {
  this->getOperation()->setAttr("use_locking", attr);
}

void ResourceApplyAdadeltaOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value var, ::mlir::Value accum, ::mlir::Value accum_update, ::mlir::Value lr, ::mlir::Value rho, ::mlir::Value epsilon, ::mlir::Value grad, ::mlir::BoolAttr use_locking) {
  odsState.addOperands(var);
  odsState.addOperands(accum);
  odsState.addOperands(accum_update);
  odsState.addOperands(lr);
  odsState.addOperands(rho);
  odsState.addOperands(epsilon);
  odsState.addOperands(grad);
  odsState.addAttribute("use_locking", use_locking);
}

void ResourceApplyAdadeltaOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value var, ::mlir::Value accum, ::mlir::Value accum_update, ::mlir::Value lr, ::mlir::Value rho, ::mlir::Value epsilon, ::mlir::Value grad, ::mlir::BoolAttr use_locking) {
  odsState.addOperands(var);
  odsState.addOperands(accum);
  odsState.addOperands(accum_update);
  odsState.addOperands(lr);
  odsState.addOperands(rho);
  odsState.addOperands(epsilon);
  odsState.addOperands(grad);
  odsState.addAttribute("use_locking", use_locking);
  assert(resultTypes.size() == 0u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void ResourceApplyAdadeltaOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value var, ::mlir::Value accum, ::mlir::Value accum_update, ::mlir::Value lr, ::mlir::Value rho, ::mlir::Value epsilon, ::mlir::Value grad, bool use_locking) {
  odsState.addOperands(var);
  odsState.addOperands(accum);
  odsState.addOperands(accum_update);
  odsState.addOperands(lr);
  odsState.addOperands(rho);
  odsState.addOperands(epsilon);
  odsState.addOperands(grad);
  odsState.addAttribute("use_locking", odsBuilder.getBoolAttr(use_locking));
}

void ResourceApplyAdadeltaOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value var, ::mlir::Value accum, ::mlir::Value accum_update, ::mlir::Value lr, ::mlir::Value rho, ::mlir::Value epsilon, ::mlir::Value grad, bool use_locking) {
  odsState.addOperands(var);
  odsState.addOperands(accum);
  odsState.addOperands(accum_update);
  odsState.addOperands(lr);
  odsState.addOperands(rho);
  odsState.addOperands(epsilon);
  odsState.addOperands(grad);
  odsState.addAttribute("use_locking", odsBuilder.getBoolAttr(use_locking));
  assert(resultTypes.size() == 0u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void ResourceApplyAdadeltaOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 7u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 0u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult ResourceApplyAdadeltaOp::verify() {
  if (failed(ResourceApplyAdadeltaOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::ResourceType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::ResourceRefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of resource values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::ResourceType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::ResourceRefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of resource values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup2 = getODSOperands(2);
    for (::mlir::Value v : valueGroup2) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::ResourceType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::ResourceRefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of resource values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup3 = getODSOperands(3);
    for (::mlir::Value v : valueGroup3) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of bfloat16 or 128-bit complex or 64-bit complex or 16-bit float or 32-bit float or 64-bit float or 16-bit integer or 32-bit integer or 64-bit integer or 8-bit integer or 32-bit quantized integer or 8-bit quantized integer or 8-bit quantized unsigned integer or 16-bit unsigned integer or 32-bit unsigned integer or 64-bit unsigned integer or 8-bit unsigned integer values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup4 = getODSOperands(4);
    for (::mlir::Value v : valueGroup4) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of bfloat16 or 128-bit complex or 64-bit complex or 16-bit float or 32-bit float or 64-bit float or 16-bit integer or 32-bit integer or 64-bit integer or 8-bit integer or 32-bit quantized integer or 8-bit quantized integer or 8-bit quantized unsigned integer or 16-bit unsigned integer or 32-bit unsigned integer or 64-bit unsigned integer or 8-bit unsigned integer values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup5 = getODSOperands(5);
    for (::mlir::Value v : valueGroup5) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of bfloat16 or 128-bit complex or 64-bit complex or 16-bit float or 32-bit float or 64-bit float or 16-bit integer or 32-bit integer or 64-bit integer or 8-bit integer or 32-bit quantized integer or 8-bit quantized integer or 8-bit quantized unsigned integer or 16-bit unsigned integer or 32-bit unsigned integer or 64-bit unsigned integer or 8-bit unsigned integer values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup6 = getODSOperands(6);
    for (::mlir::Value v : valueGroup6) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of bfloat16 or 128-bit complex or 64-bit complex or 16-bit float or 32-bit float or 64-bit float or 16-bit integer or 32-bit integer or 64-bit integer or 8-bit integer or 32-bit quantized integer or 8-bit quantized integer or 8-bit quantized unsigned integer or 16-bit unsigned integer or 32-bit unsigned integer or 64-bit unsigned integer or 8-bit unsigned integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
  }
  return ::mlir::success();
}

void ResourceApplyAdadeltaOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
  for (::mlir::Value value : getODSOperands(0))
    effects.emplace_back(MemoryEffects::Read::get(), value, ::mlir::TF::ResourceEffects::Variable::get());
  for (::mlir::Value value : getODSOperands(0))
    effects.emplace_back(MemoryEffects::Write::get(), value, ::mlir::TF::ResourceEffects::Variable::get());
  for (::mlir::Value value : getODSOperands(1))
    effects.emplace_back(MemoryEffects::Read::get(), value, ::mlir::TF::ResourceEffects::Variable::get());
  for (::mlir::Value value : getODSOperands(1))
    effects.emplace_back(MemoryEffects::Write::get(), value, ::mlir::TF::ResourceEffects::Variable::get());
  for (::mlir::Value value : getODSOperands(2))
    effects.emplace_back(MemoryEffects::Read::get(), value, ::mlir::TF::ResourceEffects::Variable::get());
  for (::mlir::Value value : getODSOperands(2))
    effects.emplace_back(MemoryEffects::Write::get(), value, ::mlir::TF::ResourceEffects::Variable::get());
}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::ResourceApplyAdagradDAOp definitions
//===----------------------------------------------------------------------===//

ResourceApplyAdagradDAOpAdaptor::ResourceApplyAdagradDAOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

ResourceApplyAdagradDAOpAdaptor::ResourceApplyAdagradDAOpAdaptor(ResourceApplyAdagradDAOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> ResourceApplyAdagradDAOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange ResourceApplyAdagradDAOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value ResourceApplyAdagradDAOpAdaptor::var() {
  return *getODSOperands(0).begin();
}

::mlir::Value ResourceApplyAdagradDAOpAdaptor::gradient_accumulator() {
  return *getODSOperands(1).begin();
}

::mlir::Value ResourceApplyAdagradDAOpAdaptor::gradient_squared_accumulator() {
  return *getODSOperands(2).begin();
}

::mlir::Value ResourceApplyAdagradDAOpAdaptor::grad() {
  return *getODSOperands(3).begin();
}

::mlir::Value ResourceApplyAdagradDAOpAdaptor::lr() {
  return *getODSOperands(4).begin();
}

::mlir::Value ResourceApplyAdagradDAOpAdaptor::l1() {
  return *getODSOperands(5).begin();
}

::mlir::Value ResourceApplyAdagradDAOpAdaptor::l2() {
  return *getODSOperands(6).begin();
}

::mlir::Value ResourceApplyAdagradDAOpAdaptor::global_step() {
  return *getODSOperands(7).begin();
}

::mlir::BoolAttr ResourceApplyAdagradDAOpAdaptor::use_locking() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::BoolAttr attr = odsAttrs.get("use_locking").dyn_cast_or_null<::mlir::BoolAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getBoolAttr(false);
  return attr;
}

::mlir::LogicalResult ResourceApplyAdagradDAOpAdaptor::verify(::mlir::Location loc) {
  {
  auto tblgen_use_locking = odsAttrs.get("use_locking");
  if (tblgen_use_locking) {
    if (!((tblgen_use_locking.isa<::mlir::BoolAttr>()))) return emitError(loc, "'tf.ResourceApplyAdagradDA' op ""attribute 'use_locking' failed to satisfy constraint: bool attribute");
  }
  }
  return ::mlir::success();
}

::llvm::StringRef ResourceApplyAdagradDAOp::getOperationName() {
  return "tf.ResourceApplyAdagradDA";
}

std::pair<unsigned, unsigned> ResourceApplyAdagradDAOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range ResourceApplyAdagradDAOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value ResourceApplyAdagradDAOp::var() {
  return *getODSOperands(0).begin();
}

::mlir::Value ResourceApplyAdagradDAOp::gradient_accumulator() {
  return *getODSOperands(1).begin();
}

::mlir::Value ResourceApplyAdagradDAOp::gradient_squared_accumulator() {
  return *getODSOperands(2).begin();
}

::mlir::Value ResourceApplyAdagradDAOp::grad() {
  return *getODSOperands(3).begin();
}

::mlir::Value ResourceApplyAdagradDAOp::lr() {
  return *getODSOperands(4).begin();
}

::mlir::Value ResourceApplyAdagradDAOp::l1() {
  return *getODSOperands(5).begin();
}

::mlir::Value ResourceApplyAdagradDAOp::l2() {
  return *getODSOperands(6).begin();
}

::mlir::Value ResourceApplyAdagradDAOp::global_step() {
  return *getODSOperands(7).begin();
}

::mlir::MutableOperandRange ResourceApplyAdagradDAOp::varMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange ResourceApplyAdagradDAOp::gradient_accumulatorMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange ResourceApplyAdagradDAOp::gradient_squared_accumulatorMutable() {
  auto range = getODSOperandIndexAndLength(2);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange ResourceApplyAdagradDAOp::gradMutable() {
  auto range = getODSOperandIndexAndLength(3);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange ResourceApplyAdagradDAOp::lrMutable() {
  auto range = getODSOperandIndexAndLength(4);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange ResourceApplyAdagradDAOp::l1Mutable() {
  auto range = getODSOperandIndexAndLength(5);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange ResourceApplyAdagradDAOp::l2Mutable() {
  auto range = getODSOperandIndexAndLength(6);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange ResourceApplyAdagradDAOp::global_stepMutable() {
  auto range = getODSOperandIndexAndLength(7);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> ResourceApplyAdagradDAOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range ResourceApplyAdagradDAOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::BoolAttr ResourceApplyAdagradDAOp::use_lockingAttr() {
  return this->getAttr("use_locking").dyn_cast_or_null<::mlir::BoolAttr>();
}

bool ResourceApplyAdagradDAOp::use_locking() {
  auto attr = use_lockingAttr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getBoolAttr(false).getValue();
  return attr.getValue();
}

Type ResourceApplyAdagradDAOp::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(3).begin());
}

bool ResourceApplyAdagradDAOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "T") return true;
 return false;
}

::mlir::DictionaryAttr ResourceApplyAdagradDAOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())}
    }, ctx);
}

void ResourceApplyAdagradDAOp::use_lockingAttr(::mlir::BoolAttr attr) {
  this->getOperation()->setAttr("use_locking", attr);
}

void ResourceApplyAdagradDAOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value var, ::mlir::Value gradient_accumulator, ::mlir::Value gradient_squared_accumulator, ::mlir::Value grad, ::mlir::Value lr, ::mlir::Value l1, ::mlir::Value l2, ::mlir::Value global_step, ::mlir::BoolAttr use_locking) {
  odsState.addOperands(var);
  odsState.addOperands(gradient_accumulator);
  odsState.addOperands(gradient_squared_accumulator);
  odsState.addOperands(grad);
  odsState.addOperands(lr);
  odsState.addOperands(l1);
  odsState.addOperands(l2);
  odsState.addOperands(global_step);
  odsState.addAttribute("use_locking", use_locking);
}

void ResourceApplyAdagradDAOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value var, ::mlir::Value gradient_accumulator, ::mlir::Value gradient_squared_accumulator, ::mlir::Value grad, ::mlir::Value lr, ::mlir::Value l1, ::mlir::Value l2, ::mlir::Value global_step, ::mlir::BoolAttr use_locking) {
  odsState.addOperands(var);
  odsState.addOperands(gradient_accumulator);
  odsState.addOperands(gradient_squared_accumulator);
  odsState.addOperands(grad);
  odsState.addOperands(lr);
  odsState.addOperands(l1);
  odsState.addOperands(l2);
  odsState.addOperands(global_step);
  odsState.addAttribute("use_locking", use_locking);
  assert(resultTypes.size() == 0u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void ResourceApplyAdagradDAOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value var, ::mlir::Value gradient_accumulator, ::mlir::Value gradient_squared_accumulator, ::mlir::Value grad, ::mlir::Value lr, ::mlir::Value l1, ::mlir::Value l2, ::mlir::Value global_step, bool use_locking) {
  odsState.addOperands(var);
  odsState.addOperands(gradient_accumulator);
  odsState.addOperands(gradient_squared_accumulator);
  odsState.addOperands(grad);
  odsState.addOperands(lr);
  odsState.addOperands(l1);
  odsState.addOperands(l2);
  odsState.addOperands(global_step);
  odsState.addAttribute("use_locking", odsBuilder.getBoolAttr(use_locking));
}

void ResourceApplyAdagradDAOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value var, ::mlir::Value gradient_accumulator, ::mlir::Value gradient_squared_accumulator, ::mlir::Value grad, ::mlir::Value lr, ::mlir::Value l1, ::mlir::Value l2, ::mlir::Value global_step, bool use_locking) {
  odsState.addOperands(var);
  odsState.addOperands(gradient_accumulator);
  odsState.addOperands(gradient_squared_accumulator);
  odsState.addOperands(grad);
  odsState.addOperands(lr);
  odsState.addOperands(l1);
  odsState.addOperands(l2);
  odsState.addOperands(global_step);
  odsState.addAttribute("use_locking", odsBuilder.getBoolAttr(use_locking));
  assert(resultTypes.size() == 0u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void ResourceApplyAdagradDAOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 8u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 0u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult ResourceApplyAdagradDAOp::verify() {
  if (failed(ResourceApplyAdagradDAOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::ResourceType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::ResourceRefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of resource values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::ResourceType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::ResourceRefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of resource values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup2 = getODSOperands(2);
    for (::mlir::Value v : valueGroup2) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::ResourceType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::ResourceRefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of resource values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup3 = getODSOperands(3);
    for (::mlir::Value v : valueGroup3) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of bfloat16 or 128-bit complex or 64-bit complex or 16-bit float or 32-bit float or 64-bit float or 16-bit integer or 32-bit integer or 64-bit integer or 8-bit integer or 32-bit quantized integer or 8-bit quantized integer or 8-bit quantized unsigned integer or 16-bit unsigned integer or 32-bit unsigned integer or 64-bit unsigned integer or 8-bit unsigned integer values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup4 = getODSOperands(4);
    for (::mlir::Value v : valueGroup4) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of bfloat16 or 128-bit complex or 64-bit complex or 16-bit float or 32-bit float or 64-bit float or 16-bit integer or 32-bit integer or 64-bit integer or 8-bit integer or 32-bit quantized integer or 8-bit quantized integer or 8-bit quantized unsigned integer or 16-bit unsigned integer or 32-bit unsigned integer or 64-bit unsigned integer or 8-bit unsigned integer values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup5 = getODSOperands(5);
    for (::mlir::Value v : valueGroup5) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of bfloat16 or 128-bit complex or 64-bit complex or 16-bit float or 32-bit float or 64-bit float or 16-bit integer or 32-bit integer or 64-bit integer or 8-bit integer or 32-bit quantized integer or 8-bit quantized integer or 8-bit quantized unsigned integer or 16-bit unsigned integer or 32-bit unsigned integer or 64-bit unsigned integer or 8-bit unsigned integer values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup6 = getODSOperands(6);
    for (::mlir::Value v : valueGroup6) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of bfloat16 or 128-bit complex or 64-bit complex or 16-bit float or 32-bit float or 64-bit float or 16-bit integer or 32-bit integer or 64-bit integer or 8-bit integer or 32-bit quantized integer or 8-bit quantized integer or 8-bit quantized unsigned integer or 16-bit unsigned integer or 32-bit unsigned integer or 64-bit unsigned integer or 8-bit unsigned integer values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup7 = getODSOperands(7);
    for (::mlir::Value v : valueGroup7) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of 64-bit integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
  }
  return ::mlir::success();
}

void ResourceApplyAdagradDAOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
  for (::mlir::Value value : getODSOperands(0))
    effects.emplace_back(MemoryEffects::Read::get(), value, ::mlir::TF::ResourceEffects::Variable::get());
  for (::mlir::Value value : getODSOperands(0))
    effects.emplace_back(MemoryEffects::Write::get(), value, ::mlir::TF::ResourceEffects::Variable::get());
  for (::mlir::Value value : getODSOperands(1))
    effects.emplace_back(MemoryEffects::Read::get(), value, ::mlir::TF::ResourceEffects::Variable::get());
  for (::mlir::Value value : getODSOperands(1))
    effects.emplace_back(MemoryEffects::Write::get(), value, ::mlir::TF::ResourceEffects::Variable::get());
  for (::mlir::Value value : getODSOperands(2))
    effects.emplace_back(MemoryEffects::Read::get(), value, ::mlir::TF::ResourceEffects::Variable::get());
  for (::mlir::Value value : getODSOperands(2))
    effects.emplace_back(MemoryEffects::Write::get(), value, ::mlir::TF::ResourceEffects::Variable::get());
}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::ResourceApplyAdagradOp definitions
//===----------------------------------------------------------------------===//

ResourceApplyAdagradOpAdaptor::ResourceApplyAdagradOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

ResourceApplyAdagradOpAdaptor::ResourceApplyAdagradOpAdaptor(ResourceApplyAdagradOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> ResourceApplyAdagradOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange ResourceApplyAdagradOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value ResourceApplyAdagradOpAdaptor::var() {
  return *getODSOperands(0).begin();
}

::mlir::Value ResourceApplyAdagradOpAdaptor::accum() {
  return *getODSOperands(1).begin();
}

::mlir::Value ResourceApplyAdagradOpAdaptor::lr() {
  return *getODSOperands(2).begin();
}

::mlir::Value ResourceApplyAdagradOpAdaptor::grad() {
  return *getODSOperands(3).begin();
}

::mlir::BoolAttr ResourceApplyAdagradOpAdaptor::use_locking() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::BoolAttr attr = odsAttrs.get("use_locking").dyn_cast_or_null<::mlir::BoolAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getBoolAttr(false);
  return attr;
}

::mlir::BoolAttr ResourceApplyAdagradOpAdaptor::update_slots() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::BoolAttr attr = odsAttrs.get("update_slots").dyn_cast_or_null<::mlir::BoolAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getBoolAttr(true);
  return attr;
}

::mlir::LogicalResult ResourceApplyAdagradOpAdaptor::verify(::mlir::Location loc) {
  {
  auto tblgen_use_locking = odsAttrs.get("use_locking");
  if (tblgen_use_locking) {
    if (!((tblgen_use_locking.isa<::mlir::BoolAttr>()))) return emitError(loc, "'tf.ResourceApplyAdagrad' op ""attribute 'use_locking' failed to satisfy constraint: bool attribute");
  }
  }
  {
  auto tblgen_update_slots = odsAttrs.get("update_slots");
  if (tblgen_update_slots) {
    if (!((tblgen_update_slots.isa<::mlir::BoolAttr>()))) return emitError(loc, "'tf.ResourceApplyAdagrad' op ""attribute 'update_slots' failed to satisfy constraint: bool attribute");
  }
  }
  return ::mlir::success();
}

::llvm::StringRef ResourceApplyAdagradOp::getOperationName() {
  return "tf.ResourceApplyAdagrad";
}

std::pair<unsigned, unsigned> ResourceApplyAdagradOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range ResourceApplyAdagradOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value ResourceApplyAdagradOp::var() {
  return *getODSOperands(0).begin();
}

::mlir::Value ResourceApplyAdagradOp::accum() {
  return *getODSOperands(1).begin();
}

::mlir::Value ResourceApplyAdagradOp::lr() {
  return *getODSOperands(2).begin();
}

::mlir::Value ResourceApplyAdagradOp::grad() {
  return *getODSOperands(3).begin();
}

::mlir::MutableOperandRange ResourceApplyAdagradOp::varMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange ResourceApplyAdagradOp::accumMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange ResourceApplyAdagradOp::lrMutable() {
  auto range = getODSOperandIndexAndLength(2);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange ResourceApplyAdagradOp::gradMutable() {
  auto range = getODSOperandIndexAndLength(3);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> ResourceApplyAdagradOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range ResourceApplyAdagradOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::BoolAttr ResourceApplyAdagradOp::use_lockingAttr() {
  return this->getAttr("use_locking").dyn_cast_or_null<::mlir::BoolAttr>();
}

bool ResourceApplyAdagradOp::use_locking() {
  auto attr = use_lockingAttr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getBoolAttr(false).getValue();
  return attr.getValue();
}

::mlir::BoolAttr ResourceApplyAdagradOp::update_slotsAttr() {
  return this->getAttr("update_slots").dyn_cast_or_null<::mlir::BoolAttr>();
}

bool ResourceApplyAdagradOp::update_slots() {
  auto attr = update_slotsAttr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getBoolAttr(true).getValue();
  return attr.getValue();
}

Type ResourceApplyAdagradOp::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(2).begin());
}

bool ResourceApplyAdagradOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "T") return true;
 return false;
}

::mlir::DictionaryAttr ResourceApplyAdagradOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())}
    }, ctx);
}

void ResourceApplyAdagradOp::use_lockingAttr(::mlir::BoolAttr attr) {
  this->getOperation()->setAttr("use_locking", attr);
}

void ResourceApplyAdagradOp::update_slotsAttr(::mlir::BoolAttr attr) {
  this->getOperation()->setAttr("update_slots", attr);
}

void ResourceApplyAdagradOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value var, ::mlir::Value accum, ::mlir::Value lr, ::mlir::Value grad, ::mlir::BoolAttr use_locking, ::mlir::BoolAttr update_slots) {
  odsState.addOperands(var);
  odsState.addOperands(accum);
  odsState.addOperands(lr);
  odsState.addOperands(grad);
  odsState.addAttribute("use_locking", use_locking);
  odsState.addAttribute("update_slots", update_slots);
}

void ResourceApplyAdagradOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value var, ::mlir::Value accum, ::mlir::Value lr, ::mlir::Value grad, ::mlir::BoolAttr use_locking, ::mlir::BoolAttr update_slots) {
  odsState.addOperands(var);
  odsState.addOperands(accum);
  odsState.addOperands(lr);
  odsState.addOperands(grad);
  odsState.addAttribute("use_locking", use_locking);
  odsState.addAttribute("update_slots", update_slots);
  assert(resultTypes.size() == 0u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void ResourceApplyAdagradOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value var, ::mlir::Value accum, ::mlir::Value lr, ::mlir::Value grad, bool use_locking, bool update_slots) {
  odsState.addOperands(var);
  odsState.addOperands(accum);
  odsState.addOperands(lr);
  odsState.addOperands(grad);
  odsState.addAttribute("use_locking", odsBuilder.getBoolAttr(use_locking));
  odsState.addAttribute("update_slots", odsBuilder.getBoolAttr(update_slots));
}

void ResourceApplyAdagradOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value var, ::mlir::Value accum, ::mlir::Value lr, ::mlir::Value grad, bool use_locking, bool update_slots) {
  odsState.addOperands(var);
  odsState.addOperands(accum);
  odsState.addOperands(lr);
  odsState.addOperands(grad);
  odsState.addAttribute("use_locking", odsBuilder.getBoolAttr(use_locking));
  odsState.addAttribute("update_slots", odsBuilder.getBoolAttr(update_slots));
  assert(resultTypes.size() == 0u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void ResourceApplyAdagradOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 4u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 0u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult ResourceApplyAdagradOp::verify() {
  if (failed(ResourceApplyAdagradOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::ResourceType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::ResourceRefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of resource values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::ResourceType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::ResourceRefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of resource values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup2 = getODSOperands(2);
    for (::mlir::Value v : valueGroup2) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of bfloat16 or 128-bit complex or 64-bit complex or 16-bit float or 32-bit float or 64-bit float or 16-bit integer or 32-bit integer or 64-bit integer or 8-bit integer or 32-bit quantized integer or 8-bit quantized integer or 8-bit quantized unsigned integer or 16-bit unsigned integer or 32-bit unsigned integer or 64-bit unsigned integer or 8-bit unsigned integer values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup3 = getODSOperands(3);
    for (::mlir::Value v : valueGroup3) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of bfloat16 or 128-bit complex or 64-bit complex or 16-bit float or 32-bit float or 64-bit float or 16-bit integer or 32-bit integer or 64-bit integer or 8-bit integer or 32-bit quantized integer or 8-bit quantized integer or 8-bit quantized unsigned integer or 16-bit unsigned integer or 32-bit unsigned integer or 64-bit unsigned integer or 8-bit unsigned integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
  }
  return ::mlir::success();
}

void ResourceApplyAdagradOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
  for (::mlir::Value value : getODSOperands(0))
    effects.emplace_back(MemoryEffects::Read::get(), value, ::mlir::TF::ResourceEffects::Variable::get());
  for (::mlir::Value value : getODSOperands(0))
    effects.emplace_back(MemoryEffects::Write::get(), value, ::mlir::TF::ResourceEffects::Variable::get());
  for (::mlir::Value value : getODSOperands(1))
    effects.emplace_back(MemoryEffects::Read::get(), value, ::mlir::TF::ResourceEffects::Variable::get());
  for (::mlir::Value value : getODSOperands(1))
    effects.emplace_back(MemoryEffects::Write::get(), value, ::mlir::TF::ResourceEffects::Variable::get());
}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::ResourceApplyAdagradV2Op definitions
//===----------------------------------------------------------------------===//

ResourceApplyAdagradV2OpAdaptor::ResourceApplyAdagradV2OpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

ResourceApplyAdagradV2OpAdaptor::ResourceApplyAdagradV2OpAdaptor(ResourceApplyAdagradV2Op&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> ResourceApplyAdagradV2OpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange ResourceApplyAdagradV2OpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value ResourceApplyAdagradV2OpAdaptor::var() {
  return *getODSOperands(0).begin();
}

::mlir::Value ResourceApplyAdagradV2OpAdaptor::accum() {
  return *getODSOperands(1).begin();
}

::mlir::Value ResourceApplyAdagradV2OpAdaptor::lr() {
  return *getODSOperands(2).begin();
}

::mlir::Value ResourceApplyAdagradV2OpAdaptor::epsilon() {
  return *getODSOperands(3).begin();
}

::mlir::Value ResourceApplyAdagradV2OpAdaptor::grad() {
  return *getODSOperands(4).begin();
}

::mlir::BoolAttr ResourceApplyAdagradV2OpAdaptor::use_locking() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::BoolAttr attr = odsAttrs.get("use_locking").dyn_cast_or_null<::mlir::BoolAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getBoolAttr(false);
  return attr;
}

::mlir::BoolAttr ResourceApplyAdagradV2OpAdaptor::update_slots() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::BoolAttr attr = odsAttrs.get("update_slots").dyn_cast_or_null<::mlir::BoolAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getBoolAttr(true);
  return attr;
}

::mlir::LogicalResult ResourceApplyAdagradV2OpAdaptor::verify(::mlir::Location loc) {
  {
  auto tblgen_use_locking = odsAttrs.get("use_locking");
  if (tblgen_use_locking) {
    if (!((tblgen_use_locking.isa<::mlir::BoolAttr>()))) return emitError(loc, "'tf.ResourceApplyAdagradV2' op ""attribute 'use_locking' failed to satisfy constraint: bool attribute");
  }
  }
  {
  auto tblgen_update_slots = odsAttrs.get("update_slots");
  if (tblgen_update_slots) {
    if (!((tblgen_update_slots.isa<::mlir::BoolAttr>()))) return emitError(loc, "'tf.ResourceApplyAdagradV2' op ""attribute 'update_slots' failed to satisfy constraint: bool attribute");
  }
  }
  return ::mlir::success();
}

::llvm::StringRef ResourceApplyAdagradV2Op::getOperationName() {
  return "tf.ResourceApplyAdagradV2";
}

std::pair<unsigned, unsigned> ResourceApplyAdagradV2Op::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range ResourceApplyAdagradV2Op::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value ResourceApplyAdagradV2Op::var() {
  return *getODSOperands(0).begin();
}

::mlir::Value ResourceApplyAdagradV2Op::accum() {
  return *getODSOperands(1).begin();
}

::mlir::Value ResourceApplyAdagradV2Op::lr() {
  return *getODSOperands(2).begin();
}

::mlir::Value ResourceApplyAdagradV2Op::epsilon() {
  return *getODSOperands(3).begin();
}

::mlir::Value ResourceApplyAdagradV2Op::grad() {
  return *getODSOperands(4).begin();
}

::mlir::MutableOperandRange ResourceApplyAdagradV2Op::varMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange ResourceApplyAdagradV2Op::accumMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange ResourceApplyAdagradV2Op::lrMutable() {
  auto range = getODSOperandIndexAndLength(2);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange ResourceApplyAdagradV2Op::epsilonMutable() {
  auto range = getODSOperandIndexAndLength(3);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange ResourceApplyAdagradV2Op::gradMutable() {
  auto range = getODSOperandIndexAndLength(4);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> ResourceApplyAdagradV2Op::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range ResourceApplyAdagradV2Op::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::BoolAttr ResourceApplyAdagradV2Op::use_lockingAttr() {
  return this->getAttr("use_locking").dyn_cast_or_null<::mlir::BoolAttr>();
}

bool ResourceApplyAdagradV2Op::use_locking() {
  auto attr = use_lockingAttr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getBoolAttr(false).getValue();
  return attr.getValue();
}

::mlir::BoolAttr ResourceApplyAdagradV2Op::update_slotsAttr() {
  return this->getAttr("update_slots").dyn_cast_or_null<::mlir::BoolAttr>();
}

bool ResourceApplyAdagradV2Op::update_slots() {
  auto attr = update_slotsAttr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getBoolAttr(true).getValue();
  return attr.getValue();
}

Type ResourceApplyAdagradV2Op::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(2).begin());
}

bool ResourceApplyAdagradV2Op::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "T") return true;
 return false;
}

::mlir::DictionaryAttr ResourceApplyAdagradV2Op::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())}
    }, ctx);
}

void ResourceApplyAdagradV2Op::use_lockingAttr(::mlir::BoolAttr attr) {
  this->getOperation()->setAttr("use_locking", attr);
}

void ResourceApplyAdagradV2Op::update_slotsAttr(::mlir::BoolAttr attr) {
  this->getOperation()->setAttr("update_slots", attr);
}

void ResourceApplyAdagradV2Op::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value var, ::mlir::Value accum, ::mlir::Value lr, ::mlir::Value epsilon, ::mlir::Value grad, ::mlir::BoolAttr use_locking, ::mlir::BoolAttr update_slots) {
  odsState.addOperands(var);
  odsState.addOperands(accum);
  odsState.addOperands(lr);
  odsState.addOperands(epsilon);
  odsState.addOperands(grad);
  odsState.addAttribute("use_locking", use_locking);
  odsState.addAttribute("update_slots", update_slots);
}

void ResourceApplyAdagradV2Op::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value var, ::mlir::Value accum, ::mlir::Value lr, ::mlir::Value epsilon, ::mlir::Value grad, ::mlir::BoolAttr use_locking, ::mlir::BoolAttr update_slots) {
  odsState.addOperands(var);
  odsState.addOperands(accum);
  odsState.addOperands(lr);
  odsState.addOperands(epsilon);
  odsState.addOperands(grad);
  odsState.addAttribute("use_locking", use_locking);
  odsState.addAttribute("update_slots", update_slots);
  assert(resultTypes.size() == 0u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void ResourceApplyAdagradV2Op::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value var, ::mlir::Value accum, ::mlir::Value lr, ::mlir::Value epsilon, ::mlir::Value grad, bool use_locking, bool update_slots) {
  odsState.addOperands(var);
  odsState.addOperands(accum);
  odsState.addOperands(lr);
  odsState.addOperands(epsilon);
  odsState.addOperands(grad);
  odsState.addAttribute("use_locking", odsBuilder.getBoolAttr(use_locking));
  odsState.addAttribute("update_slots", odsBuilder.getBoolAttr(update_slots));
}

void ResourceApplyAdagradV2Op::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value var, ::mlir::Value accum, ::mlir::Value lr, ::mlir::Value epsilon, ::mlir::Value grad, bool use_locking, bool update_slots) {
  odsState.addOperands(var);
  odsState.addOperands(accum);
  odsState.addOperands(lr);
  odsState.addOperands(epsilon);
  odsState.addOperands(grad);
  odsState.addAttribute("use_locking", odsBuilder.getBoolAttr(use_locking));
  odsState.addAttribute("update_slots", odsBuilder.getBoolAttr(update_slots));
  assert(resultTypes.size() == 0u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void ResourceApplyAdagradV2Op::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 5u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 0u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult ResourceApplyAdagradV2Op::verify() {
  if (failed(ResourceApplyAdagradV2OpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::ResourceType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::ResourceRefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of resource values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::ResourceType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::ResourceRefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of resource values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup2 = getODSOperands(2);
    for (::mlir::Value v : valueGroup2) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of bfloat16 or 128-bit complex or 64-bit complex or 16-bit float or 32-bit float or 64-bit float or 16-bit integer or 32-bit integer or 64-bit integer or 8-bit integer or 32-bit quantized integer or 8-bit quantized integer or 8-bit quantized unsigned integer or 16-bit unsigned integer or 32-bit unsigned integer or 64-bit unsigned integer or 8-bit unsigned integer values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup3 = getODSOperands(3);
    for (::mlir::Value v : valueGroup3) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of bfloat16 or 128-bit complex or 64-bit complex or 16-bit float or 32-bit float or 64-bit float or 16-bit integer or 32-bit integer or 64-bit integer or 8-bit integer or 32-bit quantized integer or 8-bit quantized integer or 8-bit quantized unsigned integer or 16-bit unsigned integer or 32-bit unsigned integer or 64-bit unsigned integer or 8-bit unsigned integer values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup4 = getODSOperands(4);
    for (::mlir::Value v : valueGroup4) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of bfloat16 or 128-bit complex or 64-bit complex or 16-bit float or 32-bit float or 64-bit float or 16-bit integer or 32-bit integer or 64-bit integer or 8-bit integer or 32-bit quantized integer or 8-bit quantized integer or 8-bit quantized unsigned integer or 16-bit unsigned integer or 32-bit unsigned integer or 64-bit unsigned integer or 8-bit unsigned integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
  }
  return ::mlir::success();
}

void ResourceApplyAdagradV2Op::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
  for (::mlir::Value value : getODSOperands(0))
    effects.emplace_back(MemoryEffects::Read::get(), value, ::mlir::TF::ResourceEffects::Variable::get());
  for (::mlir::Value value : getODSOperands(0))
    effects.emplace_back(MemoryEffects::Write::get(), value, ::mlir::TF::ResourceEffects::Variable::get());
  for (::mlir::Value value : getODSOperands(1))
    effects.emplace_back(MemoryEffects::Read::get(), value, ::mlir::TF::ResourceEffects::Variable::get());
  for (::mlir::Value value : getODSOperands(1))
    effects.emplace_back(MemoryEffects::Write::get(), value, ::mlir::TF::ResourceEffects::Variable::get());
}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::ResourceApplyAdamOp definitions
//===----------------------------------------------------------------------===//

ResourceApplyAdamOpAdaptor::ResourceApplyAdamOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

ResourceApplyAdamOpAdaptor::ResourceApplyAdamOpAdaptor(ResourceApplyAdamOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> ResourceApplyAdamOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange ResourceApplyAdamOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value ResourceApplyAdamOpAdaptor::var() {
  return *getODSOperands(0).begin();
}

::mlir::Value ResourceApplyAdamOpAdaptor::m() {
  return *getODSOperands(1).begin();
}

::mlir::Value ResourceApplyAdamOpAdaptor::v() {
  return *getODSOperands(2).begin();
}

::mlir::Value ResourceApplyAdamOpAdaptor::beta1_power() {
  return *getODSOperands(3).begin();
}

::mlir::Value ResourceApplyAdamOpAdaptor::beta2_power() {
  return *getODSOperands(4).begin();
}

::mlir::Value ResourceApplyAdamOpAdaptor::lr() {
  return *getODSOperands(5).begin();
}

::mlir::Value ResourceApplyAdamOpAdaptor::beta1() {
  return *getODSOperands(6).begin();
}

::mlir::Value ResourceApplyAdamOpAdaptor::beta2() {
  return *getODSOperands(7).begin();
}

::mlir::Value ResourceApplyAdamOpAdaptor::epsilon() {
  return *getODSOperands(8).begin();
}

::mlir::Value ResourceApplyAdamOpAdaptor::grad() {
  return *getODSOperands(9).begin();
}

::mlir::BoolAttr ResourceApplyAdamOpAdaptor::use_locking() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::BoolAttr attr = odsAttrs.get("use_locking").dyn_cast_or_null<::mlir::BoolAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getBoolAttr(false);
  return attr;
}

::mlir::BoolAttr ResourceApplyAdamOpAdaptor::use_nesterov() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::BoolAttr attr = odsAttrs.get("use_nesterov").dyn_cast_or_null<::mlir::BoolAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getBoolAttr(false);
  return attr;
}

::mlir::LogicalResult ResourceApplyAdamOpAdaptor::verify(::mlir::Location loc) {
  {
  auto tblgen_use_locking = odsAttrs.get("use_locking");
  if (tblgen_use_locking) {
    if (!((tblgen_use_locking.isa<::mlir::BoolAttr>()))) return emitError(loc, "'tf.ResourceApplyAdam' op ""attribute 'use_locking' failed to satisfy constraint: bool attribute");
  }
  }
  {
  auto tblgen_use_nesterov = odsAttrs.get("use_nesterov");
  if (tblgen_use_nesterov) {
    if (!((tblgen_use_nesterov.isa<::mlir::BoolAttr>()))) return emitError(loc, "'tf.ResourceApplyAdam' op ""attribute 'use_nesterov' failed to satisfy constraint: bool attribute");
  }
  }
  return ::mlir::success();
}

::llvm::StringRef ResourceApplyAdamOp::getOperationName() {
  return "tf.ResourceApplyAdam";
}

std::pair<unsigned, unsigned> ResourceApplyAdamOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range ResourceApplyAdamOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value ResourceApplyAdamOp::var() {
  return *getODSOperands(0).begin();
}

::mlir::Value ResourceApplyAdamOp::m() {
  return *getODSOperands(1).begin();
}

::mlir::Value ResourceApplyAdamOp::v() {
  return *getODSOperands(2).begin();
}

::mlir::Value ResourceApplyAdamOp::beta1_power() {
  return *getODSOperands(3).begin();
}

::mlir::Value ResourceApplyAdamOp::beta2_power() {
  return *getODSOperands(4).begin();
}

::mlir::Value ResourceApplyAdamOp::lr() {
  return *getODSOperands(5).begin();
}

::mlir::Value ResourceApplyAdamOp::beta1() {
  return *getODSOperands(6).begin();
}

::mlir::Value ResourceApplyAdamOp::beta2() {
  return *getODSOperands(7).begin();
}

::mlir::Value ResourceApplyAdamOp::epsilon() {
  return *getODSOperands(8).begin();
}

::mlir::Value ResourceApplyAdamOp::grad() {
  return *getODSOperands(9).begin();
}

::mlir::MutableOperandRange ResourceApplyAdamOp::varMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange ResourceApplyAdamOp::mMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange ResourceApplyAdamOp::vMutable() {
  auto range = getODSOperandIndexAndLength(2);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange ResourceApplyAdamOp::beta1_powerMutable() {
  auto range = getODSOperandIndexAndLength(3);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange ResourceApplyAdamOp::beta2_powerMutable() {
  auto range = getODSOperandIndexAndLength(4);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange ResourceApplyAdamOp::lrMutable() {
  auto range = getODSOperandIndexAndLength(5);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange ResourceApplyAdamOp::beta1Mutable() {
  auto range = getODSOperandIndexAndLength(6);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange ResourceApplyAdamOp::beta2Mutable() {
  auto range = getODSOperandIndexAndLength(7);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange ResourceApplyAdamOp::epsilonMutable() {
  auto range = getODSOperandIndexAndLength(8);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange ResourceApplyAdamOp::gradMutable() {
  auto range = getODSOperandIndexAndLength(9);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> ResourceApplyAdamOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range ResourceApplyAdamOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::BoolAttr ResourceApplyAdamOp::use_lockingAttr() {
  return this->getAttr("use_locking").dyn_cast_or_null<::mlir::BoolAttr>();
}

bool ResourceApplyAdamOp::use_locking() {
  auto attr = use_lockingAttr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getBoolAttr(false).getValue();
  return attr.getValue();
}

::mlir::BoolAttr ResourceApplyAdamOp::use_nesterovAttr() {
  return this->getAttr("use_nesterov").dyn_cast_or_null<::mlir::BoolAttr>();
}

bool ResourceApplyAdamOp::use_nesterov() {
  auto attr = use_nesterovAttr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getBoolAttr(false).getValue();
  return attr.getValue();
}

Type ResourceApplyAdamOp::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(3).begin());
}

bool ResourceApplyAdamOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "T") return true;
 return false;
}

::mlir::DictionaryAttr ResourceApplyAdamOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())}
    }, ctx);
}

void ResourceApplyAdamOp::use_lockingAttr(::mlir::BoolAttr attr) {
  this->getOperation()->setAttr("use_locking", attr);
}

void ResourceApplyAdamOp::use_nesterovAttr(::mlir::BoolAttr attr) {
  this->getOperation()->setAttr("use_nesterov", attr);
}

void ResourceApplyAdamOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value var, ::mlir::Value m, ::mlir::Value v, ::mlir::Value beta1_power, ::mlir::Value beta2_power, ::mlir::Value lr, ::mlir::Value beta1, ::mlir::Value beta2, ::mlir::Value epsilon, ::mlir::Value grad, ::mlir::BoolAttr use_locking, ::mlir::BoolAttr use_nesterov) {
  odsState.addOperands(var);
  odsState.addOperands(m);
  odsState.addOperands(v);
  odsState.addOperands(beta1_power);
  odsState.addOperands(beta2_power);
  odsState.addOperands(lr);
  odsState.addOperands(beta1);
  odsState.addOperands(beta2);
  odsState.addOperands(epsilon);
  odsState.addOperands(grad);
  odsState.addAttribute("use_locking", use_locking);
  odsState.addAttribute("use_nesterov", use_nesterov);
}

void ResourceApplyAdamOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value var, ::mlir::Value m, ::mlir::Value v, ::mlir::Value beta1_power, ::mlir::Value beta2_power, ::mlir::Value lr, ::mlir::Value beta1, ::mlir::Value beta2, ::mlir::Value epsilon, ::mlir::Value grad, ::mlir::BoolAttr use_locking, ::mlir::BoolAttr use_nesterov) {
  odsState.addOperands(var);
  odsState.addOperands(m);
  odsState.addOperands(v);
  odsState.addOperands(beta1_power);
  odsState.addOperands(beta2_power);
  odsState.addOperands(lr);
  odsState.addOperands(beta1);
  odsState.addOperands(beta2);
  odsState.addOperands(epsilon);
  odsState.addOperands(grad);
  odsState.addAttribute("use_locking", use_locking);
  odsState.addAttribute("use_nesterov", use_nesterov);
  assert(resultTypes.size() == 0u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void ResourceApplyAdamOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value var, ::mlir::Value m, ::mlir::Value v, ::mlir::Value beta1_power, ::mlir::Value beta2_power, ::mlir::Value lr, ::mlir::Value beta1, ::mlir::Value beta2, ::mlir::Value epsilon, ::mlir::Value grad, bool use_locking, bool use_nesterov) {
  odsState.addOperands(var);
  odsState.addOperands(m);
  odsState.addOperands(v);
  odsState.addOperands(beta1_power);
  odsState.addOperands(beta2_power);
  odsState.addOperands(lr);
  odsState.addOperands(beta1);
  odsState.addOperands(beta2);
  odsState.addOperands(epsilon);
  odsState.addOperands(grad);
  odsState.addAttribute("use_locking", odsBuilder.getBoolAttr(use_locking));
  odsState.addAttribute("use_nesterov", odsBuilder.getBoolAttr(use_nesterov));
}

void ResourceApplyAdamOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value var, ::mlir::Value m, ::mlir::Value v, ::mlir::Value beta1_power, ::mlir::Value beta2_power, ::mlir::Value lr, ::mlir::Value beta1, ::mlir::Value beta2, ::mlir::Value epsilon, ::mlir::Value grad, bool use_locking, bool use_nesterov) {
  odsState.addOperands(var);
  odsState.addOperands(m);
  odsState.addOperands(v);
  odsState.addOperands(beta1_power);
  odsState.addOperands(beta2_power);
  odsState.addOperands(lr);
  odsState.addOperands(beta1);
  odsState.addOperands(beta2);
  odsState.addOperands(epsilon);
  odsState.addOperands(grad);
  odsState.addAttribute("use_locking", odsBuilder.getBoolAttr(use_locking));
  odsState.addAttribute("use_nesterov", odsBuilder.getBoolAttr(use_nesterov));
  assert(resultTypes.size() == 0u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void ResourceApplyAdamOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 10u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 0u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult ResourceApplyAdamOp::verify() {
  if (failed(ResourceApplyAdamOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::ResourceType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::ResourceRefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of resource values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::ResourceType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::ResourceRefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of resource values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup2 = getODSOperands(2);
    for (::mlir::Value v : valueGroup2) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::ResourceType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::ResourceRefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of resource values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup3 = getODSOperands(3);
    for (::mlir::Value v : valueGroup3) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of bfloat16 or 128-bit complex or 64-bit complex or 16-bit float or 32-bit float or 64-bit float or 16-bit integer or 32-bit integer or 64-bit integer or 8-bit integer or 32-bit quantized integer or 8-bit quantized integer or 8-bit quantized unsigned integer or 16-bit unsigned integer or 32-bit unsigned integer or 64-bit unsigned integer or 8-bit unsigned integer values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup4 = getODSOperands(4);
    for (::mlir::Value v : valueGroup4) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of bfloat16 or 128-bit complex or 64-bit complex or 16-bit float or 32-bit float or 64-bit float or 16-bit integer or 32-bit integer or 64-bit integer or 8-bit integer or 32-bit quantized integer or 8-bit quantized integer or 8-bit quantized unsigned integer or 16-bit unsigned integer or 32-bit unsigned integer or 64-bit unsigned integer or 8-bit unsigned integer values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup5 = getODSOperands(5);
    for (::mlir::Value v : valueGroup5) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of bfloat16 or 128-bit complex or 64-bit complex or 16-bit float or 32-bit float or 64-bit float or 16-bit integer or 32-bit integer or 64-bit integer or 8-bit integer or 32-bit quantized integer or 8-bit quantized integer or 8-bit quantized unsigned integer or 16-bit unsigned integer or 32-bit unsigned integer or 64-bit unsigned integer or 8-bit unsigned integer values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup6 = getODSOperands(6);
    for (::mlir::Value v : valueGroup6) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of bfloat16 or 128-bit complex or 64-bit complex or 16-bit float or 32-bit float or 64-bit float or 16-bit integer or 32-bit integer or 64-bit integer or 8-bit integer or 32-bit quantized integer or 8-bit quantized integer or 8-bit quantized unsigned integer or 16-bit unsigned integer or 32-bit unsigned integer or 64-bit unsigned integer or 8-bit unsigned integer values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup7 = getODSOperands(7);
    for (::mlir::Value v : valueGroup7) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of bfloat16 or 128-bit complex or 64-bit complex or 16-bit float or 32-bit float or 64-bit float or 16-bit integer or 32-bit integer or 64-bit integer or 8-bit integer or 32-bit quantized integer or 8-bit quantized integer or 8-bit quantized unsigned integer or 16-bit unsigned integer or 32-bit unsigned integer or 64-bit unsigned integer or 8-bit unsigned integer values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup8 = getODSOperands(8);
    for (::mlir::Value v : valueGroup8) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of bfloat16 or 128-bit complex or 64-bit complex or 16-bit float or 32-bit float or 64-bit float or 16-bit integer or 32-bit integer or 64-bit integer or 8-bit integer or 32-bit quantized integer or 8-bit quantized integer or 8-bit quantized unsigned integer or 16-bit unsigned integer or 32-bit unsigned integer or 64-bit unsigned integer or 8-bit unsigned integer values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup9 = getODSOperands(9);
    for (::mlir::Value v : valueGroup9) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of bfloat16 or 128-bit complex or 64-bit complex or 16-bit float or 32-bit float or 64-bit float or 16-bit integer or 32-bit integer or 64-bit integer or 8-bit integer or 32-bit quantized integer or 8-bit quantized integer or 8-bit quantized unsigned integer or 16-bit unsigned integer or 32-bit unsigned integer or 64-bit unsigned integer or 8-bit unsigned integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
  }
  return ::mlir::success();
}

void ResourceApplyAdamOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
  for (::mlir::Value value : getODSOperands(0))
    effects.emplace_back(MemoryEffects::Read::get(), value, ::mlir::TF::ResourceEffects::Variable::get());
  for (::mlir::Value value : getODSOperands(0))
    effects.emplace_back(MemoryEffects::Write::get(), value, ::mlir::TF::ResourceEffects::Variable::get());
  for (::mlir::Value value : getODSOperands(1))
    effects.emplace_back(MemoryEffects::Read::get(), value, ::mlir::TF::ResourceEffects::Variable::get());
  for (::mlir::Value value : getODSOperands(1))
    effects.emplace_back(MemoryEffects::Write::get(), value, ::mlir::TF::ResourceEffects::Variable::get());
  for (::mlir::Value value : getODSOperands(2))
    effects.emplace_back(MemoryEffects::Read::get(), value, ::mlir::TF::ResourceEffects::Variable::get());
  for (::mlir::Value value : getODSOperands(2))
    effects.emplace_back(MemoryEffects::Write::get(), value, ::mlir::TF::ResourceEffects::Variable::get());
}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::ResourceApplyAddSignOp definitions
//===----------------------------------------------------------------------===//

ResourceApplyAddSignOpAdaptor::ResourceApplyAddSignOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

ResourceApplyAddSignOpAdaptor::ResourceApplyAddSignOpAdaptor(ResourceApplyAddSignOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> ResourceApplyAddSignOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange ResourceApplyAddSignOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value ResourceApplyAddSignOpAdaptor::var() {
  return *getODSOperands(0).begin();
}

::mlir::Value ResourceApplyAddSignOpAdaptor::m() {
  return *getODSOperands(1).begin();
}

::mlir::Value ResourceApplyAddSignOpAdaptor::lr() {
  return *getODSOperands(2).begin();
}

::mlir::Value ResourceApplyAddSignOpAdaptor::alpha() {
  return *getODSOperands(3).begin();
}

::mlir::Value ResourceApplyAddSignOpAdaptor::sign_decay() {
  return *getODSOperands(4).begin();
}

::mlir::Value ResourceApplyAddSignOpAdaptor::beta() {
  return *getODSOperands(5).begin();
}

::mlir::Value ResourceApplyAddSignOpAdaptor::grad() {
  return *getODSOperands(6).begin();
}

::mlir::BoolAttr ResourceApplyAddSignOpAdaptor::use_locking() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::BoolAttr attr = odsAttrs.get("use_locking").dyn_cast_or_null<::mlir::BoolAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getBoolAttr(false);
  return attr;
}

::mlir::LogicalResult ResourceApplyAddSignOpAdaptor::verify(::mlir::Location loc) {
  {
  auto tblgen_use_locking = odsAttrs.get("use_locking");
  if (tblgen_use_locking) {
    if (!((tblgen_use_locking.isa<::mlir::BoolAttr>()))) return emitError(loc, "'tf.ResourceApplyAddSign' op ""attribute 'use_locking' failed to satisfy constraint: bool attribute");
  }
  }
  return ::mlir::success();
}

::llvm::StringRef ResourceApplyAddSignOp::getOperationName() {
  return "tf.ResourceApplyAddSign";
}

std::pair<unsigned, unsigned> ResourceApplyAddSignOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range ResourceApplyAddSignOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value ResourceApplyAddSignOp::var() {
  return *getODSOperands(0).begin();
}

::mlir::Value ResourceApplyAddSignOp::m() {
  return *getODSOperands(1).begin();
}

::mlir::Value ResourceApplyAddSignOp::lr() {
  return *getODSOperands(2).begin();
}

::mlir::Value ResourceApplyAddSignOp::alpha() {
  return *getODSOperands(3).begin();
}

::mlir::Value ResourceApplyAddSignOp::sign_decay() {
  return *getODSOperands(4).begin();
}

::mlir::Value ResourceApplyAddSignOp::beta() {
  return *getODSOperands(5).begin();
}

::mlir::Value ResourceApplyAddSignOp::grad() {
  return *getODSOperands(6).begin();
}

::mlir::MutableOperandRange ResourceApplyAddSignOp::varMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange ResourceApplyAddSignOp::mMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange ResourceApplyAddSignOp::lrMutable() {
  auto range = getODSOperandIndexAndLength(2);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange ResourceApplyAddSignOp::alphaMutable() {
  auto range = getODSOperandIndexAndLength(3);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange ResourceApplyAddSignOp::sign_decayMutable() {
  auto range = getODSOperandIndexAndLength(4);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange ResourceApplyAddSignOp::betaMutable() {
  auto range = getODSOperandIndexAndLength(5);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange ResourceApplyAddSignOp::gradMutable() {
  auto range = getODSOperandIndexAndLength(6);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> ResourceApplyAddSignOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range ResourceApplyAddSignOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::BoolAttr ResourceApplyAddSignOp::use_lockingAttr() {
  return this->getAttr("use_locking").dyn_cast_or_null<::mlir::BoolAttr>();
}

bool ResourceApplyAddSignOp::use_locking() {
  auto attr = use_lockingAttr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getBoolAttr(false).getValue();
  return attr.getValue();
}

Type ResourceApplyAddSignOp::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(2).begin());
}

bool ResourceApplyAddSignOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "T") return true;
 return false;
}

::mlir::DictionaryAttr ResourceApplyAddSignOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())}
    }, ctx);
}

void ResourceApplyAddSignOp::use_lockingAttr(::mlir::BoolAttr attr) {
  this->getOperation()->setAttr("use_locking", attr);
}

void ResourceApplyAddSignOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value var, ::mlir::Value m, ::mlir::Value lr, ::mlir::Value alpha, ::mlir::Value sign_decay, ::mlir::Value beta, ::mlir::Value grad, ::mlir::BoolAttr use_locking) {
  odsState.addOperands(var);
  odsState.addOperands(m);
  odsState.addOperands(lr);
  odsState.addOperands(alpha);
  odsState.addOperands(sign_decay);
  odsState.addOperands(beta);
  odsState.addOperands(grad);
  odsState.addAttribute("use_locking", use_locking);
}

void ResourceApplyAddSignOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value var, ::mlir::Value m, ::mlir::Value lr, ::mlir::Value alpha, ::mlir::Value sign_decay, ::mlir::Value beta, ::mlir::Value grad, ::mlir::BoolAttr use_locking) {
  odsState.addOperands(var);
  odsState.addOperands(m);
  odsState.addOperands(lr);
  odsState.addOperands(alpha);
  odsState.addOperands(sign_decay);
  odsState.addOperands(beta);
  odsState.addOperands(grad);
  odsState.addAttribute("use_locking", use_locking);
  assert(resultTypes.size() == 0u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void ResourceApplyAddSignOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value var, ::mlir::Value m, ::mlir::Value lr, ::mlir::Value alpha, ::mlir::Value sign_decay, ::mlir::Value beta, ::mlir::Value grad, bool use_locking) {
  odsState.addOperands(var);
  odsState.addOperands(m);
  odsState.addOperands(lr);
  odsState.addOperands(alpha);
  odsState.addOperands(sign_decay);
  odsState.addOperands(beta);
  odsState.addOperands(grad);
  odsState.addAttribute("use_locking", odsBuilder.getBoolAttr(use_locking));
}

void ResourceApplyAddSignOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value var, ::mlir::Value m, ::mlir::Value lr, ::mlir::Value alpha, ::mlir::Value sign_decay, ::mlir::Value beta, ::mlir::Value grad, bool use_locking) {
  odsState.addOperands(var);
  odsState.addOperands(m);
  odsState.addOperands(lr);
  odsState.addOperands(alpha);
  odsState.addOperands(sign_decay);
  odsState.addOperands(beta);
  odsState.addOperands(grad);
  odsState.addAttribute("use_locking", odsBuilder.getBoolAttr(use_locking));
  assert(resultTypes.size() == 0u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void ResourceApplyAddSignOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 7u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 0u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult ResourceApplyAddSignOp::verify() {
  if (failed(ResourceApplyAddSignOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::ResourceType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::ResourceRefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of resource values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::ResourceType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::ResourceRefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of resource values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup2 = getODSOperands(2);
    for (::mlir::Value v : valueGroup2) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of bfloat16 or 128-bit complex or 64-bit complex or 16-bit float or 32-bit float or 64-bit float or 16-bit integer or 32-bit integer or 64-bit integer or 8-bit integer or 32-bit quantized integer or 8-bit quantized integer or 8-bit quantized unsigned integer or 16-bit unsigned integer or 32-bit unsigned integer or 64-bit unsigned integer or 8-bit unsigned integer values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup3 = getODSOperands(3);
    for (::mlir::Value v : valueGroup3) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of bfloat16 or 128-bit complex or 64-bit complex or 16-bit float or 32-bit float or 64-bit float or 16-bit integer or 32-bit integer or 64-bit integer or 8-bit integer or 32-bit quantized integer or 8-bit quantized integer or 8-bit quantized unsigned integer or 16-bit unsigned integer or 32-bit unsigned integer or 64-bit unsigned integer or 8-bit unsigned integer values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup4 = getODSOperands(4);
    for (::mlir::Value v : valueGroup4) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of bfloat16 or 128-bit complex or 64-bit complex or 16-bit float or 32-bit float or 64-bit float or 16-bit integer or 32-bit integer or 64-bit integer or 8-bit integer or 32-bit quantized integer or 8-bit quantized integer or 8-bit quantized unsigned integer or 16-bit unsigned integer or 32-bit unsigned integer or 64-bit unsigned integer or 8-bit unsigned integer values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup5 = getODSOperands(5);
    for (::mlir::Value v : valueGroup5) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of bfloat16 or 128-bit complex or 64-bit complex or 16-bit float or 32-bit float or 64-bit float or 16-bit integer or 32-bit integer or 64-bit integer or 8-bit integer or 32-bit quantized integer or 8-bit quantized integer or 8-bit quantized unsigned integer or 16-bit unsigned integer or 32-bit unsigned integer or 64-bit unsigned integer or 8-bit unsigned integer values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup6 = getODSOperands(6);
    for (::mlir::Value v : valueGroup6) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of bfloat16 or 128-bit complex or 64-bit complex or 16-bit float or 32-bit float or 64-bit float or 16-bit integer or 32-bit integer or 64-bit integer or 8-bit integer or 32-bit quantized integer or 8-bit quantized integer or 8-bit quantized unsigned integer or 16-bit unsigned integer or 32-bit unsigned integer or 64-bit unsigned integer or 8-bit unsigned integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
  }
  return ::mlir::success();
}

void ResourceApplyAddSignOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
  for (::mlir::Value value : getODSOperands(0))
    effects.emplace_back(MemoryEffects::Read::get(), value, ::mlir::TF::ResourceEffects::Variable::get());
  for (::mlir::Value value : getODSOperands(0))
    effects.emplace_back(MemoryEffects::Write::get(), value, ::mlir::TF::ResourceEffects::Variable::get());
  for (::mlir::Value value : getODSOperands(1))
    effects.emplace_back(MemoryEffects::Read::get(), value, ::mlir::TF::ResourceEffects::Variable::get());
  for (::mlir::Value value : getODSOperands(1))
    effects.emplace_back(MemoryEffects::Write::get(), value, ::mlir::TF::ResourceEffects::Variable::get());
}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::ResourceApplyCenteredRMSPropOp definitions
//===----------------------------------------------------------------------===//

ResourceApplyCenteredRMSPropOpAdaptor::ResourceApplyCenteredRMSPropOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

ResourceApplyCenteredRMSPropOpAdaptor::ResourceApplyCenteredRMSPropOpAdaptor(ResourceApplyCenteredRMSPropOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> ResourceApplyCenteredRMSPropOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange ResourceApplyCenteredRMSPropOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value ResourceApplyCenteredRMSPropOpAdaptor::var() {
  return *getODSOperands(0).begin();
}

::mlir::Value ResourceApplyCenteredRMSPropOpAdaptor::mg() {
  return *getODSOperands(1).begin();
}

::mlir::Value ResourceApplyCenteredRMSPropOpAdaptor::ms() {
  return *getODSOperands(2).begin();
}

::mlir::Value ResourceApplyCenteredRMSPropOpAdaptor::mom() {
  return *getODSOperands(3).begin();
}

::mlir::Value ResourceApplyCenteredRMSPropOpAdaptor::lr() {
  return *getODSOperands(4).begin();
}

::mlir::Value ResourceApplyCenteredRMSPropOpAdaptor::rho() {
  return *getODSOperands(5).begin();
}

::mlir::Value ResourceApplyCenteredRMSPropOpAdaptor::momentum() {
  return *getODSOperands(6).begin();
}

::mlir::Value ResourceApplyCenteredRMSPropOpAdaptor::epsilon() {
  return *getODSOperands(7).begin();
}

::mlir::Value ResourceApplyCenteredRMSPropOpAdaptor::grad() {
  return *getODSOperands(8).begin();
}

::mlir::BoolAttr ResourceApplyCenteredRMSPropOpAdaptor::use_locking() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::BoolAttr attr = odsAttrs.get("use_locking").dyn_cast_or_null<::mlir::BoolAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getBoolAttr(false);
  return attr;
}

::mlir::LogicalResult ResourceApplyCenteredRMSPropOpAdaptor::verify(::mlir::Location loc) {
  {
  auto tblgen_use_locking = odsAttrs.get("use_locking");
  if (tblgen_use_locking) {
    if (!((tblgen_use_locking.isa<::mlir::BoolAttr>()))) return emitError(loc, "'tf.ResourceApplyCenteredRMSProp' op ""attribute 'use_locking' failed to satisfy constraint: bool attribute");
  }
  }
  return ::mlir::success();
}

::llvm::StringRef ResourceApplyCenteredRMSPropOp::getOperationName() {
  return "tf.ResourceApplyCenteredRMSProp";
}

std::pair<unsigned, unsigned> ResourceApplyCenteredRMSPropOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range ResourceApplyCenteredRMSPropOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value ResourceApplyCenteredRMSPropOp::var() {
  return *getODSOperands(0).begin();
}

::mlir::Value ResourceApplyCenteredRMSPropOp::mg() {
  return *getODSOperands(1).begin();
}

::mlir::Value ResourceApplyCenteredRMSPropOp::ms() {
  return *getODSOperands(2).begin();
}

::mlir::Value ResourceApplyCenteredRMSPropOp::mom() {
  return *getODSOperands(3).begin();
}

::mlir::Value ResourceApplyCenteredRMSPropOp::lr() {
  return *getODSOperands(4).begin();
}

::mlir::Value ResourceApplyCenteredRMSPropOp::rho() {
  return *getODSOperands(5).begin();
}

::mlir::Value ResourceApplyCenteredRMSPropOp::momentum() {
  return *getODSOperands(6).begin();
}

::mlir::Value ResourceApplyCenteredRMSPropOp::epsilon() {
  return *getODSOperands(7).begin();
}

::mlir::Value ResourceApplyCenteredRMSPropOp::grad() {
  return *getODSOperands(8).begin();
}

::mlir::MutableOperandRange ResourceApplyCenteredRMSPropOp::varMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange ResourceApplyCenteredRMSPropOp::mgMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange ResourceApplyCenteredRMSPropOp::msMutable() {
  auto range = getODSOperandIndexAndLength(2);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange ResourceApplyCenteredRMSPropOp::momMutable() {
  auto range = getODSOperandIndexAndLength(3);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange ResourceApplyCenteredRMSPropOp::lrMutable() {
  auto range = getODSOperandIndexAndLength(4);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange ResourceApplyCenteredRMSPropOp::rhoMutable() {
  auto range = getODSOperandIndexAndLength(5);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange ResourceApplyCenteredRMSPropOp::momentumMutable() {
  auto range = getODSOperandIndexAndLength(6);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange ResourceApplyCenteredRMSPropOp::epsilonMutable() {
  auto range = getODSOperandIndexAndLength(7);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange ResourceApplyCenteredRMSPropOp::gradMutable() {
  auto range = getODSOperandIndexAndLength(8);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> ResourceApplyCenteredRMSPropOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range ResourceApplyCenteredRMSPropOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::BoolAttr ResourceApplyCenteredRMSPropOp::use_lockingAttr() {
  return this->getAttr("use_locking").dyn_cast_or_null<::mlir::BoolAttr>();
}

bool ResourceApplyCenteredRMSPropOp::use_locking() {
  auto attr = use_lockingAttr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getBoolAttr(false).getValue();
  return attr.getValue();
}

Type ResourceApplyCenteredRMSPropOp::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(4).begin());
}

bool ResourceApplyCenteredRMSPropOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "T") return true;
 return false;
}

::mlir::DictionaryAttr ResourceApplyCenteredRMSPropOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())}
    }, ctx);
}

void ResourceApplyCenteredRMSPropOp::use_lockingAttr(::mlir::BoolAttr attr) {
  this->getOperation()->setAttr("use_locking", attr);
}

void ResourceApplyCenteredRMSPropOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value var, ::mlir::Value mg, ::mlir::Value ms, ::mlir::Value mom, ::mlir::Value lr, ::mlir::Value rho, ::mlir::Value momentum, ::mlir::Value epsilon, ::mlir::Value grad, ::mlir::BoolAttr use_locking) {
  odsState.addOperands(var);
  odsState.addOperands(mg);
  odsState.addOperands(ms);
  odsState.addOperands(mom);
  odsState.addOperands(lr);
  odsState.addOperands(rho);
  odsState.addOperands(momentum);
  odsState.addOperands(epsilon);
  odsState.addOperands(grad);
  odsState.addAttribute("use_locking", use_locking);
}

void ResourceApplyCenteredRMSPropOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value var, ::mlir::Value mg, ::mlir::Value ms, ::mlir::Value mom, ::mlir::Value lr, ::mlir::Value rho, ::mlir::Value momentum, ::mlir::Value epsilon, ::mlir::Value grad, ::mlir::BoolAttr use_locking) {
  odsState.addOperands(var);
  odsState.addOperands(mg);
  odsState.addOperands(ms);
  odsState.addOperands(mom);
  odsState.addOperands(lr);
  odsState.addOperands(rho);
  odsState.addOperands(momentum);
  odsState.addOperands(epsilon);
  odsState.addOperands(grad);
  odsState.addAttribute("use_locking", use_locking);
  assert(resultTypes.size() == 0u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void ResourceApplyCenteredRMSPropOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value var, ::mlir::Value mg, ::mlir::Value ms, ::mlir::Value mom, ::mlir::Value lr, ::mlir::Value rho, ::mlir::Value momentum, ::mlir::Value epsilon, ::mlir::Value grad, bool use_locking) {
  odsState.addOperands(var);
  odsState.addOperands(mg);
  odsState.addOperands(ms);
  odsState.addOperands(mom);
  odsState.addOperands(lr);
  odsState.addOperands(rho);
  odsState.addOperands(momentum);
  odsState.addOperands(epsilon);
  odsState.addOperands(grad);
  odsState.addAttribute("use_locking", odsBuilder.getBoolAttr(use_locking));
}

void ResourceApplyCenteredRMSPropOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value var, ::mlir::Value mg, ::mlir::Value ms, ::mlir::Value mom, ::mlir::Value lr, ::mlir::Value rho, ::mlir::Value momentum, ::mlir::Value epsilon, ::mlir::Value grad, bool use_locking) {
  odsState.addOperands(var);
  odsState.addOperands(mg);
  odsState.addOperands(ms);
  odsState.addOperands(mom);
  odsState.addOperands(lr);
  odsState.addOperands(rho);
  odsState.addOperands(momentum);
  odsState.addOperands(epsilon);
  odsState.addOperands(grad);
  odsState.addAttribute("use_locking", odsBuilder.getBoolAttr(use_locking));
  assert(resultTypes.size() == 0u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void ResourceApplyCenteredRMSPropOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 9u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 0u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult ResourceApplyCenteredRMSPropOp::verify() {
  if (failed(ResourceApplyCenteredRMSPropOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::ResourceType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::ResourceRefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of resource values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::ResourceType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::ResourceRefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of resource values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup2 = getODSOperands(2);
    for (::mlir::Value v : valueGroup2) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::ResourceType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::ResourceRefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of resource values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup3 = getODSOperands(3);
    for (::mlir::Value v : valueGroup3) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::ResourceType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::ResourceRefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of resource values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup4 = getODSOperands(4);
    for (::mlir::Value v : valueGroup4) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of bfloat16 or 128-bit complex or 64-bit complex or 16-bit float or 32-bit float or 64-bit float or 16-bit integer or 32-bit integer or 64-bit integer or 8-bit integer or 32-bit quantized integer or 8-bit quantized integer or 8-bit quantized unsigned integer or 16-bit unsigned integer or 32-bit unsigned integer or 64-bit unsigned integer or 8-bit unsigned integer values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup5 = getODSOperands(5);
    for (::mlir::Value v : valueGroup5) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of bfloat16 or 128-bit complex or 64-bit complex or 16-bit float or 32-bit float or 64-bit float or 16-bit integer or 32-bit integer or 64-bit integer or 8-bit integer or 32-bit quantized integer or 8-bit quantized integer or 8-bit quantized unsigned integer or 16-bit unsigned integer or 32-bit unsigned integer or 64-bit unsigned integer or 8-bit unsigned integer values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup6 = getODSOperands(6);
    for (::mlir::Value v : valueGroup6) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of bfloat16 or 128-bit complex or 64-bit complex or 16-bit float or 32-bit float or 64-bit float or 16-bit integer or 32-bit integer or 64-bit integer or 8-bit integer or 32-bit quantized integer or 8-bit quantized integer or 8-bit quantized unsigned integer or 16-bit unsigned integer or 32-bit unsigned integer or 64-bit unsigned integer or 8-bit unsigned integer values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup7 = getODSOperands(7);
    for (::mlir::Value v : valueGroup7) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of bfloat16 or 128-bit complex or 64-bit complex or 16-bit float or 32-bit float or 64-bit float or 16-bit integer or 32-bit integer or 64-bit integer or 8-bit integer or 32-bit quantized integer or 8-bit quantized integer or 8-bit quantized unsigned integer or 16-bit unsigned integer or 32-bit unsigned integer or 64-bit unsigned integer or 8-bit unsigned integer values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup8 = getODSOperands(8);
    for (::mlir::Value v : valueGroup8) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of bfloat16 or 128-bit complex or 64-bit complex or 16-bit float or 32-bit float or 64-bit float or 16-bit integer or 32-bit integer or 64-bit integer or 8-bit integer or 32-bit quantized integer or 8-bit quantized integer or 8-bit quantized unsigned integer or 16-bit unsigned integer or 32-bit unsigned integer or 64-bit unsigned integer or 8-bit unsigned integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
  }
  return ::mlir::success();
}

void ResourceApplyCenteredRMSPropOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
  for (::mlir::Value value : getODSOperands(0))
    effects.emplace_back(MemoryEffects::Read::get(), value, ::mlir::TF::ResourceEffects::Variable::get());
  for (::mlir::Value value : getODSOperands(0))
    effects.emplace_back(MemoryEffects::Write::get(), value, ::mlir::TF::ResourceEffects::Variable::get());
  for (::mlir::Value value : getODSOperands(1))
    effects.emplace_back(MemoryEffects::Read::get(), value, ::mlir::TF::ResourceEffects::Variable::get());
  for (::mlir::Value value : getODSOperands(1))
    effects.emplace_back(MemoryEffects::Write::get(), value, ::mlir::TF::ResourceEffects::Variable::get());
  for (::mlir::Value value : getODSOperands(2))
    effects.emplace_back(MemoryEffects::Read::get(), value, ::mlir::TF::ResourceEffects::Variable::get());
  for (::mlir::Value value : getODSOperands(2))
    effects.emplace_back(MemoryEffects::Write::get(), value, ::mlir::TF::ResourceEffects::Variable::get());
  for (::mlir::Value value : getODSOperands(3))
    effects.emplace_back(MemoryEffects::Read::get(), value, ::mlir::TF::ResourceEffects::Variable::get());
  for (::mlir::Value value : getODSOperands(3))
    effects.emplace_back(MemoryEffects::Write::get(), value, ::mlir::TF::ResourceEffects::Variable::get());
}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::ResourceApplyFtrlOp definitions
//===----------------------------------------------------------------------===//

ResourceApplyFtrlOpAdaptor::ResourceApplyFtrlOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

ResourceApplyFtrlOpAdaptor::ResourceApplyFtrlOpAdaptor(ResourceApplyFtrlOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> ResourceApplyFtrlOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange ResourceApplyFtrlOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value ResourceApplyFtrlOpAdaptor::var() {
  return *getODSOperands(0).begin();
}

::mlir::Value ResourceApplyFtrlOpAdaptor::accum() {
  return *getODSOperands(1).begin();
}

::mlir::Value ResourceApplyFtrlOpAdaptor::linear() {
  return *getODSOperands(2).begin();
}

::mlir::Value ResourceApplyFtrlOpAdaptor::grad() {
  return *getODSOperands(3).begin();
}

::mlir::Value ResourceApplyFtrlOpAdaptor::lr() {
  return *getODSOperands(4).begin();
}

::mlir::Value ResourceApplyFtrlOpAdaptor::l1() {
  return *getODSOperands(5).begin();
}

::mlir::Value ResourceApplyFtrlOpAdaptor::l2() {
  return *getODSOperands(6).begin();
}

::mlir::Value ResourceApplyFtrlOpAdaptor::lr_power() {
  return *getODSOperands(7).begin();
}

::mlir::BoolAttr ResourceApplyFtrlOpAdaptor::use_locking() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::BoolAttr attr = odsAttrs.get("use_locking").dyn_cast_or_null<::mlir::BoolAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getBoolAttr(false);
  return attr;
}

::mlir::BoolAttr ResourceApplyFtrlOpAdaptor::multiply_linear_by_lr() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::BoolAttr attr = odsAttrs.get("multiply_linear_by_lr").dyn_cast_or_null<::mlir::BoolAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getBoolAttr(false);
  return attr;
}

::mlir::LogicalResult ResourceApplyFtrlOpAdaptor::verify(::mlir::Location loc) {
  {
  auto tblgen_use_locking = odsAttrs.get("use_locking");
  if (tblgen_use_locking) {
    if (!((tblgen_use_locking.isa<::mlir::BoolAttr>()))) return emitError(loc, "'tf.ResourceApplyFtrl' op ""attribute 'use_locking' failed to satisfy constraint: bool attribute");
  }
  }
  {
  auto tblgen_multiply_linear_by_lr = odsAttrs.get("multiply_linear_by_lr");
  if (tblgen_multiply_linear_by_lr) {
    if (!((tblgen_multiply_linear_by_lr.isa<::mlir::BoolAttr>()))) return emitError(loc, "'tf.ResourceApplyFtrl' op ""attribute 'multiply_linear_by_lr' failed to satisfy constraint: bool attribute");
  }
  }
  return ::mlir::success();
}

::llvm::StringRef ResourceApplyFtrlOp::getOperationName() {
  return "tf.ResourceApplyFtrl";
}

std::pair<unsigned, unsigned> ResourceApplyFtrlOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range ResourceApplyFtrlOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value ResourceApplyFtrlOp::var() {
  return *getODSOperands(0).begin();
}

::mlir::Value ResourceApplyFtrlOp::accum() {
  return *getODSOperands(1).begin();
}

::mlir::Value ResourceApplyFtrlOp::linear() {
  return *getODSOperands(2).begin();
}

::mlir::Value ResourceApplyFtrlOp::grad() {
  return *getODSOperands(3).begin();
}

::mlir::Value ResourceApplyFtrlOp::lr() {
  return *getODSOperands(4).begin();
}

::mlir::Value ResourceApplyFtrlOp::l1() {
  return *getODSOperands(5).begin();
}

::mlir::Value ResourceApplyFtrlOp::l2() {
  return *getODSOperands(6).begin();
}

::mlir::Value ResourceApplyFtrlOp::lr_power() {
  return *getODSOperands(7).begin();
}

::mlir::MutableOperandRange ResourceApplyFtrlOp::varMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange ResourceApplyFtrlOp::accumMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange ResourceApplyFtrlOp::linearMutable() {
  auto range = getODSOperandIndexAndLength(2);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange ResourceApplyFtrlOp::gradMutable() {
  auto range = getODSOperandIndexAndLength(3);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange ResourceApplyFtrlOp::lrMutable() {
  auto range = getODSOperandIndexAndLength(4);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange ResourceApplyFtrlOp::l1Mutable() {
  auto range = getODSOperandIndexAndLength(5);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange ResourceApplyFtrlOp::l2Mutable() {
  auto range = getODSOperandIndexAndLength(6);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange ResourceApplyFtrlOp::lr_powerMutable() {
  auto range = getODSOperandIndexAndLength(7);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> ResourceApplyFtrlOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range ResourceApplyFtrlOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::BoolAttr ResourceApplyFtrlOp::use_lockingAttr() {
  return this->getAttr("use_locking").dyn_cast_or_null<::mlir::BoolAttr>();
}

bool ResourceApplyFtrlOp::use_locking() {
  auto attr = use_lockingAttr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getBoolAttr(false).getValue();
  return attr.getValue();
}

::mlir::BoolAttr ResourceApplyFtrlOp::multiply_linear_by_lrAttr() {
  return this->getAttr("multiply_linear_by_lr").dyn_cast_or_null<::mlir::BoolAttr>();
}

bool ResourceApplyFtrlOp::multiply_linear_by_lr() {
  auto attr = multiply_linear_by_lrAttr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getBoolAttr(false).getValue();
  return attr.getValue();
}

Type ResourceApplyFtrlOp::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(3).begin());
}

bool ResourceApplyFtrlOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "T") return true;
 return false;
}

::mlir::DictionaryAttr ResourceApplyFtrlOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())}
    }, ctx);
}

void ResourceApplyFtrlOp::use_lockingAttr(::mlir::BoolAttr attr) {
  this->getOperation()->setAttr("use_locking", attr);
}

void ResourceApplyFtrlOp::multiply_linear_by_lrAttr(::mlir::BoolAttr attr) {
  this->getOperation()->setAttr("multiply_linear_by_lr", attr);
}

void ResourceApplyFtrlOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value var, ::mlir::Value accum, ::mlir::Value linear, ::mlir::Value grad, ::mlir::Value lr, ::mlir::Value l1, ::mlir::Value l2, ::mlir::Value lr_power, ::mlir::BoolAttr use_locking, ::mlir::BoolAttr multiply_linear_by_lr) {
  odsState.addOperands(var);
  odsState.addOperands(accum);
  odsState.addOperands(linear);
  odsState.addOperands(grad);
  odsState.addOperands(lr);
  odsState.addOperands(l1);
  odsState.addOperands(l2);
  odsState.addOperands(lr_power);
  odsState.addAttribute("use_locking", use_locking);
  odsState.addAttribute("multiply_linear_by_lr", multiply_linear_by_lr);
}

void ResourceApplyFtrlOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value var, ::mlir::Value accum, ::mlir::Value linear, ::mlir::Value grad, ::mlir::Value lr, ::mlir::Value l1, ::mlir::Value l2, ::mlir::Value lr_power, ::mlir::BoolAttr use_locking, ::mlir::BoolAttr multiply_linear_by_lr) {
  odsState.addOperands(var);
  odsState.addOperands(accum);
  odsState.addOperands(linear);
  odsState.addOperands(grad);
  odsState.addOperands(lr);
  odsState.addOperands(l1);
  odsState.addOperands(l2);
  odsState.addOperands(lr_power);
  odsState.addAttribute("use_locking", use_locking);
  odsState.addAttribute("multiply_linear_by_lr", multiply_linear_by_lr);
  assert(resultTypes.size() == 0u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void ResourceApplyFtrlOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value var, ::mlir::Value accum, ::mlir::Value linear, ::mlir::Value grad, ::mlir::Value lr, ::mlir::Value l1, ::mlir::Value l2, ::mlir::Value lr_power, bool use_locking, bool multiply_linear_by_lr) {
  odsState.addOperands(var);
  odsState.addOperands(accum);
  odsState.addOperands(linear);
  odsState.addOperands(grad);
  odsState.addOperands(lr);
  odsState.addOperands(l1);
  odsState.addOperands(l2);
  odsState.addOperands(lr_power);
  odsState.addAttribute("use_locking", odsBuilder.getBoolAttr(use_locking));
  odsState.addAttribute("multiply_linear_by_lr", odsBuilder.getBoolAttr(multiply_linear_by_lr));
}

void ResourceApplyFtrlOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value var, ::mlir::Value accum, ::mlir::Value linear, ::mlir::Value grad, ::mlir::Value lr, ::mlir::Value l1, ::mlir::Value l2, ::mlir::Value lr_power, bool use_locking, bool multiply_linear_by_lr) {
  odsState.addOperands(var);
  odsState.addOperands(accum);
  odsState.addOperands(linear);
  odsState.addOperands(grad);
  odsState.addOperands(lr);
  odsState.addOperands(l1);
  odsState.addOperands(l2);
  odsState.addOperands(lr_power);
  odsState.addAttribute("use_locking", odsBuilder.getBoolAttr(use_locking));
  odsState.addAttribute("multiply_linear_by_lr", odsBuilder.getBoolAttr(multiply_linear_by_lr));
  assert(resultTypes.size() == 0u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void ResourceApplyFtrlOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 8u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 0u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult ResourceApplyFtrlOp::verify() {
  if (failed(ResourceApplyFtrlOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::ResourceType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::ResourceRefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of resource values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::ResourceType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::ResourceRefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of resource values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup2 = getODSOperands(2);
    for (::mlir::Value v : valueGroup2) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::ResourceType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::ResourceRefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of resource values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup3 = getODSOperands(3);
    for (::mlir::Value v : valueGroup3) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of bfloat16 or 128-bit complex or 64-bit complex or 16-bit float or 32-bit float or 64-bit float or 16-bit integer or 32-bit integer or 64-bit integer or 8-bit integer or 32-bit quantized integer or 8-bit quantized integer or 8-bit quantized unsigned integer or 16-bit unsigned integer or 32-bit unsigned integer or 64-bit unsigned integer or 8-bit unsigned integer values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup4 = getODSOperands(4);
    for (::mlir::Value v : valueGroup4) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of bfloat16 or 128-bit complex or 64-bit complex or 16-bit float or 32-bit float or 64-bit float or 16-bit integer or 32-bit integer or 64-bit integer or 8-bit integer or 32-bit quantized integer or 8-bit quantized integer or 8-bit quantized unsigned integer or 16-bit unsigned integer or 32-bit unsigned integer or 64-bit unsigned integer or 8-bit unsigned integer values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup5 = getODSOperands(5);
    for (::mlir::Value v : valueGroup5) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of bfloat16 or 128-bit complex or 64-bit complex or 16-bit float or 32-bit float or 64-bit float or 16-bit integer or 32-bit integer or 64-bit integer or 8-bit integer or 32-bit quantized integer or 8-bit quantized integer or 8-bit quantized unsigned integer or 16-bit unsigned integer or 32-bit unsigned integer or 64-bit unsigned integer or 8-bit unsigned integer values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup6 = getODSOperands(6);
    for (::mlir::Value v : valueGroup6) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of bfloat16 or 128-bit complex or 64-bit complex or 16-bit float or 32-bit float or 64-bit float or 16-bit integer or 32-bit integer or 64-bit integer or 8-bit integer or 32-bit quantized integer or 8-bit quantized integer or 8-bit quantized unsigned integer or 16-bit unsigned integer or 32-bit unsigned integer or 64-bit unsigned integer or 8-bit unsigned integer values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup7 = getODSOperands(7);
    for (::mlir::Value v : valueGroup7) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of bfloat16 or 128-bit complex or 64-bit complex or 16-bit float or 32-bit float or 64-bit float or 16-bit integer or 32-bit integer or 64-bit integer or 8-bit integer or 32-bit quantized integer or 8-bit quantized integer or 8-bit quantized unsigned integer or 16-bit unsigned integer or 32-bit unsigned integer or 64-bit unsigned integer or 8-bit unsigned integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
  }
  return ::mlir::success();
}

void ResourceApplyFtrlOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
  for (::mlir::Value value : getODSOperands(0))
    effects.emplace_back(MemoryEffects::Read::get(), value, ::mlir::TF::ResourceEffects::Variable::get());
  for (::mlir::Value value : getODSOperands(0))
    effects.emplace_back(MemoryEffects::Write::get(), value, ::mlir::TF::ResourceEffects::Variable::get());
  for (::mlir::Value value : getODSOperands(1))
    effects.emplace_back(MemoryEffects::Read::get(), value, ::mlir::TF::ResourceEffects::Variable::get());
  for (::mlir::Value value : getODSOperands(1))
    effects.emplace_back(MemoryEffects::Write::get(), value, ::mlir::TF::ResourceEffects::Variable::get());
  for (::mlir::Value value : getODSOperands(2))
    effects.emplace_back(MemoryEffects::Read::get(), value, ::mlir::TF::ResourceEffects::Variable::get());
  for (::mlir::Value value : getODSOperands(2))
    effects.emplace_back(MemoryEffects::Write::get(), value, ::mlir::TF::ResourceEffects::Variable::get());
}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::ResourceApplyFtrlV2Op definitions
//===----------------------------------------------------------------------===//

ResourceApplyFtrlV2OpAdaptor::ResourceApplyFtrlV2OpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

ResourceApplyFtrlV2OpAdaptor::ResourceApplyFtrlV2OpAdaptor(ResourceApplyFtrlV2Op&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> ResourceApplyFtrlV2OpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange ResourceApplyFtrlV2OpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value ResourceApplyFtrlV2OpAdaptor::var() {
  return *getODSOperands(0).begin();
}

::mlir::Value ResourceApplyFtrlV2OpAdaptor::accum() {
  return *getODSOperands(1).begin();
}

::mlir::Value ResourceApplyFtrlV2OpAdaptor::linear() {
  return *getODSOperands(2).begin();
}

::mlir::Value ResourceApplyFtrlV2OpAdaptor::grad() {
  return *getODSOperands(3).begin();
}

::mlir::Value ResourceApplyFtrlV2OpAdaptor::lr() {
  return *getODSOperands(4).begin();
}

::mlir::Value ResourceApplyFtrlV2OpAdaptor::l1() {
  return *getODSOperands(5).begin();
}

::mlir::Value ResourceApplyFtrlV2OpAdaptor::l2() {
  return *getODSOperands(6).begin();
}

::mlir::Value ResourceApplyFtrlV2OpAdaptor::l2_shrinkage() {
  return *getODSOperands(7).begin();
}

::mlir::Value ResourceApplyFtrlV2OpAdaptor::lr_power() {
  return *getODSOperands(8).begin();
}

::mlir::BoolAttr ResourceApplyFtrlV2OpAdaptor::use_locking() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::BoolAttr attr = odsAttrs.get("use_locking").dyn_cast_or_null<::mlir::BoolAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getBoolAttr(false);
  return attr;
}

::mlir::BoolAttr ResourceApplyFtrlV2OpAdaptor::multiply_linear_by_lr() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::BoolAttr attr = odsAttrs.get("multiply_linear_by_lr").dyn_cast_or_null<::mlir::BoolAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getBoolAttr(false);
  return attr;
}

::mlir::LogicalResult ResourceApplyFtrlV2OpAdaptor::verify(::mlir::Location loc) {
  {
  auto tblgen_use_locking = odsAttrs.get("use_locking");
  if (tblgen_use_locking) {
    if (!((tblgen_use_locking.isa<::mlir::BoolAttr>()))) return emitError(loc, "'tf.ResourceApplyFtrlV2' op ""attribute 'use_locking' failed to satisfy constraint: bool attribute");
  }
  }
  {
  auto tblgen_multiply_linear_by_lr = odsAttrs.get("multiply_linear_by_lr");
  if (tblgen_multiply_linear_by_lr) {
    if (!((tblgen_multiply_linear_by_lr.isa<::mlir::BoolAttr>()))) return emitError(loc, "'tf.ResourceApplyFtrlV2' op ""attribute 'multiply_linear_by_lr' failed to satisfy constraint: bool attribute");
  }
  }
  return ::mlir::success();
}

::llvm::StringRef ResourceApplyFtrlV2Op::getOperationName() {
  return "tf.ResourceApplyFtrlV2";
}

std::pair<unsigned, unsigned> ResourceApplyFtrlV2Op::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range ResourceApplyFtrlV2Op::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value ResourceApplyFtrlV2Op::var() {
  return *getODSOperands(0).begin();
}

::mlir::Value ResourceApplyFtrlV2Op::accum() {
  return *getODSOperands(1).begin();
}

::mlir::Value ResourceApplyFtrlV2Op::linear() {
  return *getODSOperands(2).begin();
}

::mlir::Value ResourceApplyFtrlV2Op::grad() {
  return *getODSOperands(3).begin();
}

::mlir::Value ResourceApplyFtrlV2Op::lr() {
  return *getODSOperands(4).begin();
}

::mlir::Value ResourceApplyFtrlV2Op::l1() {
  return *getODSOperands(5).begin();
}

::mlir::Value ResourceApplyFtrlV2Op::l2() {
  return *getODSOperands(6).begin();
}

::mlir::Value ResourceApplyFtrlV2Op::l2_shrinkage() {
  return *getODSOperands(7).begin();
}

::mlir::Value ResourceApplyFtrlV2Op::lr_power() {
  return *getODSOperands(8).begin();
}

::mlir::MutableOperandRange ResourceApplyFtrlV2Op::varMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange ResourceApplyFtrlV2Op::accumMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange ResourceApplyFtrlV2Op::linearMutable() {
  auto range = getODSOperandIndexAndLength(2);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange ResourceApplyFtrlV2Op::gradMutable() {
  auto range = getODSOperandIndexAndLength(3);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange ResourceApplyFtrlV2Op::lrMutable() {
  auto range = getODSOperandIndexAndLength(4);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange ResourceApplyFtrlV2Op::l1Mutable() {
  auto range = getODSOperandIndexAndLength(5);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange ResourceApplyFtrlV2Op::l2Mutable() {
  auto range = getODSOperandIndexAndLength(6);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange ResourceApplyFtrlV2Op::l2_shrinkageMutable() {
  auto range = getODSOperandIndexAndLength(7);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange ResourceApplyFtrlV2Op::lr_powerMutable() {
  auto range = getODSOperandIndexAndLength(8);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> ResourceApplyFtrlV2Op::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range ResourceApplyFtrlV2Op::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::BoolAttr ResourceApplyFtrlV2Op::use_lockingAttr() {
  return this->getAttr("use_locking").dyn_cast_or_null<::mlir::BoolAttr>();
}

bool ResourceApplyFtrlV2Op::use_locking() {
  auto attr = use_lockingAttr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getBoolAttr(false).getValue();
  return attr.getValue();
}

::mlir::BoolAttr ResourceApplyFtrlV2Op::multiply_linear_by_lrAttr() {
  return this->getAttr("multiply_linear_by_lr").dyn_cast_or_null<::mlir::BoolAttr>();
}

bool ResourceApplyFtrlV2Op::multiply_linear_by_lr() {
  auto attr = multiply_linear_by_lrAttr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getBoolAttr(false).getValue();
  return attr.getValue();
}

Type ResourceApplyFtrlV2Op::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(3).begin());
}

bool ResourceApplyFtrlV2Op::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "T") return true;
 return false;
}

::mlir::DictionaryAttr ResourceApplyFtrlV2Op::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())}
    }, ctx);
}

void ResourceApplyFtrlV2Op::use_lockingAttr(::mlir::BoolAttr attr) {
  this->getOperation()->setAttr("use_locking", attr);
}

void ResourceApplyFtrlV2Op::multiply_linear_by_lrAttr(::mlir::BoolAttr attr) {
  this->getOperation()->setAttr("multiply_linear_by_lr", attr);
}

void ResourceApplyFtrlV2Op::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value var, ::mlir::Value accum, ::mlir::Value linear, ::mlir::Value grad, ::mlir::Value lr, ::mlir::Value l1, ::mlir::Value l2, ::mlir::Value l2_shrinkage, ::mlir::Value lr_power, ::mlir::BoolAttr use_locking, ::mlir::BoolAttr multiply_linear_by_lr) {
  odsState.addOperands(var);
  odsState.addOperands(accum);
  odsState.addOperands(linear);
  odsState.addOperands(grad);
  odsState.addOperands(lr);
  odsState.addOperands(l1);
  odsState.addOperands(l2);
  odsState.addOperands(l2_shrinkage);
  odsState.addOperands(lr_power);
  odsState.addAttribute("use_locking", use_locking);
  odsState.addAttribute("multiply_linear_by_lr", multiply_linear_by_lr);
}

void ResourceApplyFtrlV2Op::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value var, ::mlir::Value accum, ::mlir::Value linear, ::mlir::Value grad, ::mlir::Value lr, ::mlir::Value l1, ::mlir::Value l2, ::mlir::Value l2_shrinkage, ::mlir::Value lr_power, ::mlir::BoolAttr use_locking, ::mlir::BoolAttr multiply_linear_by_lr) {
  odsState.addOperands(var);
  odsState.addOperands(accum);
  odsState.addOperands(linear);
  odsState.addOperands(grad);
  odsState.addOperands(lr);
  odsState.addOperands(l1);
  odsState.addOperands(l2);
  odsState.addOperands(l2_shrinkage);
  odsState.addOperands(lr_power);
  odsState.addAttribute("use_locking", use_locking);
  odsState.addAttribute("multiply_linear_by_lr", multiply_linear_by_lr);
  assert(resultTypes.size() == 0u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void ResourceApplyFtrlV2Op::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value var, ::mlir::Value accum, ::mlir::Value linear, ::mlir::Value grad, ::mlir::Value lr, ::mlir::Value l1, ::mlir::Value l2, ::mlir::Value l2_shrinkage, ::mlir::Value lr_power, bool use_locking, bool multiply_linear_by_lr) {
  odsState.addOperands(var);
  odsState.addOperands(accum);
  odsState.addOperands(linear);
  odsState.addOperands(grad);
  odsState.addOperands(lr);
  odsState.addOperands(l1);
  odsState.addOperands(l2);
  odsState.addOperands(l2_shrinkage);
  odsState.addOperands(lr_power);
  odsState.addAttribute("use_locking", odsBuilder.getBoolAttr(use_locking));
  odsState.addAttribute("multiply_linear_by_lr", odsBuilder.getBoolAttr(multiply_linear_by_lr));
}

void ResourceApplyFtrlV2Op::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value var, ::mlir::Value accum, ::mlir::Value linear, ::mlir::Value grad, ::mlir::Value lr, ::mlir::Value l1, ::mlir::Value l2, ::mlir::Value l2_shrinkage, ::mlir::Value lr_power, bool use_locking, bool multiply_linear_by_lr) {
  odsState.addOperands(var);
  odsState.addOperands(accum);
  odsState.addOperands(linear);
  odsState.addOperands(grad);
  odsState.addOperands(lr);
  odsState.addOperands(l1);
  odsState.addOperands(l2);
  odsState.addOperands(l2_shrinkage);
  odsState.addOperands(lr_power);
  odsState.addAttribute("use_locking", odsBuilder.getBoolAttr(use_locking));
  odsState.addAttribute("multiply_linear_by_lr", odsBuilder.getBoolAttr(multiply_linear_by_lr));
  assert(resultTypes.size() == 0u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void ResourceApplyFtrlV2Op::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 9u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 0u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult ResourceApplyFtrlV2Op::verify() {
  if (failed(ResourceApplyFtrlV2OpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::ResourceType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::ResourceRefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of resource values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::ResourceType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::ResourceRefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of resource values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup2 = getODSOperands(2);
    for (::mlir::Value v : valueGroup2) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::ResourceType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::ResourceRefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of resource values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup3 = getODSOperands(3);
    for (::mlir::Value v : valueGroup3) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of bfloat16 or 128-bit complex or 64-bit complex or 16-bit float or 32-bit float or 64-bit float or 16-bit integer or 32-bit integer or 64-bit integer or 8-bit integer or 32-bit quantized integer or 8-bit quantized integer or 8-bit quantized unsigned integer or 16-bit unsigned integer or 32-bit unsigned integer or 64-bit unsigned integer or 8-bit unsigned integer values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup4 = getODSOperands(4);
    for (::mlir::Value v : valueGroup4) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of bfloat16 or 128-bit complex or 64-bit complex or 16-bit float or 32-bit float or 64-bit float or 16-bit integer or 32-bit integer or 64-bit integer or 8-bit integer or 32-bit quantized integer or 8-bit quantized integer or 8-bit quantized unsigned integer or 16-bit unsigned integer or 32-bit unsigned integer or 64-bit unsigned integer or 8-bit unsigned integer values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup5 = getODSOperands(5);
    for (::mlir::Value v : valueGroup5) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of bfloat16 or 128-bit complex or 64-bit complex or 16-bit float or 32-bit float or 64-bit float or 16-bit integer or 32-bit integer or 64-bit integer or 8-bit integer or 32-bit quantized integer or 8-bit quantized integer or 8-bit quantized unsigned integer or 16-bit unsigned integer or 32-bit unsigned integer or 64-bit unsigned integer or 8-bit unsigned integer values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup6 = getODSOperands(6);
    for (::mlir::Value v : valueGroup6) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of bfloat16 or 128-bit complex or 64-bit complex or 16-bit float or 32-bit float or 64-bit float or 16-bit integer or 32-bit integer or 64-bit integer or 8-bit integer or 32-bit quantized integer or 8-bit quantized integer or 8-bit quantized unsigned integer or 16-bit unsigned integer or 32-bit unsigned integer or 64-bit unsigned integer or 8-bit unsigned integer values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup7 = getODSOperands(7);
    for (::mlir::Value v : valueGroup7) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of bfloat16 or 128-bit complex or 64-bit complex or 16-bit float or 32-bit float or 64-bit float or 16-bit integer or 32-bit integer or 64-bit integer or 8-bit integer or 32-bit quantized integer or 8-bit quantized integer or 8-bit quantized unsigned integer or 16-bit unsigned integer or 32-bit unsigned integer or 64-bit unsigned integer or 8-bit unsigned integer values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup8 = getODSOperands(8);
    for (::mlir::Value v : valueGroup8) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of bfloat16 or 128-bit complex or 64-bit complex or 16-bit float or 32-bit float or 64-bit float or 16-bit integer or 32-bit integer or 64-bit integer or 8-bit integer or 32-bit quantized integer or 8-bit quantized integer or 8-bit quantized unsigned integer or 16-bit unsigned integer or 32-bit unsigned integer or 64-bit unsigned integer or 8-bit unsigned integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
  }
  return ::mlir::success();
}

void ResourceApplyFtrlV2Op::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
  for (::mlir::Value value : getODSOperands(0))
    effects.emplace_back(MemoryEffects::Read::get(), value, ::mlir::TF::ResourceEffects::Variable::get());
  for (::mlir::Value value : getODSOperands(0))
    effects.emplace_back(MemoryEffects::Write::get(), value, ::mlir::TF::ResourceEffects::Variable::get());
  for (::mlir::Value value : getODSOperands(1))
    effects.emplace_back(MemoryEffects::Read::get(), value, ::mlir::TF::ResourceEffects::Variable::get());
  for (::mlir::Value value : getODSOperands(1))
    effects.emplace_back(MemoryEffects::Write::get(), value, ::mlir::TF::ResourceEffects::Variable::get());
  for (::mlir::Value value : getODSOperands(2))
    effects.emplace_back(MemoryEffects::Read::get(), value, ::mlir::TF::ResourceEffects::Variable::get());
  for (::mlir::Value value : getODSOperands(2))
    effects.emplace_back(MemoryEffects::Write::get(), value, ::mlir::TF::ResourceEffects::Variable::get());
}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::ResourceApplyGradientDescentOp definitions
//===----------------------------------------------------------------------===//

ResourceApplyGradientDescentOpAdaptor::ResourceApplyGradientDescentOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

ResourceApplyGradientDescentOpAdaptor::ResourceApplyGradientDescentOpAdaptor(ResourceApplyGradientDescentOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> ResourceApplyGradientDescentOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange ResourceApplyGradientDescentOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value ResourceApplyGradientDescentOpAdaptor::var() {
  return *getODSOperands(0).begin();
}

::mlir::Value ResourceApplyGradientDescentOpAdaptor::alpha() {
  return *getODSOperands(1).begin();
}

::mlir::Value ResourceApplyGradientDescentOpAdaptor::delta() {
  return *getODSOperands(2).begin();
}

::mlir::BoolAttr ResourceApplyGradientDescentOpAdaptor::use_locking() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::BoolAttr attr = odsAttrs.get("use_locking").dyn_cast_or_null<::mlir::BoolAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getBoolAttr(false);
  return attr;
}

::mlir::LogicalResult ResourceApplyGradientDescentOpAdaptor::verify(::mlir::Location loc) {
  {
  auto tblgen_use_locking = odsAttrs.get("use_locking");
  if (tblgen_use_locking) {
    if (!((tblgen_use_locking.isa<::mlir::BoolAttr>()))) return emitError(loc, "'tf.ResourceApplyGradientDescent' op ""attribute 'use_locking' failed to satisfy constraint: bool attribute");
  }
  }
  return ::mlir::success();
}

::llvm::StringRef ResourceApplyGradientDescentOp::getOperationName() {
  return "tf.ResourceApplyGradientDescent";
}

std::pair<unsigned, unsigned> ResourceApplyGradientDescentOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range ResourceApplyGradientDescentOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value ResourceApplyGradientDescentOp::var() {
  return *getODSOperands(0).begin();
}

::mlir::Value ResourceApplyGradientDescentOp::alpha() {
  return *getODSOperands(1).begin();
}

::mlir::Value ResourceApplyGradientDescentOp::delta() {
  return *getODSOperands(2).begin();
}

::mlir::MutableOperandRange ResourceApplyGradientDescentOp::varMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange ResourceApplyGradientDescentOp::alphaMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange ResourceApplyGradientDescentOp::deltaMutable() {
  auto range = getODSOperandIndexAndLength(2);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> ResourceApplyGradientDescentOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range ResourceApplyGradientDescentOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::BoolAttr ResourceApplyGradientDescentOp::use_lockingAttr() {
  return this->getAttr("use_locking").dyn_cast_or_null<::mlir::BoolAttr>();
}

bool ResourceApplyGradientDescentOp::use_locking() {
  auto attr = use_lockingAttr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getBoolAttr(false).getValue();
  return attr.getValue();
}

Type ResourceApplyGradientDescentOp::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(1).begin());
}

bool ResourceApplyGradientDescentOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "T") return true;
 return false;
}

::mlir::DictionaryAttr ResourceApplyGradientDescentOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())}
    }, ctx);
}

void ResourceApplyGradientDescentOp::use_lockingAttr(::mlir::BoolAttr attr) {
  this->getOperation()->setAttr("use_locking", attr);
}

void ResourceApplyGradientDescentOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value var, ::mlir::Value alpha, ::mlir::Value delta, ::mlir::BoolAttr use_locking) {
  odsState.addOperands(var);
  odsState.addOperands(alpha);
  odsState.addOperands(delta);
  odsState.addAttribute("use_locking", use_locking);
}

void ResourceApplyGradientDescentOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value var, ::mlir::Value alpha, ::mlir::Value delta, ::mlir::BoolAttr use_locking) {
  odsState.addOperands(var);
  odsState.addOperands(alpha);
  odsState.addOperands(delta);
  odsState.addAttribute("use_locking", use_locking);
  assert(resultTypes.size() == 0u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void ResourceApplyGradientDescentOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value var, ::mlir::Value alpha, ::mlir::Value delta, bool use_locking) {
  odsState.addOperands(var);
  odsState.addOperands(alpha);
  odsState.addOperands(delta);
  odsState.addAttribute("use_locking", odsBuilder.getBoolAttr(use_locking));
}

void ResourceApplyGradientDescentOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value var, ::mlir::Value alpha, ::mlir::Value delta, bool use_locking) {
  odsState.addOperands(var);
  odsState.addOperands(alpha);
  odsState.addOperands(delta);
  odsState.addAttribute("use_locking", odsBuilder.getBoolAttr(use_locking));
  assert(resultTypes.size() == 0u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void ResourceApplyGradientDescentOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 3u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 0u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult ResourceApplyGradientDescentOp::verify() {
  if (failed(ResourceApplyGradientDescentOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::ResourceType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::ResourceRefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of resource values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of bfloat16 or 128-bit complex or 64-bit complex or 16-bit float or 32-bit float or 64-bit float or 16-bit integer or 32-bit integer or 64-bit integer or 8-bit integer or 32-bit quantized integer or 8-bit quantized integer or 8-bit quantized unsigned integer or 16-bit unsigned integer or 32-bit unsigned integer or 64-bit unsigned integer or 8-bit unsigned integer values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup2 = getODSOperands(2);
    for (::mlir::Value v : valueGroup2) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of bfloat16 or 128-bit complex or 64-bit complex or 16-bit float or 32-bit float or 64-bit float or 16-bit integer or 32-bit integer or 64-bit integer or 8-bit integer or 32-bit quantized integer or 8-bit quantized integer or 8-bit quantized unsigned integer or 16-bit unsigned integer or 32-bit unsigned integer or 64-bit unsigned integer or 8-bit unsigned integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
  }
  return ::mlir::success();
}

void ResourceApplyGradientDescentOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
  for (::mlir::Value value : getODSOperands(0))
    effects.emplace_back(MemoryEffects::Read::get(), value, ::mlir::TF::ResourceEffects::Variable::get());
  for (::mlir::Value value : getODSOperands(0))
    effects.emplace_back(MemoryEffects::Write::get(), value, ::mlir::TF::ResourceEffects::Variable::get());
}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::ResourceApplyKerasMomentumOp definitions
//===----------------------------------------------------------------------===//

ResourceApplyKerasMomentumOpAdaptor::ResourceApplyKerasMomentumOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

ResourceApplyKerasMomentumOpAdaptor::ResourceApplyKerasMomentumOpAdaptor(ResourceApplyKerasMomentumOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> ResourceApplyKerasMomentumOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange ResourceApplyKerasMomentumOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value ResourceApplyKerasMomentumOpAdaptor::var() {
  return *getODSOperands(0).begin();
}

::mlir::Value ResourceApplyKerasMomentumOpAdaptor::accum() {
  return *getODSOperands(1).begin();
}

::mlir::Value ResourceApplyKerasMomentumOpAdaptor::lr() {
  return *getODSOperands(2).begin();
}

::mlir::Value ResourceApplyKerasMomentumOpAdaptor::grad() {
  return *getODSOperands(3).begin();
}

::mlir::Value ResourceApplyKerasMomentumOpAdaptor::momentum() {
  return *getODSOperands(4).begin();
}

::mlir::BoolAttr ResourceApplyKerasMomentumOpAdaptor::use_locking() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::BoolAttr attr = odsAttrs.get("use_locking").dyn_cast_or_null<::mlir::BoolAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getBoolAttr(false);
  return attr;
}

::mlir::BoolAttr ResourceApplyKerasMomentumOpAdaptor::use_nesterov() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::BoolAttr attr = odsAttrs.get("use_nesterov").dyn_cast_or_null<::mlir::BoolAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getBoolAttr(false);
  return attr;
}

::mlir::LogicalResult ResourceApplyKerasMomentumOpAdaptor::verify(::mlir::Location loc) {
  {
  auto tblgen_use_locking = odsAttrs.get("use_locking");
  if (tblgen_use_locking) {
    if (!((tblgen_use_locking.isa<::mlir::BoolAttr>()))) return emitError(loc, "'tf.ResourceApplyKerasMomentum' op ""attribute 'use_locking' failed to satisfy constraint: bool attribute");
  }
  }
  {
  auto tblgen_use_nesterov = odsAttrs.get("use_nesterov");
  if (tblgen_use_nesterov) {
    if (!((tblgen_use_nesterov.isa<::mlir::BoolAttr>()))) return emitError(loc, "'tf.ResourceApplyKerasMomentum' op ""attribute 'use_nesterov' failed to satisfy constraint: bool attribute");
  }
  }
  return ::mlir::success();
}

::llvm::StringRef ResourceApplyKerasMomentumOp::getOperationName() {
  return "tf.ResourceApplyKerasMomentum";
}

std::pair<unsigned, unsigned> ResourceApplyKerasMomentumOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range ResourceApplyKerasMomentumOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value ResourceApplyKerasMomentumOp::var() {
  return *getODSOperands(0).begin();
}

::mlir::Value ResourceApplyKerasMomentumOp::accum() {
  return *getODSOperands(1).begin();
}

::mlir::Value ResourceApplyKerasMomentumOp::lr() {
  return *getODSOperands(2).begin();
}

::mlir::Value ResourceApplyKerasMomentumOp::grad() {
  return *getODSOperands(3).begin();
}

::mlir::Value ResourceApplyKerasMomentumOp::momentum() {
  return *getODSOperands(4).begin();
}

::mlir::MutableOperandRange ResourceApplyKerasMomentumOp::varMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange ResourceApplyKerasMomentumOp::accumMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange ResourceApplyKerasMomentumOp::lrMutable() {
  auto range = getODSOperandIndexAndLength(2);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange ResourceApplyKerasMomentumOp::gradMutable() {
  auto range = getODSOperandIndexAndLength(3);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange ResourceApplyKerasMomentumOp::momentumMutable() {
  auto range = getODSOperandIndexAndLength(4);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> ResourceApplyKerasMomentumOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range ResourceApplyKerasMomentumOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::BoolAttr ResourceApplyKerasMomentumOp::use_lockingAttr() {
  return this->getAttr("use_locking").dyn_cast_or_null<::mlir::BoolAttr>();
}

bool ResourceApplyKerasMomentumOp::use_locking() {
  auto attr = use_lockingAttr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getBoolAttr(false).getValue();
  return attr.getValue();
}

::mlir::BoolAttr ResourceApplyKerasMomentumOp::use_nesterovAttr() {
  return this->getAttr("use_nesterov").dyn_cast_or_null<::mlir::BoolAttr>();
}

bool ResourceApplyKerasMomentumOp::use_nesterov() {
  auto attr = use_nesterovAttr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getBoolAttr(false).getValue();
  return attr.getValue();
}

Type ResourceApplyKerasMomentumOp::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(2).begin());
}

bool ResourceApplyKerasMomentumOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "T") return true;
 return false;
}

::mlir::DictionaryAttr ResourceApplyKerasMomentumOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())}
    }, ctx);
}

void ResourceApplyKerasMomentumOp::use_lockingAttr(::mlir::BoolAttr attr) {
  this->getOperation()->setAttr("use_locking", attr);
}

void ResourceApplyKerasMomentumOp::use_nesterovAttr(::mlir::BoolAttr attr) {
  this->getOperation()->setAttr("use_nesterov", attr);
}

void ResourceApplyKerasMomentumOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value var, ::mlir::Value accum, ::mlir::Value lr, ::mlir::Value grad, ::mlir::Value momentum, ::mlir::BoolAttr use_locking, ::mlir::BoolAttr use_nesterov) {
  odsState.addOperands(var);
  odsState.addOperands(accum);
  odsState.addOperands(lr);
  odsState.addOperands(grad);
  odsState.addOperands(momentum);
  odsState.addAttribute("use_locking", use_locking);
  odsState.addAttribute("use_nesterov", use_nesterov);
}

void ResourceApplyKerasMomentumOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value var, ::mlir::Value accum, ::mlir::Value lr, ::mlir::Value grad, ::mlir::Value momentum, ::mlir::BoolAttr use_locking, ::mlir::BoolAttr use_nesterov) {
  odsState.addOperands(var);
  odsState.addOperands(accum);
  odsState.addOperands(lr);
  odsState.addOperands(grad);
  odsState.addOperands(momentum);
  odsState.addAttribute("use_locking", use_locking);
  odsState.addAttribute("use_nesterov", use_nesterov);
  assert(resultTypes.size() == 0u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void ResourceApplyKerasMomentumOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value var, ::mlir::Value accum, ::mlir::Value lr, ::mlir::Value grad, ::mlir::Value momentum, bool use_locking, bool use_nesterov) {
  odsState.addOperands(var);
  odsState.addOperands(accum);
  odsState.addOperands(lr);
  odsState.addOperands(grad);
  odsState.addOperands(momentum);
  odsState.addAttribute("use_locking", odsBuilder.getBoolAttr(use_locking));
  odsState.addAttribute("use_nesterov", odsBuilder.getBoolAttr(use_nesterov));
}

void ResourceApplyKerasMomentumOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value var, ::mlir::Value accum, ::mlir::Value lr, ::mlir::Value grad, ::mlir::Value momentum, bool use_locking, bool use_nesterov) {
  odsState.addOperands(var);
  odsState.addOperands(accum);
  odsState.addOperands(lr);
  odsState.addOperands(grad);
  odsState.addOperands(momentum);
  odsState.addAttribute("use_locking", odsBuilder.getBoolAttr(use_locking));
  odsState.addAttribute("use_nesterov", odsBuilder.getBoolAttr(use_nesterov));
  assert(resultTypes.size() == 0u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void ResourceApplyKerasMomentumOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 5u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 0u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult ResourceApplyKerasMomentumOp::verify() {
  if (failed(ResourceApplyKerasMomentumOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::ResourceType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::ResourceRefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of resource values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::ResourceType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::ResourceRefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of resource values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup2 = getODSOperands(2);
    for (::mlir::Value v : valueGroup2) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of bfloat16 or 128-bit complex or 64-bit complex or 16-bit float or 32-bit float or 64-bit float or 16-bit integer or 32-bit integer or 64-bit integer or 8-bit integer or 32-bit quantized integer or 8-bit quantized integer or 8-bit quantized unsigned integer or 16-bit unsigned integer or 32-bit unsigned integer or 64-bit unsigned integer or 8-bit unsigned integer values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup3 = getODSOperands(3);
    for (::mlir::Value v : valueGroup3) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of bfloat16 or 128-bit complex or 64-bit complex or 16-bit float or 32-bit float or 64-bit float or 16-bit integer or 32-bit integer or 64-bit integer or 8-bit integer or 32-bit quantized integer or 8-bit quantized integer or 8-bit quantized unsigned integer or 16-bit unsigned integer or 32-bit unsigned integer or 64-bit unsigned integer or 8-bit unsigned integer values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup4 = getODSOperands(4);
    for (::mlir::Value v : valueGroup4) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of bfloat16 or 128-bit complex or 64-bit complex or 16-bit float or 32-bit float or 64-bit float or 16-bit integer or 32-bit integer or 64-bit integer or 8-bit integer or 32-bit quantized integer or 8-bit quantized integer or 8-bit quantized unsigned integer or 16-bit unsigned integer or 32-bit unsigned integer or 64-bit unsigned integer or 8-bit unsigned integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
  }
  return ::mlir::success();
}

void ResourceApplyKerasMomentumOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
  for (::mlir::Value value : getODSOperands(0))
    effects.emplace_back(MemoryEffects::Read::get(), value, ::mlir::TF::ResourceEffects::Variable::get());
  for (::mlir::Value value : getODSOperands(0))
    effects.emplace_back(MemoryEffects::Write::get(), value, ::mlir::TF::ResourceEffects::Variable::get());
  for (::mlir::Value value : getODSOperands(1))
    effects.emplace_back(MemoryEffects::Read::get(), value, ::mlir::TF::ResourceEffects::Variable::get());
  for (::mlir::Value value : getODSOperands(1))
    effects.emplace_back(MemoryEffects::Write::get(), value, ::mlir::TF::ResourceEffects::Variable::get());
}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::ResourceApplyMomentumOp definitions
//===----------------------------------------------------------------------===//

ResourceApplyMomentumOpAdaptor::ResourceApplyMomentumOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

ResourceApplyMomentumOpAdaptor::ResourceApplyMomentumOpAdaptor(ResourceApplyMomentumOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> ResourceApplyMomentumOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange ResourceApplyMomentumOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value ResourceApplyMomentumOpAdaptor::var() {
  return *getODSOperands(0).begin();
}

::mlir::Value ResourceApplyMomentumOpAdaptor::accum() {
  return *getODSOperands(1).begin();
}

::mlir::Value ResourceApplyMomentumOpAdaptor::lr() {
  return *getODSOperands(2).begin();
}

::mlir::Value ResourceApplyMomentumOpAdaptor::grad() {
  return *getODSOperands(3).begin();
}

::mlir::Value ResourceApplyMomentumOpAdaptor::momentum() {
  return *getODSOperands(4).begin();
}

::mlir::BoolAttr ResourceApplyMomentumOpAdaptor::use_locking() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::BoolAttr attr = odsAttrs.get("use_locking").dyn_cast_or_null<::mlir::BoolAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getBoolAttr(false);
  return attr;
}

::mlir::BoolAttr ResourceApplyMomentumOpAdaptor::use_nesterov() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::BoolAttr attr = odsAttrs.get("use_nesterov").dyn_cast_or_null<::mlir::BoolAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getBoolAttr(false);
  return attr;
}

::mlir::LogicalResult ResourceApplyMomentumOpAdaptor::verify(::mlir::Location loc) {
  {
  auto tblgen_use_locking = odsAttrs.get("use_locking");
  if (tblgen_use_locking) {
    if (!((tblgen_use_locking.isa<::mlir::BoolAttr>()))) return emitError(loc, "'tf.ResourceApplyMomentum' op ""attribute 'use_locking' failed to satisfy constraint: bool attribute");
  }
  }
  {
  auto tblgen_use_nesterov = odsAttrs.get("use_nesterov");
  if (tblgen_use_nesterov) {
    if (!((tblgen_use_nesterov.isa<::mlir::BoolAttr>()))) return emitError(loc, "'tf.ResourceApplyMomentum' op ""attribute 'use_nesterov' failed to satisfy constraint: bool attribute");
  }
  }
  return ::mlir::success();
}

::llvm::StringRef ResourceApplyMomentumOp::getOperationName() {
  return "tf.ResourceApplyMomentum";
}

std::pair<unsigned, unsigned> ResourceApplyMomentumOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range ResourceApplyMomentumOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value ResourceApplyMomentumOp::var() {
  return *getODSOperands(0).begin();
}

::mlir::Value ResourceApplyMomentumOp::accum() {
  return *getODSOperands(1).begin();
}

::mlir::Value ResourceApplyMomentumOp::lr() {
  return *getODSOperands(2).begin();
}

::mlir::Value ResourceApplyMomentumOp::grad() {
  return *getODSOperands(3).begin();
}

::mlir::Value ResourceApplyMomentumOp::momentum() {
  return *getODSOperands(4).begin();
}

::mlir::MutableOperandRange ResourceApplyMomentumOp::varMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange ResourceApplyMomentumOp::accumMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange ResourceApplyMomentumOp::lrMutable() {
  auto range = getODSOperandIndexAndLength(2);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange ResourceApplyMomentumOp::gradMutable() {
  auto range = getODSOperandIndexAndLength(3);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange ResourceApplyMomentumOp::momentumMutable() {
  auto range = getODSOperandIndexAndLength(4);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> ResourceApplyMomentumOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range ResourceApplyMomentumOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::BoolAttr ResourceApplyMomentumOp::use_lockingAttr() {
  return this->getAttr("use_locking").dyn_cast_or_null<::mlir::BoolAttr>();
}

bool ResourceApplyMomentumOp::use_locking() {
  auto attr = use_lockingAttr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getBoolAttr(false).getValue();
  return attr.getValue();
}

::mlir::BoolAttr ResourceApplyMomentumOp::use_nesterovAttr() {
  return this->getAttr("use_nesterov").dyn_cast_or_null<::mlir::BoolAttr>();
}

bool ResourceApplyMomentumOp::use_nesterov() {
  auto attr = use_nesterovAttr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getBoolAttr(false).getValue();
  return attr.getValue();
}

Type ResourceApplyMomentumOp::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(2).begin());
}

bool ResourceApplyMomentumOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "T") return true;
 return false;
}

::mlir::DictionaryAttr ResourceApplyMomentumOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())}
    }, ctx);
}

void ResourceApplyMomentumOp::use_lockingAttr(::mlir::BoolAttr attr) {
  this->getOperation()->setAttr("use_locking", attr);
}

void ResourceApplyMomentumOp::use_nesterovAttr(::mlir::BoolAttr attr) {
  this->getOperation()->setAttr("use_nesterov", attr);
}

void ResourceApplyMomentumOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value var, ::mlir::Value accum, ::mlir::Value lr, ::mlir::Value grad, ::mlir::Value momentum, ::mlir::BoolAttr use_locking, ::mlir::BoolAttr use_nesterov) {
  odsState.addOperands(var);
  odsState.addOperands(accum);
  odsState.addOperands(lr);
  odsState.addOperands(grad);
  odsState.addOperands(momentum);
  odsState.addAttribute("use_locking", use_locking);
  odsState.addAttribute("use_nesterov", use_nesterov);
}

void ResourceApplyMomentumOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value var, ::mlir::Value accum, ::mlir::Value lr, ::mlir::Value grad, ::mlir::Value momentum, ::mlir::BoolAttr use_locking, ::mlir::BoolAttr use_nesterov) {
  odsState.addOperands(var);
  odsState.addOperands(accum);
  odsState.addOperands(lr);
  odsState.addOperands(grad);
  odsState.addOperands(momentum);
  odsState.addAttribute("use_locking", use_locking);
  odsState.addAttribute("use_nesterov", use_nesterov);
  assert(resultTypes.size() == 0u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void ResourceApplyMomentumOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value var, ::mlir::Value accum, ::mlir::Value lr, ::mlir::Value grad, ::mlir::Value momentum, bool use_locking, bool use_nesterov) {
  odsState.addOperands(var);
  odsState.addOperands(accum);
  odsState.addOperands(lr);
  odsState.addOperands(grad);
  odsState.addOperands(momentum);
  odsState.addAttribute("use_locking", odsBuilder.getBoolAttr(use_locking));
  odsState.addAttribute("use_nesterov", odsBuilder.getBoolAttr(use_nesterov));
}

void ResourceApplyMomentumOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value var, ::mlir::Value accum, ::mlir::Value lr, ::mlir::Value grad, ::mlir::Value momentum, bool use_locking, bool use_nesterov) {
  odsState.addOperands(var);
  odsState.addOperands(accum);
  odsState.addOperands(lr);
  odsState.addOperands(grad);
  odsState.addOperands(momentum);
  odsState.addAttribute("use_locking", odsBuilder.getBoolAttr(use_locking));
  odsState.addAttribute("use_nesterov", odsBuilder.getBoolAttr(use_nesterov));
  assert(resultTypes.size() == 0u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void ResourceApplyMomentumOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 5u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 0u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult ResourceApplyMomentumOp::verify() {
  if (failed(ResourceApplyMomentumOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::ResourceType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::ResourceRefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of resource values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::ResourceType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::ResourceRefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of resource values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup2 = getODSOperands(2);
    for (::mlir::Value v : valueGroup2) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of bfloat16 or 128-bit complex or 64-bit complex or 16-bit float or 32-bit float or 64-bit float or 16-bit integer or 32-bit integer or 64-bit integer or 8-bit integer or 32-bit quantized integer or 8-bit quantized integer or 8-bit quantized unsigned integer or 16-bit unsigned integer or 32-bit unsigned integer or 64-bit unsigned integer or 8-bit unsigned integer values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup3 = getODSOperands(3);
    for (::mlir::Value v : valueGroup3) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of bfloat16 or 128-bit complex or 64-bit complex or 16-bit float or 32-bit float or 64-bit float or 16-bit integer or 32-bit integer or 64-bit integer or 8-bit integer or 32-bit quantized integer or 8-bit quantized integer or 8-bit quantized unsigned integer or 16-bit unsigned integer or 32-bit unsigned integer or 64-bit unsigned integer or 8-bit unsigned integer values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup4 = getODSOperands(4);
    for (::mlir::Value v : valueGroup4) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of bfloat16 or 128-bit complex or 64-bit complex or 16-bit float or 32-bit float or 64-bit float or 16-bit integer or 32-bit integer or 64-bit integer or 8-bit integer or 32-bit quantized integer or 8-bit quantized integer or 8-bit quantized unsigned integer or 16-bit unsigned integer or 32-bit unsigned integer or 64-bit unsigned integer or 8-bit unsigned integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
  }
  return ::mlir::success();
}

void ResourceApplyMomentumOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
  for (::mlir::Value value : getODSOperands(0))
    effects.emplace_back(MemoryEffects::Read::get(), value, ::mlir::TF::ResourceEffects::Variable::get());
  for (::mlir::Value value : getODSOperands(0))
    effects.emplace_back(MemoryEffects::Write::get(), value, ::mlir::TF::ResourceEffects::Variable::get());
  for (::mlir::Value value : getODSOperands(1))
    effects.emplace_back(MemoryEffects::Read::get(), value, ::mlir::TF::ResourceEffects::Variable::get());
  for (::mlir::Value value : getODSOperands(1))
    effects.emplace_back(MemoryEffects::Write::get(), value, ::mlir::TF::ResourceEffects::Variable::get());
}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::ResourceApplyPowerSignOp definitions
//===----------------------------------------------------------------------===//

ResourceApplyPowerSignOpAdaptor::ResourceApplyPowerSignOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

ResourceApplyPowerSignOpAdaptor::ResourceApplyPowerSignOpAdaptor(ResourceApplyPowerSignOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> ResourceApplyPowerSignOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange ResourceApplyPowerSignOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value ResourceApplyPowerSignOpAdaptor::var() {
  return *getODSOperands(0).begin();
}

::mlir::Value ResourceApplyPowerSignOpAdaptor::m() {
  return *getODSOperands(1).begin();
}

::mlir::Value ResourceApplyPowerSignOpAdaptor::lr() {
  return *getODSOperands(2).begin();
}

::mlir::Value ResourceApplyPowerSignOpAdaptor::logbase() {
  return *getODSOperands(3).begin();
}

::mlir::Value ResourceApplyPowerSignOpAdaptor::sign_decay() {
  return *getODSOperands(4).begin();
}

::mlir::Value ResourceApplyPowerSignOpAdaptor::beta() {
  return *getODSOperands(5).begin();
}

::mlir::Value ResourceApplyPowerSignOpAdaptor::grad() {
  return *getODSOperands(6).begin();
}

::mlir::BoolAttr ResourceApplyPowerSignOpAdaptor::use_locking() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::BoolAttr attr = odsAttrs.get("use_locking").dyn_cast_or_null<::mlir::BoolAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getBoolAttr(false);
  return attr;
}

::mlir::LogicalResult ResourceApplyPowerSignOpAdaptor::verify(::mlir::Location loc) {
  {
  auto tblgen_use_locking = odsAttrs.get("use_locking");
  if (tblgen_use_locking) {
    if (!((tblgen_use_locking.isa<::mlir::BoolAttr>()))) return emitError(loc, "'tf.ResourceApplyPowerSign' op ""attribute 'use_locking' failed to satisfy constraint: bool attribute");
  }
  }
  return ::mlir::success();
}

::llvm::StringRef ResourceApplyPowerSignOp::getOperationName() {
  return "tf.ResourceApplyPowerSign";
}

std::pair<unsigned, unsigned> ResourceApplyPowerSignOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range ResourceApplyPowerSignOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value ResourceApplyPowerSignOp::var() {
  return *getODSOperands(0).begin();
}

::mlir::Value ResourceApplyPowerSignOp::m() {
  return *getODSOperands(1).begin();
}

::mlir::Value ResourceApplyPowerSignOp::lr() {
  return *getODSOperands(2).begin();
}

::mlir::Value ResourceApplyPowerSignOp::logbase() {
  return *getODSOperands(3).begin();
}

::mlir::Value ResourceApplyPowerSignOp::sign_decay() {
  return *getODSOperands(4).begin();
}

::mlir::Value ResourceApplyPowerSignOp::beta() {
  return *getODSOperands(5).begin();
}

::mlir::Value ResourceApplyPowerSignOp::grad() {
  return *getODSOperands(6).begin();
}

::mlir::MutableOperandRange ResourceApplyPowerSignOp::varMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange ResourceApplyPowerSignOp::mMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange ResourceApplyPowerSignOp::lrMutable() {
  auto range = getODSOperandIndexAndLength(2);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange ResourceApplyPowerSignOp::logbaseMutable() {
  auto range = getODSOperandIndexAndLength(3);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange ResourceApplyPowerSignOp::sign_decayMutable() {
  auto range = getODSOperandIndexAndLength(4);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange ResourceApplyPowerSignOp::betaMutable() {
  auto range = getODSOperandIndexAndLength(5);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange ResourceApplyPowerSignOp::gradMutable() {
  auto range = getODSOperandIndexAndLength(6);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> ResourceApplyPowerSignOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range ResourceApplyPowerSignOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::BoolAttr ResourceApplyPowerSignOp::use_lockingAttr() {
  return this->getAttr("use_locking").dyn_cast_or_null<::mlir::BoolAttr>();
}

bool ResourceApplyPowerSignOp::use_locking() {
  auto attr = use_lockingAttr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getBoolAttr(false).getValue();
  return attr.getValue();
}

Type ResourceApplyPowerSignOp::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(2).begin());
}

bool ResourceApplyPowerSignOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "T") return true;
 return false;
}

::mlir::DictionaryAttr ResourceApplyPowerSignOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())}
    }, ctx);
}

void ResourceApplyPowerSignOp::use_lockingAttr(::mlir::BoolAttr attr) {
  this->getOperation()->setAttr("use_locking", attr);
}

void ResourceApplyPowerSignOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value var, ::mlir::Value m, ::mlir::Value lr, ::mlir::Value logbase, ::mlir::Value sign_decay, ::mlir::Value beta, ::mlir::Value grad, ::mlir::BoolAttr use_locking) {
  odsState.addOperands(var);
  odsState.addOperands(m);
  odsState.addOperands(lr);
  odsState.addOperands(logbase);
  odsState.addOperands(sign_decay);
  odsState.addOperands(beta);
  odsState.addOperands(grad);
  odsState.addAttribute("use_locking", use_locking);
}

void ResourceApplyPowerSignOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value var, ::mlir::Value m, ::mlir::Value lr, ::mlir::Value logbase, ::mlir::Value sign_decay, ::mlir::Value beta, ::mlir::Value grad, ::mlir::BoolAttr use_locking) {
  odsState.addOperands(var);
  odsState.addOperands(m);
  odsState.addOperands(lr);
  odsState.addOperands(logbase);
  odsState.addOperands(sign_decay);
  odsState.addOperands(beta);
  odsState.addOperands(grad);
  odsState.addAttribute("use_locking", use_locking);
  assert(resultTypes.size() == 0u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void ResourceApplyPowerSignOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value var, ::mlir::Value m, ::mlir::Value lr, ::mlir::Value logbase, ::mlir::Value sign_decay, ::mlir::Value beta, ::mlir::Value grad, bool use_locking) {
  odsState.addOperands(var);
  odsState.addOperands(m);
  odsState.addOperands(lr);
  odsState.addOperands(logbase);
  odsState.addOperands(sign_decay);
  odsState.addOperands(beta);
  odsState.addOperands(grad);
  odsState.addAttribute("use_locking", odsBuilder.getBoolAttr(use_locking));
}

void ResourceApplyPowerSignOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value var, ::mlir::Value m, ::mlir::Value lr, ::mlir::Value logbase, ::mlir::Value sign_decay, ::mlir::Value beta, ::mlir::Value grad, bool use_locking) {
  odsState.addOperands(var);
  odsState.addOperands(m);
  odsState.addOperands(lr);
  odsState.addOperands(logbase);
  odsState.addOperands(sign_decay);
  odsState.addOperands(beta);
  odsState.addOperands(grad);
  odsState.addAttribute("use_locking", odsBuilder.getBoolAttr(use_locking));
  assert(resultTypes.size() == 0u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void ResourceApplyPowerSignOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 7u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 0u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult ResourceApplyPowerSignOp::verify() {
  if (failed(ResourceApplyPowerSignOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::ResourceType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::ResourceRefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of resource values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::ResourceType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::ResourceRefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of resource values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup2 = getODSOperands(2);
    for (::mlir::Value v : valueGroup2) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of bfloat16 or 128-bit complex or 64-bit complex or 16-bit float or 32-bit float or 64-bit float or 16-bit integer or 32-bit integer or 64-bit integer or 8-bit integer or 32-bit quantized integer or 8-bit quantized integer or 8-bit quantized unsigned integer or 16-bit unsigned integer or 32-bit unsigned integer or 64-bit unsigned integer or 8-bit unsigned integer values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup3 = getODSOperands(3);
    for (::mlir::Value v : valueGroup3) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of bfloat16 or 128-bit complex or 64-bit complex or 16-bit float or 32-bit float or 64-bit float or 16-bit integer or 32-bit integer or 64-bit integer or 8-bit integer or 32-bit quantized integer or 8-bit quantized integer or 8-bit quantized unsigned integer or 16-bit unsigned integer or 32-bit unsigned integer or 64-bit unsigned integer or 8-bit unsigned integer values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup4 = getODSOperands(4);
    for (::mlir::Value v : valueGroup4) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of bfloat16 or 128-bit complex or 64-bit complex or 16-bit float or 32-bit float or 64-bit float or 16-bit integer or 32-bit integer or 64-bit integer or 8-bit integer or 32-bit quantized integer or 8-bit quantized integer or 8-bit quantized unsigned integer or 16-bit unsigned integer or 32-bit unsigned integer or 64-bit unsigned integer or 8-bit unsigned integer values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup5 = getODSOperands(5);
    for (::mlir::Value v : valueGroup5) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of bfloat16 or 128-bit complex or 64-bit complex or 16-bit float or 32-bit float or 64-bit float or 16-bit integer or 32-bit integer or 64-bit integer or 8-bit integer or 32-bit quantized integer or 8-bit quantized integer or 8-bit quantized unsigned integer or 16-bit unsigned integer or 32-bit unsigned integer or 64-bit unsigned integer or 8-bit unsigned integer values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup6 = getODSOperands(6);
    for (::mlir::Value v : valueGroup6) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of bfloat16 or 128-bit complex or 64-bit complex or 16-bit float or 32-bit float or 64-bit float or 16-bit integer or 32-bit integer or 64-bit integer or 8-bit integer or 32-bit quantized integer or 8-bit quantized integer or 8-bit quantized unsigned integer or 16-bit unsigned integer or 32-bit unsigned integer or 64-bit unsigned integer or 8-bit unsigned integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
  }
  return ::mlir::success();
}

void ResourceApplyPowerSignOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
  for (::mlir::Value value : getODSOperands(0))
    effects.emplace_back(MemoryEffects::Read::get(), value, ::mlir::TF::ResourceEffects::Variable::get());
  for (::mlir::Value value : getODSOperands(0))
    effects.emplace_back(MemoryEffects::Write::get(), value, ::mlir::TF::ResourceEffects::Variable::get());
  for (::mlir::Value value : getODSOperands(1))
    effects.emplace_back(MemoryEffects::Read::get(), value, ::mlir::TF::ResourceEffects::Variable::get());
  for (::mlir::Value value : getODSOperands(1))
    effects.emplace_back(MemoryEffects::Write::get(), value, ::mlir::TF::ResourceEffects::Variable::get());
}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::ResourceApplyProximalAdagradOp definitions
//===----------------------------------------------------------------------===//

ResourceApplyProximalAdagradOpAdaptor::ResourceApplyProximalAdagradOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

ResourceApplyProximalAdagradOpAdaptor::ResourceApplyProximalAdagradOpAdaptor(ResourceApplyProximalAdagradOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> ResourceApplyProximalAdagradOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange ResourceApplyProximalAdagradOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value ResourceApplyProximalAdagradOpAdaptor::var() {
  return *getODSOperands(0).begin();
}

::mlir::Value ResourceApplyProximalAdagradOpAdaptor::accum() {
  return *getODSOperands(1).begin();
}

::mlir::Value ResourceApplyProximalAdagradOpAdaptor::lr() {
  return *getODSOperands(2).begin();
}

::mlir::Value ResourceApplyProximalAdagradOpAdaptor::l1() {
  return *getODSOperands(3).begin();
}

::mlir::Value ResourceApplyProximalAdagradOpAdaptor::l2() {
  return *getODSOperands(4).begin();
}

::mlir::Value ResourceApplyProximalAdagradOpAdaptor::grad() {
  return *getODSOperands(5).begin();
}

::mlir::BoolAttr ResourceApplyProximalAdagradOpAdaptor::use_locking() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::BoolAttr attr = odsAttrs.get("use_locking").dyn_cast_or_null<::mlir::BoolAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getBoolAttr(false);
  return attr;
}

::mlir::LogicalResult ResourceApplyProximalAdagradOpAdaptor::verify(::mlir::Location loc) {
  {
  auto tblgen_use_locking = odsAttrs.get("use_locking");
  if (tblgen_use_locking) {
    if (!((tblgen_use_locking.isa<::mlir::BoolAttr>()))) return emitError(loc, "'tf.ResourceApplyProximalAdagrad' op ""attribute 'use_locking' failed to satisfy constraint: bool attribute");
  }
  }
  return ::mlir::success();
}

::llvm::StringRef ResourceApplyProximalAdagradOp::getOperationName() {
  return "tf.ResourceApplyProximalAdagrad";
}

std::pair<unsigned, unsigned> ResourceApplyProximalAdagradOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range ResourceApplyProximalAdagradOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value ResourceApplyProximalAdagradOp::var() {
  return *getODSOperands(0).begin();
}

::mlir::Value ResourceApplyProximalAdagradOp::accum() {
  return *getODSOperands(1).begin();
}

::mlir::Value ResourceApplyProximalAdagradOp::lr() {
  return *getODSOperands(2).begin();
}

::mlir::Value ResourceApplyProximalAdagradOp::l1() {
  return *getODSOperands(3).begin();
}

::mlir::Value ResourceApplyProximalAdagradOp::l2() {
  return *getODSOperands(4).begin();
}

::mlir::Value ResourceApplyProximalAdagradOp::grad() {
  return *getODSOperands(5).begin();
}

::mlir::MutableOperandRange ResourceApplyProximalAdagradOp::varMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange ResourceApplyProximalAdagradOp::accumMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange ResourceApplyProximalAdagradOp::lrMutable() {
  auto range = getODSOperandIndexAndLength(2);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange ResourceApplyProximalAdagradOp::l1Mutable() {
  auto range = getODSOperandIndexAndLength(3);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange ResourceApplyProximalAdagradOp::l2Mutable() {
  auto range = getODSOperandIndexAndLength(4);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange ResourceApplyProximalAdagradOp::gradMutable() {
  auto range = getODSOperandIndexAndLength(5);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> ResourceApplyProximalAdagradOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range ResourceApplyProximalAdagradOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::BoolAttr ResourceApplyProximalAdagradOp::use_lockingAttr() {
  return this->getAttr("use_locking").dyn_cast_or_null<::mlir::BoolAttr>();
}

bool ResourceApplyProximalAdagradOp::use_locking() {
  auto attr = use_lockingAttr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getBoolAttr(false).getValue();
  return attr.getValue();
}

Type ResourceApplyProximalAdagradOp::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(2).begin());
}

bool ResourceApplyProximalAdagradOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "T") return true;
 return false;
}

::mlir::DictionaryAttr ResourceApplyProximalAdagradOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())}
    }, ctx);
}

void ResourceApplyProximalAdagradOp::use_lockingAttr(::mlir::BoolAttr attr) {
  this->getOperation()->setAttr("use_locking", attr);
}

void ResourceApplyProximalAdagradOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value var, ::mlir::Value accum, ::mlir::Value lr, ::mlir::Value l1, ::mlir::Value l2, ::mlir::Value grad, ::mlir::BoolAttr use_locking) {
  odsState.addOperands(var);
  odsState.addOperands(accum);
  odsState.addOperands(lr);
  odsState.addOperands(l1);
  odsState.addOperands(l2);
  odsState.addOperands(grad);
  odsState.addAttribute("use_locking", use_locking);
}

void ResourceApplyProximalAdagradOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value var, ::mlir::Value accum, ::mlir::Value lr, ::mlir::Value l1, ::mlir::Value l2, ::mlir::Value grad, ::mlir::BoolAttr use_locking) {
  odsState.addOperands(var);
  odsState.addOperands(accum);
  odsState.addOperands(lr);
  odsState.addOperands(l1);
  odsState.addOperands(l2);
  odsState.addOperands(grad);
  odsState.addAttribute("use_locking", use_locking);
  assert(resultTypes.size() == 0u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void ResourceApplyProximalAdagradOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value var, ::mlir::Value accum, ::mlir::Value lr, ::mlir::Value l1, ::mlir::Value l2, ::mlir::Value grad, bool use_locking) {
  odsState.addOperands(var);
  odsState.addOperands(accum);
  odsState.addOperands(lr);
  odsState.addOperands(l1);
  odsState.addOperands(l2);
  odsState.addOperands(grad);
  odsState.addAttribute("use_locking", odsBuilder.getBoolAttr(use_locking));
}

void ResourceApplyProximalAdagradOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value var, ::mlir::Value accum, ::mlir::Value lr, ::mlir::Value l1, ::mlir::Value l2, ::mlir::Value grad, bool use_locking) {
  odsState.addOperands(var);
  odsState.addOperands(accum);
  odsState.addOperands(lr);
  odsState.addOperands(l1);
  odsState.addOperands(l2);
  odsState.addOperands(grad);
  odsState.addAttribute("use_locking", odsBuilder.getBoolAttr(use_locking));
  assert(resultTypes.size() == 0u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void ResourceApplyProximalAdagradOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 6u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 0u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult ResourceApplyProximalAdagradOp::verify() {
  if (failed(ResourceApplyProximalAdagradOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::ResourceType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::ResourceRefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of resource values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::ResourceType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::ResourceRefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of resource values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup2 = getODSOperands(2);
    for (::mlir::Value v : valueGroup2) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of bfloat16 or 128-bit complex or 64-bit complex or 16-bit float or 32-bit float or 64-bit float or 16-bit integer or 32-bit integer or 64-bit integer or 8-bit integer or 32-bit quantized integer or 8-bit quantized integer or 8-bit quantized unsigned integer or 16-bit unsigned integer or 32-bit unsigned integer or 64-bit unsigned integer or 8-bit unsigned integer values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup3 = getODSOperands(3);
    for (::mlir::Value v : valueGroup3) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of bfloat16 or 128-bit complex or 64-bit complex or 16-bit float or 32-bit float or 64-bit float or 16-bit integer or 32-bit integer or 64-bit integer or 8-bit integer or 32-bit quantized integer or 8-bit quantized integer or 8-bit quantized unsigned integer or 16-bit unsigned integer or 32-bit unsigned integer or 64-bit unsigned integer or 8-bit unsigned integer values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup4 = getODSOperands(4);
    for (::mlir::Value v : valueGroup4) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of bfloat16 or 128-bit complex or 64-bit complex or 16-bit float or 32-bit float or 64-bit float or 16-bit integer or 32-bit integer or 64-bit integer or 8-bit integer or 32-bit quantized integer or 8-bit quantized integer or 8-bit quantized unsigned integer or 16-bit unsigned integer or 32-bit unsigned integer or 64-bit unsigned integer or 8-bit unsigned integer values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup5 = getODSOperands(5);
    for (::mlir::Value v : valueGroup5) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of bfloat16 or 128-bit complex or 64-bit complex or 16-bit float or 32-bit float or 64-bit float or 16-bit integer or 32-bit integer or 64-bit integer or 8-bit integer or 32-bit quantized integer or 8-bit quantized integer or 8-bit quantized unsigned integer or 16-bit unsigned integer or 32-bit unsigned integer or 64-bit unsigned integer or 8-bit unsigned integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
  }
  return ::mlir::success();
}

void ResourceApplyProximalAdagradOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
  for (::mlir::Value value : getODSOperands(0))
    effects.emplace_back(MemoryEffects::Read::get(), value, ::mlir::TF::ResourceEffects::Variable::get());
  for (::mlir::Value value : getODSOperands(0))
    effects.emplace_back(MemoryEffects::Write::get(), value, ::mlir::TF::ResourceEffects::Variable::get());
  for (::mlir::Value value : getODSOperands(1))
    effects.emplace_back(MemoryEffects::Read::get(), value, ::mlir::TF::ResourceEffects::Variable::get());
  for (::mlir::Value value : getODSOperands(1))
    effects.emplace_back(MemoryEffects::Write::get(), value, ::mlir::TF::ResourceEffects::Variable::get());
}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::ResourceApplyProximalGradientDescentOp definitions
//===----------------------------------------------------------------------===//

ResourceApplyProximalGradientDescentOpAdaptor::ResourceApplyProximalGradientDescentOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

ResourceApplyProximalGradientDescentOpAdaptor::ResourceApplyProximalGradientDescentOpAdaptor(ResourceApplyProximalGradientDescentOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> ResourceApplyProximalGradientDescentOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange ResourceApplyProximalGradientDescentOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value ResourceApplyProximalGradientDescentOpAdaptor::var() {
  return *getODSOperands(0).begin();
}

::mlir::Value ResourceApplyProximalGradientDescentOpAdaptor::alpha() {
  return *getODSOperands(1).begin();
}

::mlir::Value ResourceApplyProximalGradientDescentOpAdaptor::l1() {
  return *getODSOperands(2).begin();
}

::mlir::Value ResourceApplyProximalGradientDescentOpAdaptor::l2() {
  return *getODSOperands(3).begin();
}

::mlir::Value ResourceApplyProximalGradientDescentOpAdaptor::delta() {
  return *getODSOperands(4).begin();
}

::mlir::BoolAttr ResourceApplyProximalGradientDescentOpAdaptor::use_locking() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::BoolAttr attr = odsAttrs.get("use_locking").dyn_cast_or_null<::mlir::BoolAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getBoolAttr(false);
  return attr;
}

::mlir::LogicalResult ResourceApplyProximalGradientDescentOpAdaptor::verify(::mlir::Location loc) {
  {
  auto tblgen_use_locking = odsAttrs.get("use_locking");
  if (tblgen_use_locking) {
    if (!((tblgen_use_locking.isa<::mlir::BoolAttr>()))) return emitError(loc, "'tf.ResourceApplyProximalGradientDescent' op ""attribute 'use_locking' failed to satisfy constraint: bool attribute");
  }
  }
  return ::mlir::success();
}

::llvm::StringRef ResourceApplyProximalGradientDescentOp::getOperationName() {
  return "tf.ResourceApplyProximalGradientDescent";
}

std::pair<unsigned, unsigned> ResourceApplyProximalGradientDescentOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range ResourceApplyProximalGradientDescentOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value ResourceApplyProximalGradientDescentOp::var() {
  return *getODSOperands(0).begin();
}

::mlir::Value ResourceApplyProximalGradientDescentOp::alpha() {
  return *getODSOperands(1).begin();
}

::mlir::Value ResourceApplyProximalGradientDescentOp::l1() {
  return *getODSOperands(2).begin();
}

::mlir::Value ResourceApplyProximalGradientDescentOp::l2() {
  return *getODSOperands(3).begin();
}

::mlir::Value ResourceApplyProximalGradientDescentOp::delta() {
  return *getODSOperands(4).begin();
}

::mlir::MutableOperandRange ResourceApplyProximalGradientDescentOp::varMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange ResourceApplyProximalGradientDescentOp::alphaMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange ResourceApplyProximalGradientDescentOp::l1Mutable() {
  auto range = getODSOperandIndexAndLength(2);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange ResourceApplyProximalGradientDescentOp::l2Mutable() {
  auto range = getODSOperandIndexAndLength(3);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange ResourceApplyProximalGradientDescentOp::deltaMutable() {
  auto range = getODSOperandIndexAndLength(4);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> ResourceApplyProximalGradientDescentOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range ResourceApplyProximalGradientDescentOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::BoolAttr ResourceApplyProximalGradientDescentOp::use_lockingAttr() {
  return this->getAttr("use_locking").dyn_cast_or_null<::mlir::BoolAttr>();
}

bool ResourceApplyProximalGradientDescentOp::use_locking() {
  auto attr = use_lockingAttr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getBoolAttr(false).getValue();
  return attr.getValue();
}

Type ResourceApplyProximalGradientDescentOp::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(1).begin());
}

bool ResourceApplyProximalGradientDescentOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "T") return true;
 return false;
}

::mlir::DictionaryAttr ResourceApplyProximalGradientDescentOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())}
    }, ctx);
}

void ResourceApplyProximalGradientDescentOp::use_lockingAttr(::mlir::BoolAttr attr) {
  this->getOperation()->setAttr("use_locking", attr);
}

void ResourceApplyProximalGradientDescentOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value var, ::mlir::Value alpha, ::mlir::Value l1, ::mlir::Value l2, ::mlir::Value delta, ::mlir::BoolAttr use_locking) {
  odsState.addOperands(var);
  odsState.addOperands(alpha);
  odsState.addOperands(l1);
  odsState.addOperands(l2);
  odsState.addOperands(delta);
  odsState.addAttribute("use_locking", use_locking);
}

void ResourceApplyProximalGradientDescentOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value var, ::mlir::Value alpha, ::mlir::Value l1, ::mlir::Value l2, ::mlir::Value delta, ::mlir::BoolAttr use_locking) {
  odsState.addOperands(var);
  odsState.addOperands(alpha);
  odsState.addOperands(l1);
  odsState.addOperands(l2);
  odsState.addOperands(delta);
  odsState.addAttribute("use_locking", use_locking);
  assert(resultTypes.size() == 0u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void ResourceApplyProximalGradientDescentOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value var, ::mlir::Value alpha, ::mlir::Value l1, ::mlir::Value l2, ::mlir::Value delta, bool use_locking) {
  odsState.addOperands(var);
  odsState.addOperands(alpha);
  odsState.addOperands(l1);
  odsState.addOperands(l2);
  odsState.addOperands(delta);
  odsState.addAttribute("use_locking", odsBuilder.getBoolAttr(use_locking));
}

void ResourceApplyProximalGradientDescentOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value var, ::mlir::Value alpha, ::mlir::Value l1, ::mlir::Value l2, ::mlir::Value delta, bool use_locking) {
  odsState.addOperands(var);
  odsState.addOperands(alpha);
  odsState.addOperands(l1);
  odsState.addOperands(l2);
  odsState.addOperands(delta);
  odsState.addAttribute("use_locking", odsBuilder.getBoolAttr(use_locking));
  assert(resultTypes.size() == 0u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void ResourceApplyProximalGradientDescentOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 5u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 0u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult ResourceApplyProximalGradientDescentOp::verify() {
  if (failed(ResourceApplyProximalGradientDescentOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::ResourceType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::ResourceRefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of resource values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of bfloat16 or 128-bit complex or 64-bit complex or 16-bit float or 32-bit float or 64-bit float or 16-bit integer or 32-bit integer or 64-bit integer or 8-bit integer or 32-bit quantized integer or 8-bit quantized integer or 8-bit quantized unsigned integer or 16-bit unsigned integer or 32-bit unsigned integer or 64-bit unsigned integer or 8-bit unsigned integer values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup2 = getODSOperands(2);
    for (::mlir::Value v : valueGroup2) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of bfloat16 or 128-bit complex or 64-bit complex or 16-bit float or 32-bit float or 64-bit float or 16-bit integer or 32-bit integer or 64-bit integer or 8-bit integer or 32-bit quantized integer or 8-bit quantized integer or 8-bit quantized unsigned integer or 16-bit unsigned integer or 32-bit unsigned integer or 64-bit unsigned integer or 8-bit unsigned integer values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup3 = getODSOperands(3);
    for (::mlir::Value v : valueGroup3) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of bfloat16 or 128-bit complex or 64-bit complex or 16-bit float or 32-bit float or 64-bit float or 16-bit integer or 32-bit integer or 64-bit integer or 8-bit integer or 32-bit quantized integer or 8-bit quantized integer or 8-bit quantized unsigned integer or 16-bit unsigned integer or 32-bit unsigned integer or 64-bit unsigned integer or 8-bit unsigned integer values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup4 = getODSOperands(4);
    for (::mlir::Value v : valueGroup4) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of bfloat16 or 128-bit complex or 64-bit complex or 16-bit float or 32-bit float or 64-bit float or 16-bit integer or 32-bit integer or 64-bit integer or 8-bit integer or 32-bit quantized integer or 8-bit quantized integer or 8-bit quantized unsigned integer or 16-bit unsigned integer or 32-bit unsigned integer or 64-bit unsigned integer or 8-bit unsigned integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
  }
  return ::mlir::success();
}

void ResourceApplyProximalGradientDescentOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
  for (::mlir::Value value : getODSOperands(0))
    effects.emplace_back(MemoryEffects::Read::get(), value, ::mlir::TF::ResourceEffects::Variable::get());
  for (::mlir::Value value : getODSOperands(0))
    effects.emplace_back(MemoryEffects::Write::get(), value, ::mlir::TF::ResourceEffects::Variable::get());
}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::ResourceApplyRMSPropOp definitions
//===----------------------------------------------------------------------===//

ResourceApplyRMSPropOpAdaptor::ResourceApplyRMSPropOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

ResourceApplyRMSPropOpAdaptor::ResourceApplyRMSPropOpAdaptor(ResourceApplyRMSPropOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> ResourceApplyRMSPropOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange ResourceApplyRMSPropOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value ResourceApplyRMSPropOpAdaptor::var() {
  return *getODSOperands(0).begin();
}

::mlir::Value ResourceApplyRMSPropOpAdaptor::ms() {
  return *getODSOperands(1).begin();
}

::mlir::Value ResourceApplyRMSPropOpAdaptor::mom() {
  return *getODSOperands(2).begin();
}

::mlir::Value ResourceApplyRMSPropOpAdaptor::lr() {
  return *getODSOperands(3).begin();
}

::mlir::Value ResourceApplyRMSPropOpAdaptor::rho() {
  return *getODSOperands(4).begin();
}

::mlir::Value ResourceApplyRMSPropOpAdaptor::momentum() {
  return *getODSOperands(5).begin();
}

::mlir::Value ResourceApplyRMSPropOpAdaptor::epsilon() {
  return *getODSOperands(6).begin();
}

::mlir::Value ResourceApplyRMSPropOpAdaptor::grad() {
  return *getODSOperands(7).begin();
}

::mlir::BoolAttr ResourceApplyRMSPropOpAdaptor::use_locking() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::BoolAttr attr = odsAttrs.get("use_locking").dyn_cast_or_null<::mlir::BoolAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getBoolAttr(false);
  return attr;
}

::mlir::LogicalResult ResourceApplyRMSPropOpAdaptor::verify(::mlir::Location loc) {
  {
  auto tblgen_use_locking = odsAttrs.get("use_locking");
  if (tblgen_use_locking) {
    if (!((tblgen_use_locking.isa<::mlir::BoolAttr>()))) return emitError(loc, "'tf.ResourceApplyRMSProp' op ""attribute 'use_locking' failed to satisfy constraint: bool attribute");
  }
  }
  return ::mlir::success();
}

::llvm::StringRef ResourceApplyRMSPropOp::getOperationName() {
  return "tf.ResourceApplyRMSProp";
}

std::pair<unsigned, unsigned> ResourceApplyRMSPropOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range ResourceApplyRMSPropOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value ResourceApplyRMSPropOp::var() {
  return *getODSOperands(0).begin();
}

::mlir::Value ResourceApplyRMSPropOp::ms() {
  return *getODSOperands(1).begin();
}

::mlir::Value ResourceApplyRMSPropOp::mom() {
  return *getODSOperands(2).begin();
}

::mlir::Value ResourceApplyRMSPropOp::lr() {
  return *getODSOperands(3).begin();
}

::mlir::Value ResourceApplyRMSPropOp::rho() {
  return *getODSOperands(4).begin();
}

::mlir::Value ResourceApplyRMSPropOp::momentum() {
  return *getODSOperands(5).begin();
}

::mlir::Value ResourceApplyRMSPropOp::epsilon() {
  return *getODSOperands(6).begin();
}

::mlir::Value ResourceApplyRMSPropOp::grad() {
  return *getODSOperands(7).begin();
}

::mlir::MutableOperandRange ResourceApplyRMSPropOp::varMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange ResourceApplyRMSPropOp::msMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange ResourceApplyRMSPropOp::momMutable() {
  auto range = getODSOperandIndexAndLength(2);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange ResourceApplyRMSPropOp::lrMutable() {
  auto range = getODSOperandIndexAndLength(3);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange ResourceApplyRMSPropOp::rhoMutable() {
  auto range = getODSOperandIndexAndLength(4);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange ResourceApplyRMSPropOp::momentumMutable() {
  auto range = getODSOperandIndexAndLength(5);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange ResourceApplyRMSPropOp::epsilonMutable() {
  auto range = getODSOperandIndexAndLength(6);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange ResourceApplyRMSPropOp::gradMutable() {
  auto range = getODSOperandIndexAndLength(7);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> ResourceApplyRMSPropOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range ResourceApplyRMSPropOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::BoolAttr ResourceApplyRMSPropOp::use_lockingAttr() {
  return this->getAttr("use_locking").dyn_cast_or_null<::mlir::BoolAttr>();
}

bool ResourceApplyRMSPropOp::use_locking() {
  auto attr = use_lockingAttr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getBoolAttr(false).getValue();
  return attr.getValue();
}

Type ResourceApplyRMSPropOp::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(3).begin());
}

bool ResourceApplyRMSPropOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "T") return true;
 return false;
}

::mlir::DictionaryAttr ResourceApplyRMSPropOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())}
    }, ctx);
}

void ResourceApplyRMSPropOp::use_lockingAttr(::mlir::BoolAttr attr) {
  this->getOperation()->setAttr("use_locking", attr);
}

void ResourceApplyRMSPropOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value var, ::mlir::Value ms, ::mlir::Value mom, ::mlir::Value lr, ::mlir::Value rho, ::mlir::Value momentum, ::mlir::Value epsilon, ::mlir::Value grad, ::mlir::BoolAttr use_locking) {
  odsState.addOperands(var);
  odsState.addOperands(ms);
  odsState.addOperands(mom);
  odsState.addOperands(lr);
  odsState.addOperands(rho);
  odsState.addOperands(momentum);
  odsState.addOperands(epsilon);
  odsState.addOperands(grad);
  odsState.addAttribute("use_locking", use_locking);
}

void ResourceApplyRMSPropOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value var, ::mlir::Value ms, ::mlir::Value mom, ::mlir::Value lr, ::mlir::Value rho, ::mlir::Value momentum, ::mlir::Value epsilon, ::mlir::Value grad, ::mlir::BoolAttr use_locking) {
  odsState.addOperands(var);
  odsState.addOperands(ms);
  odsState.addOperands(mom);
  odsState.addOperands(lr);
  odsState.addOperands(rho);
  odsState.addOperands(momentum);
  odsState.addOperands(epsilon);
  odsState.addOperands(grad);
  odsState.addAttribute("use_locking", use_locking);
  assert(resultTypes.size() == 0u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void ResourceApplyRMSPropOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value var, ::mlir::Value ms, ::mlir::Value mom, ::mlir::Value lr, ::mlir::Value rho, ::mlir::Value momentum, ::mlir::Value epsilon, ::mlir::Value grad, bool use_locking) {
  odsState.addOperands(var);
  odsState.addOperands(ms);
  odsState.addOperands(mom);
  odsState.addOperands(lr);
  odsState.addOperands(rho);
  odsState.addOperands(momentum);
  odsState.addOperands(epsilon);
  odsState.addOperands(grad);
  odsState.addAttribute("use_locking", odsBuilder.getBoolAttr(use_locking));
}

void ResourceApplyRMSPropOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value var, ::mlir::Value ms, ::mlir::Value mom, ::mlir::Value lr, ::mlir::Value rho, ::mlir::Value momentum, ::mlir::Value epsilon, ::mlir::Value grad, bool use_locking) {
  odsState.addOperands(var);
  odsState.addOperands(ms);
  odsState.addOperands(mom);
  odsState.addOperands(lr);
  odsState.addOperands(rho);
  odsState.addOperands(momentum);
  odsState.addOperands(epsilon);
  odsState.addOperands(grad);
  odsState.addAttribute("use_locking", odsBuilder.getBoolAttr(use_locking));
  assert(resultTypes.size() == 0u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void ResourceApplyRMSPropOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 8u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 0u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult ResourceApplyRMSPropOp::verify() {
  if (failed(ResourceApplyRMSPropOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::ResourceType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::ResourceRefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of resource values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::ResourceType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::ResourceRefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of resource values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup2 = getODSOperands(2);
    for (::mlir::Value v : valueGroup2) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::ResourceType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::ResourceRefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of resource values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup3 = getODSOperands(3);
    for (::mlir::Value v : valueGroup3) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of bfloat16 or 128-bit complex or 64-bit complex or 16-bit float or 32-bit float or 64-bit float or 16-bit integer or 32-bit integer or 64-bit integer or 8-bit integer or 32-bit quantized integer or 8-bit quantized integer or 8-bit quantized unsigned integer or 16-bit unsigned integer or 32-bit unsigned integer or 64-bit unsigned integer or 8-bit unsigned integer values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup4 = getODSOperands(4);
    for (::mlir::Value v : valueGroup4) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of bfloat16 or 128-bit complex or 64-bit complex or 16-bit float or 32-bit float or 64-bit float or 16-bit integer or 32-bit integer or 64-bit integer or 8-bit integer or 32-bit quantized integer or 8-bit quantized integer or 8-bit quantized unsigned integer or 16-bit unsigned integer or 32-bit unsigned integer or 64-bit unsigned integer or 8-bit unsigned integer values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup5 = getODSOperands(5);
    for (::mlir::Value v : valueGroup5) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of bfloat16 or 128-bit complex or 64-bit complex or 16-bit float or 32-bit float or 64-bit float or 16-bit integer or 32-bit integer or 64-bit integer or 8-bit integer or 32-bit quantized integer or 8-bit quantized integer or 8-bit quantized unsigned integer or 16-bit unsigned integer or 32-bit unsigned integer or 64-bit unsigned integer or 8-bit unsigned integer values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup6 = getODSOperands(6);
    for (::mlir::Value v : valueGroup6) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of bfloat16 or 128-bit complex or 64-bit complex or 16-bit float or 32-bit float or 64-bit float or 16-bit integer or 32-bit integer or 64-bit integer or 8-bit integer or 32-bit quantized integer or 8-bit quantized integer or 8-bit quantized unsigned integer or 16-bit unsigned integer or 32-bit unsigned integer or 64-bit unsigned integer or 8-bit unsigned integer values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup7 = getODSOperands(7);
    for (::mlir::Value v : valueGroup7) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of bfloat16 or 128-bit complex or 64-bit complex or 16-bit float or 32-bit float or 64-bit float or 16-bit integer or 32-bit integer or 64-bit integer or 8-bit integer or 32-bit quantized integer or 8-bit quantized integer or 8-bit quantized unsigned integer or 16-bit unsigned integer or 32-bit unsigned integer or 64-bit unsigned integer or 8-bit unsigned integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
  }
  return ::mlir::success();
}

void ResourceApplyRMSPropOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
  for (::mlir::Value value : getODSOperands(0))
    effects.emplace_back(MemoryEffects::Read::get(), value, ::mlir::TF::ResourceEffects::Variable::get());
  for (::mlir::Value value : getODSOperands(0))
    effects.emplace_back(MemoryEffects::Write::get(), value, ::mlir::TF::ResourceEffects::Variable::get());
  for (::mlir::Value value : getODSOperands(1))
    effects.emplace_back(MemoryEffects::Read::get(), value, ::mlir::TF::ResourceEffects::Variable::get());
  for (::mlir::Value value : getODSOperands(1))
    effects.emplace_back(MemoryEffects::Write::get(), value, ::mlir::TF::ResourceEffects::Variable::get());
  for (::mlir::Value value : getODSOperands(2))
    effects.emplace_back(MemoryEffects::Read::get(), value, ::mlir::TF::ResourceEffects::Variable::get());
  for (::mlir::Value value : getODSOperands(2))
    effects.emplace_back(MemoryEffects::Write::get(), value, ::mlir::TF::ResourceEffects::Variable::get());
}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::ResourceGatherOp definitions
//===----------------------------------------------------------------------===//

ResourceGatherOpAdaptor::ResourceGatherOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

ResourceGatherOpAdaptor::ResourceGatherOpAdaptor(ResourceGatherOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> ResourceGatherOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange ResourceGatherOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value ResourceGatherOpAdaptor::resource() {
  return *getODSOperands(0).begin();
}

::mlir::Value ResourceGatherOpAdaptor::indices() {
  return *getODSOperands(1).begin();
}

::mlir::IntegerAttr ResourceGatherOpAdaptor::batch_dims() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::IntegerAttr attr = odsAttrs.get("batch_dims").dyn_cast_or_null<::mlir::IntegerAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getIntegerAttr(::mlir::Builder(odsAttrs.getContext()).getIntegerType(64), 0);
  return attr;
}

::mlir::BoolAttr ResourceGatherOpAdaptor::validate_indices() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::BoolAttr attr = odsAttrs.get("validate_indices").dyn_cast_or_null<::mlir::BoolAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getBoolAttr(true);
  return attr;
}

::mlir::LogicalResult ResourceGatherOpAdaptor::verify(::mlir::Location loc) {
  {
  auto tblgen_batch_dims = odsAttrs.get("batch_dims");
  if (tblgen_batch_dims) {
    if (!(((tblgen_batch_dims.isa<::mlir::IntegerAttr>())) && ((tblgen_batch_dims.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(64))))) return emitError(loc, "'tf.ResourceGather' op ""attribute 'batch_dims' failed to satisfy constraint: 64-bit signless integer attribute");
  }
  }
  {
  auto tblgen_validate_indices = odsAttrs.get("validate_indices");
  if (tblgen_validate_indices) {
    if (!((tblgen_validate_indices.isa<::mlir::BoolAttr>()))) return emitError(loc, "'tf.ResourceGather' op ""attribute 'validate_indices' failed to satisfy constraint: bool attribute");
  }
  }
  return ::mlir::success();
}

::llvm::StringRef ResourceGatherOp::getOperationName() {
  return "tf.ResourceGather";
}

std::pair<unsigned, unsigned> ResourceGatherOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range ResourceGatherOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value ResourceGatherOp::resource() {
  return *getODSOperands(0).begin();
}

::mlir::Value ResourceGatherOp::indices() {
  return *getODSOperands(1).begin();
}

::mlir::MutableOperandRange ResourceGatherOp::resourceMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange ResourceGatherOp::indicesMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> ResourceGatherOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range ResourceGatherOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value ResourceGatherOp::output() {
  return *getODSResults(0).begin();
}

::mlir::IntegerAttr ResourceGatherOp::batch_dimsAttr() {
  return this->getAttr("batch_dims").dyn_cast_or_null<::mlir::IntegerAttr>();
}

uint64_t ResourceGatherOp::batch_dims() {
  auto attr = batch_dimsAttr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getIntegerAttr(::mlir::Builder(this->getContext()).getIntegerType(64), 0).getValue().getZExtValue();
  return attr.getValue().getZExtValue();
}

::mlir::BoolAttr ResourceGatherOp::validate_indicesAttr() {
  return this->getAttr("validate_indices").dyn_cast_or_null<::mlir::BoolAttr>();
}

bool ResourceGatherOp::validate_indices() {
  auto attr = validate_indicesAttr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getBoolAttr(true).getValue();
  return attr.getValue();
}

Type ResourceGatherOp::Tindices() {
  return mlir::getElementTypeOrSelf(*getODSOperands(1).begin());
}

Type ResourceGatherOp::dtype() {
  return mlir::getElementTypeOrSelf(*getODSResults(0).begin());
}

bool ResourceGatherOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "Tindices") return true;
  if (name == "dtype") return true;
 return false;
}

::mlir::DictionaryAttr ResourceGatherOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("Tindices", ctx),
::mlir::TypeAttr::get(Tindices())},
    {::mlir::Identifier::get("dtype", ctx),
::mlir::TypeAttr::get(dtype())}
    }, ctx);
}

void ResourceGatherOp::batch_dimsAttr(::mlir::IntegerAttr attr) {
  this->getOperation()->setAttr("batch_dims", attr);
}

void ResourceGatherOp::validate_indicesAttr(::mlir::BoolAttr attr) {
  this->getOperation()->setAttr("validate_indices", attr);
}

void ResourceGatherOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value resource, ::mlir::Value indices, ::mlir::IntegerAttr batch_dims, ::mlir::BoolAttr validate_indices) {
  odsState.addOperands(resource);
  odsState.addOperands(indices);
  odsState.addAttribute("batch_dims", batch_dims);
  odsState.addAttribute("validate_indices", validate_indices);
  odsState.addTypes(output);
}

void ResourceGatherOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value resource, ::mlir::Value indices, ::mlir::IntegerAttr batch_dims, ::mlir::BoolAttr validate_indices) {
  odsState.addOperands(resource);
  odsState.addOperands(indices);
  odsState.addAttribute("batch_dims", batch_dims);
  odsState.addAttribute("validate_indices", validate_indices);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void ResourceGatherOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value resource, ::mlir::Value indices, uint64_t batch_dims, bool validate_indices) {
  odsState.addOperands(resource);
  odsState.addOperands(indices);
  odsState.addAttribute("batch_dims", odsBuilder.getIntegerAttr(odsBuilder.getIntegerType(64), batch_dims));
  odsState.addAttribute("validate_indices", odsBuilder.getBoolAttr(validate_indices));
  odsState.addTypes(output);
}

void ResourceGatherOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value resource, ::mlir::Value indices, uint64_t batch_dims, bool validate_indices) {
  odsState.addOperands(resource);
  odsState.addOperands(indices);
  odsState.addAttribute("batch_dims", odsBuilder.getIntegerAttr(odsBuilder.getIntegerType(64), batch_dims));
  odsState.addAttribute("validate_indices", odsBuilder.getBoolAttr(validate_indices));
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void ResourceGatherOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult ResourceGatherOp::verify() {
  if (failed(ResourceGatherOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::ResourceType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::ResourceRefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of resource values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of 32/64-bit signed integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>())))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::TensorFlowType>()))))) {
        return emitOpError("result #") << index << " must be tensor of tf.dtype values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void ResourceGatherOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
  for (::mlir::Value value : getODSOperands(0))
    effects.emplace_back(MemoryEffects::Read::get(), value, ::mlir::TF::ResourceEffects::Variable::get());
}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::ResourceScatterAddOp definitions
//===----------------------------------------------------------------------===//

ResourceScatterAddOpAdaptor::ResourceScatterAddOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

ResourceScatterAddOpAdaptor::ResourceScatterAddOpAdaptor(ResourceScatterAddOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> ResourceScatterAddOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange ResourceScatterAddOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value ResourceScatterAddOpAdaptor::resource() {
  return *getODSOperands(0).begin();
}

::mlir::Value ResourceScatterAddOpAdaptor::indices() {
  return *getODSOperands(1).begin();
}

::mlir::Value ResourceScatterAddOpAdaptor::updates() {
  return *getODSOperands(2).begin();
}

::mlir::LogicalResult ResourceScatterAddOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

::llvm::StringRef ResourceScatterAddOp::getOperationName() {
  return "tf.ResourceScatterAdd";
}

std::pair<unsigned, unsigned> ResourceScatterAddOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range ResourceScatterAddOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value ResourceScatterAddOp::resource() {
  return *getODSOperands(0).begin();
}

::mlir::Value ResourceScatterAddOp::indices() {
  return *getODSOperands(1).begin();
}

::mlir::Value ResourceScatterAddOp::updates() {
  return *getODSOperands(2).begin();
}

::mlir::MutableOperandRange ResourceScatterAddOp::resourceMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange ResourceScatterAddOp::indicesMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange ResourceScatterAddOp::updatesMutable() {
  auto range = getODSOperandIndexAndLength(2);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> ResourceScatterAddOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range ResourceScatterAddOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

Type ResourceScatterAddOp::Tindices() {
  return mlir::getElementTypeOrSelf(*getODSOperands(1).begin());
}

Type ResourceScatterAddOp::dtype() {
  return mlir::getElementTypeOrSelf(*getODSOperands(2).begin());
}

bool ResourceScatterAddOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "Tindices") return true;
  if (name == "dtype") return true;
 return false;
}

::mlir::DictionaryAttr ResourceScatterAddOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("Tindices", ctx),
::mlir::TypeAttr::get(Tindices())},
    {::mlir::Identifier::get("dtype", ctx),
::mlir::TypeAttr::get(dtype())}
    }, ctx);
}

void ResourceScatterAddOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value resource, ::mlir::Value indices, ::mlir::Value updates) {
  odsState.addOperands(resource);
  odsState.addOperands(indices);
  odsState.addOperands(updates);
}

void ResourceScatterAddOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value resource, ::mlir::Value indices, ::mlir::Value updates) {
  odsState.addOperands(resource);
  odsState.addOperands(indices);
  odsState.addOperands(updates);
  assert(resultTypes.size() == 0u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void ResourceScatterAddOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 3u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 0u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult ResourceScatterAddOp::verify() {
  if (failed(ResourceScatterAddOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::ResourceType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::ResourceRefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of resource values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of 32/64-bit signed integer values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup2 = getODSOperands(2);
    for (::mlir::Value v : valueGroup2) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of bfloat16 or 128-bit complex or 64-bit complex or 16-bit float or 32-bit float or 64-bit float or 16-bit integer or 32-bit integer or 64-bit integer or 8-bit integer or 32-bit quantized integer or 8-bit quantized integer or 8-bit quantized unsigned integer or 16-bit unsigned integer or 32-bit unsigned integer or 64-bit unsigned integer or 8-bit unsigned integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
  }
  return ::mlir::success();
}

void ResourceScatterAddOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
  for (::mlir::Value value : getODSOperands(0))
    effects.emplace_back(MemoryEffects::Read::get(), value, ::mlir::TF::ResourceEffects::Variable::get());
  for (::mlir::Value value : getODSOperands(0))
    effects.emplace_back(MemoryEffects::Write::get(), value, ::mlir::TF::ResourceEffects::Variable::get());
}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::ResourceScatterDivOp definitions
//===----------------------------------------------------------------------===//

ResourceScatterDivOpAdaptor::ResourceScatterDivOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

ResourceScatterDivOpAdaptor::ResourceScatterDivOpAdaptor(ResourceScatterDivOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> ResourceScatterDivOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange ResourceScatterDivOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value ResourceScatterDivOpAdaptor::resource() {
  return *getODSOperands(0).begin();
}

::mlir::Value ResourceScatterDivOpAdaptor::indices() {
  return *getODSOperands(1).begin();
}

::mlir::Value ResourceScatterDivOpAdaptor::updates() {
  return *getODSOperands(2).begin();
}

::mlir::LogicalResult ResourceScatterDivOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

::llvm::StringRef ResourceScatterDivOp::getOperationName() {
  return "tf.ResourceScatterDiv";
}

std::pair<unsigned, unsigned> ResourceScatterDivOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range ResourceScatterDivOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value ResourceScatterDivOp::resource() {
  return *getODSOperands(0).begin();
}

::mlir::Value ResourceScatterDivOp::indices() {
  return *getODSOperands(1).begin();
}

::mlir::Value ResourceScatterDivOp::updates() {
  return *getODSOperands(2).begin();
}

::mlir::MutableOperandRange ResourceScatterDivOp::resourceMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange ResourceScatterDivOp::indicesMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange ResourceScatterDivOp::updatesMutable() {
  auto range = getODSOperandIndexAndLength(2);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> ResourceScatterDivOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range ResourceScatterDivOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

Type ResourceScatterDivOp::Tindices() {
  return mlir::getElementTypeOrSelf(*getODSOperands(1).begin());
}

Type ResourceScatterDivOp::dtype() {
  return mlir::getElementTypeOrSelf(*getODSOperands(2).begin());
}

bool ResourceScatterDivOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "Tindices") return true;
  if (name == "dtype") return true;
 return false;
}

::mlir::DictionaryAttr ResourceScatterDivOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("Tindices", ctx),
::mlir::TypeAttr::get(Tindices())},
    {::mlir::Identifier::get("dtype", ctx),
::mlir::TypeAttr::get(dtype())}
    }, ctx);
}

void ResourceScatterDivOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value resource, ::mlir::Value indices, ::mlir::Value updates) {
  odsState.addOperands(resource);
  odsState.addOperands(indices);
  odsState.addOperands(updates);
}

void ResourceScatterDivOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value resource, ::mlir::Value indices, ::mlir::Value updates) {
  odsState.addOperands(resource);
  odsState.addOperands(indices);
  odsState.addOperands(updates);
  assert(resultTypes.size() == 0u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void ResourceScatterDivOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 3u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 0u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult ResourceScatterDivOp::verify() {
  if (failed(ResourceScatterDivOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::ResourceType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::ResourceRefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of resource values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of 32/64-bit signed integer values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup2 = getODSOperands(2);
    for (::mlir::Value v : valueGroup2) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of bfloat16 or 128-bit complex or 64-bit complex or 16-bit float or 32-bit float or 64-bit float or 16-bit integer or 32-bit integer or 64-bit integer or 8-bit integer or 32-bit quantized integer or 8-bit quantized integer or 8-bit quantized unsigned integer or 16-bit unsigned integer or 32-bit unsigned integer or 64-bit unsigned integer or 8-bit unsigned integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
  }
  return ::mlir::success();
}

void ResourceScatterDivOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
  for (::mlir::Value value : getODSOperands(0))
    effects.emplace_back(MemoryEffects::Read::get(), value, ::mlir::TF::ResourceEffects::Variable::get());
  for (::mlir::Value value : getODSOperands(0))
    effects.emplace_back(MemoryEffects::Write::get(), value, ::mlir::TF::ResourceEffects::Variable::get());
}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::ResourceScatterMaxOp definitions
//===----------------------------------------------------------------------===//

ResourceScatterMaxOpAdaptor::ResourceScatterMaxOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

ResourceScatterMaxOpAdaptor::ResourceScatterMaxOpAdaptor(ResourceScatterMaxOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> ResourceScatterMaxOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange ResourceScatterMaxOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value ResourceScatterMaxOpAdaptor::resource() {
  return *getODSOperands(0).begin();
}

::mlir::Value ResourceScatterMaxOpAdaptor::indices() {
  return *getODSOperands(1).begin();
}

::mlir::Value ResourceScatterMaxOpAdaptor::updates() {
  return *getODSOperands(2).begin();
}

::mlir::LogicalResult ResourceScatterMaxOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

::llvm::StringRef ResourceScatterMaxOp::getOperationName() {
  return "tf.ResourceScatterMax";
}

std::pair<unsigned, unsigned> ResourceScatterMaxOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range ResourceScatterMaxOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value ResourceScatterMaxOp::resource() {
  return *getODSOperands(0).begin();
}

::mlir::Value ResourceScatterMaxOp::indices() {
  return *getODSOperands(1).begin();
}

::mlir::Value ResourceScatterMaxOp::updates() {
  return *getODSOperands(2).begin();
}

::mlir::MutableOperandRange ResourceScatterMaxOp::resourceMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange ResourceScatterMaxOp::indicesMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange ResourceScatterMaxOp::updatesMutable() {
  auto range = getODSOperandIndexAndLength(2);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> ResourceScatterMaxOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range ResourceScatterMaxOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

Type ResourceScatterMaxOp::Tindices() {
  return mlir::getElementTypeOrSelf(*getODSOperands(1).begin());
}

Type ResourceScatterMaxOp::dtype() {
  return mlir::getElementTypeOrSelf(*getODSOperands(2).begin());
}

bool ResourceScatterMaxOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "Tindices") return true;
  if (name == "dtype") return true;
 return false;
}

::mlir::DictionaryAttr ResourceScatterMaxOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("Tindices", ctx),
::mlir::TypeAttr::get(Tindices())},
    {::mlir::Identifier::get("dtype", ctx),
::mlir::TypeAttr::get(dtype())}
    }, ctx);
}

void ResourceScatterMaxOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value resource, ::mlir::Value indices, ::mlir::Value updates) {
  odsState.addOperands(resource);
  odsState.addOperands(indices);
  odsState.addOperands(updates);
}

void ResourceScatterMaxOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value resource, ::mlir::Value indices, ::mlir::Value updates) {
  odsState.addOperands(resource);
  odsState.addOperands(indices);
  odsState.addOperands(updates);
  assert(resultTypes.size() == 0u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void ResourceScatterMaxOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 3u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 0u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult ResourceScatterMaxOp::verify() {
  if (failed(ResourceScatterMaxOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::ResourceType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::ResourceRefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of resource values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of 32/64-bit signed integer values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup2 = getODSOperands(2);
    for (::mlir::Value v : valueGroup2) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of bfloat16 or 128-bit complex or 64-bit complex or 16-bit float or 32-bit float or 64-bit float or 16-bit integer or 32-bit integer or 64-bit integer or 8-bit integer or 32-bit quantized integer or 8-bit quantized integer or 8-bit quantized unsigned integer or 16-bit unsigned integer or 32-bit unsigned integer or 64-bit unsigned integer or 8-bit unsigned integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
  }
  return ::mlir::success();
}

void ResourceScatterMaxOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
  for (::mlir::Value value : getODSOperands(0))
    effects.emplace_back(MemoryEffects::Read::get(), value, ::mlir::TF::ResourceEffects::Variable::get());
  for (::mlir::Value value : getODSOperands(0))
    effects.emplace_back(MemoryEffects::Write::get(), value, ::mlir::TF::ResourceEffects::Variable::get());
}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::ResourceScatterMinOp definitions
//===----------------------------------------------------------------------===//

ResourceScatterMinOpAdaptor::ResourceScatterMinOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

ResourceScatterMinOpAdaptor::ResourceScatterMinOpAdaptor(ResourceScatterMinOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> ResourceScatterMinOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange ResourceScatterMinOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value ResourceScatterMinOpAdaptor::resource() {
  return *getODSOperands(0).begin();
}

::mlir::Value ResourceScatterMinOpAdaptor::indices() {
  return *getODSOperands(1).begin();
}

::mlir::Value ResourceScatterMinOpAdaptor::updates() {
  return *getODSOperands(2).begin();
}

::mlir::LogicalResult ResourceScatterMinOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

::llvm::StringRef ResourceScatterMinOp::getOperationName() {
  return "tf.ResourceScatterMin";
}

std::pair<unsigned, unsigned> ResourceScatterMinOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range ResourceScatterMinOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value ResourceScatterMinOp::resource() {
  return *getODSOperands(0).begin();
}

::mlir::Value ResourceScatterMinOp::indices() {
  return *getODSOperands(1).begin();
}

::mlir::Value ResourceScatterMinOp::updates() {
  return *getODSOperands(2).begin();
}

::mlir::MutableOperandRange ResourceScatterMinOp::resourceMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange ResourceScatterMinOp::indicesMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange ResourceScatterMinOp::updatesMutable() {
  auto range = getODSOperandIndexAndLength(2);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> ResourceScatterMinOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range ResourceScatterMinOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

Type ResourceScatterMinOp::Tindices() {
  return mlir::getElementTypeOrSelf(*getODSOperands(1).begin());
}

Type ResourceScatterMinOp::dtype() {
  return mlir::getElementTypeOrSelf(*getODSOperands(2).begin());
}

bool ResourceScatterMinOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "Tindices") return true;
  if (name == "dtype") return true;
 return false;
}

::mlir::DictionaryAttr ResourceScatterMinOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("Tindices", ctx),
::mlir::TypeAttr::get(Tindices())},
    {::mlir::Identifier::get("dtype", ctx),
::mlir::TypeAttr::get(dtype())}
    }, ctx);
}

void ResourceScatterMinOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value resource, ::mlir::Value indices, ::mlir::Value updates) {
  odsState.addOperands(resource);
  odsState.addOperands(indices);
  odsState.addOperands(updates);
}

void ResourceScatterMinOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value resource, ::mlir::Value indices, ::mlir::Value updates) {
  odsState.addOperands(resource);
  odsState.addOperands(indices);
  odsState.addOperands(updates);
  assert(resultTypes.size() == 0u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void ResourceScatterMinOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 3u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 0u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult ResourceScatterMinOp::verify() {
  if (failed(ResourceScatterMinOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::ResourceType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::ResourceRefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of resource values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of 32/64-bit signed integer values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup2 = getODSOperands(2);
    for (::mlir::Value v : valueGroup2) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of bfloat16 or 128-bit complex or 64-bit complex or 16-bit float or 32-bit float or 64-bit float or 16-bit integer or 32-bit integer or 64-bit integer or 8-bit integer or 32-bit quantized integer or 8-bit quantized integer or 8-bit quantized unsigned integer or 16-bit unsigned integer or 32-bit unsigned integer or 64-bit unsigned integer or 8-bit unsigned integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
  }
  return ::mlir::success();
}

void ResourceScatterMinOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
  for (::mlir::Value value : getODSOperands(0))
    effects.emplace_back(MemoryEffects::Read::get(), value, ::mlir::TF::ResourceEffects::Variable::get());
  for (::mlir::Value value : getODSOperands(0))
    effects.emplace_back(MemoryEffects::Write::get(), value, ::mlir::TF::ResourceEffects::Variable::get());
}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::ResourceScatterMulOp definitions
//===----------------------------------------------------------------------===//

ResourceScatterMulOpAdaptor::ResourceScatterMulOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

ResourceScatterMulOpAdaptor::ResourceScatterMulOpAdaptor(ResourceScatterMulOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> ResourceScatterMulOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange ResourceScatterMulOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value ResourceScatterMulOpAdaptor::resource() {
  return *getODSOperands(0).begin();
}

::mlir::Value ResourceScatterMulOpAdaptor::indices() {
  return *getODSOperands(1).begin();
}

::mlir::Value ResourceScatterMulOpAdaptor::updates() {
  return *getODSOperands(2).begin();
}

::mlir::LogicalResult ResourceScatterMulOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

::llvm::StringRef ResourceScatterMulOp::getOperationName() {
  return "tf.ResourceScatterMul";
}

std::pair<unsigned, unsigned> ResourceScatterMulOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range ResourceScatterMulOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value ResourceScatterMulOp::resource() {
  return *getODSOperands(0).begin();
}

::mlir::Value ResourceScatterMulOp::indices() {
  return *getODSOperands(1).begin();
}

::mlir::Value ResourceScatterMulOp::updates() {
  return *getODSOperands(2).begin();
}

::mlir::MutableOperandRange ResourceScatterMulOp::resourceMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange ResourceScatterMulOp::indicesMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange ResourceScatterMulOp::updatesMutable() {
  auto range = getODSOperandIndexAndLength(2);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> ResourceScatterMulOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range ResourceScatterMulOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

Type ResourceScatterMulOp::Tindices() {
  return mlir::getElementTypeOrSelf(*getODSOperands(1).begin());
}

Type ResourceScatterMulOp::dtype() {
  return mlir::getElementTypeOrSelf(*getODSOperands(2).begin());
}

bool ResourceScatterMulOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "Tindices") return true;
  if (name == "dtype") return true;
 return false;
}

::mlir::DictionaryAttr ResourceScatterMulOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("Tindices", ctx),
::mlir::TypeAttr::get(Tindices())},
    {::mlir::Identifier::get("dtype", ctx),
::mlir::TypeAttr::get(dtype())}
    }, ctx);
}

void ResourceScatterMulOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value resource, ::mlir::Value indices, ::mlir::Value updates) {
  odsState.addOperands(resource);
  odsState.addOperands(indices);
  odsState.addOperands(updates);
}

void ResourceScatterMulOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value resource, ::mlir::Value indices, ::mlir::Value updates) {
  odsState.addOperands(resource);
  odsState.addOperands(indices);
  odsState.addOperands(updates);
  assert(resultTypes.size() == 0u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void ResourceScatterMulOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 3u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 0u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult ResourceScatterMulOp::verify() {
  if (failed(ResourceScatterMulOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::ResourceType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::ResourceRefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of resource values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of 32/64-bit signed integer values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup2 = getODSOperands(2);
    for (::mlir::Value v : valueGroup2) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of bfloat16 or 128-bit complex or 64-bit complex or 16-bit float or 32-bit float or 64-bit float or 16-bit integer or 32-bit integer or 64-bit integer or 8-bit integer or 32-bit quantized integer or 8-bit quantized integer or 8-bit quantized unsigned integer or 16-bit unsigned integer or 32-bit unsigned integer or 64-bit unsigned integer or 8-bit unsigned integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
  }
  return ::mlir::success();
}

void ResourceScatterMulOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
  for (::mlir::Value value : getODSOperands(0))
    effects.emplace_back(MemoryEffects::Read::get(), value, ::mlir::TF::ResourceEffects::Variable::get());
  for (::mlir::Value value : getODSOperands(0))
    effects.emplace_back(MemoryEffects::Write::get(), value, ::mlir::TF::ResourceEffects::Variable::get());
}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::ResourceScatterNdAddOp definitions
//===----------------------------------------------------------------------===//

ResourceScatterNdAddOpAdaptor::ResourceScatterNdAddOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

ResourceScatterNdAddOpAdaptor::ResourceScatterNdAddOpAdaptor(ResourceScatterNdAddOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> ResourceScatterNdAddOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange ResourceScatterNdAddOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value ResourceScatterNdAddOpAdaptor::ref() {
  return *getODSOperands(0).begin();
}

::mlir::Value ResourceScatterNdAddOpAdaptor::indices() {
  return *getODSOperands(1).begin();
}

::mlir::Value ResourceScatterNdAddOpAdaptor::updates() {
  return *getODSOperands(2).begin();
}

::mlir::BoolAttr ResourceScatterNdAddOpAdaptor::use_locking() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::BoolAttr attr = odsAttrs.get("use_locking").dyn_cast_or_null<::mlir::BoolAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getBoolAttr(true);
  return attr;
}

::mlir::LogicalResult ResourceScatterNdAddOpAdaptor::verify(::mlir::Location loc) {
  {
  auto tblgen_use_locking = odsAttrs.get("use_locking");
  if (tblgen_use_locking) {
    if (!((tblgen_use_locking.isa<::mlir::BoolAttr>()))) return emitError(loc, "'tf.ResourceScatterNdAdd' op ""attribute 'use_locking' failed to satisfy constraint: bool attribute");
  }
  }
  return ::mlir::success();
}

::llvm::StringRef ResourceScatterNdAddOp::getOperationName() {
  return "tf.ResourceScatterNdAdd";
}

std::pair<unsigned, unsigned> ResourceScatterNdAddOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range ResourceScatterNdAddOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value ResourceScatterNdAddOp::ref() {
  return *getODSOperands(0).begin();
}

::mlir::Value ResourceScatterNdAddOp::indices() {
  return *getODSOperands(1).begin();
}

::mlir::Value ResourceScatterNdAddOp::updates() {
  return *getODSOperands(2).begin();
}

::mlir::MutableOperandRange ResourceScatterNdAddOp::refMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange ResourceScatterNdAddOp::indicesMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange ResourceScatterNdAddOp::updatesMutable() {
  auto range = getODSOperandIndexAndLength(2);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> ResourceScatterNdAddOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range ResourceScatterNdAddOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::BoolAttr ResourceScatterNdAddOp::use_lockingAttr() {
  return this->getAttr("use_locking").dyn_cast_or_null<::mlir::BoolAttr>();
}

bool ResourceScatterNdAddOp::use_locking() {
  auto attr = use_lockingAttr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getBoolAttr(true).getValue();
  return attr.getValue();
}

Type ResourceScatterNdAddOp::Tindices() {
  return mlir::getElementTypeOrSelf(*getODSOperands(1).begin());
}

Type ResourceScatterNdAddOp::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(2).begin());
}

bool ResourceScatterNdAddOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "Tindices") return true;
  if (name == "T") return true;
 return false;
}

::mlir::DictionaryAttr ResourceScatterNdAddOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("Tindices", ctx),
::mlir::TypeAttr::get(Tindices())},
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())}
    }, ctx);
}

void ResourceScatterNdAddOp::use_lockingAttr(::mlir::BoolAttr attr) {
  this->getOperation()->setAttr("use_locking", attr);
}

void ResourceScatterNdAddOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value ref, ::mlir::Value indices, ::mlir::Value updates, ::mlir::BoolAttr use_locking) {
  odsState.addOperands(ref);
  odsState.addOperands(indices);
  odsState.addOperands(updates);
  odsState.addAttribute("use_locking", use_locking);
}

void ResourceScatterNdAddOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value ref, ::mlir::Value indices, ::mlir::Value updates, ::mlir::BoolAttr use_locking) {
  odsState.addOperands(ref);
  odsState.addOperands(indices);
  odsState.addOperands(updates);
  odsState.addAttribute("use_locking", use_locking);
  assert(resultTypes.size() == 0u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void ResourceScatterNdAddOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value ref, ::mlir::Value indices, ::mlir::Value updates, bool use_locking) {
  odsState.addOperands(ref);
  odsState.addOperands(indices);
  odsState.addOperands(updates);
  odsState.addAttribute("use_locking", odsBuilder.getBoolAttr(use_locking));
}

void ResourceScatterNdAddOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value ref, ::mlir::Value indices, ::mlir::Value updates, bool use_locking) {
  odsState.addOperands(ref);
  odsState.addOperands(indices);
  odsState.addOperands(updates);
  odsState.addAttribute("use_locking", odsBuilder.getBoolAttr(use_locking));
  assert(resultTypes.size() == 0u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void ResourceScatterNdAddOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 3u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 0u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult ResourceScatterNdAddOp::verify() {
  if (failed(ResourceScatterNdAddOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::ResourceType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::ResourceRefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of resource values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of 32/64-bit signed integer values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup2 = getODSOperands(2);
    for (::mlir::Value v : valueGroup2) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>())))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::TensorFlowType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of tf.dtype values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
  }
  return ::mlir::success();
}

void ResourceScatterNdAddOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
  for (::mlir::Value value : getODSOperands(0))
    effects.emplace_back(MemoryEffects::Read::get(), value, ::mlir::TF::ResourceEffects::Variable::get());
  for (::mlir::Value value : getODSOperands(0))
    effects.emplace_back(MemoryEffects::Write::get(), value, ::mlir::TF::ResourceEffects::Variable::get());
}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::ResourceScatterNdSubOp definitions
//===----------------------------------------------------------------------===//

ResourceScatterNdSubOpAdaptor::ResourceScatterNdSubOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

ResourceScatterNdSubOpAdaptor::ResourceScatterNdSubOpAdaptor(ResourceScatterNdSubOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> ResourceScatterNdSubOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange ResourceScatterNdSubOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value ResourceScatterNdSubOpAdaptor::ref() {
  return *getODSOperands(0).begin();
}

::mlir::Value ResourceScatterNdSubOpAdaptor::indices() {
  return *getODSOperands(1).begin();
}

::mlir::Value ResourceScatterNdSubOpAdaptor::updates() {
  return *getODSOperands(2).begin();
}

::mlir::BoolAttr ResourceScatterNdSubOpAdaptor::use_locking() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::BoolAttr attr = odsAttrs.get("use_locking").dyn_cast_or_null<::mlir::BoolAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getBoolAttr(true);
  return attr;
}

::mlir::LogicalResult ResourceScatterNdSubOpAdaptor::verify(::mlir::Location loc) {
  {
  auto tblgen_use_locking = odsAttrs.get("use_locking");
  if (tblgen_use_locking) {
    if (!((tblgen_use_locking.isa<::mlir::BoolAttr>()))) return emitError(loc, "'tf.ResourceScatterNdSub' op ""attribute 'use_locking' failed to satisfy constraint: bool attribute");
  }
  }
  return ::mlir::success();
}

::llvm::StringRef ResourceScatterNdSubOp::getOperationName() {
  return "tf.ResourceScatterNdSub";
}

std::pair<unsigned, unsigned> ResourceScatterNdSubOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range ResourceScatterNdSubOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value ResourceScatterNdSubOp::ref() {
  return *getODSOperands(0).begin();
}

::mlir::Value ResourceScatterNdSubOp::indices() {
  return *getODSOperands(1).begin();
}

::mlir::Value ResourceScatterNdSubOp::updates() {
  return *getODSOperands(2).begin();
}

::mlir::MutableOperandRange ResourceScatterNdSubOp::refMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange ResourceScatterNdSubOp::indicesMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange ResourceScatterNdSubOp::updatesMutable() {
  auto range = getODSOperandIndexAndLength(2);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> ResourceScatterNdSubOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range ResourceScatterNdSubOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::BoolAttr ResourceScatterNdSubOp::use_lockingAttr() {
  return this->getAttr("use_locking").dyn_cast_or_null<::mlir::BoolAttr>();
}

bool ResourceScatterNdSubOp::use_locking() {
  auto attr = use_lockingAttr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getBoolAttr(true).getValue();
  return attr.getValue();
}

Type ResourceScatterNdSubOp::Tindices() {
  return mlir::getElementTypeOrSelf(*getODSOperands(1).begin());
}

Type ResourceScatterNdSubOp::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(2).begin());
}

bool ResourceScatterNdSubOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "Tindices") return true;
  if (name == "T") return true;
 return false;
}

::mlir::DictionaryAttr ResourceScatterNdSubOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("Tindices", ctx),
::mlir::TypeAttr::get(Tindices())},
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())}
    }, ctx);
}

void ResourceScatterNdSubOp::use_lockingAttr(::mlir::BoolAttr attr) {
  this->getOperation()->setAttr("use_locking", attr);
}

void ResourceScatterNdSubOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value ref, ::mlir::Value indices, ::mlir::Value updates, ::mlir::BoolAttr use_locking) {
  odsState.addOperands(ref);
  odsState.addOperands(indices);
  odsState.addOperands(updates);
  odsState.addAttribute("use_locking", use_locking);
}

void ResourceScatterNdSubOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value ref, ::mlir::Value indices, ::mlir::Value updates, ::mlir::BoolAttr use_locking) {
  odsState.addOperands(ref);
  odsState.addOperands(indices);
  odsState.addOperands(updates);
  odsState.addAttribute("use_locking", use_locking);
  assert(resultTypes.size() == 0u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void ResourceScatterNdSubOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value ref, ::mlir::Value indices, ::mlir::Value updates, bool use_locking) {
  odsState.addOperands(ref);
  odsState.addOperands(indices);
  odsState.addOperands(updates);
  odsState.addAttribute("use_locking", odsBuilder.getBoolAttr(use_locking));
}

void ResourceScatterNdSubOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value ref, ::mlir::Value indices, ::mlir::Value updates, bool use_locking) {
  odsState.addOperands(ref);
  odsState.addOperands(indices);
  odsState.addOperands(updates);
  odsState.addAttribute("use_locking", odsBuilder.getBoolAttr(use_locking));
  assert(resultTypes.size() == 0u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void ResourceScatterNdSubOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 3u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 0u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult ResourceScatterNdSubOp::verify() {
  if (failed(ResourceScatterNdSubOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::ResourceType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::ResourceRefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of resource values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of 32/64-bit signed integer values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup2 = getODSOperands(2);
    for (::mlir::Value v : valueGroup2) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>())))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::TensorFlowType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of tf.dtype values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
  }
  return ::mlir::success();
}

void ResourceScatterNdSubOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
  for (::mlir::Value value : getODSOperands(0))
    effects.emplace_back(MemoryEffects::Read::get(), value, ::mlir::TF::ResourceEffects::Variable::get());
  for (::mlir::Value value : getODSOperands(0))
    effects.emplace_back(MemoryEffects::Write::get(), value, ::mlir::TF::ResourceEffects::Variable::get());
}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::ResourceScatterNdUpdateOp definitions
//===----------------------------------------------------------------------===//

ResourceScatterNdUpdateOpAdaptor::ResourceScatterNdUpdateOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

ResourceScatterNdUpdateOpAdaptor::ResourceScatterNdUpdateOpAdaptor(ResourceScatterNdUpdateOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> ResourceScatterNdUpdateOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange ResourceScatterNdUpdateOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value ResourceScatterNdUpdateOpAdaptor::ref() {
  return *getODSOperands(0).begin();
}

::mlir::Value ResourceScatterNdUpdateOpAdaptor::indices() {
  return *getODSOperands(1).begin();
}

::mlir::Value ResourceScatterNdUpdateOpAdaptor::updates() {
  return *getODSOperands(2).begin();
}

::mlir::BoolAttr ResourceScatterNdUpdateOpAdaptor::use_locking() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::BoolAttr attr = odsAttrs.get("use_locking").dyn_cast_or_null<::mlir::BoolAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getBoolAttr(true);
  return attr;
}

::mlir::LogicalResult ResourceScatterNdUpdateOpAdaptor::verify(::mlir::Location loc) {
  {
  auto tblgen_use_locking = odsAttrs.get("use_locking");
  if (tblgen_use_locking) {
    if (!((tblgen_use_locking.isa<::mlir::BoolAttr>()))) return emitError(loc, "'tf.ResourceScatterNdUpdate' op ""attribute 'use_locking' failed to satisfy constraint: bool attribute");
  }
  }
  return ::mlir::success();
}

::llvm::StringRef ResourceScatterNdUpdateOp::getOperationName() {
  return "tf.ResourceScatterNdUpdate";
}

std::pair<unsigned, unsigned> ResourceScatterNdUpdateOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range ResourceScatterNdUpdateOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value ResourceScatterNdUpdateOp::ref() {
  return *getODSOperands(0).begin();
}

::mlir::Value ResourceScatterNdUpdateOp::indices() {
  return *getODSOperands(1).begin();
}

::mlir::Value ResourceScatterNdUpdateOp::updates() {
  return *getODSOperands(2).begin();
}

::mlir::MutableOperandRange ResourceScatterNdUpdateOp::refMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange ResourceScatterNdUpdateOp::indicesMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange ResourceScatterNdUpdateOp::updatesMutable() {
  auto range = getODSOperandIndexAndLength(2);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> ResourceScatterNdUpdateOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range ResourceScatterNdUpdateOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::BoolAttr ResourceScatterNdUpdateOp::use_lockingAttr() {
  return this->getAttr("use_locking").dyn_cast_or_null<::mlir::BoolAttr>();
}

bool ResourceScatterNdUpdateOp::use_locking() {
  auto attr = use_lockingAttr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getBoolAttr(true).getValue();
  return attr.getValue();
}

Type ResourceScatterNdUpdateOp::Tindices() {
  return mlir::getElementTypeOrSelf(*getODSOperands(1).begin());
}

Type ResourceScatterNdUpdateOp::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(2).begin());
}

bool ResourceScatterNdUpdateOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "Tindices") return true;
  if (name == "T") return true;
 return false;
}

::mlir::DictionaryAttr ResourceScatterNdUpdateOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("Tindices", ctx),
::mlir::TypeAttr::get(Tindices())},
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())}
    }, ctx);
}

void ResourceScatterNdUpdateOp::use_lockingAttr(::mlir::BoolAttr attr) {
  this->getOperation()->setAttr("use_locking", attr);
}

void ResourceScatterNdUpdateOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value ref, ::mlir::Value indices, ::mlir::Value updates, ::mlir::BoolAttr use_locking) {
  odsState.addOperands(ref);
  odsState.addOperands(indices);
  odsState.addOperands(updates);
  odsState.addAttribute("use_locking", use_locking);
}

void ResourceScatterNdUpdateOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value ref, ::mlir::Value indices, ::mlir::Value updates, ::mlir::BoolAttr use_locking) {
  odsState.addOperands(ref);
  odsState.addOperands(indices);
  odsState.addOperands(updates);
  odsState.addAttribute("use_locking", use_locking);
  assert(resultTypes.size() == 0u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void ResourceScatterNdUpdateOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value ref, ::mlir::Value indices, ::mlir::Value updates, bool use_locking) {
  odsState.addOperands(ref);
  odsState.addOperands(indices);
  odsState.addOperands(updates);
  odsState.addAttribute("use_locking", odsBuilder.getBoolAttr(use_locking));
}

void ResourceScatterNdUpdateOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value ref, ::mlir::Value indices, ::mlir::Value updates, bool use_locking) {
  odsState.addOperands(ref);
  odsState.addOperands(indices);
  odsState.addOperands(updates);
  odsState.addAttribute("use_locking", odsBuilder.getBoolAttr(use_locking));
  assert(resultTypes.size() == 0u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void ResourceScatterNdUpdateOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 3u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 0u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult ResourceScatterNdUpdateOp::verify() {
  if (failed(ResourceScatterNdUpdateOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::ResourceType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::ResourceRefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of resource values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of 32/64-bit signed integer values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup2 = getODSOperands(2);
    for (::mlir::Value v : valueGroup2) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>())))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::TensorFlowType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of tf.dtype values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
  }
  return ::mlir::success();
}

void ResourceScatterNdUpdateOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
  for (::mlir::Value value : getODSOperands(0))
    effects.emplace_back(MemoryEffects::Read::get(), value, ::mlir::TF::ResourceEffects::Variable::get());
  for (::mlir::Value value : getODSOperands(0))
    effects.emplace_back(MemoryEffects::Write::get(), value, ::mlir::TF::ResourceEffects::Variable::get());
}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::ResourceScatterSubOp definitions
//===----------------------------------------------------------------------===//

ResourceScatterSubOpAdaptor::ResourceScatterSubOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

ResourceScatterSubOpAdaptor::ResourceScatterSubOpAdaptor(ResourceScatterSubOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> ResourceScatterSubOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange ResourceScatterSubOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value ResourceScatterSubOpAdaptor::resource() {
  return *getODSOperands(0).begin();
}

::mlir::Value ResourceScatterSubOpAdaptor::indices() {
  return *getODSOperands(1).begin();
}

::mlir::Value ResourceScatterSubOpAdaptor::updates() {
  return *getODSOperands(2).begin();
}

::mlir::LogicalResult ResourceScatterSubOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

::llvm::StringRef ResourceScatterSubOp::getOperationName() {
  return "tf.ResourceScatterSub";
}

std::pair<unsigned, unsigned> ResourceScatterSubOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range ResourceScatterSubOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value ResourceScatterSubOp::resource() {
  return *getODSOperands(0).begin();
}

::mlir::Value ResourceScatterSubOp::indices() {
  return *getODSOperands(1).begin();
}

::mlir::Value ResourceScatterSubOp::updates() {
  return *getODSOperands(2).begin();
}

::mlir::MutableOperandRange ResourceScatterSubOp::resourceMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange ResourceScatterSubOp::indicesMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange ResourceScatterSubOp::updatesMutable() {
  auto range = getODSOperandIndexAndLength(2);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> ResourceScatterSubOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range ResourceScatterSubOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

Type ResourceScatterSubOp::Tindices() {
  return mlir::getElementTypeOrSelf(*getODSOperands(1).begin());
}

Type ResourceScatterSubOp::dtype() {
  return mlir::getElementTypeOrSelf(*getODSOperands(2).begin());
}

bool ResourceScatterSubOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "Tindices") return true;
  if (name == "dtype") return true;
 return false;
}

::mlir::DictionaryAttr ResourceScatterSubOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("Tindices", ctx),
::mlir::TypeAttr::get(Tindices())},
    {::mlir::Identifier::get("dtype", ctx),
::mlir::TypeAttr::get(dtype())}
    }, ctx);
}

void ResourceScatterSubOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value resource, ::mlir::Value indices, ::mlir::Value updates) {
  odsState.addOperands(resource);
  odsState.addOperands(indices);
  odsState.addOperands(updates);
}

void ResourceScatterSubOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value resource, ::mlir::Value indices, ::mlir::Value updates) {
  odsState.addOperands(resource);
  odsState.addOperands(indices);
  odsState.addOperands(updates);
  assert(resultTypes.size() == 0u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void ResourceScatterSubOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 3u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 0u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult ResourceScatterSubOp::verify() {
  if (failed(ResourceScatterSubOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::ResourceType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::ResourceRefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of resource values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of 32/64-bit signed integer values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup2 = getODSOperands(2);
    for (::mlir::Value v : valueGroup2) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of bfloat16 or 128-bit complex or 64-bit complex or 16-bit float or 32-bit float or 64-bit float or 16-bit integer or 32-bit integer or 64-bit integer or 8-bit integer or 32-bit quantized integer or 8-bit quantized integer or 8-bit quantized unsigned integer or 16-bit unsigned integer or 32-bit unsigned integer or 64-bit unsigned integer or 8-bit unsigned integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
  }
  return ::mlir::success();
}

void ResourceScatterSubOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
  for (::mlir::Value value : getODSOperands(0))
    effects.emplace_back(MemoryEffects::Read::get(), value, ::mlir::TF::ResourceEffects::Variable::get());
  for (::mlir::Value value : getODSOperands(0))
    effects.emplace_back(MemoryEffects::Write::get(), value, ::mlir::TF::ResourceEffects::Variable::get());
}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::ResourceScatterUpdateOp definitions
//===----------------------------------------------------------------------===//

ResourceScatterUpdateOpAdaptor::ResourceScatterUpdateOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

ResourceScatterUpdateOpAdaptor::ResourceScatterUpdateOpAdaptor(ResourceScatterUpdateOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> ResourceScatterUpdateOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange ResourceScatterUpdateOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value ResourceScatterUpdateOpAdaptor::resource() {
  return *getODSOperands(0).begin();
}

::mlir::Value ResourceScatterUpdateOpAdaptor::indices() {
  return *getODSOperands(1).begin();
}

::mlir::Value ResourceScatterUpdateOpAdaptor::updates() {
  return *getODSOperands(2).begin();
}

::mlir::LogicalResult ResourceScatterUpdateOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

::llvm::StringRef ResourceScatterUpdateOp::getOperationName() {
  return "tf.ResourceScatterUpdate";
}

std::pair<unsigned, unsigned> ResourceScatterUpdateOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range ResourceScatterUpdateOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value ResourceScatterUpdateOp::resource() {
  return *getODSOperands(0).begin();
}

::mlir::Value ResourceScatterUpdateOp::indices() {
  return *getODSOperands(1).begin();
}

::mlir::Value ResourceScatterUpdateOp::updates() {
  return *getODSOperands(2).begin();
}

::mlir::MutableOperandRange ResourceScatterUpdateOp::resourceMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange ResourceScatterUpdateOp::indicesMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange ResourceScatterUpdateOp::updatesMutable() {
  auto range = getODSOperandIndexAndLength(2);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> ResourceScatterUpdateOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range ResourceScatterUpdateOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

Type ResourceScatterUpdateOp::Tindices() {
  return mlir::getElementTypeOrSelf(*getODSOperands(1).begin());
}

Type ResourceScatterUpdateOp::dtype() {
  return mlir::getElementTypeOrSelf(*getODSOperands(2).begin());
}

bool ResourceScatterUpdateOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "Tindices") return true;
  if (name == "dtype") return true;
 return false;
}

::mlir::DictionaryAttr ResourceScatterUpdateOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("Tindices", ctx),
::mlir::TypeAttr::get(Tindices())},
    {::mlir::Identifier::get("dtype", ctx),
::mlir::TypeAttr::get(dtype())}
    }, ctx);
}

void ResourceScatterUpdateOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value resource, ::mlir::Value indices, ::mlir::Value updates) {
  odsState.addOperands(resource);
  odsState.addOperands(indices);
  odsState.addOperands(updates);
}

void ResourceScatterUpdateOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value resource, ::mlir::Value indices, ::mlir::Value updates) {
  odsState.addOperands(resource);
  odsState.addOperands(indices);
  odsState.addOperands(updates);
  assert(resultTypes.size() == 0u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void ResourceScatterUpdateOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 3u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 0u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult ResourceScatterUpdateOp::verify() {
  if (failed(ResourceScatterUpdateOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::ResourceType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::ResourceRefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of resource values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of 32/64-bit signed integer values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup2 = getODSOperands(2);
    for (::mlir::Value v : valueGroup2) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>())))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::TensorFlowType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of tf.dtype values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
  }
  return ::mlir::success();
}

void ResourceScatterUpdateOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
  for (::mlir::Value value : getODSOperands(0))
    effects.emplace_back(MemoryEffects::Read::get(), value, ::mlir::TF::ResourceEffects::Variable::get());
  for (::mlir::Value value : getODSOperands(0))
    effects.emplace_back(MemoryEffects::Write::get(), value, ::mlir::TF::ResourceEffects::Variable::get());
}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::ResourceStridedSliceAssignOp definitions
//===----------------------------------------------------------------------===//

ResourceStridedSliceAssignOpAdaptor::ResourceStridedSliceAssignOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

ResourceStridedSliceAssignOpAdaptor::ResourceStridedSliceAssignOpAdaptor(ResourceStridedSliceAssignOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> ResourceStridedSliceAssignOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange ResourceStridedSliceAssignOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value ResourceStridedSliceAssignOpAdaptor::ref() {
  return *getODSOperands(0).begin();
}

::mlir::Value ResourceStridedSliceAssignOpAdaptor::begin() {
  return *getODSOperands(1).begin();
}

::mlir::Value ResourceStridedSliceAssignOpAdaptor::end() {
  return *getODSOperands(2).begin();
}

::mlir::Value ResourceStridedSliceAssignOpAdaptor::strides() {
  return *getODSOperands(3).begin();
}

::mlir::Value ResourceStridedSliceAssignOpAdaptor::value() {
  return *getODSOperands(4).begin();
}

::mlir::IntegerAttr ResourceStridedSliceAssignOpAdaptor::begin_mask() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::IntegerAttr attr = odsAttrs.get("begin_mask").dyn_cast_or_null<::mlir::IntegerAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getIntegerAttr(::mlir::Builder(odsAttrs.getContext()).getIntegerType(64), 0);
  return attr;
}

::mlir::IntegerAttr ResourceStridedSliceAssignOpAdaptor::end_mask() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::IntegerAttr attr = odsAttrs.get("end_mask").dyn_cast_or_null<::mlir::IntegerAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getIntegerAttr(::mlir::Builder(odsAttrs.getContext()).getIntegerType(64), 0);
  return attr;
}

::mlir::IntegerAttr ResourceStridedSliceAssignOpAdaptor::ellipsis_mask() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::IntegerAttr attr = odsAttrs.get("ellipsis_mask").dyn_cast_or_null<::mlir::IntegerAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getIntegerAttr(::mlir::Builder(odsAttrs.getContext()).getIntegerType(64), 0);
  return attr;
}

::mlir::IntegerAttr ResourceStridedSliceAssignOpAdaptor::new_axis_mask() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::IntegerAttr attr = odsAttrs.get("new_axis_mask").dyn_cast_or_null<::mlir::IntegerAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getIntegerAttr(::mlir::Builder(odsAttrs.getContext()).getIntegerType(64), 0);
  return attr;
}

::mlir::IntegerAttr ResourceStridedSliceAssignOpAdaptor::shrink_axis_mask() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::IntegerAttr attr = odsAttrs.get("shrink_axis_mask").dyn_cast_or_null<::mlir::IntegerAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getIntegerAttr(::mlir::Builder(odsAttrs.getContext()).getIntegerType(64), 0);
  return attr;
}

::mlir::LogicalResult ResourceStridedSliceAssignOpAdaptor::verify(::mlir::Location loc) {
  {
  auto tblgen_begin_mask = odsAttrs.get("begin_mask");
  if (tblgen_begin_mask) {
    if (!(((tblgen_begin_mask.isa<::mlir::IntegerAttr>())) && ((tblgen_begin_mask.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(64))))) return emitError(loc, "'tf.ResourceStridedSliceAssign' op ""attribute 'begin_mask' failed to satisfy constraint: 64-bit signless integer attribute");
  }
  }
  {
  auto tblgen_end_mask = odsAttrs.get("end_mask");
  if (tblgen_end_mask) {
    if (!(((tblgen_end_mask.isa<::mlir::IntegerAttr>())) && ((tblgen_end_mask.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(64))))) return emitError(loc, "'tf.ResourceStridedSliceAssign' op ""attribute 'end_mask' failed to satisfy constraint: 64-bit signless integer attribute");
  }
  }
  {
  auto tblgen_ellipsis_mask = odsAttrs.get("ellipsis_mask");
  if (tblgen_ellipsis_mask) {
    if (!(((tblgen_ellipsis_mask.isa<::mlir::IntegerAttr>())) && ((tblgen_ellipsis_mask.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(64))))) return emitError(loc, "'tf.ResourceStridedSliceAssign' op ""attribute 'ellipsis_mask' failed to satisfy constraint: 64-bit signless integer attribute");
  }
  }
  {
  auto tblgen_new_axis_mask = odsAttrs.get("new_axis_mask");
  if (tblgen_new_axis_mask) {
    if (!(((tblgen_new_axis_mask.isa<::mlir::IntegerAttr>())) && ((tblgen_new_axis_mask.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(64))))) return emitError(loc, "'tf.ResourceStridedSliceAssign' op ""attribute 'new_axis_mask' failed to satisfy constraint: 64-bit signless integer attribute");
  }
  }
  {
  auto tblgen_shrink_axis_mask = odsAttrs.get("shrink_axis_mask");
  if (tblgen_shrink_axis_mask) {
    if (!(((tblgen_shrink_axis_mask.isa<::mlir::IntegerAttr>())) && ((tblgen_shrink_axis_mask.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(64))))) return emitError(loc, "'tf.ResourceStridedSliceAssign' op ""attribute 'shrink_axis_mask' failed to satisfy constraint: 64-bit signless integer attribute");
  }
  }
  return ::mlir::success();
}

::llvm::StringRef ResourceStridedSliceAssignOp::getOperationName() {
  return "tf.ResourceStridedSliceAssign";
}

std::pair<unsigned, unsigned> ResourceStridedSliceAssignOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range ResourceStridedSliceAssignOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value ResourceStridedSliceAssignOp::ref() {
  return *getODSOperands(0).begin();
}

::mlir::Value ResourceStridedSliceAssignOp::begin() {
  return *getODSOperands(1).begin();
}

::mlir::Value ResourceStridedSliceAssignOp::end() {
  return *getODSOperands(2).begin();
}

::mlir::Value ResourceStridedSliceAssignOp::strides() {
  return *getODSOperands(3).begin();
}

::mlir::Value ResourceStridedSliceAssignOp::value() {
  return *getODSOperands(4).begin();
}

::mlir::MutableOperandRange ResourceStridedSliceAssignOp::refMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange ResourceStridedSliceAssignOp::beginMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange ResourceStridedSliceAssignOp::endMutable() {
  auto range = getODSOperandIndexAndLength(2);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange ResourceStridedSliceAssignOp::stridesMutable() {
  auto range = getODSOperandIndexAndLength(3);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange ResourceStridedSliceAssignOp::valueMutable() {
  auto range = getODSOperandIndexAndLength(4);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> ResourceStridedSliceAssignOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range ResourceStridedSliceAssignOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::IntegerAttr ResourceStridedSliceAssignOp::begin_maskAttr() {
  return this->getAttr("begin_mask").dyn_cast_or_null<::mlir::IntegerAttr>();
}

uint64_t ResourceStridedSliceAssignOp::begin_mask() {
  auto attr = begin_maskAttr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getIntegerAttr(::mlir::Builder(this->getContext()).getIntegerType(64), 0).getValue().getZExtValue();
  return attr.getValue().getZExtValue();
}

::mlir::IntegerAttr ResourceStridedSliceAssignOp::end_maskAttr() {
  return this->getAttr("end_mask").dyn_cast_or_null<::mlir::IntegerAttr>();
}

uint64_t ResourceStridedSliceAssignOp::end_mask() {
  auto attr = end_maskAttr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getIntegerAttr(::mlir::Builder(this->getContext()).getIntegerType(64), 0).getValue().getZExtValue();
  return attr.getValue().getZExtValue();
}

::mlir::IntegerAttr ResourceStridedSliceAssignOp::ellipsis_maskAttr() {
  return this->getAttr("ellipsis_mask").dyn_cast_or_null<::mlir::IntegerAttr>();
}

uint64_t ResourceStridedSliceAssignOp::ellipsis_mask() {
  auto attr = ellipsis_maskAttr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getIntegerAttr(::mlir::Builder(this->getContext()).getIntegerType(64), 0).getValue().getZExtValue();
  return attr.getValue().getZExtValue();
}

::mlir::IntegerAttr ResourceStridedSliceAssignOp::new_axis_maskAttr() {
  return this->getAttr("new_axis_mask").dyn_cast_or_null<::mlir::IntegerAttr>();
}

uint64_t ResourceStridedSliceAssignOp::new_axis_mask() {
  auto attr = new_axis_maskAttr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getIntegerAttr(::mlir::Builder(this->getContext()).getIntegerType(64), 0).getValue().getZExtValue();
  return attr.getValue().getZExtValue();
}

::mlir::IntegerAttr ResourceStridedSliceAssignOp::shrink_axis_maskAttr() {
  return this->getAttr("shrink_axis_mask").dyn_cast_or_null<::mlir::IntegerAttr>();
}

uint64_t ResourceStridedSliceAssignOp::shrink_axis_mask() {
  auto attr = shrink_axis_maskAttr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getIntegerAttr(::mlir::Builder(this->getContext()).getIntegerType(64), 0).getValue().getZExtValue();
  return attr.getValue().getZExtValue();
}

Type ResourceStridedSliceAssignOp::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(4).begin());
}

Type ResourceStridedSliceAssignOp::Index() {
  return mlir::getElementTypeOrSelf(*getODSOperands(1).begin());
}

bool ResourceStridedSliceAssignOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "T") return true;
  if (name == "Index") return true;
 return false;
}

::mlir::DictionaryAttr ResourceStridedSliceAssignOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())},
    {::mlir::Identifier::get("Index", ctx),
::mlir::TypeAttr::get(Index())}
    }, ctx);
}

void ResourceStridedSliceAssignOp::begin_maskAttr(::mlir::IntegerAttr attr) {
  this->getOperation()->setAttr("begin_mask", attr);
}

void ResourceStridedSliceAssignOp::end_maskAttr(::mlir::IntegerAttr attr) {
  this->getOperation()->setAttr("end_mask", attr);
}

void ResourceStridedSliceAssignOp::ellipsis_maskAttr(::mlir::IntegerAttr attr) {
  this->getOperation()->setAttr("ellipsis_mask", attr);
}

void ResourceStridedSliceAssignOp::new_axis_maskAttr(::mlir::IntegerAttr attr) {
  this->getOperation()->setAttr("new_axis_mask", attr);
}

void ResourceStridedSliceAssignOp::shrink_axis_maskAttr(::mlir::IntegerAttr attr) {
  this->getOperation()->setAttr("shrink_axis_mask", attr);
}

void ResourceStridedSliceAssignOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value ref, ::mlir::Value begin, ::mlir::Value end, ::mlir::Value strides, ::mlir::Value value, ::mlir::IntegerAttr begin_mask, ::mlir::IntegerAttr end_mask, ::mlir::IntegerAttr ellipsis_mask, ::mlir::IntegerAttr new_axis_mask, ::mlir::IntegerAttr shrink_axis_mask) {
  odsState.addOperands(ref);
  odsState.addOperands(begin);
  odsState.addOperands(end);
  odsState.addOperands(strides);
  odsState.addOperands(value);
  odsState.addAttribute("begin_mask", begin_mask);
  odsState.addAttribute("end_mask", end_mask);
  odsState.addAttribute("ellipsis_mask", ellipsis_mask);
  odsState.addAttribute("new_axis_mask", new_axis_mask);
  odsState.addAttribute("shrink_axis_mask", shrink_axis_mask);
}

void ResourceStridedSliceAssignOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value ref, ::mlir::Value begin, ::mlir::Value end, ::mlir::Value strides, ::mlir::Value value, ::mlir::IntegerAttr begin_mask, ::mlir::IntegerAttr end_mask, ::mlir::IntegerAttr ellipsis_mask, ::mlir::IntegerAttr new_axis_mask, ::mlir::IntegerAttr shrink_axis_mask) {
  odsState.addOperands(ref);
  odsState.addOperands(begin);
  odsState.addOperands(end);
  odsState.addOperands(strides);
  odsState.addOperands(value);
  odsState.addAttribute("begin_mask", begin_mask);
  odsState.addAttribute("end_mask", end_mask);
  odsState.addAttribute("ellipsis_mask", ellipsis_mask);
  odsState.addAttribute("new_axis_mask", new_axis_mask);
  odsState.addAttribute("shrink_axis_mask", shrink_axis_mask);
  assert(resultTypes.size() == 0u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void ResourceStridedSliceAssignOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value ref, ::mlir::Value begin, ::mlir::Value end, ::mlir::Value strides, ::mlir::Value value, uint64_t begin_mask, uint64_t end_mask, uint64_t ellipsis_mask, uint64_t new_axis_mask, uint64_t shrink_axis_mask) {
  odsState.addOperands(ref);
  odsState.addOperands(begin);
  odsState.addOperands(end);
  odsState.addOperands(strides);
  odsState.addOperands(value);
  odsState.addAttribute("begin_mask", odsBuilder.getIntegerAttr(odsBuilder.getIntegerType(64), begin_mask));
  odsState.addAttribute("end_mask", odsBuilder.getIntegerAttr(odsBuilder.getIntegerType(64), end_mask));
  odsState.addAttribute("ellipsis_mask", odsBuilder.getIntegerAttr(odsBuilder.getIntegerType(64), ellipsis_mask));
  odsState.addAttribute("new_axis_mask", odsBuilder.getIntegerAttr(odsBuilder.getIntegerType(64), new_axis_mask));
  odsState.addAttribute("shrink_axis_mask", odsBuilder.getIntegerAttr(odsBuilder.getIntegerType(64), shrink_axis_mask));
}

void ResourceStridedSliceAssignOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value ref, ::mlir::Value begin, ::mlir::Value end, ::mlir::Value strides, ::mlir::Value value, uint64_t begin_mask, uint64_t end_mask, uint64_t ellipsis_mask, uint64_t new_axis_mask, uint64_t shrink_axis_mask) {
  odsState.addOperands(ref);
  odsState.addOperands(begin);
  odsState.addOperands(end);
  odsState.addOperands(strides);
  odsState.addOperands(value);
  odsState.addAttribute("begin_mask", odsBuilder.getIntegerAttr(odsBuilder.getIntegerType(64), begin_mask));
  odsState.addAttribute("end_mask", odsBuilder.getIntegerAttr(odsBuilder.getIntegerType(64), end_mask));
  odsState.addAttribute("ellipsis_mask", odsBuilder.getIntegerAttr(odsBuilder.getIntegerType(64), ellipsis_mask));
  odsState.addAttribute("new_axis_mask", odsBuilder.getIntegerAttr(odsBuilder.getIntegerType(64), new_axis_mask));
  odsState.addAttribute("shrink_axis_mask", odsBuilder.getIntegerAttr(odsBuilder.getIntegerType(64), shrink_axis_mask));
  assert(resultTypes.size() == 0u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void ResourceStridedSliceAssignOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 5u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 0u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult ResourceStridedSliceAssignOp::verify() {
  if (failed(ResourceStridedSliceAssignOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::ResourceType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::ResourceRefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of resource values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of 32/64-bit signed integer values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup2 = getODSOperands(2);
    for (::mlir::Value v : valueGroup2) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of 32/64-bit signed integer values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup3 = getODSOperands(3);
    for (::mlir::Value v : valueGroup3) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of 32/64-bit signed integer values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup4 = getODSOperands(4);
    for (::mlir::Value v : valueGroup4) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>())))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::TensorFlowType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of tf.dtype values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
  }
  return ::mlir::success();
}

void ResourceStridedSliceAssignOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
  for (::mlir::Value value : getODSOperands(0))
    effects.emplace_back(MemoryEffects::Read::get(), value, ::mlir::TF::ResourceEffects::Variable::get());
  for (::mlir::Value value : getODSOperands(0))
    effects.emplace_back(MemoryEffects::Write::get(), value, ::mlir::TF::ResourceEffects::Variable::get());
}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::RestoreV2Op definitions
//===----------------------------------------------------------------------===//

RestoreV2OpAdaptor::RestoreV2OpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

RestoreV2OpAdaptor::RestoreV2OpAdaptor(RestoreV2Op&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> RestoreV2OpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange RestoreV2OpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value RestoreV2OpAdaptor::prefix() {
  return *getODSOperands(0).begin();
}

::mlir::Value RestoreV2OpAdaptor::tensor_names() {
  return *getODSOperands(1).begin();
}

::mlir::Value RestoreV2OpAdaptor::shape_and_slices() {
  return *getODSOperands(2).begin();
}

::mlir::LogicalResult RestoreV2OpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

::llvm::StringRef RestoreV2Op::getOperationName() {
  return "tf.RestoreV2";
}

std::pair<unsigned, unsigned> RestoreV2Op::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range RestoreV2Op::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value RestoreV2Op::prefix() {
  return *getODSOperands(0).begin();
}

::mlir::Value RestoreV2Op::tensor_names() {
  return *getODSOperands(1).begin();
}

::mlir::Value RestoreV2Op::shape_and_slices() {
  return *getODSOperands(2).begin();
}

::mlir::MutableOperandRange RestoreV2Op::prefixMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange RestoreV2Op::tensor_namesMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange RestoreV2Op::shape_and_slicesMutable() {
  auto range = getODSOperandIndexAndLength(2);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> RestoreV2Op::getODSResultIndexAndLength(unsigned index) {
  bool isVariadic[] = {true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (getOperation()->getNumResults() - 0) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::mlir::Operation::result_range RestoreV2Op::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Operation::result_range RestoreV2Op::tensors() {
  return getODSResults(0);
}

mlir::ResultElementTypeRange RestoreV2Op::dtypes() {
  auto values = getODSResults(0);
return {mlir::ResultElementTypeIterator(values.begin()), mlir::ResultElementTypeIterator(values.end())};
}

bool RestoreV2Op::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "dtypes") return true;
 return false;
}

::mlir::DictionaryAttr RestoreV2Op::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("dtypes", ctx),
ArrayAttr::get(
    [&]() {
      llvm::SmallVector<Attribute, 4> ret;
      for (auto t : dtypes())
        ret.push_back(TypeAttr::get(t));
      return ret;
    }(), ctx)}
    }, ctx);
}

void RestoreV2Op::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange tensors, ::mlir::Value prefix, ::mlir::Value tensor_names, ::mlir::Value shape_and_slices) {
  odsState.addOperands(prefix);
  odsState.addOperands(tensor_names);
  odsState.addOperands(shape_and_slices);
  odsState.addTypes(tensors);
}

void RestoreV2Op::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 3u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult RestoreV2Op::verify() {
  if (failed(RestoreV2OpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::StringType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::StringRefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of string values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::StringType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::StringRefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of string values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup2 = getODSOperands(2);
    for (::mlir::Value v : valueGroup2) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::StringType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::StringRefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of string values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>())))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::TensorFlowType>()))))) {
        return emitOpError("result #") << index << " must be tensor of tf.dtype values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::ReverseSequenceOp definitions
//===----------------------------------------------------------------------===//

ReverseSequenceOpAdaptor::ReverseSequenceOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

ReverseSequenceOpAdaptor::ReverseSequenceOpAdaptor(ReverseSequenceOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> ReverseSequenceOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange ReverseSequenceOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value ReverseSequenceOpAdaptor::input() {
  return *getODSOperands(0).begin();
}

::mlir::Value ReverseSequenceOpAdaptor::seq_lengths() {
  return *getODSOperands(1).begin();
}

::mlir::IntegerAttr ReverseSequenceOpAdaptor::seq_dim() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::IntegerAttr attr = odsAttrs.get("seq_dim").cast<::mlir::IntegerAttr>();
  return attr;
}

::mlir::IntegerAttr ReverseSequenceOpAdaptor::batch_dim() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::IntegerAttr attr = odsAttrs.get("batch_dim").dyn_cast_or_null<::mlir::IntegerAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getIntegerAttr(::mlir::Builder(odsAttrs.getContext()).getIntegerType(64), 0);
  return attr;
}

::mlir::LogicalResult ReverseSequenceOpAdaptor::verify(::mlir::Location loc) {
  {
  auto tblgen_seq_dim = odsAttrs.get("seq_dim");
  if (!tblgen_seq_dim) return emitError(loc, "'tf.ReverseSequence' op ""requires attribute 'seq_dim'");
    if (!(((tblgen_seq_dim.isa<::mlir::IntegerAttr>())) && ((tblgen_seq_dim.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(64))))) return emitError(loc, "'tf.ReverseSequence' op ""attribute 'seq_dim' failed to satisfy constraint: 64-bit signless integer attribute");
  }
  {
  auto tblgen_batch_dim = odsAttrs.get("batch_dim");
  if (tblgen_batch_dim) {
    if (!(((tblgen_batch_dim.isa<::mlir::IntegerAttr>())) && ((tblgen_batch_dim.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(64))))) return emitError(loc, "'tf.ReverseSequence' op ""attribute 'batch_dim' failed to satisfy constraint: 64-bit signless integer attribute");
  }
  }
  return ::mlir::success();
}

::llvm::StringRef ReverseSequenceOp::getOperationName() {
  return "tf.ReverseSequence";
}

std::pair<unsigned, unsigned> ReverseSequenceOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range ReverseSequenceOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value ReverseSequenceOp::input() {
  return *getODSOperands(0).begin();
}

::mlir::Value ReverseSequenceOp::seq_lengths() {
  return *getODSOperands(1).begin();
}

::mlir::MutableOperandRange ReverseSequenceOp::inputMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange ReverseSequenceOp::seq_lengthsMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> ReverseSequenceOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range ReverseSequenceOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value ReverseSequenceOp::output() {
  return *getODSResults(0).begin();
}

::mlir::IntegerAttr ReverseSequenceOp::seq_dimAttr() {
  return this->getAttr("seq_dim").cast<::mlir::IntegerAttr>();
}

uint64_t ReverseSequenceOp::seq_dim() {
  auto attr = seq_dimAttr();
  return attr.getValue().getZExtValue();
}

::mlir::IntegerAttr ReverseSequenceOp::batch_dimAttr() {
  return this->getAttr("batch_dim").dyn_cast_or_null<::mlir::IntegerAttr>();
}

uint64_t ReverseSequenceOp::batch_dim() {
  auto attr = batch_dimAttr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getIntegerAttr(::mlir::Builder(this->getContext()).getIntegerType(64), 0).getValue().getZExtValue();
  return attr.getValue().getZExtValue();
}

Type ReverseSequenceOp::Tlen() {
  return mlir::getElementTypeOrSelf(*getODSOperands(1).begin());
}

Type ReverseSequenceOp::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

bool ReverseSequenceOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "Tlen") return true;
  if (name == "T") return true;
 return false;
}

::mlir::DictionaryAttr ReverseSequenceOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("Tlen", ctx),
::mlir::TypeAttr::get(Tlen())},
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())}
    }, ctx);
}

void ReverseSequenceOp::seq_dimAttr(::mlir::IntegerAttr attr) {
  this->getOperation()->setAttr("seq_dim", attr);
}

void ReverseSequenceOp::batch_dimAttr(::mlir::IntegerAttr attr) {
  this->getOperation()->setAttr("batch_dim", attr);
}

void ReverseSequenceOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value input, ::mlir::Value seq_lengths, ::mlir::IntegerAttr seq_dim, ::mlir::IntegerAttr batch_dim) {
  odsState.addOperands(input);
  odsState.addOperands(seq_lengths);
  odsState.addAttribute("seq_dim", seq_dim);
  odsState.addAttribute("batch_dim", batch_dim);
  odsState.addTypes(output);
}

void ReverseSequenceOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input, ::mlir::Value seq_lengths, ::mlir::IntegerAttr seq_dim, ::mlir::IntegerAttr batch_dim) {
  odsState.addOperands(input);
  odsState.addOperands(seq_lengths);
  odsState.addAttribute("seq_dim", seq_dim);
  odsState.addAttribute("batch_dim", batch_dim);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void ReverseSequenceOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value input, ::mlir::Value seq_lengths, uint64_t seq_dim, uint64_t batch_dim) {
  odsState.addOperands(input);
  odsState.addOperands(seq_lengths);
  odsState.addAttribute("seq_dim", odsBuilder.getIntegerAttr(odsBuilder.getIntegerType(64), seq_dim));
  odsState.addAttribute("batch_dim", odsBuilder.getIntegerAttr(odsBuilder.getIntegerType(64), batch_dim));
  odsState.addTypes(output);
}

void ReverseSequenceOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input, ::mlir::Value seq_lengths, uint64_t seq_dim, uint64_t batch_dim) {
  odsState.addOperands(input);
  odsState.addOperands(seq_lengths);
  odsState.addAttribute("seq_dim", odsBuilder.getIntegerAttr(odsBuilder.getIntegerType(64), seq_dim));
  odsState.addAttribute("batch_dim", odsBuilder.getIntegerAttr(odsBuilder.getIntegerType(64), batch_dim));
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void ReverseSequenceOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult ReverseSequenceOp::verify() {
  if (failed(ReverseSequenceOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>())))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::TensorFlowType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of tf.dtype values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of 32/64-bit signed integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>())))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::TensorFlowType>()))))) {
        return emitOpError("result #") << index << " must be tensor of tf.dtype values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void ReverseSequenceOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::ReverseV2Op definitions
//===----------------------------------------------------------------------===//

ReverseV2OpAdaptor::ReverseV2OpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

ReverseV2OpAdaptor::ReverseV2OpAdaptor(ReverseV2Op&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> ReverseV2OpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange ReverseV2OpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value ReverseV2OpAdaptor::tensor() {
  return *getODSOperands(0).begin();
}

::mlir::Value ReverseV2OpAdaptor::axis() {
  return *getODSOperands(1).begin();
}

::mlir::LogicalResult ReverseV2OpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

::llvm::StringRef ReverseV2Op::getOperationName() {
  return "tf.ReverseV2";
}

std::pair<unsigned, unsigned> ReverseV2Op::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range ReverseV2Op::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value ReverseV2Op::tensor() {
  return *getODSOperands(0).begin();
}

::mlir::Value ReverseV2Op::axis() {
  return *getODSOperands(1).begin();
}

::mlir::MutableOperandRange ReverseV2Op::tensorMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange ReverseV2Op::axisMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> ReverseV2Op::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range ReverseV2Op::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value ReverseV2Op::output() {
  return *getODSResults(0).begin();
}

Type ReverseV2Op::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

Type ReverseV2Op::Tidx() {
  return mlir::getElementTypeOrSelf(*getODSOperands(1).begin());
}

bool ReverseV2Op::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "T") return true;
  if (name == "Tidx") return true;
 return false;
}

::mlir::DictionaryAttr ReverseV2Op::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())},
    {::mlir::Identifier::get("Tidx", ctx),
::mlir::TypeAttr::get(Tidx())}
    }, ctx);
}

void ReverseV2Op::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value tensor, ::mlir::Value axis) {
  odsState.addOperands(tensor);
  odsState.addOperands(axis);
  odsState.addTypes(output);
}

void ReverseV2Op::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value tensor, ::mlir::Value axis) {
  odsState.addOperands(tensor);
  odsState.addOperands(axis);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void ReverseV2Op::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult ReverseV2Op::verify() {
  if (failed(ReverseV2OpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::StringType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::StringRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of bfloat16 or bool or 128-bit complex or 64-bit complex or 16-bit float or 32-bit float or 64-bit float or 16-bit integer or 32-bit integer or 64-bit integer or 8-bit integer or string or 16-bit unsigned integer or 8-bit unsigned integer values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of 32/64-bit signed integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::StringType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::StringRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>())))))) {
        return emitOpError("result #") << index << " must be tensor of bfloat16 or bool or 128-bit complex or 64-bit complex or 16-bit float or 32-bit float or 64-bit float or 16-bit integer or 32-bit integer or 64-bit integer or 8-bit integer or string or 16-bit unsigned integer or 8-bit unsigned integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void ReverseV2Op::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::RightShiftOp definitions
//===----------------------------------------------------------------------===//

RightShiftOpAdaptor::RightShiftOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

RightShiftOpAdaptor::RightShiftOpAdaptor(RightShiftOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> RightShiftOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange RightShiftOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value RightShiftOpAdaptor::x() {
  return *getODSOperands(0).begin();
}

::mlir::Value RightShiftOpAdaptor::y() {
  return *getODSOperands(1).begin();
}

::mlir::LogicalResult RightShiftOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

::llvm::StringRef RightShiftOp::getOperationName() {
  return "tf.RightShift";
}

std::pair<unsigned, unsigned> RightShiftOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range RightShiftOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value RightShiftOp::x() {
  return *getODSOperands(0).begin();
}

::mlir::Value RightShiftOp::y() {
  return *getODSOperands(1).begin();
}

::mlir::MutableOperandRange RightShiftOp::xMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange RightShiftOp::yMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> RightShiftOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range RightShiftOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value RightShiftOp::z() {
  return *getODSResults(0).begin();
}

Type RightShiftOp::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

bool RightShiftOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "T") return true;
 return false;
}

::mlir::DictionaryAttr RightShiftOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())}
    }, ctx);
}

void RightShiftOp::build(OpBuilder &builder, OperationState &result, Value  x, Value  y) {
  auto resultType =
      OpTrait::util::getBroadcastedType(x.getType(), y.getType());
  if (!resultType)
    mlir::emitError(result.location, "non-broadcastable operands");
  return build(builder, result, resultType, x, y);
}

void RightShiftOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type z, ::mlir::Value x, ::mlir::Value y) {
  odsState.addOperands(x);
  odsState.addOperands(y);
  odsState.addTypes(z);
}

void RightShiftOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value x, ::mlir::Value y) {
  odsState.addOperands(x);
  odsState.addOperands(y);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void RightShiftOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult RightShiftOp::verify() {
  if (failed(RightShiftOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))))) {
        return emitOpError("operand #") << index << " must be tensor of integer values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))))) {
        return emitOpError("operand #") << index << " must be tensor of integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))))) {
        return emitOpError("result #") << index << " must be tensor of integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void RightShiftOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::RintOp definitions
//===----------------------------------------------------------------------===//

RintOpAdaptor::RintOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

RintOpAdaptor::RintOpAdaptor(RintOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> RintOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange RintOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value RintOpAdaptor::x() {
  return *getODSOperands(0).begin();
}

::mlir::LogicalResult RintOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

::llvm::StringRef RintOp::getOperationName() {
  return "tf.Rint";
}

std::pair<unsigned, unsigned> RintOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range RintOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value RintOp::x() {
  return *getODSOperands(0).begin();
}

::mlir::MutableOperandRange RintOp::xMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> RintOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range RintOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value RintOp::y() {
  return *getODSResults(0).begin();
}

Type RintOp::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

bool RintOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "T") return true;
 return false;
}

::mlir::DictionaryAttr RintOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())}
    }, ctx);
}

void RintOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type y, ::mlir::Value x) {
  odsState.addOperands(x);
  odsState.addTypes(y);
}

void RintOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value x) {
  odsState.addOperands(x);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void RintOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

void RintOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value x) {
  odsState.addOperands(x);
  odsState.addTypes({x.getType()});

}

void RintOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  odsState.addTypes({operands[0].getType()});

}

::mlir::LogicalResult RintOp::verify() {
  if (failed(RintOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of floating-point values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))))) {
        return emitOpError("result #") << index << " must be tensor of floating-point values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void RintOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::RollOp definitions
//===----------------------------------------------------------------------===//

RollOpAdaptor::RollOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

RollOpAdaptor::RollOpAdaptor(RollOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> RollOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange RollOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value RollOpAdaptor::input() {
  return *getODSOperands(0).begin();
}

::mlir::Value RollOpAdaptor::shift() {
  return *getODSOperands(1).begin();
}

::mlir::Value RollOpAdaptor::axis() {
  return *getODSOperands(2).begin();
}

::mlir::LogicalResult RollOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

::llvm::StringRef RollOp::getOperationName() {
  return "tf.Roll";
}

std::pair<unsigned, unsigned> RollOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range RollOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value RollOp::input() {
  return *getODSOperands(0).begin();
}

::mlir::Value RollOp::shift() {
  return *getODSOperands(1).begin();
}

::mlir::Value RollOp::axis() {
  return *getODSOperands(2).begin();
}

::mlir::MutableOperandRange RollOp::inputMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange RollOp::shiftMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange RollOp::axisMutable() {
  auto range = getODSOperandIndexAndLength(2);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> RollOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range RollOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value RollOp::output() {
  return *getODSResults(0).begin();
}

Type RollOp::Tshift() {
  return mlir::getElementTypeOrSelf(*getODSOperands(1).begin());
}

Type RollOp::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

Type RollOp::Taxis() {
  return mlir::getElementTypeOrSelf(*getODSOperands(2).begin());
}

bool RollOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "Tshift") return true;
  if (name == "T") return true;
  if (name == "Taxis") return true;
 return false;
}

::mlir::DictionaryAttr RollOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("Tshift", ctx),
::mlir::TypeAttr::get(Tshift())},
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())},
    {::mlir::Identifier::get("Taxis", ctx),
::mlir::TypeAttr::get(Taxis())}
    }, ctx);
}

void RollOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value input, ::mlir::Value shift, ::mlir::Value axis) {
  odsState.addOperands(input);
  odsState.addOperands(shift);
  odsState.addOperands(axis);
  odsState.addTypes(output);
}

void RollOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input, ::mlir::Value shift, ::mlir::Value axis) {
  odsState.addOperands(input);
  odsState.addOperands(shift);
  odsState.addOperands(axis);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void RollOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 3u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult RollOp::verify() {
  if (failed(RollOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>())))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::TensorFlowType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of tf.dtype values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of 32/64-bit signed integer values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup2 = getODSOperands(2);
    for (::mlir::Value v : valueGroup2) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of 32/64-bit signed integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>())))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::TensorFlowType>()))))) {
        return emitOpError("result #") << index << " must be tensor of tf.dtype values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void RollOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::RoundOp definitions
//===----------------------------------------------------------------------===//

RoundOpAdaptor::RoundOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

RoundOpAdaptor::RoundOpAdaptor(RoundOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> RoundOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange RoundOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value RoundOpAdaptor::x() {
  return *getODSOperands(0).begin();
}

::mlir::LogicalResult RoundOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

::llvm::StringRef RoundOp::getOperationName() {
  return "tf.Round";
}

std::pair<unsigned, unsigned> RoundOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range RoundOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value RoundOp::x() {
  return *getODSOperands(0).begin();
}

::mlir::MutableOperandRange RoundOp::xMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> RoundOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range RoundOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value RoundOp::y() {
  return *getODSResults(0).begin();
}

Type RoundOp::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

bool RoundOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "T") return true;
 return false;
}

::mlir::DictionaryAttr RoundOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())}
    }, ctx);
}

void RoundOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type y, ::mlir::Value x) {
  odsState.addOperands(x);
  odsState.addTypes(y);
}

void RoundOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value x) {
  odsState.addOperands(x);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void RoundOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

void RoundOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value x) {
  odsState.addOperands(x);
  odsState.addTypes({x.getType()});

}

void RoundOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  odsState.addTypes({operands[0].getType()});

}

::mlir::LogicalResult RoundOp::verify() {
  if (failed(RoundOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of bfloat16 or 128-bit complex or 64-bit complex or 16-bit float or 32-bit float or 64-bit float or 16-bit integer or 32-bit integer or 64-bit integer or 8-bit integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>())))))) {
        return emitOpError("result #") << index << " must be tensor of bfloat16 or 128-bit complex or 64-bit complex or 16-bit float or 32-bit float or 64-bit float or 16-bit integer or 32-bit integer or 64-bit integer or 8-bit integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void RoundOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::RsqrtGradOp definitions
//===----------------------------------------------------------------------===//

RsqrtGradOpAdaptor::RsqrtGradOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

RsqrtGradOpAdaptor::RsqrtGradOpAdaptor(RsqrtGradOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> RsqrtGradOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange RsqrtGradOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value RsqrtGradOpAdaptor::y() {
  return *getODSOperands(0).begin();
}

::mlir::Value RsqrtGradOpAdaptor::dy() {
  return *getODSOperands(1).begin();
}

::mlir::LogicalResult RsqrtGradOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

::llvm::StringRef RsqrtGradOp::getOperationName() {
  return "tf.RsqrtGrad";
}

std::pair<unsigned, unsigned> RsqrtGradOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range RsqrtGradOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value RsqrtGradOp::y() {
  return *getODSOperands(0).begin();
}

::mlir::Value RsqrtGradOp::dy() {
  return *getODSOperands(1).begin();
}

::mlir::MutableOperandRange RsqrtGradOp::yMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange RsqrtGradOp::dyMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> RsqrtGradOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range RsqrtGradOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value RsqrtGradOp::z() {
  return *getODSResults(0).begin();
}

Type RsqrtGradOp::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

bool RsqrtGradOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "T") return true;
 return false;
}

::mlir::DictionaryAttr RsqrtGradOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())}
    }, ctx);
}

void RsqrtGradOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type z, ::mlir::Value y, ::mlir::Value dy) {
  odsState.addOperands(y);
  odsState.addOperands(dy);
  odsState.addTypes(z);
}

void RsqrtGradOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value y, ::mlir::Value dy) {
  odsState.addOperands(y);
  odsState.addOperands(dy);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void RsqrtGradOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

void RsqrtGradOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value y, ::mlir::Value dy) {
  odsState.addOperands(y);
  odsState.addOperands(dy);
  odsState.addTypes({y.getType()});

}

void RsqrtGradOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  odsState.addTypes({operands[0].getType()});

}

::mlir::LogicalResult RsqrtGradOp::verify() {
  if (failed(RsqrtGradOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))))))) {
        return emitOpError("operand #") << index << " must be tensor of floating-point or complex values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))))))) {
        return emitOpError("operand #") << index << " must be tensor of floating-point or complex values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))))))) {
        return emitOpError("result #") << index << " must be tensor of floating-point or complex values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void RsqrtGradOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::RsqrtOp definitions
//===----------------------------------------------------------------------===//

RsqrtOpAdaptor::RsqrtOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

RsqrtOpAdaptor::RsqrtOpAdaptor(RsqrtOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> RsqrtOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange RsqrtOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value RsqrtOpAdaptor::x() {
  return *getODSOperands(0).begin();
}

::mlir::LogicalResult RsqrtOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

::llvm::StringRef RsqrtOp::getOperationName() {
  return "tf.Rsqrt";
}

std::pair<unsigned, unsigned> RsqrtOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range RsqrtOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value RsqrtOp::x() {
  return *getODSOperands(0).begin();
}

::mlir::MutableOperandRange RsqrtOp::xMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> RsqrtOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range RsqrtOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value RsqrtOp::y() {
  return *getODSResults(0).begin();
}

Type RsqrtOp::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

bool RsqrtOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "T") return true;
 return false;
}

::mlir::DictionaryAttr RsqrtOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())}
    }, ctx);
}

void RsqrtOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type y, ::mlir::Value x) {
  odsState.addOperands(x);
  odsState.addTypes(y);
}

void RsqrtOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value x) {
  odsState.addOperands(x);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void RsqrtOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

void RsqrtOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value x) {
  odsState.addOperands(x);
  odsState.addTypes({x.getType()});

}

void RsqrtOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  odsState.addTypes({operands[0].getType()});

}

::mlir::LogicalResult RsqrtOp::verify() {
  if (failed(RsqrtOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))))))) {
        return emitOpError("operand #") << index << " must be tensor of floating-point or complex values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))))))) {
        return emitOpError("result #") << index << " must be tensor of floating-point or complex values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void RsqrtOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::ScatterNdOp definitions
//===----------------------------------------------------------------------===//

ScatterNdOpAdaptor::ScatterNdOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

ScatterNdOpAdaptor::ScatterNdOpAdaptor(ScatterNdOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> ScatterNdOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange ScatterNdOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value ScatterNdOpAdaptor::indices() {
  return *getODSOperands(0).begin();
}

::mlir::Value ScatterNdOpAdaptor::updates() {
  return *getODSOperands(1).begin();
}

::mlir::Value ScatterNdOpAdaptor::shape() {
  return *getODSOperands(2).begin();
}

::mlir::LogicalResult ScatterNdOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

::llvm::StringRef ScatterNdOp::getOperationName() {
  return "tf.ScatterNd";
}

std::pair<unsigned, unsigned> ScatterNdOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range ScatterNdOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value ScatterNdOp::indices() {
  return *getODSOperands(0).begin();
}

::mlir::Value ScatterNdOp::updates() {
  return *getODSOperands(1).begin();
}

::mlir::Value ScatterNdOp::shape() {
  return *getODSOperands(2).begin();
}

::mlir::MutableOperandRange ScatterNdOp::indicesMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange ScatterNdOp::updatesMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange ScatterNdOp::shapeMutable() {
  auto range = getODSOperandIndexAndLength(2);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> ScatterNdOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range ScatterNdOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value ScatterNdOp::output() {
  return *getODSResults(0).begin();
}

Type ScatterNdOp::Tindices() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

Type ScatterNdOp::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(1).begin());
}

bool ScatterNdOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "Tindices") return true;
  if (name == "T") return true;
 return false;
}

::mlir::DictionaryAttr ScatterNdOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("Tindices", ctx),
::mlir::TypeAttr::get(Tindices())},
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())}
    }, ctx);
}

void ScatterNdOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value indices, ::mlir::Value updates, ::mlir::Value shape) {
  odsState.addOperands(indices);
  odsState.addOperands(updates);
  odsState.addOperands(shape);
  odsState.addTypes(output);
}

void ScatterNdOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value indices, ::mlir::Value updates, ::mlir::Value shape) {
  odsState.addOperands(indices);
  odsState.addOperands(updates);
  odsState.addOperands(shape);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void ScatterNdOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 3u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult ScatterNdOp::verify() {
  if (failed(ScatterNdOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of 32/64-bit signed integer values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>())))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::TensorFlowType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of tf.dtype values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup2 = getODSOperands(2);
    for (::mlir::Value v : valueGroup2) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of 32/64-bit signed integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>())))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::TensorFlowType>()))))) {
        return emitOpError("result #") << index << " must be tensor of tf.dtype values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void ScatterNdOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::SegmentMaxOp definitions
//===----------------------------------------------------------------------===//

SegmentMaxOpAdaptor::SegmentMaxOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

SegmentMaxOpAdaptor::SegmentMaxOpAdaptor(SegmentMaxOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> SegmentMaxOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange SegmentMaxOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value SegmentMaxOpAdaptor::data() {
  return *getODSOperands(0).begin();
}

::mlir::Value SegmentMaxOpAdaptor::segment_ids() {
  return *getODSOperands(1).begin();
}

::mlir::LogicalResult SegmentMaxOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

::llvm::StringRef SegmentMaxOp::getOperationName() {
  return "tf.SegmentMax";
}

std::pair<unsigned, unsigned> SegmentMaxOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range SegmentMaxOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value SegmentMaxOp::data() {
  return *getODSOperands(0).begin();
}

::mlir::Value SegmentMaxOp::segment_ids() {
  return *getODSOperands(1).begin();
}

::mlir::MutableOperandRange SegmentMaxOp::dataMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange SegmentMaxOp::segment_idsMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> SegmentMaxOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range SegmentMaxOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value SegmentMaxOp::output() {
  return *getODSResults(0).begin();
}

Type SegmentMaxOp::Tindices() {
  return mlir::getElementTypeOrSelf(*getODSOperands(1).begin());
}

Type SegmentMaxOp::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

bool SegmentMaxOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "Tindices") return true;
  if (name == "T") return true;
 return false;
}

::mlir::DictionaryAttr SegmentMaxOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("Tindices", ctx),
::mlir::TypeAttr::get(Tindices())},
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())}
    }, ctx);
}

void SegmentMaxOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value data, ::mlir::Value segment_ids) {
  odsState.addOperands(data);
  odsState.addOperands(segment_ids);
  odsState.addTypes(output);
}

void SegmentMaxOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value data, ::mlir::Value segment_ids) {
  odsState.addOperands(data);
  odsState.addOperands(segment_ids);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void SegmentMaxOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult SegmentMaxOp::verify() {
  if (failed(SegmentMaxOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of integer or floating-point values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of 32/64-bit signed integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>())))))) {
        return emitOpError("result #") << index << " must be tensor of integer or floating-point values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void SegmentMaxOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::SegmentMeanOp definitions
//===----------------------------------------------------------------------===//

SegmentMeanOpAdaptor::SegmentMeanOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

SegmentMeanOpAdaptor::SegmentMeanOpAdaptor(SegmentMeanOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> SegmentMeanOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange SegmentMeanOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value SegmentMeanOpAdaptor::data() {
  return *getODSOperands(0).begin();
}

::mlir::Value SegmentMeanOpAdaptor::segment_ids() {
  return *getODSOperands(1).begin();
}

::mlir::LogicalResult SegmentMeanOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

::llvm::StringRef SegmentMeanOp::getOperationName() {
  return "tf.SegmentMean";
}

std::pair<unsigned, unsigned> SegmentMeanOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range SegmentMeanOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value SegmentMeanOp::data() {
  return *getODSOperands(0).begin();
}

::mlir::Value SegmentMeanOp::segment_ids() {
  return *getODSOperands(1).begin();
}

::mlir::MutableOperandRange SegmentMeanOp::dataMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange SegmentMeanOp::segment_idsMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> SegmentMeanOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range SegmentMeanOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value SegmentMeanOp::output() {
  return *getODSResults(0).begin();
}

Type SegmentMeanOp::Tindices() {
  return mlir::getElementTypeOrSelf(*getODSOperands(1).begin());
}

Type SegmentMeanOp::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

bool SegmentMeanOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "Tindices") return true;
  if (name == "T") return true;
 return false;
}

::mlir::DictionaryAttr SegmentMeanOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("Tindices", ctx),
::mlir::TypeAttr::get(Tindices())},
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())}
    }, ctx);
}

void SegmentMeanOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value data, ::mlir::Value segment_ids) {
  odsState.addOperands(data);
  odsState.addOperands(segment_ids);
  odsState.addTypes(output);
}

void SegmentMeanOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value data, ::mlir::Value segment_ids) {
  odsState.addOperands(data);
  odsState.addOperands(segment_ids);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void SegmentMeanOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult SegmentMeanOp::verify() {
  if (failed(SegmentMeanOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of bfloat16 or 128-bit complex or 64-bit complex or 16-bit float or 32-bit float or 64-bit float or 16-bit integer or 32-bit integer or 64-bit integer or 8-bit integer or 32-bit quantized integer or 8-bit quantized integer or 8-bit quantized unsigned integer or 16-bit unsigned integer or 32-bit unsigned integer or 64-bit unsigned integer or 8-bit unsigned integer values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of 32/64-bit signed integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>())))))) {
        return emitOpError("result #") << index << " must be tensor of bfloat16 or 128-bit complex or 64-bit complex or 16-bit float or 32-bit float or 64-bit float or 16-bit integer or 32-bit integer or 64-bit integer or 8-bit integer or 32-bit quantized integer or 8-bit quantized integer or 8-bit quantized unsigned integer or 16-bit unsigned integer or 32-bit unsigned integer or 64-bit unsigned integer or 8-bit unsigned integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void SegmentMeanOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::SegmentMinOp definitions
//===----------------------------------------------------------------------===//

SegmentMinOpAdaptor::SegmentMinOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

SegmentMinOpAdaptor::SegmentMinOpAdaptor(SegmentMinOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> SegmentMinOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange SegmentMinOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value SegmentMinOpAdaptor::data() {
  return *getODSOperands(0).begin();
}

::mlir::Value SegmentMinOpAdaptor::segment_ids() {
  return *getODSOperands(1).begin();
}

::mlir::LogicalResult SegmentMinOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

::llvm::StringRef SegmentMinOp::getOperationName() {
  return "tf.SegmentMin";
}

std::pair<unsigned, unsigned> SegmentMinOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range SegmentMinOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value SegmentMinOp::data() {
  return *getODSOperands(0).begin();
}

::mlir::Value SegmentMinOp::segment_ids() {
  return *getODSOperands(1).begin();
}

::mlir::MutableOperandRange SegmentMinOp::dataMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange SegmentMinOp::segment_idsMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> SegmentMinOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range SegmentMinOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value SegmentMinOp::output() {
  return *getODSResults(0).begin();
}

Type SegmentMinOp::Tindices() {
  return mlir::getElementTypeOrSelf(*getODSOperands(1).begin());
}

Type SegmentMinOp::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

bool SegmentMinOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "Tindices") return true;
  if (name == "T") return true;
 return false;
}

::mlir::DictionaryAttr SegmentMinOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("Tindices", ctx),
::mlir::TypeAttr::get(Tindices())},
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())}
    }, ctx);
}

void SegmentMinOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value data, ::mlir::Value segment_ids) {
  odsState.addOperands(data);
  odsState.addOperands(segment_ids);
  odsState.addTypes(output);
}

void SegmentMinOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value data, ::mlir::Value segment_ids) {
  odsState.addOperands(data);
  odsState.addOperands(segment_ids);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void SegmentMinOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult SegmentMinOp::verify() {
  if (failed(SegmentMinOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of integer or floating-point values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of 32/64-bit signed integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>())))))) {
        return emitOpError("result #") << index << " must be tensor of integer or floating-point values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void SegmentMinOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::SegmentProdOp definitions
//===----------------------------------------------------------------------===//

SegmentProdOpAdaptor::SegmentProdOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

SegmentProdOpAdaptor::SegmentProdOpAdaptor(SegmentProdOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> SegmentProdOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange SegmentProdOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value SegmentProdOpAdaptor::data() {
  return *getODSOperands(0).begin();
}

::mlir::Value SegmentProdOpAdaptor::segment_ids() {
  return *getODSOperands(1).begin();
}

::mlir::LogicalResult SegmentProdOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

::llvm::StringRef SegmentProdOp::getOperationName() {
  return "tf.SegmentProd";
}

std::pair<unsigned, unsigned> SegmentProdOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range SegmentProdOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value SegmentProdOp::data() {
  return *getODSOperands(0).begin();
}

::mlir::Value SegmentProdOp::segment_ids() {
  return *getODSOperands(1).begin();
}

::mlir::MutableOperandRange SegmentProdOp::dataMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange SegmentProdOp::segment_idsMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> SegmentProdOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range SegmentProdOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value SegmentProdOp::output() {
  return *getODSResults(0).begin();
}

Type SegmentProdOp::Tindices() {
  return mlir::getElementTypeOrSelf(*getODSOperands(1).begin());
}

Type SegmentProdOp::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

bool SegmentProdOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "Tindices") return true;
  if (name == "T") return true;
 return false;
}

::mlir::DictionaryAttr SegmentProdOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("Tindices", ctx),
::mlir::TypeAttr::get(Tindices())},
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())}
    }, ctx);
}

void SegmentProdOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value data, ::mlir::Value segment_ids) {
  odsState.addOperands(data);
  odsState.addOperands(segment_ids);
  odsState.addTypes(output);
}

void SegmentProdOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value data, ::mlir::Value segment_ids) {
  odsState.addOperands(data);
  odsState.addOperands(segment_ids);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void SegmentProdOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult SegmentProdOp::verify() {
  if (failed(SegmentProdOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of bfloat16 or 128-bit complex or 64-bit complex or 16-bit float or 32-bit float or 64-bit float or 16-bit integer or 32-bit integer or 64-bit integer or 8-bit integer or 32-bit quantized integer or 8-bit quantized integer or 8-bit quantized unsigned integer or 16-bit unsigned integer or 32-bit unsigned integer or 64-bit unsigned integer or 8-bit unsigned integer values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of 32/64-bit signed integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>())))))) {
        return emitOpError("result #") << index << " must be tensor of bfloat16 or 128-bit complex or 64-bit complex or 16-bit float or 32-bit float or 64-bit float or 16-bit integer or 32-bit integer or 64-bit integer or 8-bit integer or 32-bit quantized integer or 8-bit quantized integer or 8-bit quantized unsigned integer or 16-bit unsigned integer or 32-bit unsigned integer or 64-bit unsigned integer or 8-bit unsigned integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void SegmentProdOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::SegmentSumOp definitions
//===----------------------------------------------------------------------===//

SegmentSumOpAdaptor::SegmentSumOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

SegmentSumOpAdaptor::SegmentSumOpAdaptor(SegmentSumOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> SegmentSumOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange SegmentSumOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value SegmentSumOpAdaptor::data() {
  return *getODSOperands(0).begin();
}

::mlir::Value SegmentSumOpAdaptor::segment_ids() {
  return *getODSOperands(1).begin();
}

::mlir::LogicalResult SegmentSumOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

::llvm::StringRef SegmentSumOp::getOperationName() {
  return "tf.SegmentSum";
}

std::pair<unsigned, unsigned> SegmentSumOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range SegmentSumOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value SegmentSumOp::data() {
  return *getODSOperands(0).begin();
}

::mlir::Value SegmentSumOp::segment_ids() {
  return *getODSOperands(1).begin();
}

::mlir::MutableOperandRange SegmentSumOp::dataMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange SegmentSumOp::segment_idsMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> SegmentSumOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range SegmentSumOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value SegmentSumOp::output() {
  return *getODSResults(0).begin();
}

Type SegmentSumOp::Tindices() {
  return mlir::getElementTypeOrSelf(*getODSOperands(1).begin());
}

Type SegmentSumOp::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

bool SegmentSumOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "Tindices") return true;
  if (name == "T") return true;
 return false;
}

::mlir::DictionaryAttr SegmentSumOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("Tindices", ctx),
::mlir::TypeAttr::get(Tindices())},
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())}
    }, ctx);
}

void SegmentSumOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value data, ::mlir::Value segment_ids) {
  odsState.addOperands(data);
  odsState.addOperands(segment_ids);
  odsState.addTypes(output);
}

void SegmentSumOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value data, ::mlir::Value segment_ids) {
  odsState.addOperands(data);
  odsState.addOperands(segment_ids);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void SegmentSumOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult SegmentSumOp::verify() {
  if (failed(SegmentSumOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of bfloat16 or 128-bit complex or 64-bit complex or 16-bit float or 32-bit float or 64-bit float or 16-bit integer or 32-bit integer or 64-bit integer or 8-bit integer or 32-bit quantized integer or 8-bit quantized integer or 8-bit quantized unsigned integer or 16-bit unsigned integer or 32-bit unsigned integer or 64-bit unsigned integer or 8-bit unsigned integer values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of 32/64-bit signed integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>())))))) {
        return emitOpError("result #") << index << " must be tensor of bfloat16 or 128-bit complex or 64-bit complex or 16-bit float or 32-bit float or 64-bit float or 16-bit integer or 32-bit integer or 64-bit integer or 8-bit integer or 32-bit quantized integer or 8-bit quantized integer or 8-bit quantized unsigned integer or 16-bit unsigned integer or 32-bit unsigned integer or 64-bit unsigned integer or 8-bit unsigned integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void SegmentSumOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::SelectOp definitions
//===----------------------------------------------------------------------===//

SelectOpAdaptor::SelectOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

SelectOpAdaptor::SelectOpAdaptor(SelectOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> SelectOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange SelectOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value SelectOpAdaptor::condition() {
  return *getODSOperands(0).begin();
}

::mlir::Value SelectOpAdaptor::t() {
  return *getODSOperands(1).begin();
}

::mlir::Value SelectOpAdaptor::e() {
  return *getODSOperands(2).begin();
}

::mlir::LogicalResult SelectOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

::llvm::StringRef SelectOp::getOperationName() {
  return "tf.Select";
}

std::pair<unsigned, unsigned> SelectOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range SelectOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value SelectOp::condition() {
  return *getODSOperands(0).begin();
}

::mlir::Value SelectOp::t() {
  return *getODSOperands(1).begin();
}

::mlir::Value SelectOp::e() {
  return *getODSOperands(2).begin();
}

::mlir::MutableOperandRange SelectOp::conditionMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange SelectOp::tMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange SelectOp::eMutable() {
  auto range = getODSOperandIndexAndLength(2);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> SelectOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range SelectOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value SelectOp::output() {
  return *getODSResults(0).begin();
}

Type SelectOp::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(1).begin());
}

bool SelectOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "T") return true;
 return false;
}

::mlir::DictionaryAttr SelectOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())}
    }, ctx);
}

void SelectOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value condition, ::mlir::Value t, ::mlir::Value e) {
  odsState.addOperands(condition);
  odsState.addOperands(t);
  odsState.addOperands(e);
  odsState.addTypes(output);
}

void SelectOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value condition, ::mlir::Value t, ::mlir::Value e) {
  odsState.addOperands(condition);
  odsState.addOperands(t);
  odsState.addOperands(e);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void SelectOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 3u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult SelectOp::verify() {
  if (failed(SelectOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of bool values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>())))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::TensorFlowType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of tf.dtype values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup2 = getODSOperands(2);
    for (::mlir::Value v : valueGroup2) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>())))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::TensorFlowType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of tf.dtype values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>())))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::TensorFlowType>()))))) {
        return emitOpError("result #") << index << " must be tensor of tf.dtype values, but got " << v.getType();
      }
      ++index;
    }
  }
  return Verify(*this);
}



void SelectOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::SelectV2Op definitions
//===----------------------------------------------------------------------===//

SelectV2OpAdaptor::SelectV2OpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

SelectV2OpAdaptor::SelectV2OpAdaptor(SelectV2Op&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> SelectV2OpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange SelectV2OpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value SelectV2OpAdaptor::condition() {
  return *getODSOperands(0).begin();
}

::mlir::Value SelectV2OpAdaptor::t() {
  return *getODSOperands(1).begin();
}

::mlir::Value SelectV2OpAdaptor::e() {
  return *getODSOperands(2).begin();
}

::mlir::LogicalResult SelectV2OpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

::llvm::StringRef SelectV2Op::getOperationName() {
  return "tf.SelectV2";
}

std::pair<unsigned, unsigned> SelectV2Op::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range SelectV2Op::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value SelectV2Op::condition() {
  return *getODSOperands(0).begin();
}

::mlir::Value SelectV2Op::t() {
  return *getODSOperands(1).begin();
}

::mlir::Value SelectV2Op::e() {
  return *getODSOperands(2).begin();
}

::mlir::MutableOperandRange SelectV2Op::conditionMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange SelectV2Op::tMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange SelectV2Op::eMutable() {
  auto range = getODSOperandIndexAndLength(2);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> SelectV2Op::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range SelectV2Op::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value SelectV2Op::output() {
  return *getODSResults(0).begin();
}

Type SelectV2Op::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(1).begin());
}

bool SelectV2Op::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "T") return true;
 return false;
}

::mlir::DictionaryAttr SelectV2Op::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())}
    }, ctx);
}



void SelectV2Op::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value condition, ::mlir::Value t, ::mlir::Value e) {
  odsState.addOperands(condition);
  odsState.addOperands(t);
  odsState.addOperands(e);
  odsState.addTypes(output);
}

void SelectV2Op::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value condition, ::mlir::Value t, ::mlir::Value e) {
  odsState.addOperands(condition);
  odsState.addOperands(t);
  odsState.addOperands(e);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void SelectV2Op::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 3u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult SelectV2Op::verify() {
  if (failed(SelectV2OpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of bool values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>())))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::TensorFlowType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of tf.dtype values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup2 = getODSOperands(2);
    for (::mlir::Value v : valueGroup2) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>())))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::TensorFlowType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of tf.dtype values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>())))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::TensorFlowType>()))))) {
        return emitOpError("result #") << index << " must be tensor of tf.dtype values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void SelectV2Op::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::SelfAdjointEigV2Op definitions
//===----------------------------------------------------------------------===//

SelfAdjointEigV2OpAdaptor::SelfAdjointEigV2OpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

SelfAdjointEigV2OpAdaptor::SelfAdjointEigV2OpAdaptor(SelfAdjointEigV2Op&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> SelfAdjointEigV2OpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange SelfAdjointEigV2OpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value SelfAdjointEigV2OpAdaptor::input() {
  return *getODSOperands(0).begin();
}

::mlir::BoolAttr SelfAdjointEigV2OpAdaptor::compute_v() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::BoolAttr attr = odsAttrs.get("compute_v").dyn_cast_or_null<::mlir::BoolAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getBoolAttr(true);
  return attr;
}

::mlir::LogicalResult SelfAdjointEigV2OpAdaptor::verify(::mlir::Location loc) {
  {
  auto tblgen_compute_v = odsAttrs.get("compute_v");
  if (tblgen_compute_v) {
    if (!((tblgen_compute_v.isa<::mlir::BoolAttr>()))) return emitError(loc, "'tf.SelfAdjointEigV2' op ""attribute 'compute_v' failed to satisfy constraint: bool attribute");
  }
  }
  return ::mlir::success();
}

void SelfAdjointEigV2Op::getAsmResultNames(::mlir::OpAsmSetValueNameFn setNameFn) {
  auto resultGroup0 = getODSResults(0);
  if (!llvm::empty(resultGroup0))
    setNameFn(*resultGroup0.begin(), "e");
  auto resultGroup1 = getODSResults(1);
  if (!llvm::empty(resultGroup1))
    setNameFn(*resultGroup1.begin(), "v");
}

::llvm::StringRef SelfAdjointEigV2Op::getOperationName() {
  return "tf.SelfAdjointEigV2";
}

std::pair<unsigned, unsigned> SelfAdjointEigV2Op::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range SelfAdjointEigV2Op::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value SelfAdjointEigV2Op::input() {
  return *getODSOperands(0).begin();
}

::mlir::MutableOperandRange SelfAdjointEigV2Op::inputMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> SelfAdjointEigV2Op::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range SelfAdjointEigV2Op::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value SelfAdjointEigV2Op::e() {
  return *getODSResults(0).begin();
}

::mlir::Value SelfAdjointEigV2Op::v() {
  return *getODSResults(1).begin();
}

::mlir::BoolAttr SelfAdjointEigV2Op::compute_vAttr() {
  return this->getAttr("compute_v").dyn_cast_or_null<::mlir::BoolAttr>();
}

bool SelfAdjointEigV2Op::compute_v() {
  auto attr = compute_vAttr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getBoolAttr(true).getValue();
  return attr.getValue();
}

Type SelfAdjointEigV2Op::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

bool SelfAdjointEigV2Op::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "T") return true;
 return false;
}

::mlir::DictionaryAttr SelfAdjointEigV2Op::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())}
    }, ctx);
}

void SelfAdjointEigV2Op::compute_vAttr(::mlir::BoolAttr attr) {
  this->getOperation()->setAttr("compute_v", attr);
}

void SelfAdjointEigV2Op::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type e, ::mlir::Type v, ::mlir::Value input, ::mlir::BoolAttr compute_v) {
  odsState.addOperands(input);
  odsState.addAttribute("compute_v", compute_v);
  odsState.addTypes(e);
  odsState.addTypes(v);
}

void SelfAdjointEigV2Op::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input, ::mlir::BoolAttr compute_v) {
  odsState.addOperands(input);
  odsState.addAttribute("compute_v", compute_v);
  assert(resultTypes.size() == 2u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void SelfAdjointEigV2Op::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type e, ::mlir::Type v, ::mlir::Value input, bool compute_v) {
  odsState.addOperands(input);
  odsState.addAttribute("compute_v", odsBuilder.getBoolAttr(compute_v));
  odsState.addTypes(e);
  odsState.addTypes(v);
}

void SelfAdjointEigV2Op::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input, bool compute_v) {
  odsState.addOperands(input);
  odsState.addAttribute("compute_v", odsBuilder.getBoolAttr(compute_v));
  assert(resultTypes.size() == 2u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void SelfAdjointEigV2Op::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 2u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult SelfAdjointEigV2Op::verify() {
  if (failed(SelfAdjointEigV2OpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of 128-bit complex or 64-bit complex or 16-bit float or 32-bit float or 64-bit float values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())))))) {
        return emitOpError("result #") << index << " must be tensor of 128-bit complex or 64-bit complex or 16-bit float or 32-bit float or 64-bit float values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSResults(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())))))) {
        return emitOpError("result #") << index << " must be tensor of 128-bit complex or 64-bit complex or 16-bit float or 32-bit float or 64-bit float values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void SelfAdjointEigV2Op::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::SeluGradOp definitions
//===----------------------------------------------------------------------===//

SeluGradOpAdaptor::SeluGradOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

SeluGradOpAdaptor::SeluGradOpAdaptor(SeluGradOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> SeluGradOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange SeluGradOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value SeluGradOpAdaptor::gradients() {
  return *getODSOperands(0).begin();
}

::mlir::Value SeluGradOpAdaptor::outputs() {
  return *getODSOperands(1).begin();
}

::mlir::LogicalResult SeluGradOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

::llvm::StringRef SeluGradOp::getOperationName() {
  return "tf.SeluGrad";
}

std::pair<unsigned, unsigned> SeluGradOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range SeluGradOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value SeluGradOp::gradients() {
  return *getODSOperands(0).begin();
}

::mlir::Value SeluGradOp::outputs() {
  return *getODSOperands(1).begin();
}

::mlir::MutableOperandRange SeluGradOp::gradientsMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange SeluGradOp::outputsMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> SeluGradOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range SeluGradOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value SeluGradOp::backprops() {
  return *getODSResults(0).begin();
}

Type SeluGradOp::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

bool SeluGradOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "T") return true;
 return false;
}

::mlir::DictionaryAttr SeluGradOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())}
    }, ctx);
}

void SeluGradOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type backprops, ::mlir::Value gradients, ::mlir::Value outputs) {
  odsState.addOperands(gradients);
  odsState.addOperands(outputs);
  odsState.addTypes(backprops);
}

void SeluGradOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value gradients, ::mlir::Value outputs) {
  odsState.addOperands(gradients);
  odsState.addOperands(outputs);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void SeluGradOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

void SeluGradOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value gradients, ::mlir::Value outputs) {
  odsState.addOperands(gradients);
  odsState.addOperands(outputs);
  odsState.addTypes({gradients.getType()});

}

void SeluGradOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  odsState.addTypes({operands[0].getType()});

}

::mlir::LogicalResult SeluGradOp::verify() {
  if (failed(SeluGradOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of floating-point values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of floating-point values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))))) {
        return emitOpError("result #") << index << " must be tensor of floating-point values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void SeluGradOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::SeluOp definitions
//===----------------------------------------------------------------------===//

SeluOpAdaptor::SeluOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

SeluOpAdaptor::SeluOpAdaptor(SeluOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> SeluOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange SeluOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value SeluOpAdaptor::features() {
  return *getODSOperands(0).begin();
}

::mlir::LogicalResult SeluOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

::llvm::StringRef SeluOp::getOperationName() {
  return "tf.Selu";
}

std::pair<unsigned, unsigned> SeluOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range SeluOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value SeluOp::features() {
  return *getODSOperands(0).begin();
}

::mlir::MutableOperandRange SeluOp::featuresMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> SeluOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range SeluOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value SeluOp::activations() {
  return *getODSResults(0).begin();
}

Type SeluOp::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

bool SeluOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "T") return true;
 return false;
}

::mlir::DictionaryAttr SeluOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())}
    }, ctx);
}

void SeluOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type activations, ::mlir::Value features) {
  odsState.addOperands(features);
  odsState.addTypes(activations);
}

void SeluOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value features) {
  odsState.addOperands(features);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void SeluOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

void SeluOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value features) {
  odsState.addOperands(features);
  odsState.addTypes({features.getType()});

}

void SeluOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  odsState.addTypes({operands[0].getType()});

}

::mlir::LogicalResult SeluOp::verify() {
  if (failed(SeluOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of floating-point values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))))) {
        return emitOpError("result #") << index << " must be tensor of floating-point values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void SeluOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::SendTPUEmbeddingGradientsOp definitions
//===----------------------------------------------------------------------===//

SendTPUEmbeddingGradientsOpAdaptor::SendTPUEmbeddingGradientsOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

SendTPUEmbeddingGradientsOpAdaptor::SendTPUEmbeddingGradientsOpAdaptor(SendTPUEmbeddingGradientsOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> SendTPUEmbeddingGradientsOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  assert(odsAttrs && "missing segment size attribute for op");
  auto sizeAttr = odsAttrs.get("operand_segment_sizes").cast<::mlir::DenseIntElementsAttr>();

  unsigned start = 0;
  for (unsigned i = 0; i < index; ++i)
    start += (*(sizeAttr.begin() + i)).getZExtValue();
  unsigned size = (*(sizeAttr.begin() + index)).getZExtValue();
  return {start, size};
}

::mlir::ValueRange SendTPUEmbeddingGradientsOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::ValueRange SendTPUEmbeddingGradientsOpAdaptor::inputs() {
  return getODSOperands(0);
}

::mlir::ValueRange SendTPUEmbeddingGradientsOpAdaptor::learning_rates() {
  return getODSOperands(1);
}

::mlir::StringAttr SendTPUEmbeddingGradientsOpAdaptor::config() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::StringAttr attr = odsAttrs.get("config").cast<::mlir::StringAttr>();
  return attr;
}

::mlir::LogicalResult SendTPUEmbeddingGradientsOpAdaptor::verify(::mlir::Location loc) {
  {
    auto sizeAttr = odsAttrs.get("operand_segment_sizes").cast<::mlir::DenseIntElementsAttr>();
    auto numElements = sizeAttr.getType().cast<::mlir::ShapedType>().getNumElements();
    if (numElements != 2)
      return emitError(loc, "'operand_segment_sizes' attribute for specifying operand segments "
                       "must have 2 elements");
  }
    {
  auto tblgen_config = odsAttrs.get("config");
  if (!tblgen_config) return emitError(loc, "'tf.SendTPUEmbeddingGradients' op ""requires attribute 'config'");
    if (!((tblgen_config.isa<::mlir::StringAttr>()))) return emitError(loc, "'tf.SendTPUEmbeddingGradients' op ""attribute 'config' failed to satisfy constraint: string attribute");
  }
  return ::mlir::success();
}

::llvm::StringRef SendTPUEmbeddingGradientsOp::getOperationName() {
  return "tf.SendTPUEmbeddingGradients";
}

std::pair<unsigned, unsigned> SendTPUEmbeddingGradientsOp::getODSOperandIndexAndLength(unsigned index) {
  auto sizeAttr = getAttrOfType<::mlir::DenseIntElementsAttr>("operand_segment_sizes");

  unsigned start = 0;
  for (unsigned i = 0; i < index; ++i)
    start += (*(sizeAttr.begin() + i)).getZExtValue();
  unsigned size = (*(sizeAttr.begin() + index)).getZExtValue();
  return {start, size};
}

::mlir::Operation::operand_range SendTPUEmbeddingGradientsOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Operation::operand_range SendTPUEmbeddingGradientsOp::inputs() {
  return getODSOperands(0);
}

::mlir::Operation::operand_range SendTPUEmbeddingGradientsOp::learning_rates() {
  return getODSOperands(1);
}

::mlir::MutableOperandRange SendTPUEmbeddingGradientsOp::inputsMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second, ::mlir::MutableOperandRange::OperandSegment(0u, *getOperation()->getMutableAttrDict().getNamed("operand_segment_sizes")));
}

::mlir::MutableOperandRange SendTPUEmbeddingGradientsOp::learning_ratesMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second, ::mlir::MutableOperandRange::OperandSegment(1u, *getOperation()->getMutableAttrDict().getNamed("operand_segment_sizes")));
}

std::pair<unsigned, unsigned> SendTPUEmbeddingGradientsOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range SendTPUEmbeddingGradientsOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::StringAttr SendTPUEmbeddingGradientsOp::configAttr() {
  return this->getAttr("config").cast<::mlir::StringAttr>();
}

::llvm::StringRef SendTPUEmbeddingGradientsOp::config() {
  auto attr = configAttr();
  return attr.getValue();
}

size_t SendTPUEmbeddingGradientsOp::N() {
  auto range = getODSOperands(0);
return std::distance(range.begin(), range.end());
}

size_t SendTPUEmbeddingGradientsOp::NN() {
  auto range = getODSOperands(1);
return std::distance(range.begin(), range.end());
}

bool SendTPUEmbeddingGradientsOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "N") return true;
  if (name == "NN") return true;
 return false;
}

::mlir::DictionaryAttr SendTPUEmbeddingGradientsOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("N", ctx),
odsBuilder.getI64IntegerAttr(N())},
    {::mlir::Identifier::get("NN", ctx),
odsBuilder.getI64IntegerAttr(NN())}
    }, ctx);
}

void SendTPUEmbeddingGradientsOp::configAttr(::mlir::StringAttr attr) {
  this->getOperation()->setAttr("config", attr);
}

void SendTPUEmbeddingGradientsOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange inputs, ::mlir::ValueRange learning_rates, ::mlir::StringAttr config) {
  odsState.addOperands(inputs);
  odsState.addOperands(learning_rates);
  odsState.addAttribute("operand_segment_sizes", odsBuilder.getI32VectorAttr({static_cast<int32_t>(inputs.size()), static_cast<int32_t>(learning_rates.size())}));
  odsState.addAttribute("config", config);
}

void SendTPUEmbeddingGradientsOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange inputs, ::mlir::ValueRange learning_rates, ::mlir::StringAttr config) {
  odsState.addOperands(inputs);
  odsState.addOperands(learning_rates);
  odsState.addAttribute("operand_segment_sizes", odsBuilder.getI32VectorAttr({static_cast<int32_t>(inputs.size()), static_cast<int32_t>(learning_rates.size())}));
  odsState.addAttribute("config", config);
  assert(resultTypes.size() == 0u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void SendTPUEmbeddingGradientsOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange inputs, ::mlir::ValueRange learning_rates, ::llvm::StringRef config) {
  odsState.addOperands(inputs);
  odsState.addOperands(learning_rates);
  odsState.addAttribute("operand_segment_sizes", odsBuilder.getI32VectorAttr({static_cast<int32_t>(inputs.size()), static_cast<int32_t>(learning_rates.size())}));
  odsState.addAttribute("config", odsBuilder.getStringAttr(config));
}

void SendTPUEmbeddingGradientsOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange inputs, ::mlir::ValueRange learning_rates, ::llvm::StringRef config) {
  odsState.addOperands(inputs);
  odsState.addOperands(learning_rates);
  odsState.addAttribute("operand_segment_sizes", odsBuilder.getI32VectorAttr({static_cast<int32_t>(inputs.size()), static_cast<int32_t>(learning_rates.size())}));
  odsState.addAttribute("config", odsBuilder.getStringAttr(config));
  assert(resultTypes.size() == 0u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void SendTPUEmbeddingGradientsOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 0u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult SendTPUEmbeddingGradientsOp::verify() {
  if (failed(SendTPUEmbeddingGradientsOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>())))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::TensorFlowType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of tf.dtype values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>())))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::TensorFlowType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of tf.dtype values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
  }
  return ::mlir::success();
}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::SerializeIteratorOp definitions
//===----------------------------------------------------------------------===//

SerializeIteratorOpAdaptor::SerializeIteratorOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

SerializeIteratorOpAdaptor::SerializeIteratorOpAdaptor(SerializeIteratorOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> SerializeIteratorOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange SerializeIteratorOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value SerializeIteratorOpAdaptor::resource_handle() {
  return *getODSOperands(0).begin();
}

::mlir::IntegerAttr SerializeIteratorOpAdaptor::external_state_policy() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::IntegerAttr attr = odsAttrs.get("external_state_policy").dyn_cast_or_null<::mlir::IntegerAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getIntegerAttr(::mlir::Builder(odsAttrs.getContext()).getIntegerType(64), 0);
  return attr;
}

::mlir::LogicalResult SerializeIteratorOpAdaptor::verify(::mlir::Location loc) {
  {
  auto tblgen_external_state_policy = odsAttrs.get("external_state_policy");
  if (tblgen_external_state_policy) {
    if (!(((tblgen_external_state_policy.isa<::mlir::IntegerAttr>())) && ((tblgen_external_state_policy.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(64))))) return emitError(loc, "'tf.SerializeIterator' op ""attribute 'external_state_policy' failed to satisfy constraint: 64-bit signless integer attribute");
  }
  }
  return ::mlir::success();
}

::llvm::StringRef SerializeIteratorOp::getOperationName() {
  return "tf.SerializeIterator";
}

std::pair<unsigned, unsigned> SerializeIteratorOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range SerializeIteratorOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value SerializeIteratorOp::resource_handle() {
  return *getODSOperands(0).begin();
}

::mlir::MutableOperandRange SerializeIteratorOp::resource_handleMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> SerializeIteratorOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range SerializeIteratorOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value SerializeIteratorOp::serialized() {
  return *getODSResults(0).begin();
}

::mlir::IntegerAttr SerializeIteratorOp::external_state_policyAttr() {
  return this->getAttr("external_state_policy").dyn_cast_or_null<::mlir::IntegerAttr>();
}

uint64_t SerializeIteratorOp::external_state_policy() {
  auto attr = external_state_policyAttr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getIntegerAttr(::mlir::Builder(this->getContext()).getIntegerType(64), 0).getValue().getZExtValue();
  return attr.getValue().getZExtValue();
}

void SerializeIteratorOp::external_state_policyAttr(::mlir::IntegerAttr attr) {
  this->getOperation()->setAttr("external_state_policy", attr);
}

void SerializeIteratorOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type serialized, ::mlir::Value resource_handle, ::mlir::IntegerAttr external_state_policy) {
  odsState.addOperands(resource_handle);
  odsState.addAttribute("external_state_policy", external_state_policy);
  odsState.addTypes(serialized);
}

void SerializeIteratorOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value resource_handle, ::mlir::IntegerAttr external_state_policy) {
  odsState.addOperands(resource_handle);
  odsState.addAttribute("external_state_policy", external_state_policy);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void SerializeIteratorOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type serialized, ::mlir::Value resource_handle, uint64_t external_state_policy) {
  odsState.addOperands(resource_handle);
  odsState.addAttribute("external_state_policy", odsBuilder.getIntegerAttr(odsBuilder.getIntegerType(64), external_state_policy));
  odsState.addTypes(serialized);
}

void SerializeIteratorOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value resource_handle, uint64_t external_state_policy) {
  odsState.addOperands(resource_handle);
  odsState.addAttribute("external_state_policy", odsBuilder.getIntegerAttr(odsBuilder.getIntegerType(64), external_state_policy));
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void SerializeIteratorOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult SerializeIteratorOp::verify() {
  if (failed(SerializeIteratorOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::ResourceType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::ResourceRefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of resource values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::VariantType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::VariantRefType>()))))) {
        return emitOpError("result #") << index << " must be tensor of variant values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void SerializeIteratorOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
  for (::mlir::Value value : getODSOperands(0))
    effects.emplace_back(MemoryEffects::Read::get(), value, ::mlir::TF::ResourceEffects::DatasetIterator::get());
}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::ShapeNOp definitions
//===----------------------------------------------------------------------===//

ShapeNOpAdaptor::ShapeNOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

ShapeNOpAdaptor::ShapeNOpAdaptor(ShapeNOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> ShapeNOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  bool isVariadic[] = {true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (odsOperands.size() - 0) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::mlir::ValueRange ShapeNOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::ValueRange ShapeNOpAdaptor::input() {
  return getODSOperands(0);
}

::mlir::LogicalResult ShapeNOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

::llvm::StringRef ShapeNOp::getOperationName() {
  return "tf.ShapeN";
}

std::pair<unsigned, unsigned> ShapeNOp::getODSOperandIndexAndLength(unsigned index) {
  bool isVariadic[] = {true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (getOperation()->getNumOperands() - 0) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::mlir::Operation::operand_range ShapeNOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Operation::operand_range ShapeNOp::input() {
  return getODSOperands(0);
}

::mlir::MutableOperandRange ShapeNOp::inputMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> ShapeNOp::getODSResultIndexAndLength(unsigned index) {
  bool isVariadic[] = {true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (getOperation()->getNumResults() - 0) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::mlir::Operation::result_range ShapeNOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Operation::result_range ShapeNOp::output() {
  return getODSResults(0);
}

Type ShapeNOp::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

Type ShapeNOp::out_type() {
  return mlir::getElementTypeOrSelf(*getODSResults(0).begin());
}

size_t ShapeNOp::N() {
  auto range = getODSOperands(0);
return std::distance(range.begin(), range.end());
}

bool ShapeNOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "T") return true;
  if (name == "out_type") return true;
  if (name == "N") return true;
 return false;
}

::mlir::DictionaryAttr ShapeNOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())},
    {::mlir::Identifier::get("out_type", ctx),
::mlir::TypeAttr::get(out_type())},
    {::mlir::Identifier::get("N", ctx),
odsBuilder.getI64IntegerAttr(N())}
    }, ctx);
}

void ShapeNOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult ShapeNOp::verify() {
  if (failed(ShapeNOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>())))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::TensorFlowType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of tf.dtype values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))))) {
        return emitOpError("result #") << index << " must be tensor of 32/64-bit signed integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  return Verify(*this);
}



void ShapeNOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::ShapeOp definitions
//===----------------------------------------------------------------------===//

ShapeOpAdaptor::ShapeOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

ShapeOpAdaptor::ShapeOpAdaptor(ShapeOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> ShapeOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange ShapeOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value ShapeOpAdaptor::input() {
  return *getODSOperands(0).begin();
}

::mlir::LogicalResult ShapeOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

::llvm::StringRef ShapeOp::getOperationName() {
  return "tf.Shape";
}

std::pair<unsigned, unsigned> ShapeOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range ShapeOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value ShapeOp::input() {
  return *getODSOperands(0).begin();
}

::mlir::MutableOperandRange ShapeOp::inputMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> ShapeOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range ShapeOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value ShapeOp::output() {
  return *getODSResults(0).begin();
}

Type ShapeOp::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

Type ShapeOp::out_type() {
  return mlir::getElementTypeOrSelf(*getODSResults(0).begin());
}

bool ShapeOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "T") return true;
  if (name == "out_type") return true;
 return false;
}

::mlir::DictionaryAttr ShapeOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())},
    {::mlir::Identifier::get("out_type", ctx),
::mlir::TypeAttr::get(out_type())}
    }, ctx);
}



void ShapeOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value input) {
  odsState.addOperands(input);
  odsState.addTypes(output);
}

void ShapeOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input) {
  odsState.addOperands(input);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void ShapeOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult ShapeOp::verify() {
  if (failed(ShapeOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>())))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::TensorFlowType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of tf.dtype values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))))) {
        return emitOpError("result #") << index << " must be tensor of 32/64-bit signed integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  return Verify(*this);
}



void ShapeOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::ShardedFilenameOp definitions
//===----------------------------------------------------------------------===//

ShardedFilenameOpAdaptor::ShardedFilenameOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

ShardedFilenameOpAdaptor::ShardedFilenameOpAdaptor(ShardedFilenameOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> ShardedFilenameOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange ShardedFilenameOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value ShardedFilenameOpAdaptor::basename() {
  return *getODSOperands(0).begin();
}

::mlir::Value ShardedFilenameOpAdaptor::shard() {
  return *getODSOperands(1).begin();
}

::mlir::Value ShardedFilenameOpAdaptor::num_shards() {
  return *getODSOperands(2).begin();
}

::mlir::LogicalResult ShardedFilenameOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

::llvm::StringRef ShardedFilenameOp::getOperationName() {
  return "tf.ShardedFilename";
}

std::pair<unsigned, unsigned> ShardedFilenameOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range ShardedFilenameOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value ShardedFilenameOp::basename() {
  return *getODSOperands(0).begin();
}

::mlir::Value ShardedFilenameOp::shard() {
  return *getODSOperands(1).begin();
}

::mlir::Value ShardedFilenameOp::num_shards() {
  return *getODSOperands(2).begin();
}

::mlir::MutableOperandRange ShardedFilenameOp::basenameMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange ShardedFilenameOp::shardMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange ShardedFilenameOp::num_shardsMutable() {
  auto range = getODSOperandIndexAndLength(2);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> ShardedFilenameOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range ShardedFilenameOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value ShardedFilenameOp::filename() {
  return *getODSResults(0).begin();
}

void ShardedFilenameOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type filename, ::mlir::Value basename, ::mlir::Value shard, ::mlir::Value num_shards) {
  odsState.addOperands(basename);
  odsState.addOperands(shard);
  odsState.addOperands(num_shards);
  odsState.addTypes(filename);
}

void ShardedFilenameOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value basename, ::mlir::Value shard, ::mlir::Value num_shards) {
  odsState.addOperands(basename);
  odsState.addOperands(shard);
  odsState.addOperands(num_shards);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void ShardedFilenameOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 3u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult ShardedFilenameOp::verify() {
  if (failed(ShardedFilenameOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::StringType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::StringRefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of string values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of 32-bit integer values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup2 = getODSOperands(2);
    for (::mlir::Value v : valueGroup2) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of 32-bit integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::StringType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::StringRefType>()))))) {
        return emitOpError("result #") << index << " must be tensor of string values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void ShardedFilenameOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::ShuffleAndRepeatDatasetV2Op definitions
//===----------------------------------------------------------------------===//

ShuffleAndRepeatDatasetV2OpAdaptor::ShuffleAndRepeatDatasetV2OpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

ShuffleAndRepeatDatasetV2OpAdaptor::ShuffleAndRepeatDatasetV2OpAdaptor(ShuffleAndRepeatDatasetV2Op&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> ShuffleAndRepeatDatasetV2OpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange ShuffleAndRepeatDatasetV2OpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value ShuffleAndRepeatDatasetV2OpAdaptor::input_dataset() {
  return *getODSOperands(0).begin();
}

::mlir::Value ShuffleAndRepeatDatasetV2OpAdaptor::buffer_size() {
  return *getODSOperands(1).begin();
}

::mlir::Value ShuffleAndRepeatDatasetV2OpAdaptor::seed() {
  return *getODSOperands(2).begin();
}

::mlir::Value ShuffleAndRepeatDatasetV2OpAdaptor::seed2() {
  return *getODSOperands(3).begin();
}

::mlir::Value ShuffleAndRepeatDatasetV2OpAdaptor::count() {
  return *getODSOperands(4).begin();
}

::mlir::Value ShuffleAndRepeatDatasetV2OpAdaptor::seed_generator() {
  return *getODSOperands(5).begin();
}

::mlir::BoolAttr ShuffleAndRepeatDatasetV2OpAdaptor::reshuffle_each_iteration() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::BoolAttr attr = odsAttrs.get("reshuffle_each_iteration").dyn_cast_or_null<::mlir::BoolAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getBoolAttr(true);
  return attr;
}

::mlir::ArrayAttr ShuffleAndRepeatDatasetV2OpAdaptor::output_types() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::ArrayAttr attr = odsAttrs.get("output_types").cast<::mlir::ArrayAttr>();
  return attr;
}

::mlir::ArrayAttr ShuffleAndRepeatDatasetV2OpAdaptor::output_shapes() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::ArrayAttr attr = odsAttrs.get("output_shapes").cast<::mlir::ArrayAttr>();
  return attr;
}

::mlir::LogicalResult ShuffleAndRepeatDatasetV2OpAdaptor::verify(::mlir::Location loc) {
  {
  auto tblgen_reshuffle_each_iteration = odsAttrs.get("reshuffle_each_iteration");
  if (tblgen_reshuffle_each_iteration) {
    if (!((tblgen_reshuffle_each_iteration.isa<::mlir::BoolAttr>()))) return emitError(loc, "'tf.ShuffleAndRepeatDatasetV2' op ""attribute 'reshuffle_each_iteration' failed to satisfy constraint: bool attribute");
  }
  }
  {
  auto tblgen_output_types = odsAttrs.get("output_types");
  if (!tblgen_output_types) return emitError(loc, "'tf.ShuffleAndRepeatDatasetV2' op ""requires attribute 'output_types'");
    if (!((((tblgen_output_types.isa<::mlir::ArrayAttr>())) && (::llvm::all_of(tblgen_output_types.cast<::mlir::ArrayAttr>(), [](::mlir::Attribute attr) { return ((attr.isa<::mlir::TypeAttr>())) && ((attr.cast<::mlir::TypeAttr>().getValue().isa<::mlir::Type>())); }))) && ((tblgen_output_types.cast<::mlir::ArrayAttr>().size() >= 1)))) return emitError(loc, "'tf.ShuffleAndRepeatDatasetV2' op ""attribute 'output_types' failed to satisfy constraint: type array attribute with at least 1 elements");
  }
  {
  auto tblgen_output_shapes = odsAttrs.get("output_shapes");
  if (!tblgen_output_shapes) return emitError(loc, "'tf.ShuffleAndRepeatDatasetV2' op ""requires attribute 'output_shapes'");
    if (!((((tblgen_output_shapes.isa<::mlir::ArrayAttr>())) && (::llvm::all_of(tblgen_output_shapes.cast<::mlir::ArrayAttr>(), [](::mlir::Attribute attr) { return (attr.isa<mlir::TF::ShapeAttr>()); }))) && ((tblgen_output_shapes.cast<::mlir::ArrayAttr>().size() >= 1)))) return emitError(loc, "'tf.ShuffleAndRepeatDatasetV2' op ""attribute 'output_shapes' failed to satisfy constraint: tensorflow shape attribute array with at least 1 elements");
  }
  return ::mlir::success();
}

::llvm::StringRef ShuffleAndRepeatDatasetV2Op::getOperationName() {
  return "tf.ShuffleAndRepeatDatasetV2";
}

std::pair<unsigned, unsigned> ShuffleAndRepeatDatasetV2Op::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range ShuffleAndRepeatDatasetV2Op::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value ShuffleAndRepeatDatasetV2Op::input_dataset() {
  return *getODSOperands(0).begin();
}

::mlir::Value ShuffleAndRepeatDatasetV2Op::buffer_size() {
  return *getODSOperands(1).begin();
}

::mlir::Value ShuffleAndRepeatDatasetV2Op::seed() {
  return *getODSOperands(2).begin();
}

::mlir::Value ShuffleAndRepeatDatasetV2Op::seed2() {
  return *getODSOperands(3).begin();
}

::mlir::Value ShuffleAndRepeatDatasetV2Op::count() {
  return *getODSOperands(4).begin();
}

::mlir::Value ShuffleAndRepeatDatasetV2Op::seed_generator() {
  return *getODSOperands(5).begin();
}

::mlir::MutableOperandRange ShuffleAndRepeatDatasetV2Op::input_datasetMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange ShuffleAndRepeatDatasetV2Op::buffer_sizeMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange ShuffleAndRepeatDatasetV2Op::seedMutable() {
  auto range = getODSOperandIndexAndLength(2);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange ShuffleAndRepeatDatasetV2Op::seed2Mutable() {
  auto range = getODSOperandIndexAndLength(3);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange ShuffleAndRepeatDatasetV2Op::countMutable() {
  auto range = getODSOperandIndexAndLength(4);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange ShuffleAndRepeatDatasetV2Op::seed_generatorMutable() {
  auto range = getODSOperandIndexAndLength(5);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> ShuffleAndRepeatDatasetV2Op::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range ShuffleAndRepeatDatasetV2Op::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value ShuffleAndRepeatDatasetV2Op::handle() {
  return *getODSResults(0).begin();
}

::mlir::BoolAttr ShuffleAndRepeatDatasetV2Op::reshuffle_each_iterationAttr() {
  return this->getAttr("reshuffle_each_iteration").dyn_cast_or_null<::mlir::BoolAttr>();
}

bool ShuffleAndRepeatDatasetV2Op::reshuffle_each_iteration() {
  auto attr = reshuffle_each_iterationAttr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getBoolAttr(true).getValue();
  return attr.getValue();
}

::mlir::ArrayAttr ShuffleAndRepeatDatasetV2Op::output_typesAttr() {
  return this->getAttr("output_types").cast<::mlir::ArrayAttr>();
}

::mlir::ArrayAttr ShuffleAndRepeatDatasetV2Op::output_types() {
  auto attr = output_typesAttr();
  return attr;
}

::mlir::ArrayAttr ShuffleAndRepeatDatasetV2Op::output_shapesAttr() {
  return this->getAttr("output_shapes").cast<::mlir::ArrayAttr>();
}

::mlir::ArrayAttr ShuffleAndRepeatDatasetV2Op::output_shapes() {
  auto attr = output_shapesAttr();
  return attr;
}

void ShuffleAndRepeatDatasetV2Op::reshuffle_each_iterationAttr(::mlir::BoolAttr attr) {
  this->getOperation()->setAttr("reshuffle_each_iteration", attr);
}

void ShuffleAndRepeatDatasetV2Op::output_typesAttr(::mlir::ArrayAttr attr) {
  this->getOperation()->setAttr("output_types", attr);
}

void ShuffleAndRepeatDatasetV2Op::output_shapesAttr(::mlir::ArrayAttr attr) {
  this->getOperation()->setAttr("output_shapes", attr);
}

void ShuffleAndRepeatDatasetV2Op::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type handle, ::mlir::Value input_dataset, ::mlir::Value buffer_size, ::mlir::Value seed, ::mlir::Value seed2, ::mlir::Value count, ::mlir::Value seed_generator, ::mlir::BoolAttr reshuffle_each_iteration, ::mlir::ArrayAttr output_types, ::mlir::ArrayAttr output_shapes) {
  odsState.addOperands(input_dataset);
  odsState.addOperands(buffer_size);
  odsState.addOperands(seed);
  odsState.addOperands(seed2);
  odsState.addOperands(count);
  odsState.addOperands(seed_generator);
  odsState.addAttribute("reshuffle_each_iteration", reshuffle_each_iteration);
  odsState.addAttribute("output_types", output_types);
  odsState.addAttribute("output_shapes", output_shapes);
  odsState.addTypes(handle);
}

void ShuffleAndRepeatDatasetV2Op::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input_dataset, ::mlir::Value buffer_size, ::mlir::Value seed, ::mlir::Value seed2, ::mlir::Value count, ::mlir::Value seed_generator, ::mlir::BoolAttr reshuffle_each_iteration, ::mlir::ArrayAttr output_types, ::mlir::ArrayAttr output_shapes) {
  odsState.addOperands(input_dataset);
  odsState.addOperands(buffer_size);
  odsState.addOperands(seed);
  odsState.addOperands(seed2);
  odsState.addOperands(count);
  odsState.addOperands(seed_generator);
  odsState.addAttribute("reshuffle_each_iteration", reshuffle_each_iteration);
  odsState.addAttribute("output_types", output_types);
  odsState.addAttribute("output_shapes", output_shapes);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void ShuffleAndRepeatDatasetV2Op::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type handle, ::mlir::Value input_dataset, ::mlir::Value buffer_size, ::mlir::Value seed, ::mlir::Value seed2, ::mlir::Value count, ::mlir::Value seed_generator, bool reshuffle_each_iteration, ::mlir::ArrayAttr output_types, ::mlir::ArrayAttr output_shapes) {
  odsState.addOperands(input_dataset);
  odsState.addOperands(buffer_size);
  odsState.addOperands(seed);
  odsState.addOperands(seed2);
  odsState.addOperands(count);
  odsState.addOperands(seed_generator);
  odsState.addAttribute("reshuffle_each_iteration", odsBuilder.getBoolAttr(reshuffle_each_iteration));
  odsState.addAttribute("output_types", output_types);
  odsState.addAttribute("output_shapes", output_shapes);
  odsState.addTypes(handle);
}

void ShuffleAndRepeatDatasetV2Op::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input_dataset, ::mlir::Value buffer_size, ::mlir::Value seed, ::mlir::Value seed2, ::mlir::Value count, ::mlir::Value seed_generator, bool reshuffle_each_iteration, ::mlir::ArrayAttr output_types, ::mlir::ArrayAttr output_shapes) {
  odsState.addOperands(input_dataset);
  odsState.addOperands(buffer_size);
  odsState.addOperands(seed);
  odsState.addOperands(seed2);
  odsState.addOperands(count);
  odsState.addOperands(seed_generator);
  odsState.addAttribute("reshuffle_each_iteration", odsBuilder.getBoolAttr(reshuffle_each_iteration));
  odsState.addAttribute("output_types", output_types);
  odsState.addAttribute("output_shapes", output_shapes);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void ShuffleAndRepeatDatasetV2Op::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 6u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult ShuffleAndRepeatDatasetV2Op::verify() {
  if (failed(ShuffleAndRepeatDatasetV2OpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::VariantType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::VariantRefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of variant values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of 64-bit integer values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup2 = getODSOperands(2);
    for (::mlir::Value v : valueGroup2) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of 64-bit integer values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup3 = getODSOperands(3);
    for (::mlir::Value v : valueGroup3) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of 64-bit integer values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup4 = getODSOperands(4);
    for (::mlir::Value v : valueGroup4) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of 64-bit integer values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup5 = getODSOperands(5);
    for (::mlir::Value v : valueGroup5) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::ResourceType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::ResourceRefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of resource values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::VariantType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::VariantRefType>()))))) {
        return emitOpError("result #") << index << " must be tensor of variant values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void ShuffleAndRepeatDatasetV2Op::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
  for (::mlir::Value value : getODSOperands(5))
    effects.emplace_back(MemoryEffects::Read::get(), value, ::mlir::TF::ResourceEffects::DatasetSeedGenerator::get());
  for (::mlir::Value value : getODSOperands(5))
    effects.emplace_back(MemoryEffects::Write::get(), value, ::mlir::TF::ResourceEffects::DatasetSeedGenerator::get());
}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::ShuffleDatasetV2Op definitions
//===----------------------------------------------------------------------===//

ShuffleDatasetV2OpAdaptor::ShuffleDatasetV2OpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

ShuffleDatasetV2OpAdaptor::ShuffleDatasetV2OpAdaptor(ShuffleDatasetV2Op&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> ShuffleDatasetV2OpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange ShuffleDatasetV2OpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value ShuffleDatasetV2OpAdaptor::input_dataset() {
  return *getODSOperands(0).begin();
}

::mlir::Value ShuffleDatasetV2OpAdaptor::buffer_size() {
  return *getODSOperands(1).begin();
}

::mlir::Value ShuffleDatasetV2OpAdaptor::seed_generator() {
  return *getODSOperands(2).begin();
}

::mlir::ArrayAttr ShuffleDatasetV2OpAdaptor::output_types() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::ArrayAttr attr = odsAttrs.get("output_types").cast<::mlir::ArrayAttr>();
  return attr;
}

::mlir::ArrayAttr ShuffleDatasetV2OpAdaptor::output_shapes() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::ArrayAttr attr = odsAttrs.get("output_shapes").cast<::mlir::ArrayAttr>();
  return attr;
}

::mlir::LogicalResult ShuffleDatasetV2OpAdaptor::verify(::mlir::Location loc) {
  {
  auto tblgen_output_types = odsAttrs.get("output_types");
  if (!tblgen_output_types) return emitError(loc, "'tf.ShuffleDatasetV2' op ""requires attribute 'output_types'");
    if (!((((tblgen_output_types.isa<::mlir::ArrayAttr>())) && (::llvm::all_of(tblgen_output_types.cast<::mlir::ArrayAttr>(), [](::mlir::Attribute attr) { return ((attr.isa<::mlir::TypeAttr>())) && ((attr.cast<::mlir::TypeAttr>().getValue().isa<::mlir::Type>())); }))) && ((tblgen_output_types.cast<::mlir::ArrayAttr>().size() >= 1)))) return emitError(loc, "'tf.ShuffleDatasetV2' op ""attribute 'output_types' failed to satisfy constraint: type array attribute with at least 1 elements");
  }
  {
  auto tblgen_output_shapes = odsAttrs.get("output_shapes");
  if (!tblgen_output_shapes) return emitError(loc, "'tf.ShuffleDatasetV2' op ""requires attribute 'output_shapes'");
    if (!((((tblgen_output_shapes.isa<::mlir::ArrayAttr>())) && (::llvm::all_of(tblgen_output_shapes.cast<::mlir::ArrayAttr>(), [](::mlir::Attribute attr) { return (attr.isa<mlir::TF::ShapeAttr>()); }))) && ((tblgen_output_shapes.cast<::mlir::ArrayAttr>().size() >= 1)))) return emitError(loc, "'tf.ShuffleDatasetV2' op ""attribute 'output_shapes' failed to satisfy constraint: tensorflow shape attribute array with at least 1 elements");
  }
  return ::mlir::success();
}

::llvm::StringRef ShuffleDatasetV2Op::getOperationName() {
  return "tf.ShuffleDatasetV2";
}

std::pair<unsigned, unsigned> ShuffleDatasetV2Op::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range ShuffleDatasetV2Op::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value ShuffleDatasetV2Op::input_dataset() {
  return *getODSOperands(0).begin();
}

::mlir::Value ShuffleDatasetV2Op::buffer_size() {
  return *getODSOperands(1).begin();
}

::mlir::Value ShuffleDatasetV2Op::seed_generator() {
  return *getODSOperands(2).begin();
}

::mlir::MutableOperandRange ShuffleDatasetV2Op::input_datasetMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange ShuffleDatasetV2Op::buffer_sizeMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange ShuffleDatasetV2Op::seed_generatorMutable() {
  auto range = getODSOperandIndexAndLength(2);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> ShuffleDatasetV2Op::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range ShuffleDatasetV2Op::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value ShuffleDatasetV2Op::handle() {
  return *getODSResults(0).begin();
}

::mlir::ArrayAttr ShuffleDatasetV2Op::output_typesAttr() {
  return this->getAttr("output_types").cast<::mlir::ArrayAttr>();
}

::mlir::ArrayAttr ShuffleDatasetV2Op::output_types() {
  auto attr = output_typesAttr();
  return attr;
}

::mlir::ArrayAttr ShuffleDatasetV2Op::output_shapesAttr() {
  return this->getAttr("output_shapes").cast<::mlir::ArrayAttr>();
}

::mlir::ArrayAttr ShuffleDatasetV2Op::output_shapes() {
  auto attr = output_shapesAttr();
  return attr;
}

void ShuffleDatasetV2Op::output_typesAttr(::mlir::ArrayAttr attr) {
  this->getOperation()->setAttr("output_types", attr);
}

void ShuffleDatasetV2Op::output_shapesAttr(::mlir::ArrayAttr attr) {
  this->getOperation()->setAttr("output_shapes", attr);
}

void ShuffleDatasetV2Op::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type handle, ::mlir::Value input_dataset, ::mlir::Value buffer_size, ::mlir::Value seed_generator, ::mlir::ArrayAttr output_types, ::mlir::ArrayAttr output_shapes) {
  odsState.addOperands(input_dataset);
  odsState.addOperands(buffer_size);
  odsState.addOperands(seed_generator);
  odsState.addAttribute("output_types", output_types);
  odsState.addAttribute("output_shapes", output_shapes);
  odsState.addTypes(handle);
}

void ShuffleDatasetV2Op::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input_dataset, ::mlir::Value buffer_size, ::mlir::Value seed_generator, ::mlir::ArrayAttr output_types, ::mlir::ArrayAttr output_shapes) {
  odsState.addOperands(input_dataset);
  odsState.addOperands(buffer_size);
  odsState.addOperands(seed_generator);
  odsState.addAttribute("output_types", output_types);
  odsState.addAttribute("output_shapes", output_shapes);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void ShuffleDatasetV2Op::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 3u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult ShuffleDatasetV2Op::verify() {
  if (failed(ShuffleDatasetV2OpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::VariantType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::VariantRefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of variant values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of 64-bit integer values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup2 = getODSOperands(2);
    for (::mlir::Value v : valueGroup2) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::ResourceType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::ResourceRefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of resource values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::VariantType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::VariantRefType>()))))) {
        return emitOpError("result #") << index << " must be tensor of variant values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void ShuffleDatasetV2Op::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
  for (::mlir::Value value : getODSOperands(2))
    effects.emplace_back(MemoryEffects::Read::get(), value, ::mlir::TF::ResourceEffects::DatasetSeedGenerator::get());
  for (::mlir::Value value : getODSOperands(2))
    effects.emplace_back(MemoryEffects::Write::get(), value, ::mlir::TF::ResourceEffects::DatasetSeedGenerator::get());
}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::ShuffleDatasetV3Op definitions
//===----------------------------------------------------------------------===//

ShuffleDatasetV3OpAdaptor::ShuffleDatasetV3OpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

ShuffleDatasetV3OpAdaptor::ShuffleDatasetV3OpAdaptor(ShuffleDatasetV3Op&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> ShuffleDatasetV3OpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange ShuffleDatasetV3OpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value ShuffleDatasetV3OpAdaptor::input_dataset() {
  return *getODSOperands(0).begin();
}

::mlir::Value ShuffleDatasetV3OpAdaptor::buffer_size() {
  return *getODSOperands(1).begin();
}

::mlir::Value ShuffleDatasetV3OpAdaptor::seed() {
  return *getODSOperands(2).begin();
}

::mlir::Value ShuffleDatasetV3OpAdaptor::seed2() {
  return *getODSOperands(3).begin();
}

::mlir::Value ShuffleDatasetV3OpAdaptor::seed_generator() {
  return *getODSOperands(4).begin();
}

::mlir::BoolAttr ShuffleDatasetV3OpAdaptor::reshuffle_each_iteration() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::BoolAttr attr = odsAttrs.get("reshuffle_each_iteration").dyn_cast_or_null<::mlir::BoolAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getBoolAttr(true);
  return attr;
}

::mlir::ArrayAttr ShuffleDatasetV3OpAdaptor::output_types() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::ArrayAttr attr = odsAttrs.get("output_types").cast<::mlir::ArrayAttr>();
  return attr;
}

::mlir::ArrayAttr ShuffleDatasetV3OpAdaptor::output_shapes() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::ArrayAttr attr = odsAttrs.get("output_shapes").cast<::mlir::ArrayAttr>();
  return attr;
}

::mlir::LogicalResult ShuffleDatasetV3OpAdaptor::verify(::mlir::Location loc) {
  {
  auto tblgen_reshuffle_each_iteration = odsAttrs.get("reshuffle_each_iteration");
  if (tblgen_reshuffle_each_iteration) {
    if (!((tblgen_reshuffle_each_iteration.isa<::mlir::BoolAttr>()))) return emitError(loc, "'tf.ShuffleDatasetV3' op ""attribute 'reshuffle_each_iteration' failed to satisfy constraint: bool attribute");
  }
  }
  {
  auto tblgen_output_types = odsAttrs.get("output_types");
  if (!tblgen_output_types) return emitError(loc, "'tf.ShuffleDatasetV3' op ""requires attribute 'output_types'");
    if (!((((tblgen_output_types.isa<::mlir::ArrayAttr>())) && (::llvm::all_of(tblgen_output_types.cast<::mlir::ArrayAttr>(), [](::mlir::Attribute attr) { return ((attr.isa<::mlir::TypeAttr>())) && ((attr.cast<::mlir::TypeAttr>().getValue().isa<::mlir::Type>())); }))) && ((tblgen_output_types.cast<::mlir::ArrayAttr>().size() >= 1)))) return emitError(loc, "'tf.ShuffleDatasetV3' op ""attribute 'output_types' failed to satisfy constraint: type array attribute with at least 1 elements");
  }
  {
  auto tblgen_output_shapes = odsAttrs.get("output_shapes");
  if (!tblgen_output_shapes) return emitError(loc, "'tf.ShuffleDatasetV3' op ""requires attribute 'output_shapes'");
    if (!((((tblgen_output_shapes.isa<::mlir::ArrayAttr>())) && (::llvm::all_of(tblgen_output_shapes.cast<::mlir::ArrayAttr>(), [](::mlir::Attribute attr) { return (attr.isa<mlir::TF::ShapeAttr>()); }))) && ((tblgen_output_shapes.cast<::mlir::ArrayAttr>().size() >= 1)))) return emitError(loc, "'tf.ShuffleDatasetV3' op ""attribute 'output_shapes' failed to satisfy constraint: tensorflow shape attribute array with at least 1 elements");
  }
  return ::mlir::success();
}

::llvm::StringRef ShuffleDatasetV3Op::getOperationName() {
  return "tf.ShuffleDatasetV3";
}

std::pair<unsigned, unsigned> ShuffleDatasetV3Op::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range ShuffleDatasetV3Op::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value ShuffleDatasetV3Op::input_dataset() {
  return *getODSOperands(0).begin();
}

::mlir::Value ShuffleDatasetV3Op::buffer_size() {
  return *getODSOperands(1).begin();
}

::mlir::Value ShuffleDatasetV3Op::seed() {
  return *getODSOperands(2).begin();
}

::mlir::Value ShuffleDatasetV3Op::seed2() {
  return *getODSOperands(3).begin();
}

::mlir::Value ShuffleDatasetV3Op::seed_generator() {
  return *getODSOperands(4).begin();
}

::mlir::MutableOperandRange ShuffleDatasetV3Op::input_datasetMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange ShuffleDatasetV3Op::buffer_sizeMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange ShuffleDatasetV3Op::seedMutable() {
  auto range = getODSOperandIndexAndLength(2);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange ShuffleDatasetV3Op::seed2Mutable() {
  auto range = getODSOperandIndexAndLength(3);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange ShuffleDatasetV3Op::seed_generatorMutable() {
  auto range = getODSOperandIndexAndLength(4);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> ShuffleDatasetV3Op::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range ShuffleDatasetV3Op::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value ShuffleDatasetV3Op::handle() {
  return *getODSResults(0).begin();
}

::mlir::BoolAttr ShuffleDatasetV3Op::reshuffle_each_iterationAttr() {
  return this->getAttr("reshuffle_each_iteration").dyn_cast_or_null<::mlir::BoolAttr>();
}

bool ShuffleDatasetV3Op::reshuffle_each_iteration() {
  auto attr = reshuffle_each_iterationAttr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getBoolAttr(true).getValue();
  return attr.getValue();
}

::mlir::ArrayAttr ShuffleDatasetV3Op::output_typesAttr() {
  return this->getAttr("output_types").cast<::mlir::ArrayAttr>();
}

::mlir::ArrayAttr ShuffleDatasetV3Op::output_types() {
  auto attr = output_typesAttr();
  return attr;
}

::mlir::ArrayAttr ShuffleDatasetV3Op::output_shapesAttr() {
  return this->getAttr("output_shapes").cast<::mlir::ArrayAttr>();
}

::mlir::ArrayAttr ShuffleDatasetV3Op::output_shapes() {
  auto attr = output_shapesAttr();
  return attr;
}

void ShuffleDatasetV3Op::reshuffle_each_iterationAttr(::mlir::BoolAttr attr) {
  this->getOperation()->setAttr("reshuffle_each_iteration", attr);
}

void ShuffleDatasetV3Op::output_typesAttr(::mlir::ArrayAttr attr) {
  this->getOperation()->setAttr("output_types", attr);
}

void ShuffleDatasetV3Op::output_shapesAttr(::mlir::ArrayAttr attr) {
  this->getOperation()->setAttr("output_shapes", attr);
}

void ShuffleDatasetV3Op::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type handle, ::mlir::Value input_dataset, ::mlir::Value buffer_size, ::mlir::Value seed, ::mlir::Value seed2, ::mlir::Value seed_generator, ::mlir::BoolAttr reshuffle_each_iteration, ::mlir::ArrayAttr output_types, ::mlir::ArrayAttr output_shapes) {
  odsState.addOperands(input_dataset);
  odsState.addOperands(buffer_size);
  odsState.addOperands(seed);
  odsState.addOperands(seed2);
  odsState.addOperands(seed_generator);
  odsState.addAttribute("reshuffle_each_iteration", reshuffle_each_iteration);
  odsState.addAttribute("output_types", output_types);
  odsState.addAttribute("output_shapes", output_shapes);
  odsState.addTypes(handle);
}

void ShuffleDatasetV3Op::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input_dataset, ::mlir::Value buffer_size, ::mlir::Value seed, ::mlir::Value seed2, ::mlir::Value seed_generator, ::mlir::BoolAttr reshuffle_each_iteration, ::mlir::ArrayAttr output_types, ::mlir::ArrayAttr output_shapes) {
  odsState.addOperands(input_dataset);
  odsState.addOperands(buffer_size);
  odsState.addOperands(seed);
  odsState.addOperands(seed2);
  odsState.addOperands(seed_generator);
  odsState.addAttribute("reshuffle_each_iteration", reshuffle_each_iteration);
  odsState.addAttribute("output_types", output_types);
  odsState.addAttribute("output_shapes", output_shapes);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void ShuffleDatasetV3Op::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type handle, ::mlir::Value input_dataset, ::mlir::Value buffer_size, ::mlir::Value seed, ::mlir::Value seed2, ::mlir::Value seed_generator, bool reshuffle_each_iteration, ::mlir::ArrayAttr output_types, ::mlir::ArrayAttr output_shapes) {
  odsState.addOperands(input_dataset);
  odsState.addOperands(buffer_size);
  odsState.addOperands(seed);
  odsState.addOperands(seed2);
  odsState.addOperands(seed_generator);
  odsState.addAttribute("reshuffle_each_iteration", odsBuilder.getBoolAttr(reshuffle_each_iteration));
  odsState.addAttribute("output_types", output_types);
  odsState.addAttribute("output_shapes", output_shapes);
  odsState.addTypes(handle);
}

void ShuffleDatasetV3Op::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input_dataset, ::mlir::Value buffer_size, ::mlir::Value seed, ::mlir::Value seed2, ::mlir::Value seed_generator, bool reshuffle_each_iteration, ::mlir::ArrayAttr output_types, ::mlir::ArrayAttr output_shapes) {
  odsState.addOperands(input_dataset);
  odsState.addOperands(buffer_size);
  odsState.addOperands(seed);
  odsState.addOperands(seed2);
  odsState.addOperands(seed_generator);
  odsState.addAttribute("reshuffle_each_iteration", odsBuilder.getBoolAttr(reshuffle_each_iteration));
  odsState.addAttribute("output_types", output_types);
  odsState.addAttribute("output_shapes", output_shapes);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void ShuffleDatasetV3Op::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 5u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult ShuffleDatasetV3Op::verify() {
  if (failed(ShuffleDatasetV3OpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::VariantType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::VariantRefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of variant values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of 64-bit integer values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup2 = getODSOperands(2);
    for (::mlir::Value v : valueGroup2) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of 64-bit integer values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup3 = getODSOperands(3);
    for (::mlir::Value v : valueGroup3) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of 64-bit integer values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup4 = getODSOperands(4);
    for (::mlir::Value v : valueGroup4) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::ResourceType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::ResourceRefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of resource values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::VariantType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::VariantRefType>()))))) {
        return emitOpError("result #") << index << " must be tensor of variant values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void ShuffleDatasetV3Op::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
  for (::mlir::Value value : getODSOperands(4))
    effects.emplace_back(MemoryEffects::Read::get(), value, ::mlir::TF::ResourceEffects::DatasetSeedGenerator::get());
  for (::mlir::Value value : getODSOperands(4))
    effects.emplace_back(MemoryEffects::Write::get(), value, ::mlir::TF::ResourceEffects::DatasetSeedGenerator::get());
}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::ShutdownDistributedTPUOp definitions
//===----------------------------------------------------------------------===//

ShutdownDistributedTPUOpAdaptor::ShutdownDistributedTPUOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

ShutdownDistributedTPUOpAdaptor::ShutdownDistributedTPUOpAdaptor(ShutdownDistributedTPUOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> ShutdownDistributedTPUOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange ShutdownDistributedTPUOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::LogicalResult ShutdownDistributedTPUOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

::llvm::StringRef ShutdownDistributedTPUOp::getOperationName() {
  return "tf.ShutdownDistributedTPU";
}

std::pair<unsigned, unsigned> ShutdownDistributedTPUOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range ShutdownDistributedTPUOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

std::pair<unsigned, unsigned> ShutdownDistributedTPUOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range ShutdownDistributedTPUOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

void ShutdownDistributedTPUOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState) {

}

void ShutdownDistributedTPUOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes) {
  assert(resultTypes.size() == 0u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void ShutdownDistributedTPUOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 0u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 0u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult ShutdownDistributedTPUOp::verify() {
  if (failed(ShutdownDistributedTPUOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
  }
  {
    unsigned index = 0; (void)index;
  }
  return ::mlir::success();
}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::SigmoidGradOp definitions
//===----------------------------------------------------------------------===//

SigmoidGradOpAdaptor::SigmoidGradOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

SigmoidGradOpAdaptor::SigmoidGradOpAdaptor(SigmoidGradOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> SigmoidGradOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange SigmoidGradOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value SigmoidGradOpAdaptor::y() {
  return *getODSOperands(0).begin();
}

::mlir::Value SigmoidGradOpAdaptor::dy() {
  return *getODSOperands(1).begin();
}

::mlir::LogicalResult SigmoidGradOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

::llvm::StringRef SigmoidGradOp::getOperationName() {
  return "tf.SigmoidGrad";
}

std::pair<unsigned, unsigned> SigmoidGradOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range SigmoidGradOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value SigmoidGradOp::y() {
  return *getODSOperands(0).begin();
}

::mlir::Value SigmoidGradOp::dy() {
  return *getODSOperands(1).begin();
}

::mlir::MutableOperandRange SigmoidGradOp::yMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange SigmoidGradOp::dyMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> SigmoidGradOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range SigmoidGradOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value SigmoidGradOp::z() {
  return *getODSResults(0).begin();
}

Type SigmoidGradOp::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

bool SigmoidGradOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "T") return true;
 return false;
}

::mlir::DictionaryAttr SigmoidGradOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())}
    }, ctx);
}

void SigmoidGradOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type z, ::mlir::Value y, ::mlir::Value dy) {
  odsState.addOperands(y);
  odsState.addOperands(dy);
  odsState.addTypes(z);
}

void SigmoidGradOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value y, ::mlir::Value dy) {
  odsState.addOperands(y);
  odsState.addOperands(dy);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void SigmoidGradOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

void SigmoidGradOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value y, ::mlir::Value dy) {
  odsState.addOperands(y);
  odsState.addOperands(dy);
  odsState.addTypes({y.getType()});

}

void SigmoidGradOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  odsState.addTypes({operands[0].getType()});

}

::mlir::LogicalResult SigmoidGradOp::verify() {
  if (failed(SigmoidGradOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))))))) {
        return emitOpError("operand #") << index << " must be tensor of floating-point or complex values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))))))) {
        return emitOpError("operand #") << index << " must be tensor of floating-point or complex values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))))))) {
        return emitOpError("result #") << index << " must be tensor of floating-point or complex values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void SigmoidGradOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::SigmoidOp definitions
//===----------------------------------------------------------------------===//

SigmoidOpAdaptor::SigmoidOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

SigmoidOpAdaptor::SigmoidOpAdaptor(SigmoidOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> SigmoidOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange SigmoidOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value SigmoidOpAdaptor::x() {
  return *getODSOperands(0).begin();
}

::mlir::LogicalResult SigmoidOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

::llvm::StringRef SigmoidOp::getOperationName() {
  return "tf.Sigmoid";
}

std::pair<unsigned, unsigned> SigmoidOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range SigmoidOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value SigmoidOp::x() {
  return *getODSOperands(0).begin();
}

::mlir::MutableOperandRange SigmoidOp::xMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> SigmoidOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range SigmoidOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value SigmoidOp::y() {
  return *getODSResults(0).begin();
}

Type SigmoidOp::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

bool SigmoidOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "T") return true;
 return false;
}

::mlir::DictionaryAttr SigmoidOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())}
    }, ctx);
}

void SigmoidOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type y, ::mlir::Value x) {
  odsState.addOperands(x);
  odsState.addTypes(y);
}

void SigmoidOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value x) {
  odsState.addOperands(x);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void SigmoidOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

void SigmoidOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value x) {
  odsState.addOperands(x);
  odsState.addTypes({x.getType()});

}

void SigmoidOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  odsState.addTypes({operands[0].getType()});

}

::mlir::LogicalResult SigmoidOp::verify() {
  if (failed(SigmoidOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))))))) {
        return emitOpError("operand #") << index << " must be tensor of floating-point or complex values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))))))) {
        return emitOpError("result #") << index << " must be tensor of floating-point or complex values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void SigmoidOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::SignOp definitions
//===----------------------------------------------------------------------===//

SignOpAdaptor::SignOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

SignOpAdaptor::SignOpAdaptor(SignOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> SignOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange SignOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value SignOpAdaptor::x() {
  return *getODSOperands(0).begin();
}

::mlir::LogicalResult SignOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

::llvm::StringRef SignOp::getOperationName() {
  return "tf.Sign";
}

std::pair<unsigned, unsigned> SignOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range SignOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value SignOp::x() {
  return *getODSOperands(0).begin();
}

::mlir::MutableOperandRange SignOp::xMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> SignOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range SignOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value SignOp::y() {
  return *getODSResults(0).begin();
}

Type SignOp::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

bool SignOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "T") return true;
 return false;
}

::mlir::DictionaryAttr SignOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())}
    }, ctx);
}

void SignOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type y, ::mlir::Value x) {
  odsState.addOperands(x);
  odsState.addTypes(y);
}

void SignOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value x) {
  odsState.addOperands(x);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void SignOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

void SignOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value x) {
  odsState.addOperands(x);
  odsState.addTypes({x.getType()});

}

void SignOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  odsState.addTypes({operands[0].getType()});

}

::mlir::LogicalResult SignOp::verify() {
  if (failed(SignOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of bfloat16 or 128-bit complex or 64-bit complex or 16-bit float or 32-bit float or 64-bit float or 32-bit integer or 64-bit integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))))) {
        return emitOpError("result #") << index << " must be tensor of bfloat16 or 128-bit complex or 64-bit complex or 16-bit float or 32-bit float or 64-bit float or 32-bit integer or 64-bit integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void SignOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::SinOp definitions
//===----------------------------------------------------------------------===//

SinOpAdaptor::SinOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

SinOpAdaptor::SinOpAdaptor(SinOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> SinOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange SinOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value SinOpAdaptor::x() {
  return *getODSOperands(0).begin();
}

::mlir::LogicalResult SinOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

::llvm::StringRef SinOp::getOperationName() {
  return "tf.Sin";
}

std::pair<unsigned, unsigned> SinOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range SinOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value SinOp::x() {
  return *getODSOperands(0).begin();
}

::mlir::MutableOperandRange SinOp::xMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> SinOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range SinOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value SinOp::y() {
  return *getODSResults(0).begin();
}

Type SinOp::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

bool SinOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "T") return true;
 return false;
}

::mlir::DictionaryAttr SinOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())}
    }, ctx);
}

void SinOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type y, ::mlir::Value x) {
  odsState.addOperands(x);
  odsState.addTypes(y);
}

void SinOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value x) {
  odsState.addOperands(x);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void SinOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

void SinOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value x) {
  odsState.addOperands(x);
  odsState.addTypes({x.getType()});

}

void SinOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  odsState.addTypes({operands[0].getType()});

}

::mlir::LogicalResult SinOp::verify() {
  if (failed(SinOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))))))) {
        return emitOpError("operand #") << index << " must be tensor of floating-point or complex values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))))))) {
        return emitOpError("result #") << index << " must be tensor of floating-point or complex values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void SinOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::SinhOp definitions
//===----------------------------------------------------------------------===//

SinhOpAdaptor::SinhOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

SinhOpAdaptor::SinhOpAdaptor(SinhOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> SinhOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange SinhOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value SinhOpAdaptor::x() {
  return *getODSOperands(0).begin();
}

::mlir::LogicalResult SinhOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

::llvm::StringRef SinhOp::getOperationName() {
  return "tf.Sinh";
}

std::pair<unsigned, unsigned> SinhOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range SinhOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value SinhOp::x() {
  return *getODSOperands(0).begin();
}

::mlir::MutableOperandRange SinhOp::xMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> SinhOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range SinhOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value SinhOp::y() {
  return *getODSResults(0).begin();
}

Type SinhOp::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

bool SinhOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "T") return true;
 return false;
}

::mlir::DictionaryAttr SinhOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())}
    }, ctx);
}

void SinhOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type y, ::mlir::Value x) {
  odsState.addOperands(x);
  odsState.addTypes(y);
}

void SinhOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value x) {
  odsState.addOperands(x);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void SinhOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

void SinhOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value x) {
  odsState.addOperands(x);
  odsState.addTypes({x.getType()});

}

void SinhOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  odsState.addTypes({operands[0].getType()});

}

::mlir::LogicalResult SinhOp::verify() {
  if (failed(SinhOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))))))) {
        return emitOpError("operand #") << index << " must be tensor of floating-point or complex values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))))))) {
        return emitOpError("result #") << index << " must be tensor of floating-point or complex values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void SinhOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::SizeOp definitions
//===----------------------------------------------------------------------===//

SizeOpAdaptor::SizeOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

SizeOpAdaptor::SizeOpAdaptor(SizeOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> SizeOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange SizeOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value SizeOpAdaptor::input() {
  return *getODSOperands(0).begin();
}

::mlir::LogicalResult SizeOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

::llvm::StringRef SizeOp::getOperationName() {
  return "tf.Size";
}

std::pair<unsigned, unsigned> SizeOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range SizeOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value SizeOp::input() {
  return *getODSOperands(0).begin();
}

::mlir::MutableOperandRange SizeOp::inputMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> SizeOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range SizeOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value SizeOp::output() {
  return *getODSResults(0).begin();
}

Type SizeOp::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

Type SizeOp::out_type() {
  return mlir::getElementTypeOrSelf(*getODSResults(0).begin());
}

bool SizeOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "T") return true;
  if (name == "out_type") return true;
 return false;
}

::mlir::DictionaryAttr SizeOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())},
    {::mlir::Identifier::get("out_type", ctx),
::mlir::TypeAttr::get(out_type())}
    }, ctx);
}

void SizeOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value input) {
  odsState.addOperands(input);
  odsState.addTypes(output);
}

void SizeOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input) {
  odsState.addOperands(input);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void SizeOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult SizeOp::verify() {
  if (failed(SizeOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>())))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::TensorFlowType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of tf.dtype values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))))) {
        return emitOpError("result #") << index << " must be tensor of 32/64-bit signed integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  return Verify(*this);
}



void SizeOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::SliceOp definitions
//===----------------------------------------------------------------------===//

SliceOpAdaptor::SliceOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

SliceOpAdaptor::SliceOpAdaptor(SliceOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> SliceOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange SliceOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value SliceOpAdaptor::input() {
  return *getODSOperands(0).begin();
}

::mlir::Value SliceOpAdaptor::begin() {
  return *getODSOperands(1).begin();
}

::mlir::Value SliceOpAdaptor::size() {
  return *getODSOperands(2).begin();
}

::mlir::LogicalResult SliceOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

::llvm::StringRef SliceOp::getOperationName() {
  return "tf.Slice";
}

std::pair<unsigned, unsigned> SliceOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range SliceOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value SliceOp::input() {
  return *getODSOperands(0).begin();
}

::mlir::Value SliceOp::begin() {
  return *getODSOperands(1).begin();
}

::mlir::Value SliceOp::size() {
  return *getODSOperands(2).begin();
}

::mlir::MutableOperandRange SliceOp::inputMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange SliceOp::beginMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange SliceOp::sizeMutable() {
  auto range = getODSOperandIndexAndLength(2);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> SliceOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range SliceOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value SliceOp::output() {
  return *getODSResults(0).begin();
}

Type SliceOp::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

Type SliceOp::Index() {
  return mlir::getElementTypeOrSelf(*getODSOperands(1).begin());
}

bool SliceOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "T") return true;
  if (name == "Index") return true;
 return false;
}

::mlir::DictionaryAttr SliceOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())},
    {::mlir::Identifier::get("Index", ctx),
::mlir::TypeAttr::get(Index())}
    }, ctx);
}

void SliceOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value input, ::mlir::Value begin, ::mlir::Value size) {
  odsState.addOperands(input);
  odsState.addOperands(begin);
  odsState.addOperands(size);
  odsState.addTypes(output);
}

void SliceOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input, ::mlir::Value begin, ::mlir::Value size) {
  odsState.addOperands(input);
  odsState.addOperands(begin);
  odsState.addOperands(size);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void SliceOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 3u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult SliceOp::verify() {
  if (failed(SliceOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>())))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::TensorFlowType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of tf.dtype values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of 32/64-bit signed integer values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup2 = getODSOperands(2);
    for (::mlir::Value v : valueGroup2) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of 32/64-bit signed integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>())))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::TensorFlowType>()))))) {
        return emitOpError("result #") << index << " must be tensor of tf.dtype values, but got " << v.getType();
      }
      ++index;
    }
  }
  return Verify(*this);
}

void SliceOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::SnapshotOp definitions
//===----------------------------------------------------------------------===//

SnapshotOpAdaptor::SnapshotOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

SnapshotOpAdaptor::SnapshotOpAdaptor(SnapshotOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> SnapshotOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange SnapshotOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value SnapshotOpAdaptor::input() {
  return *getODSOperands(0).begin();
}

::mlir::LogicalResult SnapshotOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

::llvm::StringRef SnapshotOp::getOperationName() {
  return "tf.Snapshot";
}

std::pair<unsigned, unsigned> SnapshotOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range SnapshotOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value SnapshotOp::input() {
  return *getODSOperands(0).begin();
}

::mlir::MutableOperandRange SnapshotOp::inputMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> SnapshotOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range SnapshotOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value SnapshotOp::output() {
  return *getODSResults(0).begin();
}

Type SnapshotOp::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

bool SnapshotOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "T") return true;
 return false;
}

::mlir::DictionaryAttr SnapshotOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())}
    }, ctx);
}

void SnapshotOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value input) {
  odsState.addOperands(input);
  odsState.addTypes(output);
}

void SnapshotOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input) {
  odsState.addOperands(input);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void SnapshotOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

void SnapshotOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value input) {
  odsState.addOperands(input);
  odsState.addTypes({input.getType()});

}

void SnapshotOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  odsState.addTypes({operands[0].getType()});

}

::mlir::LogicalResult SnapshotOp::verify() {
  if (failed(SnapshotOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>())))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::TensorFlowType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of tf.dtype values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>())))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::TensorFlowType>()))))) {
        return emitOpError("result #") << index << " must be tensor of tf.dtype values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void SnapshotOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::SoftmaxCrossEntropyWithLogitsOp definitions
//===----------------------------------------------------------------------===//

SoftmaxCrossEntropyWithLogitsOpAdaptor::SoftmaxCrossEntropyWithLogitsOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

SoftmaxCrossEntropyWithLogitsOpAdaptor::SoftmaxCrossEntropyWithLogitsOpAdaptor(SoftmaxCrossEntropyWithLogitsOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> SoftmaxCrossEntropyWithLogitsOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange SoftmaxCrossEntropyWithLogitsOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value SoftmaxCrossEntropyWithLogitsOpAdaptor::features() {
  return *getODSOperands(0).begin();
}

::mlir::Value SoftmaxCrossEntropyWithLogitsOpAdaptor::labels() {
  return *getODSOperands(1).begin();
}

::mlir::LogicalResult SoftmaxCrossEntropyWithLogitsOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

void SoftmaxCrossEntropyWithLogitsOp::getAsmResultNames(::mlir::OpAsmSetValueNameFn setNameFn) {
  auto resultGroup0 = getODSResults(0);
  if (!llvm::empty(resultGroup0))
    setNameFn(*resultGroup0.begin(), "loss");
  auto resultGroup1 = getODSResults(1);
  if (!llvm::empty(resultGroup1))
    setNameFn(*resultGroup1.begin(), "backprop");
}

::llvm::StringRef SoftmaxCrossEntropyWithLogitsOp::getOperationName() {
  return "tf.SoftmaxCrossEntropyWithLogits";
}

std::pair<unsigned, unsigned> SoftmaxCrossEntropyWithLogitsOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range SoftmaxCrossEntropyWithLogitsOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value SoftmaxCrossEntropyWithLogitsOp::features() {
  return *getODSOperands(0).begin();
}

::mlir::Value SoftmaxCrossEntropyWithLogitsOp::labels() {
  return *getODSOperands(1).begin();
}

::mlir::MutableOperandRange SoftmaxCrossEntropyWithLogitsOp::featuresMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange SoftmaxCrossEntropyWithLogitsOp::labelsMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> SoftmaxCrossEntropyWithLogitsOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range SoftmaxCrossEntropyWithLogitsOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value SoftmaxCrossEntropyWithLogitsOp::loss() {
  return *getODSResults(0).begin();
}

::mlir::Value SoftmaxCrossEntropyWithLogitsOp::backprop() {
  return *getODSResults(1).begin();
}

Type SoftmaxCrossEntropyWithLogitsOp::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

bool SoftmaxCrossEntropyWithLogitsOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "T") return true;
 return false;
}

::mlir::DictionaryAttr SoftmaxCrossEntropyWithLogitsOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())}
    }, ctx);
}

void SoftmaxCrossEntropyWithLogitsOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type loss, ::mlir::Type backprop, ::mlir::Value features, ::mlir::Value labels) {
  odsState.addOperands(features);
  odsState.addOperands(labels);
  odsState.addTypes(loss);
  odsState.addTypes(backprop);
}

void SoftmaxCrossEntropyWithLogitsOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value features, ::mlir::Value labels) {
  odsState.addOperands(features);
  odsState.addOperands(labels);
  assert(resultTypes.size() == 2u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void SoftmaxCrossEntropyWithLogitsOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 2u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult SoftmaxCrossEntropyWithLogitsOp::verify() {
  if (failed(SoftmaxCrossEntropyWithLogitsOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of floating-point values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of floating-point values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))))) {
        return emitOpError("result #") << index << " must be tensor of floating-point values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSResults(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))))) {
        return emitOpError("result #") << index << " must be tensor of floating-point values, but got " << v.getType();
      }
      ++index;
    }
  }
  return Verify(*this);
}

void SoftmaxCrossEntropyWithLogitsOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::SoftmaxOp definitions
//===----------------------------------------------------------------------===//

SoftmaxOpAdaptor::SoftmaxOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

SoftmaxOpAdaptor::SoftmaxOpAdaptor(SoftmaxOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> SoftmaxOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange SoftmaxOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value SoftmaxOpAdaptor::logits() {
  return *getODSOperands(0).begin();
}

::mlir::LogicalResult SoftmaxOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

::llvm::StringRef SoftmaxOp::getOperationName() {
  return "tf.Softmax";
}

std::pair<unsigned, unsigned> SoftmaxOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range SoftmaxOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value SoftmaxOp::logits() {
  return *getODSOperands(0).begin();
}

::mlir::MutableOperandRange SoftmaxOp::logitsMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> SoftmaxOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range SoftmaxOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value SoftmaxOp::softmax() {
  return *getODSResults(0).begin();
}

Type SoftmaxOp::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

bool SoftmaxOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "T") return true;
 return false;
}

::mlir::DictionaryAttr SoftmaxOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())}
    }, ctx);
}

void SoftmaxOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type softmax, ::mlir::Value logits) {
  odsState.addOperands(logits);
  odsState.addTypes(softmax);
}

void SoftmaxOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value logits) {
  odsState.addOperands(logits);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void SoftmaxOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

void SoftmaxOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value logits) {
  odsState.addOperands(logits);
  odsState.addTypes({logits.getType()});

}

void SoftmaxOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  odsState.addTypes({operands[0].getType()});

}

::mlir::LogicalResult SoftmaxOp::verify() {
  if (failed(SoftmaxOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of floating-point values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))))) {
        return emitOpError("result #") << index << " must be tensor of floating-point values, but got " << v.getType();
      }
      ++index;
    }
  }
  return Verify(*this);
}

void SoftmaxOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::SoftplusGradOp definitions
//===----------------------------------------------------------------------===//

SoftplusGradOpAdaptor::SoftplusGradOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

SoftplusGradOpAdaptor::SoftplusGradOpAdaptor(SoftplusGradOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> SoftplusGradOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange SoftplusGradOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value SoftplusGradOpAdaptor::gradients() {
  return *getODSOperands(0).begin();
}

::mlir::Value SoftplusGradOpAdaptor::features() {
  return *getODSOperands(1).begin();
}

::mlir::LogicalResult SoftplusGradOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

::llvm::StringRef SoftplusGradOp::getOperationName() {
  return "tf.SoftplusGrad";
}

std::pair<unsigned, unsigned> SoftplusGradOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range SoftplusGradOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value SoftplusGradOp::gradients() {
  return *getODSOperands(0).begin();
}

::mlir::Value SoftplusGradOp::features() {
  return *getODSOperands(1).begin();
}

::mlir::MutableOperandRange SoftplusGradOp::gradientsMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange SoftplusGradOp::featuresMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> SoftplusGradOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range SoftplusGradOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value SoftplusGradOp::backprops() {
  return *getODSResults(0).begin();
}

Type SoftplusGradOp::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

bool SoftplusGradOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "T") return true;
 return false;
}

::mlir::DictionaryAttr SoftplusGradOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())}
    }, ctx);
}

void SoftplusGradOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type backprops, ::mlir::Value gradients, ::mlir::Value features) {
  odsState.addOperands(gradients);
  odsState.addOperands(features);
  odsState.addTypes(backprops);
}

void SoftplusGradOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value gradients, ::mlir::Value features) {
  odsState.addOperands(gradients);
  odsState.addOperands(features);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void SoftplusGradOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

void SoftplusGradOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value gradients, ::mlir::Value features) {
  odsState.addOperands(gradients);
  odsState.addOperands(features);
  odsState.addTypes({gradients.getType()});

}

void SoftplusGradOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  odsState.addTypes({operands[0].getType()});

}

::mlir::LogicalResult SoftplusGradOp::verify() {
  if (failed(SoftplusGradOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of floating-point values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of floating-point values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))))) {
        return emitOpError("result #") << index << " must be tensor of floating-point values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void SoftplusGradOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::SoftplusOp definitions
//===----------------------------------------------------------------------===//

SoftplusOpAdaptor::SoftplusOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

SoftplusOpAdaptor::SoftplusOpAdaptor(SoftplusOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> SoftplusOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange SoftplusOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value SoftplusOpAdaptor::features() {
  return *getODSOperands(0).begin();
}

::mlir::LogicalResult SoftplusOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

::llvm::StringRef SoftplusOp::getOperationName() {
  return "tf.Softplus";
}

std::pair<unsigned, unsigned> SoftplusOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range SoftplusOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value SoftplusOp::features() {
  return *getODSOperands(0).begin();
}

::mlir::MutableOperandRange SoftplusOp::featuresMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> SoftplusOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range SoftplusOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value SoftplusOp::activations() {
  return *getODSResults(0).begin();
}

Type SoftplusOp::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

bool SoftplusOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "T") return true;
 return false;
}

::mlir::DictionaryAttr SoftplusOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())}
    }, ctx);
}

void SoftplusOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type activations, ::mlir::Value features) {
  odsState.addOperands(features);
  odsState.addTypes(activations);
}

void SoftplusOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value features) {
  odsState.addOperands(features);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void SoftplusOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

void SoftplusOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value features) {
  odsState.addOperands(features);
  odsState.addTypes({features.getType()});

}

void SoftplusOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  odsState.addTypes({operands[0].getType()});

}

::mlir::LogicalResult SoftplusOp::verify() {
  if (failed(SoftplusOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of floating-point values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))))) {
        return emitOpError("result #") << index << " must be tensor of floating-point values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void SoftplusOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::SoftsignGradOp definitions
//===----------------------------------------------------------------------===//

SoftsignGradOpAdaptor::SoftsignGradOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

SoftsignGradOpAdaptor::SoftsignGradOpAdaptor(SoftsignGradOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> SoftsignGradOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange SoftsignGradOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value SoftsignGradOpAdaptor::gradients() {
  return *getODSOperands(0).begin();
}

::mlir::Value SoftsignGradOpAdaptor::features() {
  return *getODSOperands(1).begin();
}

::mlir::LogicalResult SoftsignGradOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

::llvm::StringRef SoftsignGradOp::getOperationName() {
  return "tf.SoftsignGrad";
}

std::pair<unsigned, unsigned> SoftsignGradOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range SoftsignGradOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value SoftsignGradOp::gradients() {
  return *getODSOperands(0).begin();
}

::mlir::Value SoftsignGradOp::features() {
  return *getODSOperands(1).begin();
}

::mlir::MutableOperandRange SoftsignGradOp::gradientsMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange SoftsignGradOp::featuresMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> SoftsignGradOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range SoftsignGradOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value SoftsignGradOp::backprops() {
  return *getODSResults(0).begin();
}

Type SoftsignGradOp::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

bool SoftsignGradOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "T") return true;
 return false;
}

::mlir::DictionaryAttr SoftsignGradOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())}
    }, ctx);
}

void SoftsignGradOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type backprops, ::mlir::Value gradients, ::mlir::Value features) {
  odsState.addOperands(gradients);
  odsState.addOperands(features);
  odsState.addTypes(backprops);
}

void SoftsignGradOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value gradients, ::mlir::Value features) {
  odsState.addOperands(gradients);
  odsState.addOperands(features);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void SoftsignGradOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

void SoftsignGradOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value gradients, ::mlir::Value features) {
  odsState.addOperands(gradients);
  odsState.addOperands(features);
  odsState.addTypes({gradients.getType()});

}

void SoftsignGradOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  odsState.addTypes({operands[0].getType()});

}

::mlir::LogicalResult SoftsignGradOp::verify() {
  if (failed(SoftsignGradOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of floating-point values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of floating-point values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))))) {
        return emitOpError("result #") << index << " must be tensor of floating-point values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void SoftsignGradOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::SoftsignOp definitions
//===----------------------------------------------------------------------===//

SoftsignOpAdaptor::SoftsignOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

SoftsignOpAdaptor::SoftsignOpAdaptor(SoftsignOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> SoftsignOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange SoftsignOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value SoftsignOpAdaptor::features() {
  return *getODSOperands(0).begin();
}

::mlir::LogicalResult SoftsignOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

::llvm::StringRef SoftsignOp::getOperationName() {
  return "tf.Softsign";
}

std::pair<unsigned, unsigned> SoftsignOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range SoftsignOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value SoftsignOp::features() {
  return *getODSOperands(0).begin();
}

::mlir::MutableOperandRange SoftsignOp::featuresMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> SoftsignOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range SoftsignOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value SoftsignOp::activations() {
  return *getODSResults(0).begin();
}

Type SoftsignOp::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

bool SoftsignOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "T") return true;
 return false;
}

::mlir::DictionaryAttr SoftsignOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())}
    }, ctx);
}

void SoftsignOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type activations, ::mlir::Value features) {
  odsState.addOperands(features);
  odsState.addTypes(activations);
}

void SoftsignOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value features) {
  odsState.addOperands(features);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void SoftsignOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

void SoftsignOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value features) {
  odsState.addOperands(features);
  odsState.addTypes({features.getType()});

}

void SoftsignOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  odsState.addTypes({operands[0].getType()});

}

::mlir::LogicalResult SoftsignOp::verify() {
  if (failed(SoftsignOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of floating-point values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))))) {
        return emitOpError("result #") << index << " must be tensor of floating-point values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void SoftsignOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::SpaceToBatchNDOp definitions
//===----------------------------------------------------------------------===//

SpaceToBatchNDOpAdaptor::SpaceToBatchNDOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

SpaceToBatchNDOpAdaptor::SpaceToBatchNDOpAdaptor(SpaceToBatchNDOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> SpaceToBatchNDOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange SpaceToBatchNDOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value SpaceToBatchNDOpAdaptor::input() {
  return *getODSOperands(0).begin();
}

::mlir::Value SpaceToBatchNDOpAdaptor::block_shape() {
  return *getODSOperands(1).begin();
}

::mlir::Value SpaceToBatchNDOpAdaptor::paddings() {
  return *getODSOperands(2).begin();
}

::mlir::LogicalResult SpaceToBatchNDOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

::llvm::StringRef SpaceToBatchNDOp::getOperationName() {
  return "tf.SpaceToBatchND";
}

std::pair<unsigned, unsigned> SpaceToBatchNDOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range SpaceToBatchNDOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value SpaceToBatchNDOp::input() {
  return *getODSOperands(0).begin();
}

::mlir::Value SpaceToBatchNDOp::block_shape() {
  return *getODSOperands(1).begin();
}

::mlir::Value SpaceToBatchNDOp::paddings() {
  return *getODSOperands(2).begin();
}

::mlir::MutableOperandRange SpaceToBatchNDOp::inputMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange SpaceToBatchNDOp::block_shapeMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange SpaceToBatchNDOp::paddingsMutable() {
  auto range = getODSOperandIndexAndLength(2);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> SpaceToBatchNDOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range SpaceToBatchNDOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value SpaceToBatchNDOp::output() {
  return *getODSResults(0).begin();
}

Type SpaceToBatchNDOp::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

Type SpaceToBatchNDOp::Tpaddings() {
  return mlir::getElementTypeOrSelf(*getODSOperands(2).begin());
}

Type SpaceToBatchNDOp::Tblock_shape() {
  return mlir::getElementTypeOrSelf(*getODSOperands(1).begin());
}

bool SpaceToBatchNDOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "T") return true;
  if (name == "Tpaddings") return true;
  if (name == "Tblock_shape") return true;
 return false;
}

::mlir::DictionaryAttr SpaceToBatchNDOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())},
    {::mlir::Identifier::get("Tpaddings", ctx),
::mlir::TypeAttr::get(Tpaddings())},
    {::mlir::Identifier::get("Tblock_shape", ctx),
::mlir::TypeAttr::get(Tblock_shape())}
    }, ctx);
}

void SpaceToBatchNDOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value input, ::mlir::Value block_shape, ::mlir::Value paddings) {
  odsState.addOperands(input);
  odsState.addOperands(block_shape);
  odsState.addOperands(paddings);
  odsState.addTypes(output);
}

void SpaceToBatchNDOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value input, ::mlir::Value block_shape, ::mlir::Value paddings) {
  odsState.addOperands(input);
  odsState.addOperands(block_shape);
  odsState.addOperands(paddings);

        ::llvm::SmallVector<::mlir::Type, 2> inferredReturnTypes;
        if (succeeded(SpaceToBatchNDOp::inferReturnTypes(odsBuilder.getContext(),
                      odsState.location, odsState.operands,
                      odsState.attributes.getDictionary(odsState.getContext()),
                      /*regions=*/{}, inferredReturnTypes)))
          odsState.addTypes(inferredReturnTypes);
        else
          ::llvm::report_fatal_error("Failed to infer result type(s).");
}

void SpaceToBatchNDOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input, ::mlir::Value block_shape, ::mlir::Value paddings) {
  odsState.addOperands(input);
  odsState.addOperands(block_shape);
  odsState.addOperands(paddings);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void SpaceToBatchNDOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 3u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

void SpaceToBatchNDOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 3u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);

    ::mlir::SmallVector<::mlir::Type, 2> inferredReturnTypes;
    if (succeeded(SpaceToBatchNDOp::inferReturnTypes(odsBuilder.getContext(),
                  odsState.location, operands,
                  odsState.attributes.getDictionary(odsState.getContext()),
                  /*regions=*/{}, inferredReturnTypes))) {  assert(inferredReturnTypes.size() == 1u && "mismatched number of return types");
      odsState.addTypes(inferredReturnTypes);
    } else
      ::llvm::report_fatal_error("Failed to infer result type(s).");
}

::mlir::LogicalResult SpaceToBatchNDOp::verify() {
  if (failed(SpaceToBatchNDOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>())))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::TensorFlowType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of tf.dtype values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of 32/64-bit signed integer values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup2 = getODSOperands(2);
    for (::mlir::Value v : valueGroup2) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of 32/64-bit signed integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>())))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::TensorFlowType>()))))) {
        return emitOpError("result #") << index << " must be tensor of tf.dtype values, but got " << v.getType();
      }
      ++index;
    }
  }
  return Verify(*this);
}



void SpaceToBatchNDOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::SpaceToBatchOp definitions
//===----------------------------------------------------------------------===//

SpaceToBatchOpAdaptor::SpaceToBatchOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

SpaceToBatchOpAdaptor::SpaceToBatchOpAdaptor(SpaceToBatchOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> SpaceToBatchOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange SpaceToBatchOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value SpaceToBatchOpAdaptor::input() {
  return *getODSOperands(0).begin();
}

::mlir::Value SpaceToBatchOpAdaptor::paddings() {
  return *getODSOperands(1).begin();
}

::mlir::IntegerAttr SpaceToBatchOpAdaptor::block_size() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::IntegerAttr attr = odsAttrs.get("block_size").cast<::mlir::IntegerAttr>();
  return attr;
}

::mlir::LogicalResult SpaceToBatchOpAdaptor::verify(::mlir::Location loc) {
  {
  auto tblgen_block_size = odsAttrs.get("block_size");
  if (!tblgen_block_size) return emitError(loc, "'tf.SpaceToBatch' op ""requires attribute 'block_size'");
    if (!((((tblgen_block_size.isa<::mlir::IntegerAttr>())) && ((tblgen_block_size.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(64)))) && ((tblgen_block_size.cast<::mlir::IntegerAttr>().getInt() >= 2)))) return emitError(loc, "'tf.SpaceToBatch' op ""attribute 'block_size' failed to satisfy constraint: 64-bit signless integer attribute whose minimum value is 2");
  }
  return ::mlir::success();
}

::llvm::StringRef SpaceToBatchOp::getOperationName() {
  return "tf.SpaceToBatch";
}

std::pair<unsigned, unsigned> SpaceToBatchOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range SpaceToBatchOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value SpaceToBatchOp::input() {
  return *getODSOperands(0).begin();
}

::mlir::Value SpaceToBatchOp::paddings() {
  return *getODSOperands(1).begin();
}

::mlir::MutableOperandRange SpaceToBatchOp::inputMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange SpaceToBatchOp::paddingsMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> SpaceToBatchOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range SpaceToBatchOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value SpaceToBatchOp::output() {
  return *getODSResults(0).begin();
}

::mlir::IntegerAttr SpaceToBatchOp::block_sizeAttr() {
  return this->getAttr("block_size").cast<::mlir::IntegerAttr>();
}

uint64_t SpaceToBatchOp::block_size() {
  auto attr = block_sizeAttr();
  return attr.getValue().getZExtValue();
}

Type SpaceToBatchOp::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

Type SpaceToBatchOp::Tpaddings() {
  return mlir::getElementTypeOrSelf(*getODSOperands(1).begin());
}

bool SpaceToBatchOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "T") return true;
  if (name == "Tpaddings") return true;
 return false;
}

::mlir::DictionaryAttr SpaceToBatchOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())},
    {::mlir::Identifier::get("Tpaddings", ctx),
::mlir::TypeAttr::get(Tpaddings())}
    }, ctx);
}

void SpaceToBatchOp::block_sizeAttr(::mlir::IntegerAttr attr) {
  this->getOperation()->setAttr("block_size", attr);
}

void SpaceToBatchOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value input, ::mlir::Value paddings, ::mlir::IntegerAttr block_size) {
  odsState.addOperands(input);
  odsState.addOperands(paddings);
  odsState.addAttribute("block_size", block_size);
  odsState.addTypes(output);
}

void SpaceToBatchOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input, ::mlir::Value paddings, ::mlir::IntegerAttr block_size) {
  odsState.addOperands(input);
  odsState.addOperands(paddings);
  odsState.addAttribute("block_size", block_size);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void SpaceToBatchOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value input, ::mlir::Value paddings, uint64_t block_size) {
  odsState.addOperands(input);
  odsState.addOperands(paddings);
  odsState.addAttribute("block_size", odsBuilder.getIntegerAttr(odsBuilder.getIntegerType(64), block_size));
  odsState.addTypes(output);
}

void SpaceToBatchOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input, ::mlir::Value paddings, uint64_t block_size) {
  odsState.addOperands(input);
  odsState.addOperands(paddings);
  odsState.addAttribute("block_size", odsBuilder.getIntegerAttr(odsBuilder.getIntegerType(64), block_size));
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void SpaceToBatchOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult SpaceToBatchOp::verify() {
  if (failed(SpaceToBatchOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>())))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::TensorFlowType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of tf.dtype values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of 32/64-bit signed integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>())))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::TensorFlowType>()))))) {
        return emitOpError("result #") << index << " must be tensor of tf.dtype values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void SpaceToBatchOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::SpaceToDepthOp definitions
//===----------------------------------------------------------------------===//

SpaceToDepthOpAdaptor::SpaceToDepthOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

SpaceToDepthOpAdaptor::SpaceToDepthOpAdaptor(SpaceToDepthOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> SpaceToDepthOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange SpaceToDepthOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value SpaceToDepthOpAdaptor::input() {
  return *getODSOperands(0).begin();
}

::mlir::IntegerAttr SpaceToDepthOpAdaptor::block_size() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::IntegerAttr attr = odsAttrs.get("block_size").cast<::mlir::IntegerAttr>();
  return attr;
}

::mlir::StringAttr SpaceToDepthOpAdaptor::data_format() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::StringAttr attr = odsAttrs.get("data_format").dyn_cast_or_null<::mlir::StringAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getStringAttr("NHWC");
  return attr;
}

::mlir::LogicalResult SpaceToDepthOpAdaptor::verify(::mlir::Location loc) {
  {
  auto tblgen_block_size = odsAttrs.get("block_size");
  if (!tblgen_block_size) return emitError(loc, "'tf.SpaceToDepth' op ""requires attribute 'block_size'");
    if (!((((tblgen_block_size.isa<::mlir::IntegerAttr>())) && ((tblgen_block_size.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(64)))) && ((tblgen_block_size.cast<::mlir::IntegerAttr>().getInt() >= 2)))) return emitError(loc, "'tf.SpaceToDepth' op ""attribute 'block_size' failed to satisfy constraint: 64-bit signless integer attribute whose minimum value is 2");
  }
  {
  auto tblgen_data_format = odsAttrs.get("data_format");
  if (tblgen_data_format) {
    if (!((tblgen_data_format.cast<StringAttr>().getValue() == "NHWC" || tblgen_data_format.cast<StringAttr>().getValue() == "NCHW" || tblgen_data_format.cast<StringAttr>().getValue() == "NCHW_VECT_C"))) return emitError(loc, "'tf.SpaceToDepth' op ""attribute 'data_format' failed to satisfy constraint: string attribute whose value is NHWC, or NCHW, or NCHW_VECT_C");
  }
  }
  return ::mlir::success();
}

::llvm::StringRef SpaceToDepthOp::getOperationName() {
  return "tf.SpaceToDepth";
}

std::pair<unsigned, unsigned> SpaceToDepthOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range SpaceToDepthOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value SpaceToDepthOp::input() {
  return *getODSOperands(0).begin();
}

::mlir::MutableOperandRange SpaceToDepthOp::inputMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> SpaceToDepthOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range SpaceToDepthOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value SpaceToDepthOp::output() {
  return *getODSResults(0).begin();
}

::mlir::IntegerAttr SpaceToDepthOp::block_sizeAttr() {
  return this->getAttr("block_size").cast<::mlir::IntegerAttr>();
}

uint64_t SpaceToDepthOp::block_size() {
  auto attr = block_sizeAttr();
  return attr.getValue().getZExtValue();
}

::mlir::StringAttr SpaceToDepthOp::data_formatAttr() {
  return this->getAttr("data_format").dyn_cast_or_null<::mlir::StringAttr>();
}

::llvm::StringRef SpaceToDepthOp::data_format() {
  auto attr = data_formatAttr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getStringAttr("NHWC").getValue();
  return attr.getValue();
}

Type SpaceToDepthOp::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

bool SpaceToDepthOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "T") return true;
 return false;
}

::mlir::DictionaryAttr SpaceToDepthOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())}
    }, ctx);
}

void SpaceToDepthOp::block_sizeAttr(::mlir::IntegerAttr attr) {
  this->getOperation()->setAttr("block_size", attr);
}

void SpaceToDepthOp::data_formatAttr(::mlir::StringAttr attr) {
  this->getOperation()->setAttr("data_format", attr);
}

void SpaceToDepthOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value input, ::mlir::IntegerAttr block_size, ::mlir::StringAttr data_format) {
  odsState.addOperands(input);
  odsState.addAttribute("block_size", block_size);
  odsState.addAttribute("data_format", data_format);
  odsState.addTypes(output);
}

void SpaceToDepthOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input, ::mlir::IntegerAttr block_size, ::mlir::StringAttr data_format) {
  odsState.addOperands(input);
  odsState.addAttribute("block_size", block_size);
  odsState.addAttribute("data_format", data_format);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void SpaceToDepthOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value input, uint64_t block_size, ::llvm::StringRef data_format) {
  odsState.addOperands(input);
  odsState.addAttribute("block_size", odsBuilder.getIntegerAttr(odsBuilder.getIntegerType(64), block_size));
  odsState.addAttribute("data_format", odsBuilder.getStringAttr(data_format));
  odsState.addTypes(output);
}

void SpaceToDepthOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input, uint64_t block_size, ::llvm::StringRef data_format) {
  odsState.addOperands(input);
  odsState.addAttribute("block_size", odsBuilder.getIntegerAttr(odsBuilder.getIntegerType(64), block_size));
  odsState.addAttribute("data_format", odsBuilder.getStringAttr(data_format));
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void SpaceToDepthOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult SpaceToDepthOp::verify() {
  if (failed(SpaceToDepthOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>())))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::TensorFlowType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of tf.dtype values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>())))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::TensorFlowType>()))))) {
        return emitOpError("result #") << index << " must be tensor of tf.dtype values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void SpaceToDepthOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::SparseFillEmptyRowsOp definitions
//===----------------------------------------------------------------------===//

SparseFillEmptyRowsOpAdaptor::SparseFillEmptyRowsOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

SparseFillEmptyRowsOpAdaptor::SparseFillEmptyRowsOpAdaptor(SparseFillEmptyRowsOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> SparseFillEmptyRowsOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange SparseFillEmptyRowsOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value SparseFillEmptyRowsOpAdaptor::indices() {
  return *getODSOperands(0).begin();
}

::mlir::Value SparseFillEmptyRowsOpAdaptor::values() {
  return *getODSOperands(1).begin();
}

::mlir::Value SparseFillEmptyRowsOpAdaptor::dense_shape() {
  return *getODSOperands(2).begin();
}

::mlir::Value SparseFillEmptyRowsOpAdaptor::default_value() {
  return *getODSOperands(3).begin();
}

::mlir::LogicalResult SparseFillEmptyRowsOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

void SparseFillEmptyRowsOp::getAsmResultNames(::mlir::OpAsmSetValueNameFn setNameFn) {
  auto resultGroup0 = getODSResults(0);
  if (!llvm::empty(resultGroup0))
    setNameFn(*resultGroup0.begin(), "output_indices");
  auto resultGroup1 = getODSResults(1);
  if (!llvm::empty(resultGroup1))
    setNameFn(*resultGroup1.begin(), "output_values");
  auto resultGroup2 = getODSResults(2);
  if (!llvm::empty(resultGroup2))
    setNameFn(*resultGroup2.begin(), "empty_row_indicator");
  auto resultGroup3 = getODSResults(3);
  if (!llvm::empty(resultGroup3))
    setNameFn(*resultGroup3.begin(), "reverse_index_map");
}

::llvm::StringRef SparseFillEmptyRowsOp::getOperationName() {
  return "tf.SparseFillEmptyRows";
}

std::pair<unsigned, unsigned> SparseFillEmptyRowsOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range SparseFillEmptyRowsOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value SparseFillEmptyRowsOp::indices() {
  return *getODSOperands(0).begin();
}

::mlir::Value SparseFillEmptyRowsOp::values() {
  return *getODSOperands(1).begin();
}

::mlir::Value SparseFillEmptyRowsOp::dense_shape() {
  return *getODSOperands(2).begin();
}

::mlir::Value SparseFillEmptyRowsOp::default_value() {
  return *getODSOperands(3).begin();
}

::mlir::MutableOperandRange SparseFillEmptyRowsOp::indicesMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange SparseFillEmptyRowsOp::valuesMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange SparseFillEmptyRowsOp::dense_shapeMutable() {
  auto range = getODSOperandIndexAndLength(2);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange SparseFillEmptyRowsOp::default_valueMutable() {
  auto range = getODSOperandIndexAndLength(3);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> SparseFillEmptyRowsOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range SparseFillEmptyRowsOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value SparseFillEmptyRowsOp::output_indices() {
  return *getODSResults(0).begin();
}

::mlir::Value SparseFillEmptyRowsOp::output_values() {
  return *getODSResults(1).begin();
}

::mlir::Value SparseFillEmptyRowsOp::empty_row_indicator() {
  return *getODSResults(2).begin();
}

::mlir::Value SparseFillEmptyRowsOp::reverse_index_map() {
  return *getODSResults(3).begin();
}

Type SparseFillEmptyRowsOp::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(1).begin());
}

bool SparseFillEmptyRowsOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "T") return true;
 return false;
}

::mlir::DictionaryAttr SparseFillEmptyRowsOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())}
    }, ctx);
}

void SparseFillEmptyRowsOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output_indices, ::mlir::Type output_values, ::mlir::Type empty_row_indicator, ::mlir::Type reverse_index_map, ::mlir::Value indices, ::mlir::Value values, ::mlir::Value dense_shape, ::mlir::Value default_value) {
  odsState.addOperands(indices);
  odsState.addOperands(values);
  odsState.addOperands(dense_shape);
  odsState.addOperands(default_value);
  odsState.addTypes(output_indices);
  odsState.addTypes(output_values);
  odsState.addTypes(empty_row_indicator);
  odsState.addTypes(reverse_index_map);
}

void SparseFillEmptyRowsOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value indices, ::mlir::Value values, ::mlir::Value dense_shape, ::mlir::Value default_value) {
  odsState.addOperands(indices);
  odsState.addOperands(values);
  odsState.addOperands(dense_shape);
  odsState.addOperands(default_value);
  assert(resultTypes.size() == 4u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void SparseFillEmptyRowsOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 4u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 4u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult SparseFillEmptyRowsOp::verify() {
  if (failed(SparseFillEmptyRowsOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of 64-bit integer values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>())))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::TensorFlowType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of tf.dtype values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup2 = getODSOperands(2);
    for (::mlir::Value v : valueGroup2) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of 64-bit integer values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup3 = getODSOperands(3);
    for (::mlir::Value v : valueGroup3) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>())))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::TensorFlowType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of tf.dtype values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))))) {
        return emitOpError("result #") << index << " must be tensor of 64-bit integer values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSResults(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>())))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::TensorFlowType>()))))) {
        return emitOpError("result #") << index << " must be tensor of tf.dtype values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup2 = getODSResults(2);
    for (::mlir::Value v : valueGroup2) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))))) {
        return emitOpError("result #") << index << " must be tensor of bool values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup3 = getODSResults(3);
    for (::mlir::Value v : valueGroup3) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))))) {
        return emitOpError("result #") << index << " must be tensor of 64-bit integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void SparseFillEmptyRowsOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::SparseMatMulOp definitions
//===----------------------------------------------------------------------===//

SparseMatMulOpAdaptor::SparseMatMulOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

SparseMatMulOpAdaptor::SparseMatMulOpAdaptor(SparseMatMulOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> SparseMatMulOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange SparseMatMulOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value SparseMatMulOpAdaptor::a() {
  return *getODSOperands(0).begin();
}

::mlir::Value SparseMatMulOpAdaptor::b() {
  return *getODSOperands(1).begin();
}

::mlir::BoolAttr SparseMatMulOpAdaptor::transpose_a() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::BoolAttr attr = odsAttrs.get("transpose_a").dyn_cast_or_null<::mlir::BoolAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getBoolAttr(false);
  return attr;
}

::mlir::BoolAttr SparseMatMulOpAdaptor::transpose_b() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::BoolAttr attr = odsAttrs.get("transpose_b").dyn_cast_or_null<::mlir::BoolAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getBoolAttr(false);
  return attr;
}

::mlir::BoolAttr SparseMatMulOpAdaptor::a_is_sparse() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::BoolAttr attr = odsAttrs.get("a_is_sparse").dyn_cast_or_null<::mlir::BoolAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getBoolAttr(false);
  return attr;
}

::mlir::BoolAttr SparseMatMulOpAdaptor::b_is_sparse() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::BoolAttr attr = odsAttrs.get("b_is_sparse").dyn_cast_or_null<::mlir::BoolAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getBoolAttr(false);
  return attr;
}

::mlir::LogicalResult SparseMatMulOpAdaptor::verify(::mlir::Location loc) {
  {
  auto tblgen_transpose_a = odsAttrs.get("transpose_a");
  if (tblgen_transpose_a) {
    if (!((tblgen_transpose_a.isa<::mlir::BoolAttr>()))) return emitError(loc, "'tf.SparseMatMul' op ""attribute 'transpose_a' failed to satisfy constraint: bool attribute");
  }
  }
  {
  auto tblgen_transpose_b = odsAttrs.get("transpose_b");
  if (tblgen_transpose_b) {
    if (!((tblgen_transpose_b.isa<::mlir::BoolAttr>()))) return emitError(loc, "'tf.SparseMatMul' op ""attribute 'transpose_b' failed to satisfy constraint: bool attribute");
  }
  }
  {
  auto tblgen_a_is_sparse = odsAttrs.get("a_is_sparse");
  if (tblgen_a_is_sparse) {
    if (!((tblgen_a_is_sparse.isa<::mlir::BoolAttr>()))) return emitError(loc, "'tf.SparseMatMul' op ""attribute 'a_is_sparse' failed to satisfy constraint: bool attribute");
  }
  }
  {
  auto tblgen_b_is_sparse = odsAttrs.get("b_is_sparse");
  if (tblgen_b_is_sparse) {
    if (!((tblgen_b_is_sparse.isa<::mlir::BoolAttr>()))) return emitError(loc, "'tf.SparseMatMul' op ""attribute 'b_is_sparse' failed to satisfy constraint: bool attribute");
  }
  }
  return ::mlir::success();
}

::llvm::StringRef SparseMatMulOp::getOperationName() {
  return "tf.SparseMatMul";
}

std::pair<unsigned, unsigned> SparseMatMulOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range SparseMatMulOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value SparseMatMulOp::a() {
  return *getODSOperands(0).begin();
}

::mlir::Value SparseMatMulOp::b() {
  return *getODSOperands(1).begin();
}

::mlir::MutableOperandRange SparseMatMulOp::aMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange SparseMatMulOp::bMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> SparseMatMulOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range SparseMatMulOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value SparseMatMulOp::product() {
  return *getODSResults(0).begin();
}

::mlir::BoolAttr SparseMatMulOp::transpose_aAttr() {
  return this->getAttr("transpose_a").dyn_cast_or_null<::mlir::BoolAttr>();
}

bool SparseMatMulOp::transpose_a() {
  auto attr = transpose_aAttr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getBoolAttr(false).getValue();
  return attr.getValue();
}

::mlir::BoolAttr SparseMatMulOp::transpose_bAttr() {
  return this->getAttr("transpose_b").dyn_cast_or_null<::mlir::BoolAttr>();
}

bool SparseMatMulOp::transpose_b() {
  auto attr = transpose_bAttr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getBoolAttr(false).getValue();
  return attr.getValue();
}

::mlir::BoolAttr SparseMatMulOp::a_is_sparseAttr() {
  return this->getAttr("a_is_sparse").dyn_cast_or_null<::mlir::BoolAttr>();
}

bool SparseMatMulOp::a_is_sparse() {
  auto attr = a_is_sparseAttr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getBoolAttr(false).getValue();
  return attr.getValue();
}

::mlir::BoolAttr SparseMatMulOp::b_is_sparseAttr() {
  return this->getAttr("b_is_sparse").dyn_cast_or_null<::mlir::BoolAttr>();
}

bool SparseMatMulOp::b_is_sparse() {
  auto attr = b_is_sparseAttr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getBoolAttr(false).getValue();
  return attr.getValue();
}

Type SparseMatMulOp::Ta() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

Type SparseMatMulOp::Tb() {
  return mlir::getElementTypeOrSelf(*getODSOperands(1).begin());
}

bool SparseMatMulOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "Ta") return true;
  if (name == "Tb") return true;
 return false;
}

::mlir::DictionaryAttr SparseMatMulOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("Ta", ctx),
::mlir::TypeAttr::get(Ta())},
    {::mlir::Identifier::get("Tb", ctx),
::mlir::TypeAttr::get(Tb())}
    }, ctx);
}

void SparseMatMulOp::transpose_aAttr(::mlir::BoolAttr attr) {
  this->getOperation()->setAttr("transpose_a", attr);
}

void SparseMatMulOp::transpose_bAttr(::mlir::BoolAttr attr) {
  this->getOperation()->setAttr("transpose_b", attr);
}

void SparseMatMulOp::a_is_sparseAttr(::mlir::BoolAttr attr) {
  this->getOperation()->setAttr("a_is_sparse", attr);
}

void SparseMatMulOp::b_is_sparseAttr(::mlir::BoolAttr attr) {
  this->getOperation()->setAttr("b_is_sparse", attr);
}

void SparseMatMulOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type product, ::mlir::Value a, ::mlir::Value b, ::mlir::BoolAttr transpose_a, ::mlir::BoolAttr transpose_b, ::mlir::BoolAttr a_is_sparse, ::mlir::BoolAttr b_is_sparse) {
  odsState.addOperands(a);
  odsState.addOperands(b);
  odsState.addAttribute("transpose_a", transpose_a);
  odsState.addAttribute("transpose_b", transpose_b);
  odsState.addAttribute("a_is_sparse", a_is_sparse);
  odsState.addAttribute("b_is_sparse", b_is_sparse);
  odsState.addTypes(product);
}

void SparseMatMulOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value a, ::mlir::Value b, ::mlir::BoolAttr transpose_a, ::mlir::BoolAttr transpose_b, ::mlir::BoolAttr a_is_sparse, ::mlir::BoolAttr b_is_sparse) {
  odsState.addOperands(a);
  odsState.addOperands(b);
  odsState.addAttribute("transpose_a", transpose_a);
  odsState.addAttribute("transpose_b", transpose_b);
  odsState.addAttribute("a_is_sparse", a_is_sparse);
  odsState.addAttribute("b_is_sparse", b_is_sparse);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void SparseMatMulOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type product, ::mlir::Value a, ::mlir::Value b, bool transpose_a, bool transpose_b, bool a_is_sparse, bool b_is_sparse) {
  odsState.addOperands(a);
  odsState.addOperands(b);
  odsState.addAttribute("transpose_a", odsBuilder.getBoolAttr(transpose_a));
  odsState.addAttribute("transpose_b", odsBuilder.getBoolAttr(transpose_b));
  odsState.addAttribute("a_is_sparse", odsBuilder.getBoolAttr(a_is_sparse));
  odsState.addAttribute("b_is_sparse", odsBuilder.getBoolAttr(b_is_sparse));
  odsState.addTypes(product);
}

void SparseMatMulOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value a, ::mlir::Value b, bool transpose_a, bool transpose_b, bool a_is_sparse, bool b_is_sparse) {
  odsState.addOperands(a);
  odsState.addOperands(b);
  odsState.addAttribute("transpose_a", odsBuilder.getBoolAttr(transpose_a));
  odsState.addAttribute("transpose_b", odsBuilder.getBoolAttr(transpose_b));
  odsState.addAttribute("a_is_sparse", odsBuilder.getBoolAttr(a_is_sparse));
  odsState.addAttribute("b_is_sparse", odsBuilder.getBoolAttr(b_is_sparse));
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void SparseMatMulOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult SparseMatMulOp::verify() {
  if (failed(SparseMatMulOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of bfloat16 or 32-bit float values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of bfloat16 or 32-bit float values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))))) {
        return emitOpError("result #") << index << " must be tensor of 32-bit float values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void SparseMatMulOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::SparseReshapeOp definitions
//===----------------------------------------------------------------------===//

SparseReshapeOpAdaptor::SparseReshapeOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

SparseReshapeOpAdaptor::SparseReshapeOpAdaptor(SparseReshapeOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> SparseReshapeOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange SparseReshapeOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value SparseReshapeOpAdaptor::input_indices() {
  return *getODSOperands(0).begin();
}

::mlir::Value SparseReshapeOpAdaptor::input_shape() {
  return *getODSOperands(1).begin();
}

::mlir::Value SparseReshapeOpAdaptor::new_shape() {
  return *getODSOperands(2).begin();
}

::mlir::LogicalResult SparseReshapeOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

void SparseReshapeOp::getAsmResultNames(::mlir::OpAsmSetValueNameFn setNameFn) {
  auto resultGroup0 = getODSResults(0);
  if (!llvm::empty(resultGroup0))
    setNameFn(*resultGroup0.begin(), "output_indices");
  auto resultGroup1 = getODSResults(1);
  if (!llvm::empty(resultGroup1))
    setNameFn(*resultGroup1.begin(), "output_shape");
}

::llvm::StringRef SparseReshapeOp::getOperationName() {
  return "tf.SparseReshape";
}

std::pair<unsigned, unsigned> SparseReshapeOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range SparseReshapeOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value SparseReshapeOp::input_indices() {
  return *getODSOperands(0).begin();
}

::mlir::Value SparseReshapeOp::input_shape() {
  return *getODSOperands(1).begin();
}

::mlir::Value SparseReshapeOp::new_shape() {
  return *getODSOperands(2).begin();
}

::mlir::MutableOperandRange SparseReshapeOp::input_indicesMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange SparseReshapeOp::input_shapeMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange SparseReshapeOp::new_shapeMutable() {
  auto range = getODSOperandIndexAndLength(2);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> SparseReshapeOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range SparseReshapeOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value SparseReshapeOp::output_indices() {
  return *getODSResults(0).begin();
}

::mlir::Value SparseReshapeOp::output_shape() {
  return *getODSResults(1).begin();
}

void SparseReshapeOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output_indices, ::mlir::Type output_shape, ::mlir::Value input_indices, ::mlir::Value input_shape, ::mlir::Value new_shape) {
  odsState.addOperands(input_indices);
  odsState.addOperands(input_shape);
  odsState.addOperands(new_shape);
  odsState.addTypes(output_indices);
  odsState.addTypes(output_shape);
}

void SparseReshapeOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input_indices, ::mlir::Value input_shape, ::mlir::Value new_shape) {
  odsState.addOperands(input_indices);
  odsState.addOperands(input_shape);
  odsState.addOperands(new_shape);
  assert(resultTypes.size() == 2u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void SparseReshapeOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 3u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 2u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult SparseReshapeOp::verify() {
  if (failed(SparseReshapeOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of 64-bit integer values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of 64-bit integer values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup2 = getODSOperands(2);
    for (::mlir::Value v : valueGroup2) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of 64-bit integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))))) {
        return emitOpError("result #") << index << " must be tensor of 64-bit integer values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSResults(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))))) {
        return emitOpError("result #") << index << " must be tensor of 64-bit integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void SparseReshapeOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::SparseSegmentSqrtNOp definitions
//===----------------------------------------------------------------------===//

SparseSegmentSqrtNOpAdaptor::SparseSegmentSqrtNOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

SparseSegmentSqrtNOpAdaptor::SparseSegmentSqrtNOpAdaptor(SparseSegmentSqrtNOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> SparseSegmentSqrtNOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange SparseSegmentSqrtNOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value SparseSegmentSqrtNOpAdaptor::data() {
  return *getODSOperands(0).begin();
}

::mlir::Value SparseSegmentSqrtNOpAdaptor::indices() {
  return *getODSOperands(1).begin();
}

::mlir::Value SparseSegmentSqrtNOpAdaptor::segment_ids() {
  return *getODSOperands(2).begin();
}

::mlir::LogicalResult SparseSegmentSqrtNOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

::llvm::StringRef SparseSegmentSqrtNOp::getOperationName() {
  return "tf.SparseSegmentSqrtN";
}

std::pair<unsigned, unsigned> SparseSegmentSqrtNOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range SparseSegmentSqrtNOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value SparseSegmentSqrtNOp::data() {
  return *getODSOperands(0).begin();
}

::mlir::Value SparseSegmentSqrtNOp::indices() {
  return *getODSOperands(1).begin();
}

::mlir::Value SparseSegmentSqrtNOp::segment_ids() {
  return *getODSOperands(2).begin();
}

::mlir::MutableOperandRange SparseSegmentSqrtNOp::dataMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange SparseSegmentSqrtNOp::indicesMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange SparseSegmentSqrtNOp::segment_idsMutable() {
  auto range = getODSOperandIndexAndLength(2);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> SparseSegmentSqrtNOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range SparseSegmentSqrtNOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value SparseSegmentSqrtNOp::output() {
  return *getODSResults(0).begin();
}

Type SparseSegmentSqrtNOp::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

Type SparseSegmentSqrtNOp::Tsegmentids() {
  return mlir::getElementTypeOrSelf(*getODSOperands(2).begin());
}

Type SparseSegmentSqrtNOp::Tidx() {
  return mlir::getElementTypeOrSelf(*getODSOperands(1).begin());
}

bool SparseSegmentSqrtNOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "T") return true;
  if (name == "Tsegmentids") return true;
  if (name == "Tidx") return true;
 return false;
}

::mlir::DictionaryAttr SparseSegmentSqrtNOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())},
    {::mlir::Identifier::get("Tsegmentids", ctx),
::mlir::TypeAttr::get(Tsegmentids())},
    {::mlir::Identifier::get("Tidx", ctx),
::mlir::TypeAttr::get(Tidx())}
    }, ctx);
}

void SparseSegmentSqrtNOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value data, ::mlir::Value indices, ::mlir::Value segment_ids) {
  odsState.addOperands(data);
  odsState.addOperands(indices);
  odsState.addOperands(segment_ids);
  odsState.addTypes(output);
}

void SparseSegmentSqrtNOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value data, ::mlir::Value indices, ::mlir::Value segment_ids) {
  odsState.addOperands(data);
  odsState.addOperands(indices);
  odsState.addOperands(segment_ids);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void SparseSegmentSqrtNOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 3u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult SparseSegmentSqrtNOp::verify() {
  if (failed(SparseSegmentSqrtNOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of bfloat16 or 32-bit float or 64-bit float values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of 32/64-bit signed integer values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup2 = getODSOperands(2);
    for (::mlir::Value v : valueGroup2) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of 32/64-bit signed integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())))))) {
        return emitOpError("result #") << index << " must be tensor of bfloat16 or 32-bit float or 64-bit float values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void SparseSegmentSqrtNOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::SparseSoftmaxCrossEntropyWithLogitsOp definitions
//===----------------------------------------------------------------------===//

SparseSoftmaxCrossEntropyWithLogitsOpAdaptor::SparseSoftmaxCrossEntropyWithLogitsOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

SparseSoftmaxCrossEntropyWithLogitsOpAdaptor::SparseSoftmaxCrossEntropyWithLogitsOpAdaptor(SparseSoftmaxCrossEntropyWithLogitsOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> SparseSoftmaxCrossEntropyWithLogitsOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange SparseSoftmaxCrossEntropyWithLogitsOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value SparseSoftmaxCrossEntropyWithLogitsOpAdaptor::features() {
  return *getODSOperands(0).begin();
}

::mlir::Value SparseSoftmaxCrossEntropyWithLogitsOpAdaptor::labels() {
  return *getODSOperands(1).begin();
}

::mlir::LogicalResult SparseSoftmaxCrossEntropyWithLogitsOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

void SparseSoftmaxCrossEntropyWithLogitsOp::getAsmResultNames(::mlir::OpAsmSetValueNameFn setNameFn) {
  auto resultGroup0 = getODSResults(0);
  if (!llvm::empty(resultGroup0))
    setNameFn(*resultGroup0.begin(), "loss");
  auto resultGroup1 = getODSResults(1);
  if (!llvm::empty(resultGroup1))
    setNameFn(*resultGroup1.begin(), "backprop");
}

::llvm::StringRef SparseSoftmaxCrossEntropyWithLogitsOp::getOperationName() {
  return "tf.SparseSoftmaxCrossEntropyWithLogits";
}

std::pair<unsigned, unsigned> SparseSoftmaxCrossEntropyWithLogitsOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range SparseSoftmaxCrossEntropyWithLogitsOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value SparseSoftmaxCrossEntropyWithLogitsOp::features() {
  return *getODSOperands(0).begin();
}

::mlir::Value SparseSoftmaxCrossEntropyWithLogitsOp::labels() {
  return *getODSOperands(1).begin();
}

::mlir::MutableOperandRange SparseSoftmaxCrossEntropyWithLogitsOp::featuresMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange SparseSoftmaxCrossEntropyWithLogitsOp::labelsMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> SparseSoftmaxCrossEntropyWithLogitsOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range SparseSoftmaxCrossEntropyWithLogitsOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value SparseSoftmaxCrossEntropyWithLogitsOp::loss() {
  return *getODSResults(0).begin();
}

::mlir::Value SparseSoftmaxCrossEntropyWithLogitsOp::backprop() {
  return *getODSResults(1).begin();
}

Type SparseSoftmaxCrossEntropyWithLogitsOp::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

Type SparseSoftmaxCrossEntropyWithLogitsOp::Tlabels() {
  return mlir::getElementTypeOrSelf(*getODSOperands(1).begin());
}

bool SparseSoftmaxCrossEntropyWithLogitsOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "T") return true;
  if (name == "Tlabels") return true;
 return false;
}

::mlir::DictionaryAttr SparseSoftmaxCrossEntropyWithLogitsOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())},
    {::mlir::Identifier::get("Tlabels", ctx),
::mlir::TypeAttr::get(Tlabels())}
    }, ctx);
}

void SparseSoftmaxCrossEntropyWithLogitsOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type loss, ::mlir::Type backprop, ::mlir::Value features, ::mlir::Value labels) {
  odsState.addOperands(features);
  odsState.addOperands(labels);
  odsState.addTypes(loss);
  odsState.addTypes(backprop);
}

void SparseSoftmaxCrossEntropyWithLogitsOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value features, ::mlir::Value labels) {
  odsState.addOperands(features);
  odsState.addOperands(labels);
  assert(resultTypes.size() == 2u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void SparseSoftmaxCrossEntropyWithLogitsOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 2u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult SparseSoftmaxCrossEntropyWithLogitsOp::verify() {
  if (failed(SparseSoftmaxCrossEntropyWithLogitsOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of floating-point values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of 32/64-bit signed integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))))) {
        return emitOpError("result #") << index << " must be tensor of floating-point values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSResults(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))))) {
        return emitOpError("result #") << index << " must be tensor of floating-point values, but got " << v.getType();
      }
      ++index;
    }
  }
  return Verify(*this);
}

void SparseSoftmaxCrossEntropyWithLogitsOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::SparseToDenseOp definitions
//===----------------------------------------------------------------------===//

SparseToDenseOpAdaptor::SparseToDenseOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

SparseToDenseOpAdaptor::SparseToDenseOpAdaptor(SparseToDenseOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> SparseToDenseOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange SparseToDenseOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value SparseToDenseOpAdaptor::sparse_indices() {
  return *getODSOperands(0).begin();
}

::mlir::Value SparseToDenseOpAdaptor::output_shape() {
  return *getODSOperands(1).begin();
}

::mlir::Value SparseToDenseOpAdaptor::sparse_values() {
  return *getODSOperands(2).begin();
}

::mlir::Value SparseToDenseOpAdaptor::default_value() {
  return *getODSOperands(3).begin();
}

::mlir::BoolAttr SparseToDenseOpAdaptor::validate_indices() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::BoolAttr attr = odsAttrs.get("validate_indices").dyn_cast_or_null<::mlir::BoolAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getBoolAttr(true);
  return attr;
}

::mlir::LogicalResult SparseToDenseOpAdaptor::verify(::mlir::Location loc) {
  {
  auto tblgen_validate_indices = odsAttrs.get("validate_indices");
  if (tblgen_validate_indices) {
    if (!((tblgen_validate_indices.isa<::mlir::BoolAttr>()))) return emitError(loc, "'tf.SparseToDense' op ""attribute 'validate_indices' failed to satisfy constraint: bool attribute");
  }
  }
  return ::mlir::success();
}

::llvm::StringRef SparseToDenseOp::getOperationName() {
  return "tf.SparseToDense";
}

std::pair<unsigned, unsigned> SparseToDenseOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range SparseToDenseOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value SparseToDenseOp::sparse_indices() {
  return *getODSOperands(0).begin();
}

::mlir::Value SparseToDenseOp::output_shape() {
  return *getODSOperands(1).begin();
}

::mlir::Value SparseToDenseOp::sparse_values() {
  return *getODSOperands(2).begin();
}

::mlir::Value SparseToDenseOp::default_value() {
  return *getODSOperands(3).begin();
}

::mlir::MutableOperandRange SparseToDenseOp::sparse_indicesMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange SparseToDenseOp::output_shapeMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange SparseToDenseOp::sparse_valuesMutable() {
  auto range = getODSOperandIndexAndLength(2);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange SparseToDenseOp::default_valueMutable() {
  auto range = getODSOperandIndexAndLength(3);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> SparseToDenseOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range SparseToDenseOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value SparseToDenseOp::dense() {
  return *getODSResults(0).begin();
}

::mlir::BoolAttr SparseToDenseOp::validate_indicesAttr() {
  return this->getAttr("validate_indices").dyn_cast_or_null<::mlir::BoolAttr>();
}

bool SparseToDenseOp::validate_indices() {
  auto attr = validate_indicesAttr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getBoolAttr(true).getValue();
  return attr.getValue();
}

Type SparseToDenseOp::Tindices() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

Type SparseToDenseOp::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(2).begin());
}

bool SparseToDenseOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "Tindices") return true;
  if (name == "T") return true;
 return false;
}

::mlir::DictionaryAttr SparseToDenseOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("Tindices", ctx),
::mlir::TypeAttr::get(Tindices())},
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())}
    }, ctx);
}

void SparseToDenseOp::validate_indicesAttr(::mlir::BoolAttr attr) {
  this->getOperation()->setAttr("validate_indices", attr);
}

void SparseToDenseOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type dense, ::mlir::Value sparse_indices, ::mlir::Value output_shape, ::mlir::Value sparse_values, ::mlir::Value default_value, ::mlir::BoolAttr validate_indices) {
  odsState.addOperands(sparse_indices);
  odsState.addOperands(output_shape);
  odsState.addOperands(sparse_values);
  odsState.addOperands(default_value);
  odsState.addAttribute("validate_indices", validate_indices);
  odsState.addTypes(dense);
}

void SparseToDenseOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value sparse_indices, ::mlir::Value output_shape, ::mlir::Value sparse_values, ::mlir::Value default_value, ::mlir::BoolAttr validate_indices) {
  odsState.addOperands(sparse_indices);
  odsState.addOperands(output_shape);
  odsState.addOperands(sparse_values);
  odsState.addOperands(default_value);
  odsState.addAttribute("validate_indices", validate_indices);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void SparseToDenseOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type dense, ::mlir::Value sparse_indices, ::mlir::Value output_shape, ::mlir::Value sparse_values, ::mlir::Value default_value, bool validate_indices) {
  odsState.addOperands(sparse_indices);
  odsState.addOperands(output_shape);
  odsState.addOperands(sparse_values);
  odsState.addOperands(default_value);
  odsState.addAttribute("validate_indices", odsBuilder.getBoolAttr(validate_indices));
  odsState.addTypes(dense);
}

void SparseToDenseOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value sparse_indices, ::mlir::Value output_shape, ::mlir::Value sparse_values, ::mlir::Value default_value, bool validate_indices) {
  odsState.addOperands(sparse_indices);
  odsState.addOperands(output_shape);
  odsState.addOperands(sparse_values);
  odsState.addOperands(default_value);
  odsState.addAttribute("validate_indices", odsBuilder.getBoolAttr(validate_indices));
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void SparseToDenseOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 4u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult SparseToDenseOp::verify() {
  if (failed(SparseToDenseOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of 32/64-bit signed integer values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of 32/64-bit signed integer values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup2 = getODSOperands(2);
    for (::mlir::Value v : valueGroup2) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>())))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::TensorFlowType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of tf.dtype values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup3 = getODSOperands(3);
    for (::mlir::Value v : valueGroup3) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>())))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::TensorFlowType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of tf.dtype values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>())))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::TensorFlowType>()))))) {
        return emitOpError("result #") << index << " must be tensor of tf.dtype values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void SparseToDenseOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::SplitOp definitions
//===----------------------------------------------------------------------===//

SplitOpAdaptor::SplitOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

SplitOpAdaptor::SplitOpAdaptor(SplitOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> SplitOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange SplitOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value SplitOpAdaptor::split_dim() {
  return *getODSOperands(0).begin();
}

::mlir::Value SplitOpAdaptor::value() {
  return *getODSOperands(1).begin();
}

::mlir::LogicalResult SplitOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

::llvm::StringRef SplitOp::getOperationName() {
  return "tf.Split";
}

std::pair<unsigned, unsigned> SplitOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range SplitOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value SplitOp::split_dim() {
  return *getODSOperands(0).begin();
}

::mlir::Value SplitOp::value() {
  return *getODSOperands(1).begin();
}

::mlir::MutableOperandRange SplitOp::split_dimMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange SplitOp::valueMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> SplitOp::getODSResultIndexAndLength(unsigned index) {
  bool isVariadic[] = {true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (getOperation()->getNumResults() - 0) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::mlir::Operation::result_range SplitOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Operation::result_range SplitOp::output() {
  return getODSResults(0);
}

Type SplitOp::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(1).begin());
}

size_t SplitOp::num_split() {
  auto range = getODSResults(0);
return std::distance(range.begin(), range.end());
}

bool SplitOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "T") return true;
  if (name == "num_split") return true;
 return false;
}

::mlir::DictionaryAttr SplitOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())},
    {::mlir::Identifier::get("num_split", ctx),
odsBuilder.getI64IntegerAttr(num_split())}
    }, ctx);
}

void SplitOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange output, ::mlir::Value split_dim, ::mlir::Value value) {
  odsState.addOperands(split_dim);
  odsState.addOperands(value);
  odsState.addTypes(output);
}

void SplitOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult SplitOp::verify() {
  if (failed(SplitOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of 32-bit integer values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>())))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::TensorFlowType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of tf.dtype values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>())))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::TensorFlowType>()))))) {
        return emitOpError("result #") << index << " must be tensor of tf.dtype values, but got " << v.getType();
      }
      ++index;
    }
  }
  return Verify(*this);
}

void SplitOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::SplitVOp definitions
//===----------------------------------------------------------------------===//

SplitVOpAdaptor::SplitVOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

SplitVOpAdaptor::SplitVOpAdaptor(SplitVOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> SplitVOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange SplitVOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value SplitVOpAdaptor::value() {
  return *getODSOperands(0).begin();
}

::mlir::Value SplitVOpAdaptor::size_splits() {
  return *getODSOperands(1).begin();
}

::mlir::Value SplitVOpAdaptor::split_dim() {
  return *getODSOperands(2).begin();
}

::mlir::LogicalResult SplitVOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

::llvm::StringRef SplitVOp::getOperationName() {
  return "tf.SplitV";
}

std::pair<unsigned, unsigned> SplitVOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range SplitVOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value SplitVOp::value() {
  return *getODSOperands(0).begin();
}

::mlir::Value SplitVOp::size_splits() {
  return *getODSOperands(1).begin();
}

::mlir::Value SplitVOp::split_dim() {
  return *getODSOperands(2).begin();
}

::mlir::MutableOperandRange SplitVOp::valueMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange SplitVOp::size_splitsMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange SplitVOp::split_dimMutable() {
  auto range = getODSOperandIndexAndLength(2);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> SplitVOp::getODSResultIndexAndLength(unsigned index) {
  bool isVariadic[] = {true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (getOperation()->getNumResults() - 0) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::mlir::Operation::result_range SplitVOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Operation::result_range SplitVOp::output() {
  return getODSResults(0);
}

Type SplitVOp::Tlen() {
  return mlir::getElementTypeOrSelf(*getODSOperands(1).begin());
}

Type SplitVOp::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

size_t SplitVOp::num_split() {
  auto range = getODSResults(0);
return std::distance(range.begin(), range.end());
}

bool SplitVOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "Tlen") return true;
  if (name == "T") return true;
  if (name == "num_split") return true;
 return false;
}

::mlir::DictionaryAttr SplitVOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("Tlen", ctx),
::mlir::TypeAttr::get(Tlen())},
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())},
    {::mlir::Identifier::get("num_split", ctx),
odsBuilder.getI64IntegerAttr(num_split())}
    }, ctx);
}

void SplitVOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange output, ::mlir::Value value, ::mlir::Value size_splits, ::mlir::Value split_dim) {
  odsState.addOperands(value);
  odsState.addOperands(size_splits);
  odsState.addOperands(split_dim);
  odsState.addTypes(output);
}

void SplitVOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 3u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult SplitVOp::verify() {
  if (failed(SplitVOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>())))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::TensorFlowType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of tf.dtype values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of 32/64-bit signed integer values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup2 = getODSOperands(2);
    for (::mlir::Value v : valueGroup2) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of 32-bit integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>())))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::TensorFlowType>()))))) {
        return emitOpError("result #") << index << " must be tensor of tf.dtype values, but got " << v.getType();
      }
      ++index;
    }
  }
  return Verify(*this);
}

void SplitVOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::SqrtGradOp definitions
//===----------------------------------------------------------------------===//

SqrtGradOpAdaptor::SqrtGradOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

SqrtGradOpAdaptor::SqrtGradOpAdaptor(SqrtGradOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> SqrtGradOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange SqrtGradOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value SqrtGradOpAdaptor::y() {
  return *getODSOperands(0).begin();
}

::mlir::Value SqrtGradOpAdaptor::dy() {
  return *getODSOperands(1).begin();
}

::mlir::LogicalResult SqrtGradOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

::llvm::StringRef SqrtGradOp::getOperationName() {
  return "tf.SqrtGrad";
}

std::pair<unsigned, unsigned> SqrtGradOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range SqrtGradOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value SqrtGradOp::y() {
  return *getODSOperands(0).begin();
}

::mlir::Value SqrtGradOp::dy() {
  return *getODSOperands(1).begin();
}

::mlir::MutableOperandRange SqrtGradOp::yMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange SqrtGradOp::dyMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> SqrtGradOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range SqrtGradOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value SqrtGradOp::z() {
  return *getODSResults(0).begin();
}

Type SqrtGradOp::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

bool SqrtGradOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "T") return true;
 return false;
}

::mlir::DictionaryAttr SqrtGradOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())}
    }, ctx);
}

void SqrtGradOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type z, ::mlir::Value y, ::mlir::Value dy) {
  odsState.addOperands(y);
  odsState.addOperands(dy);
  odsState.addTypes(z);
}

void SqrtGradOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value y, ::mlir::Value dy) {
  odsState.addOperands(y);
  odsState.addOperands(dy);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void SqrtGradOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

void SqrtGradOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value y, ::mlir::Value dy) {
  odsState.addOperands(y);
  odsState.addOperands(dy);
  odsState.addTypes({y.getType()});

}

void SqrtGradOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  odsState.addTypes({operands[0].getType()});

}

::mlir::LogicalResult SqrtGradOp::verify() {
  if (failed(SqrtGradOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))))))) {
        return emitOpError("operand #") << index << " must be tensor of floating-point or complex values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))))))) {
        return emitOpError("operand #") << index << " must be tensor of floating-point or complex values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))))))) {
        return emitOpError("result #") << index << " must be tensor of floating-point or complex values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void SqrtGradOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::SqrtOp definitions
//===----------------------------------------------------------------------===//

SqrtOpAdaptor::SqrtOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

SqrtOpAdaptor::SqrtOpAdaptor(SqrtOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> SqrtOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange SqrtOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value SqrtOpAdaptor::x() {
  return *getODSOperands(0).begin();
}

::mlir::LogicalResult SqrtOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

::llvm::StringRef SqrtOp::getOperationName() {
  return "tf.Sqrt";
}

std::pair<unsigned, unsigned> SqrtOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range SqrtOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value SqrtOp::x() {
  return *getODSOperands(0).begin();
}

::mlir::MutableOperandRange SqrtOp::xMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> SqrtOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range SqrtOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value SqrtOp::y() {
  return *getODSResults(0).begin();
}

Type SqrtOp::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

bool SqrtOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "T") return true;
 return false;
}

::mlir::DictionaryAttr SqrtOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())}
    }, ctx);
}

void SqrtOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type y, ::mlir::Value x) {
  odsState.addOperands(x);
  odsState.addTypes(y);
}

void SqrtOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value x) {
  odsState.addOperands(x);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void SqrtOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

void SqrtOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value x) {
  odsState.addOperands(x);
  odsState.addTypes({x.getType()});

}

void SqrtOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  odsState.addTypes({operands[0].getType()});

}

::mlir::LogicalResult SqrtOp::verify() {
  if (failed(SqrtOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))))))) {
        return emitOpError("operand #") << index << " must be tensor of floating-point or complex values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))))))) {
        return emitOpError("result #") << index << " must be tensor of floating-point or complex values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void SqrtOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::SquareOp definitions
//===----------------------------------------------------------------------===//

SquareOpAdaptor::SquareOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

SquareOpAdaptor::SquareOpAdaptor(SquareOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> SquareOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange SquareOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value SquareOpAdaptor::x() {
  return *getODSOperands(0).begin();
}

::mlir::LogicalResult SquareOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

::llvm::StringRef SquareOp::getOperationName() {
  return "tf.Square";
}

std::pair<unsigned, unsigned> SquareOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range SquareOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value SquareOp::x() {
  return *getODSOperands(0).begin();
}

::mlir::MutableOperandRange SquareOp::xMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> SquareOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range SquareOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value SquareOp::y() {
  return *getODSResults(0).begin();
}

Type SquareOp::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

bool SquareOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "T") return true;
 return false;
}

::mlir::DictionaryAttr SquareOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())}
    }, ctx);
}

void SquareOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type y, ::mlir::Value x) {
  odsState.addOperands(x);
  odsState.addTypes(y);
}

void SquareOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value x) {
  odsState.addOperands(x);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void SquareOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

void SquareOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value x) {
  odsState.addOperands(x);
  odsState.addTypes({x.getType()});

}

void SquareOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  odsState.addTypes({operands[0].getType()});

}

::mlir::LogicalResult SquareOp::verify() {
  if (failed(SquareOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of bfloat16 or 128-bit complex or 64-bit complex or 16-bit float or 32-bit float or 64-bit float or 16-bit integer or 32-bit integer or 64-bit integer or 8-bit integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>())))))) {
        return emitOpError("result #") << index << " must be tensor of bfloat16 or 128-bit complex or 64-bit complex or 16-bit float or 32-bit float or 64-bit float or 16-bit integer or 32-bit integer or 64-bit integer or 8-bit integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}



void SquareOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::SquaredDifferenceOp definitions
//===----------------------------------------------------------------------===//

SquaredDifferenceOpAdaptor::SquaredDifferenceOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

SquaredDifferenceOpAdaptor::SquaredDifferenceOpAdaptor(SquaredDifferenceOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> SquaredDifferenceOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange SquaredDifferenceOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value SquaredDifferenceOpAdaptor::x() {
  return *getODSOperands(0).begin();
}

::mlir::Value SquaredDifferenceOpAdaptor::y() {
  return *getODSOperands(1).begin();
}

::mlir::LogicalResult SquaredDifferenceOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

::llvm::StringRef SquaredDifferenceOp::getOperationName() {
  return "tf.SquaredDifference";
}

std::pair<unsigned, unsigned> SquaredDifferenceOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range SquaredDifferenceOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value SquaredDifferenceOp::x() {
  return *getODSOperands(0).begin();
}

::mlir::Value SquaredDifferenceOp::y() {
  return *getODSOperands(1).begin();
}

::mlir::MutableOperandRange SquaredDifferenceOp::xMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange SquaredDifferenceOp::yMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> SquaredDifferenceOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range SquaredDifferenceOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value SquaredDifferenceOp::z() {
  return *getODSResults(0).begin();
}

Type SquaredDifferenceOp::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

bool SquaredDifferenceOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "T") return true;
 return false;
}

::mlir::DictionaryAttr SquaredDifferenceOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())}
    }, ctx);
}

void SquaredDifferenceOp::build(OpBuilder &builder, OperationState &result, Value  x, Value  y) {
  auto resultType =
      OpTrait::util::getBroadcastedType(x.getType(), y.getType());
  if (!resultType)
    mlir::emitError(result.location, "non-broadcastable operands");
  return build(builder, result, resultType, x, y);
}

void SquaredDifferenceOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type z, ::mlir::Value x, ::mlir::Value y) {
  odsState.addOperands(x);
  odsState.addOperands(y);
  odsState.addTypes(z);
}

void SquaredDifferenceOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value x, ::mlir::Value y) {
  odsState.addOperands(x);
  odsState.addOperands(y);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void SquaredDifferenceOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult SquaredDifferenceOp::verify() {
  if (failed(SquaredDifferenceOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of bfloat16 or 128-bit complex or 64-bit complex or 16-bit float or 32-bit float or 64-bit float or 32-bit integer or 64-bit integer values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of bfloat16 or 128-bit complex or 64-bit complex or 16-bit float or 32-bit float or 64-bit float or 32-bit integer or 64-bit integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))))) {
        return emitOpError("result #") << index << " must be tensor of bfloat16 or 128-bit complex or 64-bit complex or 16-bit float or 32-bit float or 64-bit float or 32-bit integer or 64-bit integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void SquaredDifferenceOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::SqueezeOp definitions
//===----------------------------------------------------------------------===//

SqueezeOpAdaptor::SqueezeOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

SqueezeOpAdaptor::SqueezeOpAdaptor(SqueezeOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> SqueezeOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange SqueezeOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value SqueezeOpAdaptor::input() {
  return *getODSOperands(0).begin();
}

::mlir::ArrayAttr SqueezeOpAdaptor::squeeze_dims() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::ArrayAttr attr = odsAttrs.get("squeeze_dims").dyn_cast_or_null<::mlir::ArrayAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getI64ArrayAttr({});
  return attr;
}

::mlir::LogicalResult SqueezeOpAdaptor::verify(::mlir::Location loc) {
  {
  auto tblgen_squeeze_dims = odsAttrs.get("squeeze_dims");
  if (tblgen_squeeze_dims) {
    if (!(((tblgen_squeeze_dims.isa<::mlir::ArrayAttr>())) && (::llvm::all_of(tblgen_squeeze_dims.cast<::mlir::ArrayAttr>(), [](::mlir::Attribute attr) { return ((attr.isa<::mlir::IntegerAttr>())) && ((attr.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(64))); })))) return emitError(loc, "'tf.Squeeze' op ""attribute 'squeeze_dims' failed to satisfy constraint: 64-bit integer array attribute");
  }
  }
  return ::mlir::success();
}

::llvm::StringRef SqueezeOp::getOperationName() {
  return "tf.Squeeze";
}

std::pair<unsigned, unsigned> SqueezeOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range SqueezeOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value SqueezeOp::input() {
  return *getODSOperands(0).begin();
}

::mlir::MutableOperandRange SqueezeOp::inputMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> SqueezeOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range SqueezeOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value SqueezeOp::output() {
  return *getODSResults(0).begin();
}

::mlir::ArrayAttr SqueezeOp::squeeze_dimsAttr() {
  return this->getAttr("squeeze_dims").dyn_cast_or_null<::mlir::ArrayAttr>();
}

::mlir::ArrayAttr SqueezeOp::squeeze_dims() {
  auto attr = squeeze_dimsAttr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getI64ArrayAttr({});
  return attr;
}

Type SqueezeOp::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

bool SqueezeOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "T") return true;
 return false;
}

::mlir::DictionaryAttr SqueezeOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())}
    }, ctx);
}

void SqueezeOp::squeeze_dimsAttr(::mlir::ArrayAttr attr) {
  this->getOperation()->setAttr("squeeze_dims", attr);
}

void SqueezeOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value input, ::mlir::ArrayAttr squeeze_dims) {
  odsState.addOperands(input);
  odsState.addAttribute("squeeze_dims", squeeze_dims);
  odsState.addTypes(output);
}

void SqueezeOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input, ::mlir::ArrayAttr squeeze_dims) {
  odsState.addOperands(input);
  odsState.addAttribute("squeeze_dims", squeeze_dims);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void SqueezeOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult SqueezeOp::verify() {
  if (failed(SqueezeOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>())))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::TensorFlowType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of tf.dtype values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>())))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::TensorFlowType>()))))) {
        return emitOpError("result #") << index << " must be tensor of tf.dtype values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void SqueezeOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::StackCloseV2Op definitions
//===----------------------------------------------------------------------===//

StackCloseV2OpAdaptor::StackCloseV2OpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

StackCloseV2OpAdaptor::StackCloseV2OpAdaptor(StackCloseV2Op&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> StackCloseV2OpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange StackCloseV2OpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value StackCloseV2OpAdaptor::handle() {
  return *getODSOperands(0).begin();
}

::mlir::LogicalResult StackCloseV2OpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

::llvm::StringRef StackCloseV2Op::getOperationName() {
  return "tf.StackCloseV2";
}

std::pair<unsigned, unsigned> StackCloseV2Op::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range StackCloseV2Op::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value StackCloseV2Op::handle() {
  return *getODSOperands(0).begin();
}

::mlir::MutableOperandRange StackCloseV2Op::handleMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> StackCloseV2Op::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range StackCloseV2Op::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

void StackCloseV2Op::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value handle) {
  odsState.addOperands(handle);
}

void StackCloseV2Op::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value handle) {
  odsState.addOperands(handle);
  assert(resultTypes.size() == 0u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void StackCloseV2Op::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 0u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult StackCloseV2Op::verify() {
  if (failed(StackCloseV2OpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::ResourceType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::ResourceRefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of resource values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
  }
  return ::mlir::success();
}

void StackCloseV2Op::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
  for (::mlir::Value value : getODSOperands(0))
    effects.emplace_back(MemoryEffects::Free::get(), value, ::mlir::TF::ResourceEffects::Stack::get());
}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::StackPopV2Op definitions
//===----------------------------------------------------------------------===//

StackPopV2OpAdaptor::StackPopV2OpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

StackPopV2OpAdaptor::StackPopV2OpAdaptor(StackPopV2Op&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> StackPopV2OpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange StackPopV2OpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value StackPopV2OpAdaptor::handle() {
  return *getODSOperands(0).begin();
}

::mlir::LogicalResult StackPopV2OpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

::llvm::StringRef StackPopV2Op::getOperationName() {
  return "tf.StackPopV2";
}

std::pair<unsigned, unsigned> StackPopV2Op::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range StackPopV2Op::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value StackPopV2Op::handle() {
  return *getODSOperands(0).begin();
}

::mlir::MutableOperandRange StackPopV2Op::handleMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> StackPopV2Op::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range StackPopV2Op::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value StackPopV2Op::elem() {
  return *getODSResults(0).begin();
}

Type StackPopV2Op::elem_type() {
  return mlir::getElementTypeOrSelf(*getODSResults(0).begin());
}

bool StackPopV2Op::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "elem_type") return true;
 return false;
}

::mlir::DictionaryAttr StackPopV2Op::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("elem_type", ctx),
::mlir::TypeAttr::get(elem_type())}
    }, ctx);
}

void StackPopV2Op::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type elem, ::mlir::Value handle) {
  odsState.addOperands(handle);
  odsState.addTypes(elem);
}

void StackPopV2Op::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value handle) {
  odsState.addOperands(handle);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void StackPopV2Op::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult StackPopV2Op::verify() {
  if (failed(StackPopV2OpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::ResourceType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::ResourceRefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of resource values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>())))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::TensorFlowType>()))))) {
        return emitOpError("result #") << index << " must be tensor of tf.dtype values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void StackPopV2Op::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
  for (::mlir::Value value : getODSOperands(0))
    effects.emplace_back(MemoryEffects::Read::get(), value, ::mlir::TF::ResourceEffects::Stack::get());
  for (::mlir::Value value : getODSOperands(0))
    effects.emplace_back(MemoryEffects::Write::get(), value, ::mlir::TF::ResourceEffects::Stack::get());
}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::StackPushV2Op definitions
//===----------------------------------------------------------------------===//

StackPushV2OpAdaptor::StackPushV2OpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

StackPushV2OpAdaptor::StackPushV2OpAdaptor(StackPushV2Op&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> StackPushV2OpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange StackPushV2OpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value StackPushV2OpAdaptor::handle() {
  return *getODSOperands(0).begin();
}

::mlir::Value StackPushV2OpAdaptor::elem() {
  return *getODSOperands(1).begin();
}

::mlir::BoolAttr StackPushV2OpAdaptor::swap_memory() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::BoolAttr attr = odsAttrs.get("swap_memory").dyn_cast_or_null<::mlir::BoolAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getBoolAttr(false);
  return attr;
}

::mlir::LogicalResult StackPushV2OpAdaptor::verify(::mlir::Location loc) {
  {
  auto tblgen_swap_memory = odsAttrs.get("swap_memory");
  if (tblgen_swap_memory) {
    if (!((tblgen_swap_memory.isa<::mlir::BoolAttr>()))) return emitError(loc, "'tf.StackPushV2' op ""attribute 'swap_memory' failed to satisfy constraint: bool attribute");
  }
  }
  return ::mlir::success();
}

::llvm::StringRef StackPushV2Op::getOperationName() {
  return "tf.StackPushV2";
}

std::pair<unsigned, unsigned> StackPushV2Op::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range StackPushV2Op::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value StackPushV2Op::handle() {
  return *getODSOperands(0).begin();
}

::mlir::Value StackPushV2Op::elem() {
  return *getODSOperands(1).begin();
}

::mlir::MutableOperandRange StackPushV2Op::handleMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange StackPushV2Op::elemMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> StackPushV2Op::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range StackPushV2Op::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value StackPushV2Op::output() {
  return *getODSResults(0).begin();
}

::mlir::BoolAttr StackPushV2Op::swap_memoryAttr() {
  return this->getAttr("swap_memory").dyn_cast_or_null<::mlir::BoolAttr>();
}

bool StackPushV2Op::swap_memory() {
  auto attr = swap_memoryAttr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getBoolAttr(false).getValue();
  return attr.getValue();
}

Type StackPushV2Op::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(1).begin());
}

bool StackPushV2Op::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "T") return true;
 return false;
}

::mlir::DictionaryAttr StackPushV2Op::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())}
    }, ctx);
}

void StackPushV2Op::swap_memoryAttr(::mlir::BoolAttr attr) {
  this->getOperation()->setAttr("swap_memory", attr);
}

void StackPushV2Op::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value handle, ::mlir::Value elem, ::mlir::BoolAttr swap_memory) {
  odsState.addOperands(handle);
  odsState.addOperands(elem);
  odsState.addAttribute("swap_memory", swap_memory);
  odsState.addTypes(output);
}

void StackPushV2Op::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value handle, ::mlir::Value elem, ::mlir::BoolAttr swap_memory) {
  odsState.addOperands(handle);
  odsState.addOperands(elem);
  odsState.addAttribute("swap_memory", swap_memory);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void StackPushV2Op::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value handle, ::mlir::Value elem, bool swap_memory) {
  odsState.addOperands(handle);
  odsState.addOperands(elem);
  odsState.addAttribute("swap_memory", odsBuilder.getBoolAttr(swap_memory));
  odsState.addTypes(output);
}

void StackPushV2Op::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value handle, ::mlir::Value elem, bool swap_memory) {
  odsState.addOperands(handle);
  odsState.addOperands(elem);
  odsState.addAttribute("swap_memory", odsBuilder.getBoolAttr(swap_memory));
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void StackPushV2Op::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult StackPushV2Op::verify() {
  if (failed(StackPushV2OpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::ResourceType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::ResourceRefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of resource values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>())))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::TensorFlowType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of tf.dtype values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>())))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::TensorFlowType>()))))) {
        return emitOpError("result #") << index << " must be tensor of tf.dtype values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void StackPushV2Op::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
  for (::mlir::Value value : getODSOperands(0))
    effects.emplace_back(MemoryEffects::Read::get(), value, ::mlir::TF::ResourceEffects::Stack::get());
  for (::mlir::Value value : getODSOperands(0))
    effects.emplace_back(MemoryEffects::Write::get(), value, ::mlir::TF::ResourceEffects::Stack::get());
}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::StackV2Op definitions
//===----------------------------------------------------------------------===//

StackV2OpAdaptor::StackV2OpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

StackV2OpAdaptor::StackV2OpAdaptor(StackV2Op&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> StackV2OpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange StackV2OpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value StackV2OpAdaptor::max_size() {
  return *getODSOperands(0).begin();
}

::mlir::TypeAttr StackV2OpAdaptor::elem_type() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::TypeAttr attr = odsAttrs.get("elem_type").cast<::mlir::TypeAttr>();
  return attr;
}

::mlir::StringAttr StackV2OpAdaptor::stack_name() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::StringAttr attr = odsAttrs.get("stack_name").cast<::mlir::StringAttr>();
  return attr;
}

::mlir::LogicalResult StackV2OpAdaptor::verify(::mlir::Location loc) {
  {
  auto tblgen_elem_type = odsAttrs.get("elem_type");
  if (!tblgen_elem_type) return emitError(loc, "'tf.StackV2' op ""requires attribute 'elem_type'");
    if (!(((tblgen_elem_type.isa<::mlir::TypeAttr>())) && ((tblgen_elem_type.cast<::mlir::TypeAttr>().getValue().isa<::mlir::Type>())))) return emitError(loc, "'tf.StackV2' op ""attribute 'elem_type' failed to satisfy constraint: any type attribute");
  }
  {
  auto tblgen_stack_name = odsAttrs.get("stack_name");
  if (!tblgen_stack_name) return emitError(loc, "'tf.StackV2' op ""requires attribute 'stack_name'");
    if (!((tblgen_stack_name.isa<::mlir::StringAttr>()))) return emitError(loc, "'tf.StackV2' op ""attribute 'stack_name' failed to satisfy constraint: string attribute");
  }
  return ::mlir::success();
}

::llvm::StringRef StackV2Op::getOperationName() {
  return "tf.StackV2";
}

std::pair<unsigned, unsigned> StackV2Op::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range StackV2Op::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value StackV2Op::max_size() {
  return *getODSOperands(0).begin();
}

::mlir::MutableOperandRange StackV2Op::max_sizeMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> StackV2Op::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range StackV2Op::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value StackV2Op::handle() {
  return *getODSResults(0).begin();
}

::mlir::TypeAttr StackV2Op::elem_typeAttr() {
  return this->getAttr("elem_type").cast<::mlir::TypeAttr>();
}

::mlir::Type StackV2Op::elem_type() {
  auto attr = elem_typeAttr();
  return attr.getValue().cast<::mlir::Type>();
}

::mlir::StringAttr StackV2Op::stack_nameAttr() {
  return this->getAttr("stack_name").cast<::mlir::StringAttr>();
}

::llvm::StringRef StackV2Op::stack_name() {
  auto attr = stack_nameAttr();
  return attr.getValue();
}

void StackV2Op::elem_typeAttr(::mlir::TypeAttr attr) {
  this->getOperation()->setAttr("elem_type", attr);
}

void StackV2Op::stack_nameAttr(::mlir::StringAttr attr) {
  this->getOperation()->setAttr("stack_name", attr);
}

void StackV2Op::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type handle, ::mlir::Value max_size, ::mlir::TypeAttr elem_type, ::mlir::StringAttr stack_name) {
  odsState.addOperands(max_size);
  odsState.addAttribute("elem_type", elem_type);
  odsState.addAttribute("stack_name", stack_name);
  odsState.addTypes(handle);
}

void StackV2Op::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value max_size, ::mlir::TypeAttr elem_type, ::mlir::StringAttr stack_name) {
  odsState.addOperands(max_size);
  odsState.addAttribute("elem_type", elem_type);
  odsState.addAttribute("stack_name", stack_name);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void StackV2Op::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type handle, ::mlir::Value max_size, ::mlir::TypeAttr elem_type, ::llvm::StringRef stack_name) {
  odsState.addOperands(max_size);
  odsState.addAttribute("elem_type", elem_type);
  odsState.addAttribute("stack_name", odsBuilder.getStringAttr(stack_name));
  odsState.addTypes(handle);
}

void StackV2Op::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value max_size, ::mlir::TypeAttr elem_type, ::llvm::StringRef stack_name) {
  odsState.addOperands(max_size);
  odsState.addAttribute("elem_type", elem_type);
  odsState.addAttribute("stack_name", odsBuilder.getStringAttr(stack_name));
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void StackV2Op::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult StackV2Op::verify() {
  if (failed(StackV2OpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of 32-bit integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::ResourceType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::ResourceRefType>()))))) {
        return emitOpError("result #") << index << " must be tensor of resource values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void StackV2Op::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
  for (::mlir::Value value : getODSResults(0))
    effects.emplace_back(MemoryEffects::Allocate::get(), value, ::mlir::TF::ResourceEffects::Stack::get());
}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::StatefulPartitionedCallOp definitions
//===----------------------------------------------------------------------===//

StatefulPartitionedCallOpAdaptor::StatefulPartitionedCallOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

StatefulPartitionedCallOpAdaptor::StatefulPartitionedCallOpAdaptor(StatefulPartitionedCallOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> StatefulPartitionedCallOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  bool isVariadic[] = {true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (odsOperands.size() - 0) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::mlir::ValueRange StatefulPartitionedCallOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::ValueRange StatefulPartitionedCallOpAdaptor::args() {
  return getODSOperands(0);
}

::mlir::FlatSymbolRefAttr StatefulPartitionedCallOpAdaptor::f() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::FlatSymbolRefAttr attr = odsAttrs.get("f").cast<::mlir::FlatSymbolRefAttr>();
  return attr;
}

::mlir::StringAttr StatefulPartitionedCallOpAdaptor::config() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::StringAttr attr = odsAttrs.get("config").cast<::mlir::StringAttr>();
  return attr;
}

::mlir::StringAttr StatefulPartitionedCallOpAdaptor::config_proto() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::StringAttr attr = odsAttrs.get("config_proto").cast<::mlir::StringAttr>();
  return attr;
}

::mlir::StringAttr StatefulPartitionedCallOpAdaptor::executor_type() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::StringAttr attr = odsAttrs.get("executor_type").cast<::mlir::StringAttr>();
  return attr;
}

::mlir::LogicalResult StatefulPartitionedCallOpAdaptor::verify(::mlir::Location loc) {
  {
  auto tblgen_f = odsAttrs.get("f");
  if (!tblgen_f) return emitError(loc, "'tf.StatefulPartitionedCall' op ""requires attribute 'f'");
    if (!((tblgen_f.isa<::mlir::FlatSymbolRefAttr>()))) return emitError(loc, "'tf.StatefulPartitionedCall' op ""attribute 'f' failed to satisfy constraint: flat symbol reference attribute");
  }
  {
  auto tblgen_config = odsAttrs.get("config");
  if (!tblgen_config) return emitError(loc, "'tf.StatefulPartitionedCall' op ""requires attribute 'config'");
    if (!((tblgen_config.isa<::mlir::StringAttr>()))) return emitError(loc, "'tf.StatefulPartitionedCall' op ""attribute 'config' failed to satisfy constraint: string attribute");
  }
  {
  auto tblgen_config_proto = odsAttrs.get("config_proto");
  if (!tblgen_config_proto) return emitError(loc, "'tf.StatefulPartitionedCall' op ""requires attribute 'config_proto'");
    if (!((tblgen_config_proto.isa<::mlir::StringAttr>()))) return emitError(loc, "'tf.StatefulPartitionedCall' op ""attribute 'config_proto' failed to satisfy constraint: string attribute");
  }
  {
  auto tblgen_executor_type = odsAttrs.get("executor_type");
  if (!tblgen_executor_type) return emitError(loc, "'tf.StatefulPartitionedCall' op ""requires attribute 'executor_type'");
    if (!((tblgen_executor_type.isa<::mlir::StringAttr>()))) return emitError(loc, "'tf.StatefulPartitionedCall' op ""attribute 'executor_type' failed to satisfy constraint: string attribute");
  }
  return ::mlir::success();
}

::llvm::StringRef StatefulPartitionedCallOp::getOperationName() {
  return "tf.StatefulPartitionedCall";
}

std::pair<unsigned, unsigned> StatefulPartitionedCallOp::getODSOperandIndexAndLength(unsigned index) {
  bool isVariadic[] = {true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (getOperation()->getNumOperands() - 0) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::mlir::Operation::operand_range StatefulPartitionedCallOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Operation::operand_range StatefulPartitionedCallOp::args() {
  return getODSOperands(0);
}

::mlir::MutableOperandRange StatefulPartitionedCallOp::argsMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> StatefulPartitionedCallOp::getODSResultIndexAndLength(unsigned index) {
  bool isVariadic[] = {true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (getOperation()->getNumResults() - 0) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::mlir::Operation::result_range StatefulPartitionedCallOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Operation::result_range StatefulPartitionedCallOp::output() {
  return getODSResults(0);
}

::mlir::FlatSymbolRefAttr StatefulPartitionedCallOp::fAttr() {
  return this->getAttr("f").cast<::mlir::FlatSymbolRefAttr>();
}

::llvm::StringRef StatefulPartitionedCallOp::f() {
  auto attr = fAttr();
  return attr.getValue();
}

::mlir::StringAttr StatefulPartitionedCallOp::configAttr() {
  return this->getAttr("config").cast<::mlir::StringAttr>();
}

::llvm::StringRef StatefulPartitionedCallOp::config() {
  auto attr = configAttr();
  return attr.getValue();
}

::mlir::StringAttr StatefulPartitionedCallOp::config_protoAttr() {
  return this->getAttr("config_proto").cast<::mlir::StringAttr>();
}

::llvm::StringRef StatefulPartitionedCallOp::config_proto() {
  auto attr = config_protoAttr();
  return attr.getValue();
}

::mlir::StringAttr StatefulPartitionedCallOp::executor_typeAttr() {
  return this->getAttr("executor_type").cast<::mlir::StringAttr>();
}

::llvm::StringRef StatefulPartitionedCallOp::executor_type() {
  auto attr = executor_typeAttr();
  return attr.getValue();
}

mlir::OperandElementTypeRange StatefulPartitionedCallOp::Tin() {
  auto values = getODSOperands(0);
return {mlir::OperandElementTypeIterator(values.begin()), mlir::OperandElementTypeIterator(values.end())};
}

mlir::ResultElementTypeRange StatefulPartitionedCallOp::Tout() {
  auto values = getODSResults(0);
return {mlir::ResultElementTypeIterator(values.begin()), mlir::ResultElementTypeIterator(values.end())};
}

bool StatefulPartitionedCallOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "Tin") return true;
  if (name == "Tout") return true;
 return false;
}

::mlir::DictionaryAttr StatefulPartitionedCallOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("Tin", ctx),
ArrayAttr::get(
    [&]() {
      llvm::SmallVector<Attribute, 4> ret;
      for (auto t : Tin())
        ret.push_back(TypeAttr::get(t));
      return ret;
    }(), ctx)},
    {::mlir::Identifier::get("Tout", ctx),
ArrayAttr::get(
    [&]() {
      llvm::SmallVector<Attribute, 4> ret;
      for (auto t : Tout())
        ret.push_back(TypeAttr::get(t));
      return ret;
    }(), ctx)}
    }, ctx);
}

void StatefulPartitionedCallOp::fAttr(::mlir::FlatSymbolRefAttr attr) {
  this->getOperation()->setAttr("f", attr);
}

void StatefulPartitionedCallOp::configAttr(::mlir::StringAttr attr) {
  this->getOperation()->setAttr("config", attr);
}

void StatefulPartitionedCallOp::config_protoAttr(::mlir::StringAttr attr) {
  this->getOperation()->setAttr("config_proto", attr);
}

void StatefulPartitionedCallOp::executor_typeAttr(::mlir::StringAttr attr) {
  this->getOperation()->setAttr("executor_type", attr);
}

void StatefulPartitionedCallOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange output, ::mlir::ValueRange args, ::mlir::FlatSymbolRefAttr f, ::mlir::StringAttr config, ::mlir::StringAttr config_proto, ::mlir::StringAttr executor_type) {
  odsState.addOperands(args);
  odsState.addAttribute("f", f);
  odsState.addAttribute("config", config);
  odsState.addAttribute("config_proto", config_proto);
  odsState.addAttribute("executor_type", executor_type);
  odsState.addTypes(output);
}

void StatefulPartitionedCallOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange output, ::mlir::ValueRange args, ::llvm::StringRef f, ::llvm::StringRef config, ::llvm::StringRef config_proto, ::llvm::StringRef executor_type) {
  odsState.addOperands(args);
  odsState.addAttribute("f", odsBuilder.getSymbolRefAttr(f));
  odsState.addAttribute("config", odsBuilder.getStringAttr(config));
  odsState.addAttribute("config_proto", odsBuilder.getStringAttr(config_proto));
  odsState.addAttribute("executor_type", odsBuilder.getStringAttr(executor_type));
  odsState.addTypes(output);
}

void StatefulPartitionedCallOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult StatefulPartitionedCallOp::verify() {
  if (failed(StatefulPartitionedCallOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>())))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::TensorFlowType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of tf.dtype values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>())))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::TensorFlowType>()))))) {
        return emitOpError("result #") << index << " must be tensor of tf.dtype values, but got " << v.getType();
      }
      ++index;
    }
  }
  return VerifyPartitionedCall(*this);
}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::StatefulStandardNormalV2Op definitions
//===----------------------------------------------------------------------===//

StatefulStandardNormalV2OpAdaptor::StatefulStandardNormalV2OpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

StatefulStandardNormalV2OpAdaptor::StatefulStandardNormalV2OpAdaptor(StatefulStandardNormalV2Op&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> StatefulStandardNormalV2OpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange StatefulStandardNormalV2OpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value StatefulStandardNormalV2OpAdaptor::resource() {
  return *getODSOperands(0).begin();
}

::mlir::Value StatefulStandardNormalV2OpAdaptor::algorithm() {
  return *getODSOperands(1).begin();
}

::mlir::Value StatefulStandardNormalV2OpAdaptor::shape() {
  return *getODSOperands(2).begin();
}

::mlir::LogicalResult StatefulStandardNormalV2OpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

::llvm::StringRef StatefulStandardNormalV2Op::getOperationName() {
  return "tf.StatefulStandardNormalV2";
}

std::pair<unsigned, unsigned> StatefulStandardNormalV2Op::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range StatefulStandardNormalV2Op::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value StatefulStandardNormalV2Op::resource() {
  return *getODSOperands(0).begin();
}

::mlir::Value StatefulStandardNormalV2Op::algorithm() {
  return *getODSOperands(1).begin();
}

::mlir::Value StatefulStandardNormalV2Op::shape() {
  return *getODSOperands(2).begin();
}

::mlir::MutableOperandRange StatefulStandardNormalV2Op::resourceMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange StatefulStandardNormalV2Op::algorithmMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange StatefulStandardNormalV2Op::shapeMutable() {
  auto range = getODSOperandIndexAndLength(2);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> StatefulStandardNormalV2Op::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range StatefulStandardNormalV2Op::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value StatefulStandardNormalV2Op::output() {
  return *getODSResults(0).begin();
}

Type StatefulStandardNormalV2Op::shape_dtype() {
  return mlir::getElementTypeOrSelf(*getODSOperands(2).begin());
}

Type StatefulStandardNormalV2Op::dtype() {
  return mlir::getElementTypeOrSelf(*getODSResults(0).begin());
}

bool StatefulStandardNormalV2Op::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "shape_dtype") return true;
  if (name == "dtype") return true;
 return false;
}

::mlir::DictionaryAttr StatefulStandardNormalV2Op::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("shape_dtype", ctx),
::mlir::TypeAttr::get(shape_dtype())},
    {::mlir::Identifier::get("dtype", ctx),
::mlir::TypeAttr::get(dtype())}
    }, ctx);
}

void StatefulStandardNormalV2Op::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value resource, ::mlir::Value algorithm, ::mlir::Value shape) {
  odsState.addOperands(resource);
  odsState.addOperands(algorithm);
  odsState.addOperands(shape);
  odsState.addTypes(output);
}

void StatefulStandardNormalV2Op::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value resource, ::mlir::Value algorithm, ::mlir::Value shape) {
  odsState.addOperands(resource);
  odsState.addOperands(algorithm);
  odsState.addOperands(shape);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void StatefulStandardNormalV2Op::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 3u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult StatefulStandardNormalV2Op::verify() {
  if (failed(StatefulStandardNormalV2OpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::ResourceType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::ResourceRefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of resource values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of 64-bit integer values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup2 = getODSOperands(2);
    for (::mlir::Value v : valueGroup2) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of 32/64-bit signed integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))))) {
        return emitOpError("result #") << index << " must be tensor of floating-point values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void StatefulStandardNormalV2Op::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
  for (::mlir::Value value : getODSOperands(0))
    effects.emplace_back(MemoryEffects::Read::get(), value, ::mlir::TF::ResourceEffects::Variable::get());
  for (::mlir::Value value : getODSOperands(0))
    effects.emplace_back(MemoryEffects::Write::get(), value, ::mlir::TF::ResourceEffects::Variable::get());
}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::StatefulTruncatedNormalOp definitions
//===----------------------------------------------------------------------===//

StatefulTruncatedNormalOpAdaptor::StatefulTruncatedNormalOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

StatefulTruncatedNormalOpAdaptor::StatefulTruncatedNormalOpAdaptor(StatefulTruncatedNormalOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> StatefulTruncatedNormalOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange StatefulTruncatedNormalOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value StatefulTruncatedNormalOpAdaptor::resource() {
  return *getODSOperands(0).begin();
}

::mlir::Value StatefulTruncatedNormalOpAdaptor::algorithm() {
  return *getODSOperands(1).begin();
}

::mlir::Value StatefulTruncatedNormalOpAdaptor::shape() {
  return *getODSOperands(2).begin();
}

::mlir::LogicalResult StatefulTruncatedNormalOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

::llvm::StringRef StatefulTruncatedNormalOp::getOperationName() {
  return "tf.StatefulTruncatedNormal";
}

std::pair<unsigned, unsigned> StatefulTruncatedNormalOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range StatefulTruncatedNormalOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value StatefulTruncatedNormalOp::resource() {
  return *getODSOperands(0).begin();
}

::mlir::Value StatefulTruncatedNormalOp::algorithm() {
  return *getODSOperands(1).begin();
}

::mlir::Value StatefulTruncatedNormalOp::shape() {
  return *getODSOperands(2).begin();
}

::mlir::MutableOperandRange StatefulTruncatedNormalOp::resourceMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange StatefulTruncatedNormalOp::algorithmMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange StatefulTruncatedNormalOp::shapeMutable() {
  auto range = getODSOperandIndexAndLength(2);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> StatefulTruncatedNormalOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range StatefulTruncatedNormalOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value StatefulTruncatedNormalOp::output() {
  return *getODSResults(0).begin();
}

Type StatefulTruncatedNormalOp::shape_dtype() {
  return mlir::getElementTypeOrSelf(*getODSOperands(2).begin());
}

Type StatefulTruncatedNormalOp::dtype() {
  return mlir::getElementTypeOrSelf(*getODSResults(0).begin());
}

bool StatefulTruncatedNormalOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "shape_dtype") return true;
  if (name == "dtype") return true;
 return false;
}

::mlir::DictionaryAttr StatefulTruncatedNormalOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("shape_dtype", ctx),
::mlir::TypeAttr::get(shape_dtype())},
    {::mlir::Identifier::get("dtype", ctx),
::mlir::TypeAttr::get(dtype())}
    }, ctx);
}

void StatefulTruncatedNormalOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value resource, ::mlir::Value algorithm, ::mlir::Value shape) {
  odsState.addOperands(resource);
  odsState.addOperands(algorithm);
  odsState.addOperands(shape);
  odsState.addTypes(output);
}

void StatefulTruncatedNormalOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value resource, ::mlir::Value algorithm, ::mlir::Value shape) {
  odsState.addOperands(resource);
  odsState.addOperands(algorithm);
  odsState.addOperands(shape);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void StatefulTruncatedNormalOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 3u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult StatefulTruncatedNormalOp::verify() {
  if (failed(StatefulTruncatedNormalOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::ResourceType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::ResourceRefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of resource values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of 64-bit integer values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup2 = getODSOperands(2);
    for (::mlir::Value v : valueGroup2) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of 32/64-bit signed integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))))) {
        return emitOpError("result #") << index << " must be tensor of floating-point values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void StatefulTruncatedNormalOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
  for (::mlir::Value value : getODSOperands(0))
    effects.emplace_back(MemoryEffects::Read::get(), value, ::mlir::TF::ResourceEffects::Variable::get());
  for (::mlir::Value value : getODSOperands(0))
    effects.emplace_back(MemoryEffects::Write::get(), value, ::mlir::TF::ResourceEffects::Variable::get());
}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::StatefulUniformFullIntOp definitions
//===----------------------------------------------------------------------===//

StatefulUniformFullIntOpAdaptor::StatefulUniformFullIntOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

StatefulUniformFullIntOpAdaptor::StatefulUniformFullIntOpAdaptor(StatefulUniformFullIntOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> StatefulUniformFullIntOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange StatefulUniformFullIntOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value StatefulUniformFullIntOpAdaptor::resource() {
  return *getODSOperands(0).begin();
}

::mlir::Value StatefulUniformFullIntOpAdaptor::algorithm() {
  return *getODSOperands(1).begin();
}

::mlir::Value StatefulUniformFullIntOpAdaptor::shape() {
  return *getODSOperands(2).begin();
}

::mlir::LogicalResult StatefulUniformFullIntOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

::llvm::StringRef StatefulUniformFullIntOp::getOperationName() {
  return "tf.StatefulUniformFullInt";
}

std::pair<unsigned, unsigned> StatefulUniformFullIntOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range StatefulUniformFullIntOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value StatefulUniformFullIntOp::resource() {
  return *getODSOperands(0).begin();
}

::mlir::Value StatefulUniformFullIntOp::algorithm() {
  return *getODSOperands(1).begin();
}

::mlir::Value StatefulUniformFullIntOp::shape() {
  return *getODSOperands(2).begin();
}

::mlir::MutableOperandRange StatefulUniformFullIntOp::resourceMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange StatefulUniformFullIntOp::algorithmMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange StatefulUniformFullIntOp::shapeMutable() {
  auto range = getODSOperandIndexAndLength(2);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> StatefulUniformFullIntOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range StatefulUniformFullIntOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value StatefulUniformFullIntOp::output() {
  return *getODSResults(0).begin();
}

Type StatefulUniformFullIntOp::shape_dtype() {
  return mlir::getElementTypeOrSelf(*getODSOperands(2).begin());
}

Type StatefulUniformFullIntOp::dtype() {
  return mlir::getElementTypeOrSelf(*getODSResults(0).begin());
}

bool StatefulUniformFullIntOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "shape_dtype") return true;
  if (name == "dtype") return true;
 return false;
}

::mlir::DictionaryAttr StatefulUniformFullIntOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("shape_dtype", ctx),
::mlir::TypeAttr::get(shape_dtype())},
    {::mlir::Identifier::get("dtype", ctx),
::mlir::TypeAttr::get(dtype())}
    }, ctx);
}

void StatefulUniformFullIntOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value resource, ::mlir::Value algorithm, ::mlir::Value shape) {
  odsState.addOperands(resource);
  odsState.addOperands(algorithm);
  odsState.addOperands(shape);
  odsState.addTypes(output);
}

void StatefulUniformFullIntOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value resource, ::mlir::Value algorithm, ::mlir::Value shape) {
  odsState.addOperands(resource);
  odsState.addOperands(algorithm);
  odsState.addOperands(shape);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void StatefulUniformFullIntOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 3u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult StatefulUniformFullIntOp::verify() {
  if (failed(StatefulUniformFullIntOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::ResourceType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::ResourceRefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of resource values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of 64-bit integer values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup2 = getODSOperands(2);
    for (::mlir::Value v : valueGroup2) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of 32/64-bit signed integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>())))))) {
        return emitOpError("result #") << index << " must be tensor of 32-bit integer or 64-bit integer or 32-bit unsigned integer or 64-bit unsigned integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void StatefulUniformFullIntOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
  for (::mlir::Value value : getODSOperands(0))
    effects.emplace_back(MemoryEffects::Read::get(), value, ::mlir::TF::ResourceEffects::Variable::get());
  for (::mlir::Value value : getODSOperands(0))
    effects.emplace_back(MemoryEffects::Write::get(), value, ::mlir::TF::ResourceEffects::Variable::get());
}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::StatefulUniformIntOp definitions
//===----------------------------------------------------------------------===//

StatefulUniformIntOpAdaptor::StatefulUniformIntOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

StatefulUniformIntOpAdaptor::StatefulUniformIntOpAdaptor(StatefulUniformIntOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> StatefulUniformIntOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange StatefulUniformIntOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value StatefulUniformIntOpAdaptor::resource() {
  return *getODSOperands(0).begin();
}

::mlir::Value StatefulUniformIntOpAdaptor::algorithm() {
  return *getODSOperands(1).begin();
}

::mlir::Value StatefulUniformIntOpAdaptor::shape() {
  return *getODSOperands(2).begin();
}

::mlir::Value StatefulUniformIntOpAdaptor::minval() {
  return *getODSOperands(3).begin();
}

::mlir::Value StatefulUniformIntOpAdaptor::maxval() {
  return *getODSOperands(4).begin();
}

::mlir::LogicalResult StatefulUniformIntOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

::llvm::StringRef StatefulUniformIntOp::getOperationName() {
  return "tf.StatefulUniformInt";
}

std::pair<unsigned, unsigned> StatefulUniformIntOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range StatefulUniformIntOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value StatefulUniformIntOp::resource() {
  return *getODSOperands(0).begin();
}

::mlir::Value StatefulUniformIntOp::algorithm() {
  return *getODSOperands(1).begin();
}

::mlir::Value StatefulUniformIntOp::shape() {
  return *getODSOperands(2).begin();
}

::mlir::Value StatefulUniformIntOp::minval() {
  return *getODSOperands(3).begin();
}

::mlir::Value StatefulUniformIntOp::maxval() {
  return *getODSOperands(4).begin();
}

::mlir::MutableOperandRange StatefulUniformIntOp::resourceMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange StatefulUniformIntOp::algorithmMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange StatefulUniformIntOp::shapeMutable() {
  auto range = getODSOperandIndexAndLength(2);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange StatefulUniformIntOp::minvalMutable() {
  auto range = getODSOperandIndexAndLength(3);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange StatefulUniformIntOp::maxvalMutable() {
  auto range = getODSOperandIndexAndLength(4);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> StatefulUniformIntOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range StatefulUniformIntOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value StatefulUniformIntOp::output() {
  return *getODSResults(0).begin();
}

Type StatefulUniformIntOp::shape_dtype() {
  return mlir::getElementTypeOrSelf(*getODSOperands(2).begin());
}

Type StatefulUniformIntOp::dtype() {
  return mlir::getElementTypeOrSelf(*getODSOperands(3).begin());
}

bool StatefulUniformIntOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "shape_dtype") return true;
  if (name == "dtype") return true;
 return false;
}

::mlir::DictionaryAttr StatefulUniformIntOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("shape_dtype", ctx),
::mlir::TypeAttr::get(shape_dtype())},
    {::mlir::Identifier::get("dtype", ctx),
::mlir::TypeAttr::get(dtype())}
    }, ctx);
}

void StatefulUniformIntOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value resource, ::mlir::Value algorithm, ::mlir::Value shape, ::mlir::Value minval, ::mlir::Value maxval) {
  odsState.addOperands(resource);
  odsState.addOperands(algorithm);
  odsState.addOperands(shape);
  odsState.addOperands(minval);
  odsState.addOperands(maxval);
  odsState.addTypes(output);
}

void StatefulUniformIntOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value resource, ::mlir::Value algorithm, ::mlir::Value shape, ::mlir::Value minval, ::mlir::Value maxval) {
  odsState.addOperands(resource);
  odsState.addOperands(algorithm);
  odsState.addOperands(shape);
  odsState.addOperands(minval);
  odsState.addOperands(maxval);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void StatefulUniformIntOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 5u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult StatefulUniformIntOp::verify() {
  if (failed(StatefulUniformIntOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::ResourceType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::ResourceRefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of resource values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of 64-bit integer values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup2 = getODSOperands(2);
    for (::mlir::Value v : valueGroup2) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of 32/64-bit signed integer values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup3 = getODSOperands(3);
    for (::mlir::Value v : valueGroup3) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of 32-bit integer or 64-bit integer or 32-bit unsigned integer or 64-bit unsigned integer values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup4 = getODSOperands(4);
    for (::mlir::Value v : valueGroup4) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of 32-bit integer or 64-bit integer or 32-bit unsigned integer or 64-bit unsigned integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>())))))) {
        return emitOpError("result #") << index << " must be tensor of 32-bit integer or 64-bit integer or 32-bit unsigned integer or 64-bit unsigned integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void StatefulUniformIntOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
  for (::mlir::Value value : getODSOperands(0))
    effects.emplace_back(MemoryEffects::Read::get(), value, ::mlir::TF::ResourceEffects::Variable::get());
  for (::mlir::Value value : getODSOperands(0))
    effects.emplace_back(MemoryEffects::Write::get(), value, ::mlir::TF::ResourceEffects::Variable::get());
}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::StatefulUniformOp definitions
//===----------------------------------------------------------------------===//

StatefulUniformOpAdaptor::StatefulUniformOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

StatefulUniformOpAdaptor::StatefulUniformOpAdaptor(StatefulUniformOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> StatefulUniformOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange StatefulUniformOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value StatefulUniformOpAdaptor::resource() {
  return *getODSOperands(0).begin();
}

::mlir::Value StatefulUniformOpAdaptor::algorithm() {
  return *getODSOperands(1).begin();
}

::mlir::Value StatefulUniformOpAdaptor::shape() {
  return *getODSOperands(2).begin();
}

::mlir::LogicalResult StatefulUniformOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

::llvm::StringRef StatefulUniformOp::getOperationName() {
  return "tf.StatefulUniform";
}

std::pair<unsigned, unsigned> StatefulUniformOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range StatefulUniformOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value StatefulUniformOp::resource() {
  return *getODSOperands(0).begin();
}

::mlir::Value StatefulUniformOp::algorithm() {
  return *getODSOperands(1).begin();
}

::mlir::Value StatefulUniformOp::shape() {
  return *getODSOperands(2).begin();
}

::mlir::MutableOperandRange StatefulUniformOp::resourceMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange StatefulUniformOp::algorithmMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange StatefulUniformOp::shapeMutable() {
  auto range = getODSOperandIndexAndLength(2);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> StatefulUniformOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range StatefulUniformOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value StatefulUniformOp::output() {
  return *getODSResults(0).begin();
}

Type StatefulUniformOp::shape_dtype() {
  return mlir::getElementTypeOrSelf(*getODSOperands(2).begin());
}

Type StatefulUniformOp::dtype() {
  return mlir::getElementTypeOrSelf(*getODSResults(0).begin());
}

bool StatefulUniformOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "shape_dtype") return true;
  if (name == "dtype") return true;
 return false;
}

::mlir::DictionaryAttr StatefulUniformOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("shape_dtype", ctx),
::mlir::TypeAttr::get(shape_dtype())},
    {::mlir::Identifier::get("dtype", ctx),
::mlir::TypeAttr::get(dtype())}
    }, ctx);
}

void StatefulUniformOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value resource, ::mlir::Value algorithm, ::mlir::Value shape) {
  odsState.addOperands(resource);
  odsState.addOperands(algorithm);
  odsState.addOperands(shape);
  odsState.addTypes(output);
}

void StatefulUniformOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value resource, ::mlir::Value algorithm, ::mlir::Value shape) {
  odsState.addOperands(resource);
  odsState.addOperands(algorithm);
  odsState.addOperands(shape);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void StatefulUniformOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 3u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult StatefulUniformOp::verify() {
  if (failed(StatefulUniformOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::ResourceType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::ResourceRefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of resource values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of 64-bit integer values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup2 = getODSOperands(2);
    for (::mlir::Value v : valueGroup2) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of 32/64-bit signed integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))))) {
        return emitOpError("result #") << index << " must be tensor of floating-point values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void StatefulUniformOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
  for (::mlir::Value value : getODSOperands(0))
    effects.emplace_back(MemoryEffects::Read::get(), value, ::mlir::TF::ResourceEffects::Variable::get());
  for (::mlir::Value value : getODSOperands(0))
    effects.emplace_back(MemoryEffects::Write::get(), value, ::mlir::TF::ResourceEffects::Variable::get());
}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::StatelessMultinomialOp definitions
//===----------------------------------------------------------------------===//

StatelessMultinomialOpAdaptor::StatelessMultinomialOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

StatelessMultinomialOpAdaptor::StatelessMultinomialOpAdaptor(StatelessMultinomialOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> StatelessMultinomialOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange StatelessMultinomialOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value StatelessMultinomialOpAdaptor::logits() {
  return *getODSOperands(0).begin();
}

::mlir::Value StatelessMultinomialOpAdaptor::num_samples() {
  return *getODSOperands(1).begin();
}

::mlir::Value StatelessMultinomialOpAdaptor::seed() {
  return *getODSOperands(2).begin();
}

::mlir::LogicalResult StatelessMultinomialOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

::llvm::StringRef StatelessMultinomialOp::getOperationName() {
  return "tf.StatelessMultinomial";
}

std::pair<unsigned, unsigned> StatelessMultinomialOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range StatelessMultinomialOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value StatelessMultinomialOp::logits() {
  return *getODSOperands(0).begin();
}

::mlir::Value StatelessMultinomialOp::num_samples() {
  return *getODSOperands(1).begin();
}

::mlir::Value StatelessMultinomialOp::seed() {
  return *getODSOperands(2).begin();
}

::mlir::MutableOperandRange StatelessMultinomialOp::logitsMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange StatelessMultinomialOp::num_samplesMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange StatelessMultinomialOp::seedMutable() {
  auto range = getODSOperandIndexAndLength(2);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> StatelessMultinomialOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range StatelessMultinomialOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value StatelessMultinomialOp::output() {
  return *getODSResults(0).begin();
}

Type StatelessMultinomialOp::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

Type StatelessMultinomialOp::Tseed() {
  return mlir::getElementTypeOrSelf(*getODSOperands(2).begin());
}

Type StatelessMultinomialOp::output_dtype() {
  return mlir::getElementTypeOrSelf(*getODSResults(0).begin());
}

bool StatelessMultinomialOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "T") return true;
  if (name == "Tseed") return true;
  if (name == "output_dtype") return true;
 return false;
}

::mlir::DictionaryAttr StatelessMultinomialOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())},
    {::mlir::Identifier::get("Tseed", ctx),
::mlir::TypeAttr::get(Tseed())},
    {::mlir::Identifier::get("output_dtype", ctx),
::mlir::TypeAttr::get(output_dtype())}
    }, ctx);
}

void StatelessMultinomialOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value logits, ::mlir::Value num_samples, ::mlir::Value seed) {
  odsState.addOperands(logits);
  odsState.addOperands(num_samples);
  odsState.addOperands(seed);
  odsState.addTypes(output);
}

void StatelessMultinomialOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value logits, ::mlir::Value num_samples, ::mlir::Value seed) {
  odsState.addOperands(logits);
  odsState.addOperands(num_samples);
  odsState.addOperands(seed);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void StatelessMultinomialOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 3u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult StatelessMultinomialOp::verify() {
  if (failed(StatelessMultinomialOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of integer or floating-point values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of 32-bit integer values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup2 = getODSOperands(2);
    for (::mlir::Value v : valueGroup2) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of 32/64-bit signed integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))))) {
        return emitOpError("result #") << index << " must be tensor of 32/64-bit signed integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void StatelessMultinomialOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::StatelessParameterizedTruncatedNormalOp definitions
//===----------------------------------------------------------------------===//

StatelessParameterizedTruncatedNormalOpAdaptor::StatelessParameterizedTruncatedNormalOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

StatelessParameterizedTruncatedNormalOpAdaptor::StatelessParameterizedTruncatedNormalOpAdaptor(StatelessParameterizedTruncatedNormalOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> StatelessParameterizedTruncatedNormalOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange StatelessParameterizedTruncatedNormalOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value StatelessParameterizedTruncatedNormalOpAdaptor::shape() {
  return *getODSOperands(0).begin();
}

::mlir::Value StatelessParameterizedTruncatedNormalOpAdaptor::seed() {
  return *getODSOperands(1).begin();
}

::mlir::Value StatelessParameterizedTruncatedNormalOpAdaptor::means() {
  return *getODSOperands(2).begin();
}

::mlir::Value StatelessParameterizedTruncatedNormalOpAdaptor::stddevs() {
  return *getODSOperands(3).begin();
}

::mlir::Value StatelessParameterizedTruncatedNormalOpAdaptor::minvals() {
  return *getODSOperands(4).begin();
}

::mlir::Value StatelessParameterizedTruncatedNormalOpAdaptor::maxvals() {
  return *getODSOperands(5).begin();
}

::mlir::LogicalResult StatelessParameterizedTruncatedNormalOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

::llvm::StringRef StatelessParameterizedTruncatedNormalOp::getOperationName() {
  return "tf.StatelessParameterizedTruncatedNormal";
}

std::pair<unsigned, unsigned> StatelessParameterizedTruncatedNormalOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range StatelessParameterizedTruncatedNormalOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value StatelessParameterizedTruncatedNormalOp::shape() {
  return *getODSOperands(0).begin();
}

::mlir::Value StatelessParameterizedTruncatedNormalOp::seed() {
  return *getODSOperands(1).begin();
}

::mlir::Value StatelessParameterizedTruncatedNormalOp::means() {
  return *getODSOperands(2).begin();
}

::mlir::Value StatelessParameterizedTruncatedNormalOp::stddevs() {
  return *getODSOperands(3).begin();
}

::mlir::Value StatelessParameterizedTruncatedNormalOp::minvals() {
  return *getODSOperands(4).begin();
}

::mlir::Value StatelessParameterizedTruncatedNormalOp::maxvals() {
  return *getODSOperands(5).begin();
}

::mlir::MutableOperandRange StatelessParameterizedTruncatedNormalOp::shapeMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange StatelessParameterizedTruncatedNormalOp::seedMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange StatelessParameterizedTruncatedNormalOp::meansMutable() {
  auto range = getODSOperandIndexAndLength(2);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange StatelessParameterizedTruncatedNormalOp::stddevsMutable() {
  auto range = getODSOperandIndexAndLength(3);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange StatelessParameterizedTruncatedNormalOp::minvalsMutable() {
  auto range = getODSOperandIndexAndLength(4);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange StatelessParameterizedTruncatedNormalOp::maxvalsMutable() {
  auto range = getODSOperandIndexAndLength(5);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> StatelessParameterizedTruncatedNormalOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range StatelessParameterizedTruncatedNormalOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value StatelessParameterizedTruncatedNormalOp::output() {
  return *getODSResults(0).begin();
}

Type StatelessParameterizedTruncatedNormalOp::S() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

Type StatelessParameterizedTruncatedNormalOp::Tseed() {
  return mlir::getElementTypeOrSelf(*getODSOperands(1).begin());
}

Type StatelessParameterizedTruncatedNormalOp::dtype() {
  return mlir::getElementTypeOrSelf(*getODSOperands(2).begin());
}

bool StatelessParameterizedTruncatedNormalOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "S") return true;
  if (name == "Tseed") return true;
  if (name == "dtype") return true;
 return false;
}

::mlir::DictionaryAttr StatelessParameterizedTruncatedNormalOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("S", ctx),
::mlir::TypeAttr::get(S())},
    {::mlir::Identifier::get("Tseed", ctx),
::mlir::TypeAttr::get(Tseed())},
    {::mlir::Identifier::get("dtype", ctx),
::mlir::TypeAttr::get(dtype())}
    }, ctx);
}

void StatelessParameterizedTruncatedNormalOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value shape, ::mlir::Value seed, ::mlir::Value means, ::mlir::Value stddevs, ::mlir::Value minvals, ::mlir::Value maxvals) {
  odsState.addOperands(shape);
  odsState.addOperands(seed);
  odsState.addOperands(means);
  odsState.addOperands(stddevs);
  odsState.addOperands(minvals);
  odsState.addOperands(maxvals);
  odsState.addTypes(output);
}

void StatelessParameterizedTruncatedNormalOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value shape, ::mlir::Value seed, ::mlir::Value means, ::mlir::Value stddevs, ::mlir::Value minvals, ::mlir::Value maxvals) {
  odsState.addOperands(shape);
  odsState.addOperands(seed);
  odsState.addOperands(means);
  odsState.addOperands(stddevs);
  odsState.addOperands(minvals);
  odsState.addOperands(maxvals);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void StatelessParameterizedTruncatedNormalOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 6u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult StatelessParameterizedTruncatedNormalOp::verify() {
  if (failed(StatelessParameterizedTruncatedNormalOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of 32/64-bit signed integer values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of 32/64-bit signed integer values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup2 = getODSOperands(2);
    for (::mlir::Value v : valueGroup2) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of 16-bit float or 32-bit float or 64-bit float values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup3 = getODSOperands(3);
    for (::mlir::Value v : valueGroup3) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of 16-bit float or 32-bit float or 64-bit float values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup4 = getODSOperands(4);
    for (::mlir::Value v : valueGroup4) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of 16-bit float or 32-bit float or 64-bit float values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup5 = getODSOperands(5);
    for (::mlir::Value v : valueGroup5) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of 16-bit float or 32-bit float or 64-bit float values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())))))) {
        return emitOpError("result #") << index << " must be tensor of 16-bit float or 32-bit float or 64-bit float values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void StatelessParameterizedTruncatedNormalOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::StatelessRandomBinomialOp definitions
//===----------------------------------------------------------------------===//

StatelessRandomBinomialOpAdaptor::StatelessRandomBinomialOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

StatelessRandomBinomialOpAdaptor::StatelessRandomBinomialOpAdaptor(StatelessRandomBinomialOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> StatelessRandomBinomialOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange StatelessRandomBinomialOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value StatelessRandomBinomialOpAdaptor::shape() {
  return *getODSOperands(0).begin();
}

::mlir::Value StatelessRandomBinomialOpAdaptor::seed() {
  return *getODSOperands(1).begin();
}

::mlir::Value StatelessRandomBinomialOpAdaptor::counts() {
  return *getODSOperands(2).begin();
}

::mlir::Value StatelessRandomBinomialOpAdaptor::probs() {
  return *getODSOperands(3).begin();
}

::mlir::LogicalResult StatelessRandomBinomialOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

::llvm::StringRef StatelessRandomBinomialOp::getOperationName() {
  return "tf.StatelessRandomBinomial";
}

std::pair<unsigned, unsigned> StatelessRandomBinomialOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range StatelessRandomBinomialOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value StatelessRandomBinomialOp::shape() {
  return *getODSOperands(0).begin();
}

::mlir::Value StatelessRandomBinomialOp::seed() {
  return *getODSOperands(1).begin();
}

::mlir::Value StatelessRandomBinomialOp::counts() {
  return *getODSOperands(2).begin();
}

::mlir::Value StatelessRandomBinomialOp::probs() {
  return *getODSOperands(3).begin();
}

::mlir::MutableOperandRange StatelessRandomBinomialOp::shapeMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange StatelessRandomBinomialOp::seedMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange StatelessRandomBinomialOp::countsMutable() {
  auto range = getODSOperandIndexAndLength(2);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange StatelessRandomBinomialOp::probsMutable() {
  auto range = getODSOperandIndexAndLength(3);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> StatelessRandomBinomialOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range StatelessRandomBinomialOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value StatelessRandomBinomialOp::output() {
  return *getODSResults(0).begin();
}

Type StatelessRandomBinomialOp::S() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

Type StatelessRandomBinomialOp::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(2).begin());
}

Type StatelessRandomBinomialOp::Tseed() {
  return mlir::getElementTypeOrSelf(*getODSOperands(1).begin());
}

Type StatelessRandomBinomialOp::dtype() {
  return mlir::getElementTypeOrSelf(*getODSResults(0).begin());
}

bool StatelessRandomBinomialOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "S") return true;
  if (name == "T") return true;
  if (name == "Tseed") return true;
  if (name == "dtype") return true;
 return false;
}

::mlir::DictionaryAttr StatelessRandomBinomialOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("S", ctx),
::mlir::TypeAttr::get(S())},
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())},
    {::mlir::Identifier::get("Tseed", ctx),
::mlir::TypeAttr::get(Tseed())},
    {::mlir::Identifier::get("dtype", ctx),
::mlir::TypeAttr::get(dtype())}
    }, ctx);
}

void StatelessRandomBinomialOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value shape, ::mlir::Value seed, ::mlir::Value counts, ::mlir::Value probs) {
  odsState.addOperands(shape);
  odsState.addOperands(seed);
  odsState.addOperands(counts);
  odsState.addOperands(probs);
  odsState.addTypes(output);
}

void StatelessRandomBinomialOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value shape, ::mlir::Value seed, ::mlir::Value counts, ::mlir::Value probs) {
  odsState.addOperands(shape);
  odsState.addOperands(seed);
  odsState.addOperands(counts);
  odsState.addOperands(probs);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void StatelessRandomBinomialOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 4u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult StatelessRandomBinomialOp::verify() {
  if (failed(StatelessRandomBinomialOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of 32/64-bit signed integer values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of 32/64-bit signed integer values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup2 = getODSOperands(2);
    for (::mlir::Value v : valueGroup2) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of 16-bit float or 32-bit float or 64-bit float or 32-bit integer or 64-bit integer values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup3 = getODSOperands(3);
    for (::mlir::Value v : valueGroup3) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of 16-bit float or 32-bit float or 64-bit float or 32-bit integer or 64-bit integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))))) {
        return emitOpError("result #") << index << " must be tensor of 16-bit float or 32-bit float or 64-bit float or 32-bit integer or 64-bit integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void StatelessRandomBinomialOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::StatelessRandomGammaV2Op definitions
//===----------------------------------------------------------------------===//

StatelessRandomGammaV2OpAdaptor::StatelessRandomGammaV2OpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

StatelessRandomGammaV2OpAdaptor::StatelessRandomGammaV2OpAdaptor(StatelessRandomGammaV2Op&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> StatelessRandomGammaV2OpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange StatelessRandomGammaV2OpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value StatelessRandomGammaV2OpAdaptor::shape() {
  return *getODSOperands(0).begin();
}

::mlir::Value StatelessRandomGammaV2OpAdaptor::seed() {
  return *getODSOperands(1).begin();
}

::mlir::Value StatelessRandomGammaV2OpAdaptor::alpha() {
  return *getODSOperands(2).begin();
}

::mlir::LogicalResult StatelessRandomGammaV2OpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

::llvm::StringRef StatelessRandomGammaV2Op::getOperationName() {
  return "tf.StatelessRandomGammaV2";
}

std::pair<unsigned, unsigned> StatelessRandomGammaV2Op::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range StatelessRandomGammaV2Op::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value StatelessRandomGammaV2Op::shape() {
  return *getODSOperands(0).begin();
}

::mlir::Value StatelessRandomGammaV2Op::seed() {
  return *getODSOperands(1).begin();
}

::mlir::Value StatelessRandomGammaV2Op::alpha() {
  return *getODSOperands(2).begin();
}

::mlir::MutableOperandRange StatelessRandomGammaV2Op::shapeMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange StatelessRandomGammaV2Op::seedMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange StatelessRandomGammaV2Op::alphaMutable() {
  auto range = getODSOperandIndexAndLength(2);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> StatelessRandomGammaV2Op::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range StatelessRandomGammaV2Op::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value StatelessRandomGammaV2Op::output() {
  return *getODSResults(0).begin();
}

Type StatelessRandomGammaV2Op::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

Type StatelessRandomGammaV2Op::Tseed() {
  return mlir::getElementTypeOrSelf(*getODSOperands(1).begin());
}

Type StatelessRandomGammaV2Op::dtype() {
  return mlir::getElementTypeOrSelf(*getODSOperands(2).begin());
}

bool StatelessRandomGammaV2Op::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "T") return true;
  if (name == "Tseed") return true;
  if (name == "dtype") return true;
 return false;
}

::mlir::DictionaryAttr StatelessRandomGammaV2Op::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())},
    {::mlir::Identifier::get("Tseed", ctx),
::mlir::TypeAttr::get(Tseed())},
    {::mlir::Identifier::get("dtype", ctx),
::mlir::TypeAttr::get(dtype())}
    }, ctx);
}

void StatelessRandomGammaV2Op::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value shape, ::mlir::Value seed, ::mlir::Value alpha) {
  odsState.addOperands(shape);
  odsState.addOperands(seed);
  odsState.addOperands(alpha);
  odsState.addTypes(output);
}

void StatelessRandomGammaV2Op::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value shape, ::mlir::Value seed, ::mlir::Value alpha) {
  odsState.addOperands(shape);
  odsState.addOperands(seed);
  odsState.addOperands(alpha);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void StatelessRandomGammaV2Op::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 3u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult StatelessRandomGammaV2Op::verify() {
  if (failed(StatelessRandomGammaV2OpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of 32/64-bit signed integer values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of 32/64-bit signed integer values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup2 = getODSOperands(2);
    for (::mlir::Value v : valueGroup2) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of 16-bit float or 32-bit float or 64-bit float values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())))))) {
        return emitOpError("result #") << index << " must be tensor of 16-bit float or 32-bit float or 64-bit float values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void StatelessRandomGammaV2Op::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::StatelessRandomNormalOp definitions
//===----------------------------------------------------------------------===//

StatelessRandomNormalOpAdaptor::StatelessRandomNormalOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

StatelessRandomNormalOpAdaptor::StatelessRandomNormalOpAdaptor(StatelessRandomNormalOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> StatelessRandomNormalOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange StatelessRandomNormalOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value StatelessRandomNormalOpAdaptor::shape() {
  return *getODSOperands(0).begin();
}

::mlir::Value StatelessRandomNormalOpAdaptor::seed() {
  return *getODSOperands(1).begin();
}

::mlir::LogicalResult StatelessRandomNormalOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

::llvm::StringRef StatelessRandomNormalOp::getOperationName() {
  return "tf.StatelessRandomNormal";
}

std::pair<unsigned, unsigned> StatelessRandomNormalOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range StatelessRandomNormalOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value StatelessRandomNormalOp::shape() {
  return *getODSOperands(0).begin();
}

::mlir::Value StatelessRandomNormalOp::seed() {
  return *getODSOperands(1).begin();
}

::mlir::MutableOperandRange StatelessRandomNormalOp::shapeMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange StatelessRandomNormalOp::seedMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> StatelessRandomNormalOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range StatelessRandomNormalOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value StatelessRandomNormalOp::output() {
  return *getODSResults(0).begin();
}

Type StatelessRandomNormalOp::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

Type StatelessRandomNormalOp::Tseed() {
  return mlir::getElementTypeOrSelf(*getODSOperands(1).begin());
}

Type StatelessRandomNormalOp::dtype() {
  return mlir::getElementTypeOrSelf(*getODSResults(0).begin());
}

bool StatelessRandomNormalOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "T") return true;
  if (name == "Tseed") return true;
  if (name == "dtype") return true;
 return false;
}

::mlir::DictionaryAttr StatelessRandomNormalOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())},
    {::mlir::Identifier::get("Tseed", ctx),
::mlir::TypeAttr::get(Tseed())},
    {::mlir::Identifier::get("dtype", ctx),
::mlir::TypeAttr::get(dtype())}
    }, ctx);
}

void StatelessRandomNormalOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value shape, ::mlir::Value seed) {
  odsState.addOperands(shape);
  odsState.addOperands(seed);
  odsState.addTypes(output);
}

void StatelessRandomNormalOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value shape, ::mlir::Value seed) {
  odsState.addOperands(shape);
  odsState.addOperands(seed);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void StatelessRandomNormalOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult StatelessRandomNormalOp::verify() {
  if (failed(StatelessRandomNormalOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of 32/64-bit signed integer values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of 32/64-bit signed integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))))) {
        return emitOpError("result #") << index << " must be tensor of floating-point values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void StatelessRandomNormalOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::StatelessRandomPoissonOp definitions
//===----------------------------------------------------------------------===//

StatelessRandomPoissonOpAdaptor::StatelessRandomPoissonOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

StatelessRandomPoissonOpAdaptor::StatelessRandomPoissonOpAdaptor(StatelessRandomPoissonOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> StatelessRandomPoissonOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange StatelessRandomPoissonOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value StatelessRandomPoissonOpAdaptor::shape() {
  return *getODSOperands(0).begin();
}

::mlir::Value StatelessRandomPoissonOpAdaptor::seed() {
  return *getODSOperands(1).begin();
}

::mlir::Value StatelessRandomPoissonOpAdaptor::lam() {
  return *getODSOperands(2).begin();
}

::mlir::LogicalResult StatelessRandomPoissonOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

::llvm::StringRef StatelessRandomPoissonOp::getOperationName() {
  return "tf.StatelessRandomPoisson";
}

std::pair<unsigned, unsigned> StatelessRandomPoissonOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range StatelessRandomPoissonOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value StatelessRandomPoissonOp::shape() {
  return *getODSOperands(0).begin();
}

::mlir::Value StatelessRandomPoissonOp::seed() {
  return *getODSOperands(1).begin();
}

::mlir::Value StatelessRandomPoissonOp::lam() {
  return *getODSOperands(2).begin();
}

::mlir::MutableOperandRange StatelessRandomPoissonOp::shapeMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange StatelessRandomPoissonOp::seedMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange StatelessRandomPoissonOp::lamMutable() {
  auto range = getODSOperandIndexAndLength(2);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> StatelessRandomPoissonOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range StatelessRandomPoissonOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value StatelessRandomPoissonOp::output() {
  return *getODSResults(0).begin();
}

Type StatelessRandomPoissonOp::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

Type StatelessRandomPoissonOp::Tseed() {
  return mlir::getElementTypeOrSelf(*getODSOperands(1).begin());
}

Type StatelessRandomPoissonOp::dtype() {
  return mlir::getElementTypeOrSelf(*getODSResults(0).begin());
}

Type StatelessRandomPoissonOp::Rtype() {
  return mlir::getElementTypeOrSelf(*getODSOperands(2).begin());
}

bool StatelessRandomPoissonOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "T") return true;
  if (name == "Tseed") return true;
  if (name == "dtype") return true;
  if (name == "Rtype") return true;
 return false;
}

::mlir::DictionaryAttr StatelessRandomPoissonOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())},
    {::mlir::Identifier::get("Tseed", ctx),
::mlir::TypeAttr::get(Tseed())},
    {::mlir::Identifier::get("dtype", ctx),
::mlir::TypeAttr::get(dtype())},
    {::mlir::Identifier::get("Rtype", ctx),
::mlir::TypeAttr::get(Rtype())}
    }, ctx);
}

void StatelessRandomPoissonOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value shape, ::mlir::Value seed, ::mlir::Value lam) {
  odsState.addOperands(shape);
  odsState.addOperands(seed);
  odsState.addOperands(lam);
  odsState.addTypes(output);
}

void StatelessRandomPoissonOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value shape, ::mlir::Value seed, ::mlir::Value lam) {
  odsState.addOperands(shape);
  odsState.addOperands(seed);
  odsState.addOperands(lam);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void StatelessRandomPoissonOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 3u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult StatelessRandomPoissonOp::verify() {
  if (failed(StatelessRandomPoissonOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of 32/64-bit signed integer values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of 32/64-bit signed integer values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup2 = getODSOperands(2);
    for (::mlir::Value v : valueGroup2) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of 16-bit float or 32-bit float or 64-bit float or 32-bit integer or 64-bit integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))))) {
        return emitOpError("result #") << index << " must be tensor of 16-bit float or 32-bit float or 64-bit float or 32-bit integer or 64-bit integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void StatelessRandomPoissonOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::StatelessRandomUniformFullIntOp definitions
//===----------------------------------------------------------------------===//

StatelessRandomUniformFullIntOpAdaptor::StatelessRandomUniformFullIntOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

StatelessRandomUniformFullIntOpAdaptor::StatelessRandomUniformFullIntOpAdaptor(StatelessRandomUniformFullIntOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> StatelessRandomUniformFullIntOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange StatelessRandomUniformFullIntOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value StatelessRandomUniformFullIntOpAdaptor::shape() {
  return *getODSOperands(0).begin();
}

::mlir::Value StatelessRandomUniformFullIntOpAdaptor::seed() {
  return *getODSOperands(1).begin();
}

::mlir::LogicalResult StatelessRandomUniformFullIntOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

::llvm::StringRef StatelessRandomUniformFullIntOp::getOperationName() {
  return "tf.StatelessRandomUniformFullInt";
}

std::pair<unsigned, unsigned> StatelessRandomUniformFullIntOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range StatelessRandomUniformFullIntOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value StatelessRandomUniformFullIntOp::shape() {
  return *getODSOperands(0).begin();
}

::mlir::Value StatelessRandomUniformFullIntOp::seed() {
  return *getODSOperands(1).begin();
}

::mlir::MutableOperandRange StatelessRandomUniformFullIntOp::shapeMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange StatelessRandomUniformFullIntOp::seedMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> StatelessRandomUniformFullIntOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range StatelessRandomUniformFullIntOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value StatelessRandomUniformFullIntOp::output() {
  return *getODSResults(0).begin();
}

Type StatelessRandomUniformFullIntOp::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

Type StatelessRandomUniformFullIntOp::Tseed() {
  return mlir::getElementTypeOrSelf(*getODSOperands(1).begin());
}

Type StatelessRandomUniformFullIntOp::dtype() {
  return mlir::getElementTypeOrSelf(*getODSResults(0).begin());
}

bool StatelessRandomUniformFullIntOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "T") return true;
  if (name == "Tseed") return true;
  if (name == "dtype") return true;
 return false;
}

::mlir::DictionaryAttr StatelessRandomUniformFullIntOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())},
    {::mlir::Identifier::get("Tseed", ctx),
::mlir::TypeAttr::get(Tseed())},
    {::mlir::Identifier::get("dtype", ctx),
::mlir::TypeAttr::get(dtype())}
    }, ctx);
}

void StatelessRandomUniformFullIntOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value shape, ::mlir::Value seed) {
  odsState.addOperands(shape);
  odsState.addOperands(seed);
  odsState.addTypes(output);
}

void StatelessRandomUniformFullIntOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value shape, ::mlir::Value seed) {
  odsState.addOperands(shape);
  odsState.addOperands(seed);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void StatelessRandomUniformFullIntOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult StatelessRandomUniformFullIntOp::verify() {
  if (failed(StatelessRandomUniformFullIntOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of 32/64-bit signed integer values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of 32-bit integer or 64-bit integer or 32-bit unsigned integer or 64-bit unsigned integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>())))))) {
        return emitOpError("result #") << index << " must be tensor of 32-bit integer or 64-bit integer or 32-bit unsigned integer or 64-bit unsigned integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void StatelessRandomUniformFullIntOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::StatelessRandomUniformIntOp definitions
//===----------------------------------------------------------------------===//

StatelessRandomUniformIntOpAdaptor::StatelessRandomUniformIntOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

StatelessRandomUniformIntOpAdaptor::StatelessRandomUniformIntOpAdaptor(StatelessRandomUniformIntOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> StatelessRandomUniformIntOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange StatelessRandomUniformIntOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value StatelessRandomUniformIntOpAdaptor::shape() {
  return *getODSOperands(0).begin();
}

::mlir::Value StatelessRandomUniformIntOpAdaptor::seed() {
  return *getODSOperands(1).begin();
}

::mlir::Value StatelessRandomUniformIntOpAdaptor::minval() {
  return *getODSOperands(2).begin();
}

::mlir::Value StatelessRandomUniformIntOpAdaptor::maxval() {
  return *getODSOperands(3).begin();
}

::mlir::LogicalResult StatelessRandomUniformIntOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

::llvm::StringRef StatelessRandomUniformIntOp::getOperationName() {
  return "tf.StatelessRandomUniformInt";
}

std::pair<unsigned, unsigned> StatelessRandomUniformIntOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range StatelessRandomUniformIntOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value StatelessRandomUniformIntOp::shape() {
  return *getODSOperands(0).begin();
}

::mlir::Value StatelessRandomUniformIntOp::seed() {
  return *getODSOperands(1).begin();
}

::mlir::Value StatelessRandomUniformIntOp::minval() {
  return *getODSOperands(2).begin();
}

::mlir::Value StatelessRandomUniformIntOp::maxval() {
  return *getODSOperands(3).begin();
}

::mlir::MutableOperandRange StatelessRandomUniformIntOp::shapeMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange StatelessRandomUniformIntOp::seedMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange StatelessRandomUniformIntOp::minvalMutable() {
  auto range = getODSOperandIndexAndLength(2);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange StatelessRandomUniformIntOp::maxvalMutable() {
  auto range = getODSOperandIndexAndLength(3);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> StatelessRandomUniformIntOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range StatelessRandomUniformIntOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value StatelessRandomUniformIntOp::output() {
  return *getODSResults(0).begin();
}

Type StatelessRandomUniformIntOp::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

Type StatelessRandomUniformIntOp::Tseed() {
  return mlir::getElementTypeOrSelf(*getODSOperands(1).begin());
}

Type StatelessRandomUniformIntOp::dtype() {
  return mlir::getElementTypeOrSelf(*getODSOperands(2).begin());
}

bool StatelessRandomUniformIntOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "T") return true;
  if (name == "Tseed") return true;
  if (name == "dtype") return true;
 return false;
}

::mlir::DictionaryAttr StatelessRandomUniformIntOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())},
    {::mlir::Identifier::get("Tseed", ctx),
::mlir::TypeAttr::get(Tseed())},
    {::mlir::Identifier::get("dtype", ctx),
::mlir::TypeAttr::get(dtype())}
    }, ctx);
}

void StatelessRandomUniformIntOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value shape, ::mlir::Value seed, ::mlir::Value minval, ::mlir::Value maxval) {
  odsState.addOperands(shape);
  odsState.addOperands(seed);
  odsState.addOperands(minval);
  odsState.addOperands(maxval);
  odsState.addTypes(output);
}

void StatelessRandomUniformIntOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value shape, ::mlir::Value seed, ::mlir::Value minval, ::mlir::Value maxval) {
  odsState.addOperands(shape);
  odsState.addOperands(seed);
  odsState.addOperands(minval);
  odsState.addOperands(maxval);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void StatelessRandomUniformIntOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 4u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult StatelessRandomUniformIntOp::verify() {
  if (failed(StatelessRandomUniformIntOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of 32/64-bit signed integer values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of 32/64-bit signed integer values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup2 = getODSOperands(2);
    for (::mlir::Value v : valueGroup2) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of 32/64-bit signed integer values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup3 = getODSOperands(3);
    for (::mlir::Value v : valueGroup3) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of 32/64-bit signed integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))))) {
        return emitOpError("result #") << index << " must be tensor of 32/64-bit signed integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void StatelessRandomUniformIntOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::StatelessRandomUniformOp definitions
//===----------------------------------------------------------------------===//

StatelessRandomUniformOpAdaptor::StatelessRandomUniformOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

StatelessRandomUniformOpAdaptor::StatelessRandomUniformOpAdaptor(StatelessRandomUniformOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> StatelessRandomUniformOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange StatelessRandomUniformOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value StatelessRandomUniformOpAdaptor::shape() {
  return *getODSOperands(0).begin();
}

::mlir::Value StatelessRandomUniformOpAdaptor::seed() {
  return *getODSOperands(1).begin();
}

::mlir::LogicalResult StatelessRandomUniformOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

::llvm::StringRef StatelessRandomUniformOp::getOperationName() {
  return "tf.StatelessRandomUniform";
}

std::pair<unsigned, unsigned> StatelessRandomUniformOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range StatelessRandomUniformOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value StatelessRandomUniformOp::shape() {
  return *getODSOperands(0).begin();
}

::mlir::Value StatelessRandomUniformOp::seed() {
  return *getODSOperands(1).begin();
}

::mlir::MutableOperandRange StatelessRandomUniformOp::shapeMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange StatelessRandomUniformOp::seedMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> StatelessRandomUniformOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range StatelessRandomUniformOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value StatelessRandomUniformOp::output() {
  return *getODSResults(0).begin();
}

Type StatelessRandomUniformOp::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

Type StatelessRandomUniformOp::Tseed() {
  return mlir::getElementTypeOrSelf(*getODSOperands(1).begin());
}

Type StatelessRandomUniformOp::dtype() {
  return mlir::getElementTypeOrSelf(*getODSResults(0).begin());
}

bool StatelessRandomUniformOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "T") return true;
  if (name == "Tseed") return true;
  if (name == "dtype") return true;
 return false;
}

::mlir::DictionaryAttr StatelessRandomUniformOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())},
    {::mlir::Identifier::get("Tseed", ctx),
::mlir::TypeAttr::get(Tseed())},
    {::mlir::Identifier::get("dtype", ctx),
::mlir::TypeAttr::get(dtype())}
    }, ctx);
}

void StatelessRandomUniformOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value shape, ::mlir::Value seed) {
  odsState.addOperands(shape);
  odsState.addOperands(seed);
  odsState.addTypes(output);
}

void StatelessRandomUniformOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value shape, ::mlir::Value seed) {
  odsState.addOperands(shape);
  odsState.addOperands(seed);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void StatelessRandomUniformOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult StatelessRandomUniformOp::verify() {
  if (failed(StatelessRandomUniformOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of 32/64-bit signed integer values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of 32/64-bit signed integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))))) {
        return emitOpError("result #") << index << " must be tensor of floating-point values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void StatelessRandomUniformOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::StatelessTruncatedNormalOp definitions
//===----------------------------------------------------------------------===//

StatelessTruncatedNormalOpAdaptor::StatelessTruncatedNormalOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

StatelessTruncatedNormalOpAdaptor::StatelessTruncatedNormalOpAdaptor(StatelessTruncatedNormalOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> StatelessTruncatedNormalOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange StatelessTruncatedNormalOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value StatelessTruncatedNormalOpAdaptor::shape() {
  return *getODSOperands(0).begin();
}

::mlir::Value StatelessTruncatedNormalOpAdaptor::seed() {
  return *getODSOperands(1).begin();
}

::mlir::LogicalResult StatelessTruncatedNormalOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

::llvm::StringRef StatelessTruncatedNormalOp::getOperationName() {
  return "tf.StatelessTruncatedNormal";
}

std::pair<unsigned, unsigned> StatelessTruncatedNormalOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range StatelessTruncatedNormalOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value StatelessTruncatedNormalOp::shape() {
  return *getODSOperands(0).begin();
}

::mlir::Value StatelessTruncatedNormalOp::seed() {
  return *getODSOperands(1).begin();
}

::mlir::MutableOperandRange StatelessTruncatedNormalOp::shapeMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange StatelessTruncatedNormalOp::seedMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> StatelessTruncatedNormalOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range StatelessTruncatedNormalOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value StatelessTruncatedNormalOp::output() {
  return *getODSResults(0).begin();
}

Type StatelessTruncatedNormalOp::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

Type StatelessTruncatedNormalOp::Tseed() {
  return mlir::getElementTypeOrSelf(*getODSOperands(1).begin());
}

Type StatelessTruncatedNormalOp::dtype() {
  return mlir::getElementTypeOrSelf(*getODSResults(0).begin());
}

bool StatelessTruncatedNormalOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "T") return true;
  if (name == "Tseed") return true;
  if (name == "dtype") return true;
 return false;
}

::mlir::DictionaryAttr StatelessTruncatedNormalOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())},
    {::mlir::Identifier::get("Tseed", ctx),
::mlir::TypeAttr::get(Tseed())},
    {::mlir::Identifier::get("dtype", ctx),
::mlir::TypeAttr::get(dtype())}
    }, ctx);
}

void StatelessTruncatedNormalOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value shape, ::mlir::Value seed) {
  odsState.addOperands(shape);
  odsState.addOperands(seed);
  odsState.addTypes(output);
}

void StatelessTruncatedNormalOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value shape, ::mlir::Value seed) {
  odsState.addOperands(shape);
  odsState.addOperands(seed);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void StatelessTruncatedNormalOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult StatelessTruncatedNormalOp::verify() {
  if (failed(StatelessTruncatedNormalOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of 32/64-bit signed integer values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of 32/64-bit signed integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))))) {
        return emitOpError("result #") << index << " must be tensor of floating-point values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void StatelessTruncatedNormalOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::StopGradientOp definitions
//===----------------------------------------------------------------------===//

StopGradientOpAdaptor::StopGradientOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

StopGradientOpAdaptor::StopGradientOpAdaptor(StopGradientOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> StopGradientOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange StopGradientOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value StopGradientOpAdaptor::input() {
  return *getODSOperands(0).begin();
}

::mlir::LogicalResult StopGradientOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

::llvm::StringRef StopGradientOp::getOperationName() {
  return "tf.StopGradient";
}

std::pair<unsigned, unsigned> StopGradientOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range StopGradientOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value StopGradientOp::input() {
  return *getODSOperands(0).begin();
}

::mlir::MutableOperandRange StopGradientOp::inputMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> StopGradientOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range StopGradientOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value StopGradientOp::output() {
  return *getODSResults(0).begin();
}

Type StopGradientOp::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

bool StopGradientOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "T") return true;
 return false;
}

::mlir::DictionaryAttr StopGradientOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())}
    }, ctx);
}

void StopGradientOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value input) {
  odsState.addOperands(input);
  odsState.addTypes(output);
}

void StopGradientOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input) {
  odsState.addOperands(input);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void StopGradientOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult StopGradientOp::verify() {
  if (failed(StopGradientOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>())))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::TensorFlowType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of tf.dtype values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>())))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::TensorFlowType>()))))) {
        return emitOpError("result #") << index << " must be tensor of tf.dtype values, but got " << v.getType();
      }
      ++index;
    }
  }
  if (!((TF::AreCastCompatible(llvm::makeArrayRef({(*this->getODSOperands(0).begin()).getType(), (*this->getODSResults(0).begin()).getType()})))))
    return emitOpError("failed to verify that all of {input, output} have dynamically equal types ");
  return ::mlir::success();
}

void StopGradientOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::StridedSliceGradOp definitions
//===----------------------------------------------------------------------===//

StridedSliceGradOpAdaptor::StridedSliceGradOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

StridedSliceGradOpAdaptor::StridedSliceGradOpAdaptor(StridedSliceGradOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> StridedSliceGradOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange StridedSliceGradOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value StridedSliceGradOpAdaptor::shape() {
  return *getODSOperands(0).begin();
}

::mlir::Value StridedSliceGradOpAdaptor::begin() {
  return *getODSOperands(1).begin();
}

::mlir::Value StridedSliceGradOpAdaptor::end() {
  return *getODSOperands(2).begin();
}

::mlir::Value StridedSliceGradOpAdaptor::strides() {
  return *getODSOperands(3).begin();
}

::mlir::Value StridedSliceGradOpAdaptor::dy() {
  return *getODSOperands(4).begin();
}

::mlir::IntegerAttr StridedSliceGradOpAdaptor::begin_mask() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::IntegerAttr attr = odsAttrs.get("begin_mask").dyn_cast_or_null<::mlir::IntegerAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getIntegerAttr(::mlir::Builder(odsAttrs.getContext()).getIntegerType(64), 0);
  return attr;
}

::mlir::IntegerAttr StridedSliceGradOpAdaptor::end_mask() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::IntegerAttr attr = odsAttrs.get("end_mask").dyn_cast_or_null<::mlir::IntegerAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getIntegerAttr(::mlir::Builder(odsAttrs.getContext()).getIntegerType(64), 0);
  return attr;
}

::mlir::IntegerAttr StridedSliceGradOpAdaptor::ellipsis_mask() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::IntegerAttr attr = odsAttrs.get("ellipsis_mask").dyn_cast_or_null<::mlir::IntegerAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getIntegerAttr(::mlir::Builder(odsAttrs.getContext()).getIntegerType(64), 0);
  return attr;
}

::mlir::IntegerAttr StridedSliceGradOpAdaptor::new_axis_mask() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::IntegerAttr attr = odsAttrs.get("new_axis_mask").dyn_cast_or_null<::mlir::IntegerAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getIntegerAttr(::mlir::Builder(odsAttrs.getContext()).getIntegerType(64), 0);
  return attr;
}

::mlir::IntegerAttr StridedSliceGradOpAdaptor::shrink_axis_mask() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::IntegerAttr attr = odsAttrs.get("shrink_axis_mask").dyn_cast_or_null<::mlir::IntegerAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getIntegerAttr(::mlir::Builder(odsAttrs.getContext()).getIntegerType(64), 0);
  return attr;
}

::mlir::LogicalResult StridedSliceGradOpAdaptor::verify(::mlir::Location loc) {
  {
  auto tblgen_begin_mask = odsAttrs.get("begin_mask");
  if (tblgen_begin_mask) {
    if (!(((tblgen_begin_mask.isa<::mlir::IntegerAttr>())) && ((tblgen_begin_mask.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(64))))) return emitError(loc, "'tf.StridedSliceGrad' op ""attribute 'begin_mask' failed to satisfy constraint: 64-bit signless integer attribute");
  }
  }
  {
  auto tblgen_end_mask = odsAttrs.get("end_mask");
  if (tblgen_end_mask) {
    if (!(((tblgen_end_mask.isa<::mlir::IntegerAttr>())) && ((tblgen_end_mask.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(64))))) return emitError(loc, "'tf.StridedSliceGrad' op ""attribute 'end_mask' failed to satisfy constraint: 64-bit signless integer attribute");
  }
  }
  {
  auto tblgen_ellipsis_mask = odsAttrs.get("ellipsis_mask");
  if (tblgen_ellipsis_mask) {
    if (!(((tblgen_ellipsis_mask.isa<::mlir::IntegerAttr>())) && ((tblgen_ellipsis_mask.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(64))))) return emitError(loc, "'tf.StridedSliceGrad' op ""attribute 'ellipsis_mask' failed to satisfy constraint: 64-bit signless integer attribute");
  }
  }
  {
  auto tblgen_new_axis_mask = odsAttrs.get("new_axis_mask");
  if (tblgen_new_axis_mask) {
    if (!(((tblgen_new_axis_mask.isa<::mlir::IntegerAttr>())) && ((tblgen_new_axis_mask.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(64))))) return emitError(loc, "'tf.StridedSliceGrad' op ""attribute 'new_axis_mask' failed to satisfy constraint: 64-bit signless integer attribute");
  }
  }
  {
  auto tblgen_shrink_axis_mask = odsAttrs.get("shrink_axis_mask");
  if (tblgen_shrink_axis_mask) {
    if (!(((tblgen_shrink_axis_mask.isa<::mlir::IntegerAttr>())) && ((tblgen_shrink_axis_mask.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(64))))) return emitError(loc, "'tf.StridedSliceGrad' op ""attribute 'shrink_axis_mask' failed to satisfy constraint: 64-bit signless integer attribute");
  }
  }
  return ::mlir::success();
}

::llvm::StringRef StridedSliceGradOp::getOperationName() {
  return "tf.StridedSliceGrad";
}

std::pair<unsigned, unsigned> StridedSliceGradOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range StridedSliceGradOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value StridedSliceGradOp::shape() {
  return *getODSOperands(0).begin();
}

::mlir::Value StridedSliceGradOp::begin() {
  return *getODSOperands(1).begin();
}

::mlir::Value StridedSliceGradOp::end() {
  return *getODSOperands(2).begin();
}

::mlir::Value StridedSliceGradOp::strides() {
  return *getODSOperands(3).begin();
}

::mlir::Value StridedSliceGradOp::dy() {
  return *getODSOperands(4).begin();
}

::mlir::MutableOperandRange StridedSliceGradOp::shapeMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange StridedSliceGradOp::beginMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange StridedSliceGradOp::endMutable() {
  auto range = getODSOperandIndexAndLength(2);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange StridedSliceGradOp::stridesMutable() {
  auto range = getODSOperandIndexAndLength(3);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange StridedSliceGradOp::dyMutable() {
  auto range = getODSOperandIndexAndLength(4);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> StridedSliceGradOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range StridedSliceGradOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value StridedSliceGradOp::output() {
  return *getODSResults(0).begin();
}

::mlir::IntegerAttr StridedSliceGradOp::begin_maskAttr() {
  return this->getAttr("begin_mask").dyn_cast_or_null<::mlir::IntegerAttr>();
}

uint64_t StridedSliceGradOp::begin_mask() {
  auto attr = begin_maskAttr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getIntegerAttr(::mlir::Builder(this->getContext()).getIntegerType(64), 0).getValue().getZExtValue();
  return attr.getValue().getZExtValue();
}

::mlir::IntegerAttr StridedSliceGradOp::end_maskAttr() {
  return this->getAttr("end_mask").dyn_cast_or_null<::mlir::IntegerAttr>();
}

uint64_t StridedSliceGradOp::end_mask() {
  auto attr = end_maskAttr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getIntegerAttr(::mlir::Builder(this->getContext()).getIntegerType(64), 0).getValue().getZExtValue();
  return attr.getValue().getZExtValue();
}

::mlir::IntegerAttr StridedSliceGradOp::ellipsis_maskAttr() {
  return this->getAttr("ellipsis_mask").dyn_cast_or_null<::mlir::IntegerAttr>();
}

uint64_t StridedSliceGradOp::ellipsis_mask() {
  auto attr = ellipsis_maskAttr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getIntegerAttr(::mlir::Builder(this->getContext()).getIntegerType(64), 0).getValue().getZExtValue();
  return attr.getValue().getZExtValue();
}

::mlir::IntegerAttr StridedSliceGradOp::new_axis_maskAttr() {
  return this->getAttr("new_axis_mask").dyn_cast_or_null<::mlir::IntegerAttr>();
}

uint64_t StridedSliceGradOp::new_axis_mask() {
  auto attr = new_axis_maskAttr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getIntegerAttr(::mlir::Builder(this->getContext()).getIntegerType(64), 0).getValue().getZExtValue();
  return attr.getValue().getZExtValue();
}

::mlir::IntegerAttr StridedSliceGradOp::shrink_axis_maskAttr() {
  return this->getAttr("shrink_axis_mask").dyn_cast_or_null<::mlir::IntegerAttr>();
}

uint64_t StridedSliceGradOp::shrink_axis_mask() {
  auto attr = shrink_axis_maskAttr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getIntegerAttr(::mlir::Builder(this->getContext()).getIntegerType(64), 0).getValue().getZExtValue();
  return attr.getValue().getZExtValue();
}

Type StridedSliceGradOp::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(4).begin());
}

Type StridedSliceGradOp::Index() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

bool StridedSliceGradOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "T") return true;
  if (name == "Index") return true;
 return false;
}

::mlir::DictionaryAttr StridedSliceGradOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())},
    {::mlir::Identifier::get("Index", ctx),
::mlir::TypeAttr::get(Index())}
    }, ctx);
}

void StridedSliceGradOp::begin_maskAttr(::mlir::IntegerAttr attr) {
  this->getOperation()->setAttr("begin_mask", attr);
}

void StridedSliceGradOp::end_maskAttr(::mlir::IntegerAttr attr) {
  this->getOperation()->setAttr("end_mask", attr);
}

void StridedSliceGradOp::ellipsis_maskAttr(::mlir::IntegerAttr attr) {
  this->getOperation()->setAttr("ellipsis_mask", attr);
}

void StridedSliceGradOp::new_axis_maskAttr(::mlir::IntegerAttr attr) {
  this->getOperation()->setAttr("new_axis_mask", attr);
}

void StridedSliceGradOp::shrink_axis_maskAttr(::mlir::IntegerAttr attr) {
  this->getOperation()->setAttr("shrink_axis_mask", attr);
}

void StridedSliceGradOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value shape, ::mlir::Value begin, ::mlir::Value end, ::mlir::Value strides, ::mlir::Value dy, ::mlir::IntegerAttr begin_mask, ::mlir::IntegerAttr end_mask, ::mlir::IntegerAttr ellipsis_mask, ::mlir::IntegerAttr new_axis_mask, ::mlir::IntegerAttr shrink_axis_mask) {
  odsState.addOperands(shape);
  odsState.addOperands(begin);
  odsState.addOperands(end);
  odsState.addOperands(strides);
  odsState.addOperands(dy);
  odsState.addAttribute("begin_mask", begin_mask);
  odsState.addAttribute("end_mask", end_mask);
  odsState.addAttribute("ellipsis_mask", ellipsis_mask);
  odsState.addAttribute("new_axis_mask", new_axis_mask);
  odsState.addAttribute("shrink_axis_mask", shrink_axis_mask);
  odsState.addTypes(output);
}

void StridedSliceGradOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value shape, ::mlir::Value begin, ::mlir::Value end, ::mlir::Value strides, ::mlir::Value dy, ::mlir::IntegerAttr begin_mask, ::mlir::IntegerAttr end_mask, ::mlir::IntegerAttr ellipsis_mask, ::mlir::IntegerAttr new_axis_mask, ::mlir::IntegerAttr shrink_axis_mask) {
  odsState.addOperands(shape);
  odsState.addOperands(begin);
  odsState.addOperands(end);
  odsState.addOperands(strides);
  odsState.addOperands(dy);
  odsState.addAttribute("begin_mask", begin_mask);
  odsState.addAttribute("end_mask", end_mask);
  odsState.addAttribute("ellipsis_mask", ellipsis_mask);
  odsState.addAttribute("new_axis_mask", new_axis_mask);
  odsState.addAttribute("shrink_axis_mask", shrink_axis_mask);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void StridedSliceGradOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value shape, ::mlir::Value begin, ::mlir::Value end, ::mlir::Value strides, ::mlir::Value dy, uint64_t begin_mask, uint64_t end_mask, uint64_t ellipsis_mask, uint64_t new_axis_mask, uint64_t shrink_axis_mask) {
  odsState.addOperands(shape);
  odsState.addOperands(begin);
  odsState.addOperands(end);
  odsState.addOperands(strides);
  odsState.addOperands(dy);
  odsState.addAttribute("begin_mask", odsBuilder.getIntegerAttr(odsBuilder.getIntegerType(64), begin_mask));
  odsState.addAttribute("end_mask", odsBuilder.getIntegerAttr(odsBuilder.getIntegerType(64), end_mask));
  odsState.addAttribute("ellipsis_mask", odsBuilder.getIntegerAttr(odsBuilder.getIntegerType(64), ellipsis_mask));
  odsState.addAttribute("new_axis_mask", odsBuilder.getIntegerAttr(odsBuilder.getIntegerType(64), new_axis_mask));
  odsState.addAttribute("shrink_axis_mask", odsBuilder.getIntegerAttr(odsBuilder.getIntegerType(64), shrink_axis_mask));
  odsState.addTypes(output);
}

void StridedSliceGradOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value shape, ::mlir::Value begin, ::mlir::Value end, ::mlir::Value strides, ::mlir::Value dy, uint64_t begin_mask, uint64_t end_mask, uint64_t ellipsis_mask, uint64_t new_axis_mask, uint64_t shrink_axis_mask) {
  odsState.addOperands(shape);
  odsState.addOperands(begin);
  odsState.addOperands(end);
  odsState.addOperands(strides);
  odsState.addOperands(dy);
  odsState.addAttribute("begin_mask", odsBuilder.getIntegerAttr(odsBuilder.getIntegerType(64), begin_mask));
  odsState.addAttribute("end_mask", odsBuilder.getIntegerAttr(odsBuilder.getIntegerType(64), end_mask));
  odsState.addAttribute("ellipsis_mask", odsBuilder.getIntegerAttr(odsBuilder.getIntegerType(64), ellipsis_mask));
  odsState.addAttribute("new_axis_mask", odsBuilder.getIntegerAttr(odsBuilder.getIntegerType(64), new_axis_mask));
  odsState.addAttribute("shrink_axis_mask", odsBuilder.getIntegerAttr(odsBuilder.getIntegerType(64), shrink_axis_mask));
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void StridedSliceGradOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 5u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult StridedSliceGradOp::verify() {
  if (failed(StridedSliceGradOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of 32/64-bit signed integer values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of 32/64-bit signed integer values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup2 = getODSOperands(2);
    for (::mlir::Value v : valueGroup2) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of 32/64-bit signed integer values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup3 = getODSOperands(3);
    for (::mlir::Value v : valueGroup3) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of 32/64-bit signed integer values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup4 = getODSOperands(4);
    for (::mlir::Value v : valueGroup4) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>())))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::TensorFlowType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of tf.dtype values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>())))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::TensorFlowType>()))))) {
        return emitOpError("result #") << index << " must be tensor of tf.dtype values, but got " << v.getType();
      }
      ++index;
    }
  }
  return Verify(*this);
}

void StridedSliceGradOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::StridedSliceOp definitions
//===----------------------------------------------------------------------===//

StridedSliceOpAdaptor::StridedSliceOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

StridedSliceOpAdaptor::StridedSliceOpAdaptor(StridedSliceOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> StridedSliceOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange StridedSliceOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value StridedSliceOpAdaptor::input() {
  return *getODSOperands(0).begin();
}

::mlir::Value StridedSliceOpAdaptor::begin() {
  return *getODSOperands(1).begin();
}

::mlir::Value StridedSliceOpAdaptor::end() {
  return *getODSOperands(2).begin();
}

::mlir::Value StridedSliceOpAdaptor::strides() {
  return *getODSOperands(3).begin();
}

::mlir::IntegerAttr StridedSliceOpAdaptor::begin_mask() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::IntegerAttr attr = odsAttrs.get("begin_mask").dyn_cast_or_null<::mlir::IntegerAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getIntegerAttr(::mlir::Builder(odsAttrs.getContext()).getIntegerType(64), 0);
  return attr;
}

::mlir::IntegerAttr StridedSliceOpAdaptor::end_mask() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::IntegerAttr attr = odsAttrs.get("end_mask").dyn_cast_or_null<::mlir::IntegerAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getIntegerAttr(::mlir::Builder(odsAttrs.getContext()).getIntegerType(64), 0);
  return attr;
}

::mlir::IntegerAttr StridedSliceOpAdaptor::ellipsis_mask() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::IntegerAttr attr = odsAttrs.get("ellipsis_mask").dyn_cast_or_null<::mlir::IntegerAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getIntegerAttr(::mlir::Builder(odsAttrs.getContext()).getIntegerType(64), 0);
  return attr;
}

::mlir::IntegerAttr StridedSliceOpAdaptor::new_axis_mask() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::IntegerAttr attr = odsAttrs.get("new_axis_mask").dyn_cast_or_null<::mlir::IntegerAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getIntegerAttr(::mlir::Builder(odsAttrs.getContext()).getIntegerType(64), 0);
  return attr;
}

::mlir::IntegerAttr StridedSliceOpAdaptor::shrink_axis_mask() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::IntegerAttr attr = odsAttrs.get("shrink_axis_mask").dyn_cast_or_null<::mlir::IntegerAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getIntegerAttr(::mlir::Builder(odsAttrs.getContext()).getIntegerType(64), 0);
  return attr;
}

::mlir::LogicalResult StridedSliceOpAdaptor::verify(::mlir::Location loc) {
  {
  auto tblgen_begin_mask = odsAttrs.get("begin_mask");
  if (tblgen_begin_mask) {
    if (!(((tblgen_begin_mask.isa<::mlir::IntegerAttr>())) && ((tblgen_begin_mask.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(64))))) return emitError(loc, "'tf.StridedSlice' op ""attribute 'begin_mask' failed to satisfy constraint: 64-bit signless integer attribute");
  }
  }
  {
  auto tblgen_end_mask = odsAttrs.get("end_mask");
  if (tblgen_end_mask) {
    if (!(((tblgen_end_mask.isa<::mlir::IntegerAttr>())) && ((tblgen_end_mask.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(64))))) return emitError(loc, "'tf.StridedSlice' op ""attribute 'end_mask' failed to satisfy constraint: 64-bit signless integer attribute");
  }
  }
  {
  auto tblgen_ellipsis_mask = odsAttrs.get("ellipsis_mask");
  if (tblgen_ellipsis_mask) {
    if (!(((tblgen_ellipsis_mask.isa<::mlir::IntegerAttr>())) && ((tblgen_ellipsis_mask.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(64))))) return emitError(loc, "'tf.StridedSlice' op ""attribute 'ellipsis_mask' failed to satisfy constraint: 64-bit signless integer attribute");
  }
  }
  {
  auto tblgen_new_axis_mask = odsAttrs.get("new_axis_mask");
  if (tblgen_new_axis_mask) {
    if (!(((tblgen_new_axis_mask.isa<::mlir::IntegerAttr>())) && ((tblgen_new_axis_mask.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(64))))) return emitError(loc, "'tf.StridedSlice' op ""attribute 'new_axis_mask' failed to satisfy constraint: 64-bit signless integer attribute");
  }
  }
  {
  auto tblgen_shrink_axis_mask = odsAttrs.get("shrink_axis_mask");
  if (tblgen_shrink_axis_mask) {
    if (!(((tblgen_shrink_axis_mask.isa<::mlir::IntegerAttr>())) && ((tblgen_shrink_axis_mask.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(64))))) return emitError(loc, "'tf.StridedSlice' op ""attribute 'shrink_axis_mask' failed to satisfy constraint: 64-bit signless integer attribute");
  }
  }
  return ::mlir::success();
}

::llvm::StringRef StridedSliceOp::getOperationName() {
  return "tf.StridedSlice";
}

std::pair<unsigned, unsigned> StridedSliceOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range StridedSliceOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value StridedSliceOp::input() {
  return *getODSOperands(0).begin();
}

::mlir::Value StridedSliceOp::begin() {
  return *getODSOperands(1).begin();
}

::mlir::Value StridedSliceOp::end() {
  return *getODSOperands(2).begin();
}

::mlir::Value StridedSliceOp::strides() {
  return *getODSOperands(3).begin();
}

::mlir::MutableOperandRange StridedSliceOp::inputMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange StridedSliceOp::beginMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange StridedSliceOp::endMutable() {
  auto range = getODSOperandIndexAndLength(2);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange StridedSliceOp::stridesMutable() {
  auto range = getODSOperandIndexAndLength(3);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> StridedSliceOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range StridedSliceOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value StridedSliceOp::output() {
  return *getODSResults(0).begin();
}

::mlir::IntegerAttr StridedSliceOp::begin_maskAttr() {
  return this->getAttr("begin_mask").dyn_cast_or_null<::mlir::IntegerAttr>();
}

uint64_t StridedSliceOp::begin_mask() {
  auto attr = begin_maskAttr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getIntegerAttr(::mlir::Builder(this->getContext()).getIntegerType(64), 0).getValue().getZExtValue();
  return attr.getValue().getZExtValue();
}

::mlir::IntegerAttr StridedSliceOp::end_maskAttr() {
  return this->getAttr("end_mask").dyn_cast_or_null<::mlir::IntegerAttr>();
}

uint64_t StridedSliceOp::end_mask() {
  auto attr = end_maskAttr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getIntegerAttr(::mlir::Builder(this->getContext()).getIntegerType(64), 0).getValue().getZExtValue();
  return attr.getValue().getZExtValue();
}

::mlir::IntegerAttr StridedSliceOp::ellipsis_maskAttr() {
  return this->getAttr("ellipsis_mask").dyn_cast_or_null<::mlir::IntegerAttr>();
}

uint64_t StridedSliceOp::ellipsis_mask() {
  auto attr = ellipsis_maskAttr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getIntegerAttr(::mlir::Builder(this->getContext()).getIntegerType(64), 0).getValue().getZExtValue();
  return attr.getValue().getZExtValue();
}

::mlir::IntegerAttr StridedSliceOp::new_axis_maskAttr() {
  return this->getAttr("new_axis_mask").dyn_cast_or_null<::mlir::IntegerAttr>();
}

uint64_t StridedSliceOp::new_axis_mask() {
  auto attr = new_axis_maskAttr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getIntegerAttr(::mlir::Builder(this->getContext()).getIntegerType(64), 0).getValue().getZExtValue();
  return attr.getValue().getZExtValue();
}

::mlir::IntegerAttr StridedSliceOp::shrink_axis_maskAttr() {
  return this->getAttr("shrink_axis_mask").dyn_cast_or_null<::mlir::IntegerAttr>();
}

uint64_t StridedSliceOp::shrink_axis_mask() {
  auto attr = shrink_axis_maskAttr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getIntegerAttr(::mlir::Builder(this->getContext()).getIntegerType(64), 0).getValue().getZExtValue();
  return attr.getValue().getZExtValue();
}

Type StridedSliceOp::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

Type StridedSliceOp::Index() {
  return mlir::getElementTypeOrSelf(*getODSOperands(1).begin());
}

bool StridedSliceOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "T") return true;
  if (name == "Index") return true;
 return false;
}

::mlir::DictionaryAttr StridedSliceOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())},
    {::mlir::Identifier::get("Index", ctx),
::mlir::TypeAttr::get(Index())}
    }, ctx);
}

void StridedSliceOp::begin_maskAttr(::mlir::IntegerAttr attr) {
  this->getOperation()->setAttr("begin_mask", attr);
}

void StridedSliceOp::end_maskAttr(::mlir::IntegerAttr attr) {
  this->getOperation()->setAttr("end_mask", attr);
}

void StridedSliceOp::ellipsis_maskAttr(::mlir::IntegerAttr attr) {
  this->getOperation()->setAttr("ellipsis_mask", attr);
}

void StridedSliceOp::new_axis_maskAttr(::mlir::IntegerAttr attr) {
  this->getOperation()->setAttr("new_axis_mask", attr);
}

void StridedSliceOp::shrink_axis_maskAttr(::mlir::IntegerAttr attr) {
  this->getOperation()->setAttr("shrink_axis_mask", attr);
}

void StridedSliceOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value input, ::mlir::Value begin, ::mlir::Value end, ::mlir::Value strides, ::mlir::IntegerAttr begin_mask, ::mlir::IntegerAttr end_mask, ::mlir::IntegerAttr ellipsis_mask, ::mlir::IntegerAttr new_axis_mask, ::mlir::IntegerAttr shrink_axis_mask) {
  odsState.addOperands(input);
  odsState.addOperands(begin);
  odsState.addOperands(end);
  odsState.addOperands(strides);
  odsState.addAttribute("begin_mask", begin_mask);
  odsState.addAttribute("end_mask", end_mask);
  odsState.addAttribute("ellipsis_mask", ellipsis_mask);
  odsState.addAttribute("new_axis_mask", new_axis_mask);
  odsState.addAttribute("shrink_axis_mask", shrink_axis_mask);
  odsState.addTypes(output);
}

void StridedSliceOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input, ::mlir::Value begin, ::mlir::Value end, ::mlir::Value strides, ::mlir::IntegerAttr begin_mask, ::mlir::IntegerAttr end_mask, ::mlir::IntegerAttr ellipsis_mask, ::mlir::IntegerAttr new_axis_mask, ::mlir::IntegerAttr shrink_axis_mask) {
  odsState.addOperands(input);
  odsState.addOperands(begin);
  odsState.addOperands(end);
  odsState.addOperands(strides);
  odsState.addAttribute("begin_mask", begin_mask);
  odsState.addAttribute("end_mask", end_mask);
  odsState.addAttribute("ellipsis_mask", ellipsis_mask);
  odsState.addAttribute("new_axis_mask", new_axis_mask);
  odsState.addAttribute("shrink_axis_mask", shrink_axis_mask);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void StridedSliceOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value input, ::mlir::Value begin, ::mlir::Value end, ::mlir::Value strides, uint64_t begin_mask, uint64_t end_mask, uint64_t ellipsis_mask, uint64_t new_axis_mask, uint64_t shrink_axis_mask) {
  odsState.addOperands(input);
  odsState.addOperands(begin);
  odsState.addOperands(end);
  odsState.addOperands(strides);
  odsState.addAttribute("begin_mask", odsBuilder.getIntegerAttr(odsBuilder.getIntegerType(64), begin_mask));
  odsState.addAttribute("end_mask", odsBuilder.getIntegerAttr(odsBuilder.getIntegerType(64), end_mask));
  odsState.addAttribute("ellipsis_mask", odsBuilder.getIntegerAttr(odsBuilder.getIntegerType(64), ellipsis_mask));
  odsState.addAttribute("new_axis_mask", odsBuilder.getIntegerAttr(odsBuilder.getIntegerType(64), new_axis_mask));
  odsState.addAttribute("shrink_axis_mask", odsBuilder.getIntegerAttr(odsBuilder.getIntegerType(64), shrink_axis_mask));
  odsState.addTypes(output);
}

void StridedSliceOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input, ::mlir::Value begin, ::mlir::Value end, ::mlir::Value strides, uint64_t begin_mask, uint64_t end_mask, uint64_t ellipsis_mask, uint64_t new_axis_mask, uint64_t shrink_axis_mask) {
  odsState.addOperands(input);
  odsState.addOperands(begin);
  odsState.addOperands(end);
  odsState.addOperands(strides);
  odsState.addAttribute("begin_mask", odsBuilder.getIntegerAttr(odsBuilder.getIntegerType(64), begin_mask));
  odsState.addAttribute("end_mask", odsBuilder.getIntegerAttr(odsBuilder.getIntegerType(64), end_mask));
  odsState.addAttribute("ellipsis_mask", odsBuilder.getIntegerAttr(odsBuilder.getIntegerType(64), ellipsis_mask));
  odsState.addAttribute("new_axis_mask", odsBuilder.getIntegerAttr(odsBuilder.getIntegerType(64), new_axis_mask));
  odsState.addAttribute("shrink_axis_mask", odsBuilder.getIntegerAttr(odsBuilder.getIntegerType(64), shrink_axis_mask));
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void StridedSliceOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 4u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult StridedSliceOp::verify() {
  if (failed(StridedSliceOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>())))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::TensorFlowType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of tf.dtype values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of 32/64-bit signed integer values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup2 = getODSOperands(2);
    for (::mlir::Value v : valueGroup2) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of 32/64-bit signed integer values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup3 = getODSOperands(3);
    for (::mlir::Value v : valueGroup3) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of 32/64-bit signed integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>())))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::TensorFlowType>()))))) {
        return emitOpError("result #") << index << " must be tensor of tf.dtype values, but got " << v.getType();
      }
      ++index;
    }
  }
  return VerifyStridedSliceBase(*this);
}

void StridedSliceOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::StringFormatOp definitions
//===----------------------------------------------------------------------===//

StringFormatOpAdaptor::StringFormatOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

StringFormatOpAdaptor::StringFormatOpAdaptor(StringFormatOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> StringFormatOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  bool isVariadic[] = {true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (odsOperands.size() - 0) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::mlir::ValueRange StringFormatOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::ValueRange StringFormatOpAdaptor::inputs() {
  return getODSOperands(0);
}

::mlir::StringAttr StringFormatOpAdaptor::strtemplate() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::StringAttr attr = odsAttrs.get("strtemplate").dyn_cast_or_null<::mlir::StringAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getStringAttr("%s");
  return attr;
}

::mlir::StringAttr StringFormatOpAdaptor::placeholder() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::StringAttr attr = odsAttrs.get("placeholder").dyn_cast_or_null<::mlir::StringAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getStringAttr("%s");
  return attr;
}

::mlir::IntegerAttr StringFormatOpAdaptor::summarize() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::IntegerAttr attr = odsAttrs.get("summarize").dyn_cast_or_null<::mlir::IntegerAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getIntegerAttr(::mlir::Builder(odsAttrs.getContext()).getIntegerType(64), 3);
  return attr;
}

::mlir::LogicalResult StringFormatOpAdaptor::verify(::mlir::Location loc) {
  {
  auto tblgen_strtemplate = odsAttrs.get("strtemplate");
  if (tblgen_strtemplate) {
    if (!((tblgen_strtemplate.isa<::mlir::StringAttr>()))) return emitError(loc, "'tf.StringFormat' op ""attribute 'strtemplate' failed to satisfy constraint: string attribute");
  }
  }
  {
  auto tblgen_placeholder = odsAttrs.get("placeholder");
  if (tblgen_placeholder) {
    if (!((tblgen_placeholder.isa<::mlir::StringAttr>()))) return emitError(loc, "'tf.StringFormat' op ""attribute 'placeholder' failed to satisfy constraint: string attribute");
  }
  }
  {
  auto tblgen_summarize = odsAttrs.get("summarize");
  if (tblgen_summarize) {
    if (!(((tblgen_summarize.isa<::mlir::IntegerAttr>())) && ((tblgen_summarize.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(64))))) return emitError(loc, "'tf.StringFormat' op ""attribute 'summarize' failed to satisfy constraint: 64-bit signless integer attribute");
  }
  }
  return ::mlir::success();
}

::llvm::StringRef StringFormatOp::getOperationName() {
  return "tf.StringFormat";
}

std::pair<unsigned, unsigned> StringFormatOp::getODSOperandIndexAndLength(unsigned index) {
  bool isVariadic[] = {true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (getOperation()->getNumOperands() - 0) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::mlir::Operation::operand_range StringFormatOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Operation::operand_range StringFormatOp::inputs() {
  return getODSOperands(0);
}

::mlir::MutableOperandRange StringFormatOp::inputsMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> StringFormatOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range StringFormatOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value StringFormatOp::output() {
  return *getODSResults(0).begin();
}

::mlir::StringAttr StringFormatOp::strtemplateAttr() {
  return this->getAttr("strtemplate").dyn_cast_or_null<::mlir::StringAttr>();
}

::llvm::StringRef StringFormatOp::strtemplate() {
  auto attr = strtemplateAttr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getStringAttr("%s").getValue();
  return attr.getValue();
}

::mlir::StringAttr StringFormatOp::placeholderAttr() {
  return this->getAttr("placeholder").dyn_cast_or_null<::mlir::StringAttr>();
}

::llvm::StringRef StringFormatOp::placeholder() {
  auto attr = placeholderAttr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getStringAttr("%s").getValue();
  return attr.getValue();
}

::mlir::IntegerAttr StringFormatOp::summarizeAttr() {
  return this->getAttr("summarize").dyn_cast_or_null<::mlir::IntegerAttr>();
}

uint64_t StringFormatOp::summarize() {
  auto attr = summarizeAttr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getIntegerAttr(::mlir::Builder(this->getContext()).getIntegerType(64), 3).getValue().getZExtValue();
  return attr.getValue().getZExtValue();
}

mlir::OperandElementTypeRange StringFormatOp::T() {
  auto values = getODSOperands(0);
return {mlir::OperandElementTypeIterator(values.begin()), mlir::OperandElementTypeIterator(values.end())};
}

bool StringFormatOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "T") return true;
 return false;
}

::mlir::DictionaryAttr StringFormatOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("T", ctx),
ArrayAttr::get(
    [&]() {
      llvm::SmallVector<Attribute, 4> ret;
      for (auto t : T())
        ret.push_back(TypeAttr::get(t));
      return ret;
    }(), ctx)}
    }, ctx);
}

void StringFormatOp::strtemplateAttr(::mlir::StringAttr attr) {
  this->getOperation()->setAttr("strtemplate", attr);
}

void StringFormatOp::placeholderAttr(::mlir::StringAttr attr) {
  this->getOperation()->setAttr("placeholder", attr);
}

void StringFormatOp::summarizeAttr(::mlir::IntegerAttr attr) {
  this->getOperation()->setAttr("summarize", attr);
}

void StringFormatOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::ValueRange inputs, ::mlir::StringAttr strtemplate, ::mlir::StringAttr placeholder, ::mlir::IntegerAttr summarize) {
  odsState.addOperands(inputs);
  odsState.addAttribute("strtemplate", strtemplate);
  odsState.addAttribute("placeholder", placeholder);
  odsState.addAttribute("summarize", summarize);
  odsState.addTypes(output);
}

void StringFormatOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange inputs, ::mlir::StringAttr strtemplate, ::mlir::StringAttr placeholder, ::mlir::IntegerAttr summarize) {
  odsState.addOperands(inputs);
  odsState.addAttribute("strtemplate", strtemplate);
  odsState.addAttribute("placeholder", placeholder);
  odsState.addAttribute("summarize", summarize);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void StringFormatOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::ValueRange inputs, ::llvm::StringRef strtemplate, ::llvm::StringRef placeholder, uint64_t summarize) {
  odsState.addOperands(inputs);
  odsState.addAttribute("strtemplate", odsBuilder.getStringAttr(strtemplate));
  odsState.addAttribute("placeholder", odsBuilder.getStringAttr(placeholder));
  odsState.addAttribute("summarize", odsBuilder.getIntegerAttr(odsBuilder.getIntegerType(64), summarize));
  odsState.addTypes(output);
}

void StringFormatOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange inputs, ::llvm::StringRef strtemplate, ::llvm::StringRef placeholder, uint64_t summarize) {
  odsState.addOperands(inputs);
  odsState.addAttribute("strtemplate", odsBuilder.getStringAttr(strtemplate));
  odsState.addAttribute("placeholder", odsBuilder.getStringAttr(placeholder));
  odsState.addAttribute("summarize", odsBuilder.getIntegerAttr(odsBuilder.getIntegerType(64), summarize));
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void StringFormatOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult StringFormatOp::verify() {
  if (failed(StringFormatOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>())))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::TensorFlowType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of tf.dtype values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::StringType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::StringRefType>()))))) {
        return emitOpError("result #") << index << " must be tensor of string values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void StringFormatOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::StringJoinOp definitions
//===----------------------------------------------------------------------===//

StringJoinOpAdaptor::StringJoinOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

StringJoinOpAdaptor::StringJoinOpAdaptor(StringJoinOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> StringJoinOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  bool isVariadic[] = {true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (odsOperands.size() - 0) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::mlir::ValueRange StringJoinOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::ValueRange StringJoinOpAdaptor::inputs() {
  return getODSOperands(0);
}

::mlir::StringAttr StringJoinOpAdaptor::separator() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::StringAttr attr = odsAttrs.get("separator").cast<::mlir::StringAttr>();
  return attr;
}

::mlir::LogicalResult StringJoinOpAdaptor::verify(::mlir::Location loc) {
  {
  auto tblgen_separator = odsAttrs.get("separator");
  if (!tblgen_separator) return emitError(loc, "'tf.StringJoin' op ""requires attribute 'separator'");
    if (!((tblgen_separator.isa<::mlir::StringAttr>()))) return emitError(loc, "'tf.StringJoin' op ""attribute 'separator' failed to satisfy constraint: string attribute");
  }
  return ::mlir::success();
}

::llvm::StringRef StringJoinOp::getOperationName() {
  return "tf.StringJoin";
}

std::pair<unsigned, unsigned> StringJoinOp::getODSOperandIndexAndLength(unsigned index) {
  bool isVariadic[] = {true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (getOperation()->getNumOperands() - 0) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::mlir::Operation::operand_range StringJoinOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Operation::operand_range StringJoinOp::inputs() {
  return getODSOperands(0);
}

::mlir::MutableOperandRange StringJoinOp::inputsMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> StringJoinOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range StringJoinOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value StringJoinOp::output() {
  return *getODSResults(0).begin();
}

::mlir::StringAttr StringJoinOp::separatorAttr() {
  return this->getAttr("separator").cast<::mlir::StringAttr>();
}

::llvm::StringRef StringJoinOp::separator() {
  auto attr = separatorAttr();
  return attr.getValue();
}

size_t StringJoinOp::N() {
  auto range = getODSOperands(0);
return std::distance(range.begin(), range.end());
}

bool StringJoinOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "N") return true;
 return false;
}

::mlir::DictionaryAttr StringJoinOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("N", ctx),
odsBuilder.getI64IntegerAttr(N())}
    }, ctx);
}

void StringJoinOp::separatorAttr(::mlir::StringAttr attr) {
  this->getOperation()->setAttr("separator", attr);
}

void StringJoinOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::ValueRange inputs, ::mlir::StringAttr separator) {
  odsState.addOperands(inputs);
  odsState.addAttribute("separator", separator);
  odsState.addTypes(output);
}

void StringJoinOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange inputs, ::mlir::StringAttr separator) {
  odsState.addOperands(inputs);
  odsState.addAttribute("separator", separator);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void StringJoinOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::ValueRange inputs, ::llvm::StringRef separator) {
  odsState.addOperands(inputs);
  odsState.addAttribute("separator", odsBuilder.getStringAttr(separator));
  odsState.addTypes(output);
}

void StringJoinOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange inputs, ::llvm::StringRef separator) {
  odsState.addOperands(inputs);
  odsState.addAttribute("separator", odsBuilder.getStringAttr(separator));
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void StringJoinOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult StringJoinOp::verify() {
  if (failed(StringJoinOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::StringType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::StringRefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of string values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::StringType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::StringRefType>()))))) {
        return emitOpError("result #") << index << " must be tensor of string values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void StringJoinOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::StringToHashBucketFastOp definitions
//===----------------------------------------------------------------------===//

StringToHashBucketFastOpAdaptor::StringToHashBucketFastOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

StringToHashBucketFastOpAdaptor::StringToHashBucketFastOpAdaptor(StringToHashBucketFastOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> StringToHashBucketFastOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange StringToHashBucketFastOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value StringToHashBucketFastOpAdaptor::input() {
  return *getODSOperands(0).begin();
}

::mlir::IntegerAttr StringToHashBucketFastOpAdaptor::num_buckets() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::IntegerAttr attr = odsAttrs.get("num_buckets").cast<::mlir::IntegerAttr>();
  return attr;
}

::mlir::LogicalResult StringToHashBucketFastOpAdaptor::verify(::mlir::Location loc) {
  {
  auto tblgen_num_buckets = odsAttrs.get("num_buckets");
  if (!tblgen_num_buckets) return emitError(loc, "'tf.StringToHashBucketFast' op ""requires attribute 'num_buckets'");
    if (!((((tblgen_num_buckets.isa<::mlir::IntegerAttr>())) && ((tblgen_num_buckets.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(64)))) && ((tblgen_num_buckets.cast<::mlir::IntegerAttr>().getInt() >= 1)))) return emitError(loc, "'tf.StringToHashBucketFast' op ""attribute 'num_buckets' failed to satisfy constraint: 64-bit signless integer attribute whose minimum value is 1");
  }
  return ::mlir::success();
}

::llvm::StringRef StringToHashBucketFastOp::getOperationName() {
  return "tf.StringToHashBucketFast";
}

std::pair<unsigned, unsigned> StringToHashBucketFastOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range StringToHashBucketFastOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value StringToHashBucketFastOp::input() {
  return *getODSOperands(0).begin();
}

::mlir::MutableOperandRange StringToHashBucketFastOp::inputMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> StringToHashBucketFastOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range StringToHashBucketFastOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value StringToHashBucketFastOp::output() {
  return *getODSResults(0).begin();
}

::mlir::IntegerAttr StringToHashBucketFastOp::num_bucketsAttr() {
  return this->getAttr("num_buckets").cast<::mlir::IntegerAttr>();
}

uint64_t StringToHashBucketFastOp::num_buckets() {
  auto attr = num_bucketsAttr();
  return attr.getValue().getZExtValue();
}

void StringToHashBucketFastOp::num_bucketsAttr(::mlir::IntegerAttr attr) {
  this->getOperation()->setAttr("num_buckets", attr);
}

void StringToHashBucketFastOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value input, ::mlir::IntegerAttr num_buckets) {
  odsState.addOperands(input);
  odsState.addAttribute("num_buckets", num_buckets);
  odsState.addTypes(output);
}

void StringToHashBucketFastOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input, ::mlir::IntegerAttr num_buckets) {
  odsState.addOperands(input);
  odsState.addAttribute("num_buckets", num_buckets);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void StringToHashBucketFastOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value input, uint64_t num_buckets) {
  odsState.addOperands(input);
  odsState.addAttribute("num_buckets", odsBuilder.getIntegerAttr(odsBuilder.getIntegerType(64), num_buckets));
  odsState.addTypes(output);
}

void StringToHashBucketFastOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input, uint64_t num_buckets) {
  odsState.addOperands(input);
  odsState.addAttribute("num_buckets", odsBuilder.getIntegerAttr(odsBuilder.getIntegerType(64), num_buckets));
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void StringToHashBucketFastOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult StringToHashBucketFastOp::verify() {
  if (failed(StringToHashBucketFastOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::StringType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::StringRefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of string values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))))) {
        return emitOpError("result #") << index << " must be tensor of 64-bit integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void StringToHashBucketFastOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::SubOp definitions
//===----------------------------------------------------------------------===//

SubOpAdaptor::SubOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

SubOpAdaptor::SubOpAdaptor(SubOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> SubOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange SubOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value SubOpAdaptor::x() {
  return *getODSOperands(0).begin();
}

::mlir::Value SubOpAdaptor::y() {
  return *getODSOperands(1).begin();
}

::mlir::LogicalResult SubOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

::llvm::StringRef SubOp::getOperationName() {
  return "tf.Sub";
}

std::pair<unsigned, unsigned> SubOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range SubOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value SubOp::x() {
  return *getODSOperands(0).begin();
}

::mlir::Value SubOp::y() {
  return *getODSOperands(1).begin();
}

::mlir::MutableOperandRange SubOp::xMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange SubOp::yMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> SubOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range SubOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value SubOp::z() {
  return *getODSResults(0).begin();
}

Type SubOp::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

bool SubOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "T") return true;
 return false;
}

::mlir::DictionaryAttr SubOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())}
    }, ctx);
}

void SubOp::build(OpBuilder &builder, OperationState &result, Value  x, Value  y) {
  auto resultType =
      OpTrait::util::getBroadcastedType(x.getType(), y.getType());
  if (!resultType)
    mlir::emitError(result.location, "non-broadcastable operands");
  return build(builder, result, resultType, x, y);
}

void SubOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type z, ::mlir::Value x, ::mlir::Value y) {
  odsState.addOperands(x);
  odsState.addOperands(y);
  odsState.addTypes(z);
}

void SubOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value x, ::mlir::Value y) {
  odsState.addOperands(x);
  odsState.addOperands(y);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void SubOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult SubOp::verify() {
  if (failed(SubOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of bfloat16 or 128-bit complex or 64-bit complex or 16-bit float or 32-bit float or 64-bit float or 16-bit integer or 32-bit integer or 64-bit integer or 8-bit integer or 16-bit unsigned integer or 32-bit unsigned integer or 8-bit unsigned integer values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of bfloat16 or 128-bit complex or 64-bit complex or 16-bit float or 32-bit float or 64-bit float or 16-bit integer or 32-bit integer or 64-bit integer or 8-bit integer or 16-bit unsigned integer or 32-bit unsigned integer or 8-bit unsigned integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>())))))) {
        return emitOpError("result #") << index << " must be tensor of bfloat16 or 128-bit complex or 64-bit complex or 16-bit float or 32-bit float or 64-bit float or 16-bit integer or 32-bit integer or 64-bit integer or 8-bit integer or 16-bit unsigned integer or 32-bit unsigned integer or 8-bit unsigned integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}





void SubOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::SumOp definitions
//===----------------------------------------------------------------------===//

SumOpAdaptor::SumOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

SumOpAdaptor::SumOpAdaptor(SumOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> SumOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange SumOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value SumOpAdaptor::input() {
  return *getODSOperands(0).begin();
}

::mlir::Value SumOpAdaptor::reduction_indices() {
  return *getODSOperands(1).begin();
}

::mlir::BoolAttr SumOpAdaptor::keep_dims() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::BoolAttr attr = odsAttrs.get("keep_dims").dyn_cast_or_null<::mlir::BoolAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getBoolAttr(false);
  return attr;
}

::mlir::LogicalResult SumOpAdaptor::verify(::mlir::Location loc) {
  {
  auto tblgen_keep_dims = odsAttrs.get("keep_dims");
  if (tblgen_keep_dims) {
    if (!((tblgen_keep_dims.isa<::mlir::BoolAttr>()))) return emitError(loc, "'tf.Sum' op ""attribute 'keep_dims' failed to satisfy constraint: bool attribute");
  }
  }
  return ::mlir::success();
}

::llvm::StringRef SumOp::getOperationName() {
  return "tf.Sum";
}

std::pair<unsigned, unsigned> SumOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range SumOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value SumOp::input() {
  return *getODSOperands(0).begin();
}

::mlir::Value SumOp::reduction_indices() {
  return *getODSOperands(1).begin();
}

::mlir::MutableOperandRange SumOp::inputMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange SumOp::reduction_indicesMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> SumOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range SumOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value SumOp::output() {
  return *getODSResults(0).begin();
}

::mlir::BoolAttr SumOp::keep_dimsAttr() {
  return this->getAttr("keep_dims").dyn_cast_or_null<::mlir::BoolAttr>();
}

bool SumOp::keep_dims() {
  auto attr = keep_dimsAttr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getBoolAttr(false).getValue();
  return attr.getValue();
}

Type SumOp::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

Type SumOp::Tidx() {
  return mlir::getElementTypeOrSelf(*getODSOperands(1).begin());
}

bool SumOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "T") return true;
  if (name == "Tidx") return true;
 return false;
}

::mlir::DictionaryAttr SumOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())},
    {::mlir::Identifier::get("Tidx", ctx),
::mlir::TypeAttr::get(Tidx())}
    }, ctx);
}

void SumOp::keep_dimsAttr(::mlir::BoolAttr attr) {
  this->getOperation()->setAttr("keep_dims", attr);
}



void SumOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value input, ::mlir::Value reduction_indices, ::mlir::BoolAttr keep_dims) {
  odsState.addOperands(input);
  odsState.addOperands(reduction_indices);
  odsState.addAttribute("keep_dims", keep_dims);
  odsState.addTypes(output);
}

void SumOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input, ::mlir::Value reduction_indices, ::mlir::BoolAttr keep_dims) {
  odsState.addOperands(input);
  odsState.addOperands(reduction_indices);
  odsState.addAttribute("keep_dims", keep_dims);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void SumOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value input, ::mlir::Value reduction_indices, bool keep_dims) {
  odsState.addOperands(input);
  odsState.addOperands(reduction_indices);
  odsState.addAttribute("keep_dims", odsBuilder.getBoolAttr(keep_dims));
  odsState.addTypes(output);
}

void SumOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input, ::mlir::Value reduction_indices, bool keep_dims) {
  odsState.addOperands(input);
  odsState.addOperands(reduction_indices);
  odsState.addAttribute("keep_dims", odsBuilder.getBoolAttr(keep_dims));
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void SumOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult SumOp::verify() {
  if (failed(SumOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of bfloat16 or 128-bit complex or 64-bit complex or 16-bit float or 32-bit float or 64-bit float or 16-bit integer or 32-bit integer or 64-bit integer or 8-bit integer or 32-bit quantized integer or 8-bit quantized integer or 8-bit quantized unsigned integer or 16-bit unsigned integer or 32-bit unsigned integer or 64-bit unsigned integer or 8-bit unsigned integer values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of 32/64-bit signed integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>())))))) {
        return emitOpError("result #") << index << " must be tensor of bfloat16 or 128-bit complex or 64-bit complex or 16-bit float or 32-bit float or 64-bit float or 16-bit integer or 32-bit integer or 64-bit integer or 8-bit integer or 32-bit quantized integer or 8-bit quantized integer or 8-bit quantized unsigned integer or 16-bit unsigned integer or 32-bit unsigned integer or 64-bit unsigned integer or 8-bit unsigned integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void SumOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::SummaryWriterOp definitions
//===----------------------------------------------------------------------===//

SummaryWriterOpAdaptor::SummaryWriterOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

SummaryWriterOpAdaptor::SummaryWriterOpAdaptor(SummaryWriterOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> SummaryWriterOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange SummaryWriterOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::StringAttr SummaryWriterOpAdaptor::shared_name() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::StringAttr attr = odsAttrs.get("shared_name").cast<::mlir::StringAttr>();
  return attr;
}

::mlir::StringAttr SummaryWriterOpAdaptor::container() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::StringAttr attr = odsAttrs.get("container").cast<::mlir::StringAttr>();
  return attr;
}

::mlir::LogicalResult SummaryWriterOpAdaptor::verify(::mlir::Location loc) {
  {
  auto tblgen_shared_name = odsAttrs.get("shared_name");
  if (!tblgen_shared_name) return emitError(loc, "'tf.SummaryWriter' op ""requires attribute 'shared_name'");
    if (!((tblgen_shared_name.isa<::mlir::StringAttr>()))) return emitError(loc, "'tf.SummaryWriter' op ""attribute 'shared_name' failed to satisfy constraint: string attribute");
  }
  {
  auto tblgen_container = odsAttrs.get("container");
  if (!tblgen_container) return emitError(loc, "'tf.SummaryWriter' op ""requires attribute 'container'");
    if (!((tblgen_container.isa<::mlir::StringAttr>()))) return emitError(loc, "'tf.SummaryWriter' op ""attribute 'container' failed to satisfy constraint: string attribute");
  }
  return ::mlir::success();
}

::llvm::StringRef SummaryWriterOp::getOperationName() {
  return "tf.SummaryWriter";
}

std::pair<unsigned, unsigned> SummaryWriterOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range SummaryWriterOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

std::pair<unsigned, unsigned> SummaryWriterOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range SummaryWriterOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value SummaryWriterOp::writer() {
  return *getODSResults(0).begin();
}

::mlir::StringAttr SummaryWriterOp::shared_nameAttr() {
  return this->getAttr("shared_name").cast<::mlir::StringAttr>();
}

::llvm::StringRef SummaryWriterOp::shared_name() {
  auto attr = shared_nameAttr();
  return attr.getValue();
}

::mlir::StringAttr SummaryWriterOp::containerAttr() {
  return this->getAttr("container").cast<::mlir::StringAttr>();
}

::llvm::StringRef SummaryWriterOp::container() {
  auto attr = containerAttr();
  return attr.getValue();
}

void SummaryWriterOp::shared_nameAttr(::mlir::StringAttr attr) {
  this->getOperation()->setAttr("shared_name", attr);
}

void SummaryWriterOp::containerAttr(::mlir::StringAttr attr) {
  this->getOperation()->setAttr("container", attr);
}

void SummaryWriterOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type writer, ::mlir::StringAttr shared_name, ::mlir::StringAttr container) {
  odsState.addAttribute("shared_name", shared_name);
  odsState.addAttribute("container", container);
  odsState.addTypes(writer);
}

void SummaryWriterOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::StringAttr shared_name, ::mlir::StringAttr container) {
  odsState.addAttribute("shared_name", shared_name);
  odsState.addAttribute("container", container);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void SummaryWriterOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type writer, ::llvm::StringRef shared_name, ::llvm::StringRef container) {
  odsState.addAttribute("shared_name", odsBuilder.getStringAttr(shared_name));
  odsState.addAttribute("container", odsBuilder.getStringAttr(container));
  odsState.addTypes(writer);
}

void SummaryWriterOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::llvm::StringRef shared_name, ::llvm::StringRef container) {
  odsState.addAttribute("shared_name", odsBuilder.getStringAttr(shared_name));
  odsState.addAttribute("container", odsBuilder.getStringAttr(container));
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void SummaryWriterOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 0u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult SummaryWriterOp::verify() {
  if (failed(SummaryWriterOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::ResourceType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::ResourceRefType>()))))) {
        return emitOpError("result #") << index << " must be tensor of resource values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void SummaryWriterOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
  for (::mlir::Value value : getODSResults(0))
    effects.emplace_back(MemoryEffects::Allocate::get(), value, ::mlir::TF::ResourceEffects::Summary::get());
}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::SymbolicGradientOp definitions
//===----------------------------------------------------------------------===//

SymbolicGradientOpAdaptor::SymbolicGradientOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

SymbolicGradientOpAdaptor::SymbolicGradientOpAdaptor(SymbolicGradientOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> SymbolicGradientOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  bool isVariadic[] = {true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (odsOperands.size() - 0) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::mlir::ValueRange SymbolicGradientOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::ValueRange SymbolicGradientOpAdaptor::input() {
  return getODSOperands(0);
}

::mlir::SymbolRefAttr SymbolicGradientOpAdaptor::f() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::SymbolRefAttr attr = odsAttrs.get("f").cast<::mlir::SymbolRefAttr>();
  return attr;
}

::mlir::LogicalResult SymbolicGradientOpAdaptor::verify(::mlir::Location loc) {
  {
  auto tblgen_f = odsAttrs.get("f");
  if (!tblgen_f) return emitError(loc, "'tf.SymbolicGradient' op ""requires attribute 'f'");
    if (!((tblgen_f.isa<::mlir::SymbolRefAttr>()))) return emitError(loc, "'tf.SymbolicGradient' op ""attribute 'f' failed to satisfy constraint: symbol reference attribute");
  }
  return ::mlir::success();
}

::llvm::StringRef SymbolicGradientOp::getOperationName() {
  return "tf.SymbolicGradient";
}

std::pair<unsigned, unsigned> SymbolicGradientOp::getODSOperandIndexAndLength(unsigned index) {
  bool isVariadic[] = {true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (getOperation()->getNumOperands() - 0) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::mlir::Operation::operand_range SymbolicGradientOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Operation::operand_range SymbolicGradientOp::input() {
  return getODSOperands(0);
}

::mlir::MutableOperandRange SymbolicGradientOp::inputMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> SymbolicGradientOp::getODSResultIndexAndLength(unsigned index) {
  bool isVariadic[] = {true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (getOperation()->getNumResults() - 0) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::mlir::Operation::result_range SymbolicGradientOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Operation::result_range SymbolicGradientOp::output() {
  return getODSResults(0);
}

::mlir::SymbolRefAttr SymbolicGradientOp::fAttr() {
  return this->getAttr("f").cast<::mlir::SymbolRefAttr>();
}

::mlir::SymbolRefAttr SymbolicGradientOp::f() {
  auto attr = fAttr();
  return attr;
}

mlir::OperandElementTypeRange SymbolicGradientOp::Tin() {
  auto values = getODSOperands(0);
return {mlir::OperandElementTypeIterator(values.begin()), mlir::OperandElementTypeIterator(values.end())};
}

mlir::ResultElementTypeRange SymbolicGradientOp::Tout() {
  auto values = getODSResults(0);
return {mlir::ResultElementTypeIterator(values.begin()), mlir::ResultElementTypeIterator(values.end())};
}

bool SymbolicGradientOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "Tin") return true;
  if (name == "Tout") return true;
 return false;
}

::mlir::DictionaryAttr SymbolicGradientOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("Tin", ctx),
ArrayAttr::get(
    [&]() {
      llvm::SmallVector<Attribute, 4> ret;
      for (auto t : Tin())
        ret.push_back(TypeAttr::get(t));
      return ret;
    }(), ctx)},
    {::mlir::Identifier::get("Tout", ctx),
ArrayAttr::get(
    [&]() {
      llvm::SmallVector<Attribute, 4> ret;
      for (auto t : Tout())
        ret.push_back(TypeAttr::get(t));
      return ret;
    }(), ctx)}
    }, ctx);
}

void SymbolicGradientOp::fAttr(::mlir::SymbolRefAttr attr) {
  this->getOperation()->setAttr("f", attr);
}

void SymbolicGradientOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange output, ::mlir::ValueRange input, ::mlir::SymbolRefAttr f) {
  odsState.addOperands(input);
  odsState.addAttribute("f", f);
  odsState.addTypes(output);
}

void SymbolicGradientOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult SymbolicGradientOp::verify() {
  if (failed(SymbolicGradientOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>())))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::TensorFlowType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of tf.dtype values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>())))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::TensorFlowType>()))))) {
        return emitOpError("result #") << index << " must be tensor of tf.dtype values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void SymbolicGradientOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::TPUCompilationResultOp definitions
//===----------------------------------------------------------------------===//

TPUCompilationResultOpAdaptor::TPUCompilationResultOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

TPUCompilationResultOpAdaptor::TPUCompilationResultOpAdaptor(TPUCompilationResultOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> TPUCompilationResultOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange TPUCompilationResultOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::LogicalResult TPUCompilationResultOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

::llvm::StringRef TPUCompilationResultOp::getOperationName() {
  return "tf.TPUCompilationResult";
}

std::pair<unsigned, unsigned> TPUCompilationResultOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range TPUCompilationResultOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

std::pair<unsigned, unsigned> TPUCompilationResultOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range TPUCompilationResultOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value TPUCompilationResultOp::output() {
  return *getODSResults(0).begin();
}

void TPUCompilationResultOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output) {
  odsState.addTypes(output);
}

void TPUCompilationResultOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes) {
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void TPUCompilationResultOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 0u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult TPUCompilationResultOp::verify() {
  if (failed(TPUCompilationResultOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::StringType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::StringRefType>()))))) {
        return emitOpError("result #") << index << " must be tensor of string values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void TPUCompilationResultOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::TPUCompileSucceededAssertOp definitions
//===----------------------------------------------------------------------===//

TPUCompileSucceededAssertOpAdaptor::TPUCompileSucceededAssertOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

TPUCompileSucceededAssertOpAdaptor::TPUCompileSucceededAssertOpAdaptor(TPUCompileSucceededAssertOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> TPUCompileSucceededAssertOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange TPUCompileSucceededAssertOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value TPUCompileSucceededAssertOpAdaptor::compilation_status() {
  return *getODSOperands(0).begin();
}

::mlir::LogicalResult TPUCompileSucceededAssertOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

::llvm::StringRef TPUCompileSucceededAssertOp::getOperationName() {
  return "tf.TPUCompileSucceededAssert";
}

std::pair<unsigned, unsigned> TPUCompileSucceededAssertOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range TPUCompileSucceededAssertOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value TPUCompileSucceededAssertOp::compilation_status() {
  return *getODSOperands(0).begin();
}

::mlir::MutableOperandRange TPUCompileSucceededAssertOp::compilation_statusMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> TPUCompileSucceededAssertOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range TPUCompileSucceededAssertOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

void TPUCompileSucceededAssertOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value compilation_status) {
  odsState.addOperands(compilation_status);
}

void TPUCompileSucceededAssertOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value compilation_status) {
  odsState.addOperands(compilation_status);
  assert(resultTypes.size() == 0u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void TPUCompileSucceededAssertOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 0u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult TPUCompileSucceededAssertOp::verify() {
  if (failed(TPUCompileSucceededAssertOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::StringType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::StringRefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of string values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
  }
  return ::mlir::success();
}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::TPUCopyWithLayoutOp definitions
//===----------------------------------------------------------------------===//

TPUCopyWithLayoutOpAdaptor::TPUCopyWithLayoutOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

TPUCopyWithLayoutOpAdaptor::TPUCopyWithLayoutOpAdaptor(TPUCopyWithLayoutOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> TPUCopyWithLayoutOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange TPUCopyWithLayoutOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value TPUCopyWithLayoutOpAdaptor::input() {
  return *getODSOperands(0).begin();
}

::mlir::Value TPUCopyWithLayoutOpAdaptor::layout() {
  return *getODSOperands(1).begin();
}

::mlir::LogicalResult TPUCopyWithLayoutOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

::llvm::StringRef TPUCopyWithLayoutOp::getOperationName() {
  return "tf.TPUCopyWithLayout";
}

std::pair<unsigned, unsigned> TPUCopyWithLayoutOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range TPUCopyWithLayoutOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value TPUCopyWithLayoutOp::input() {
  return *getODSOperands(0).begin();
}

::mlir::Value TPUCopyWithLayoutOp::layout() {
  return *getODSOperands(1).begin();
}

::mlir::MutableOperandRange TPUCopyWithLayoutOp::inputMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange TPUCopyWithLayoutOp::layoutMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> TPUCopyWithLayoutOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range TPUCopyWithLayoutOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value TPUCopyWithLayoutOp::output() {
  return *getODSResults(0).begin();
}

Type TPUCopyWithLayoutOp::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

bool TPUCopyWithLayoutOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "T") return true;
 return false;
}

::mlir::DictionaryAttr TPUCopyWithLayoutOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())}
    }, ctx);
}

void TPUCopyWithLayoutOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value input, ::mlir::Value layout) {
  odsState.addOperands(input);
  odsState.addOperands(layout);
  odsState.addTypes(output);
}

void TPUCopyWithLayoutOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input, ::mlir::Value layout) {
  odsState.addOperands(input);
  odsState.addOperands(layout);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void TPUCopyWithLayoutOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult TPUCopyWithLayoutOp::verify() {
  if (failed(TPUCopyWithLayoutOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>())))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::TensorFlowType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of tf.dtype values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of 64-bit integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>())))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::TensorFlowType>()))))) {
        return emitOpError("result #") << index << " must be tensor of tf.dtype values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void TPUCopyWithLayoutOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::TPUEmbeddingActivationsOp definitions
//===----------------------------------------------------------------------===//

TPUEmbeddingActivationsOpAdaptor::TPUEmbeddingActivationsOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

TPUEmbeddingActivationsOpAdaptor::TPUEmbeddingActivationsOpAdaptor(TPUEmbeddingActivationsOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> TPUEmbeddingActivationsOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange TPUEmbeddingActivationsOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value TPUEmbeddingActivationsOpAdaptor::embedding_variable() {
  return *getODSOperands(0).begin();
}

::mlir::Value TPUEmbeddingActivationsOpAdaptor::sliced_activations() {
  return *getODSOperands(1).begin();
}

::mlir::IntegerAttr TPUEmbeddingActivationsOpAdaptor::table_id() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::IntegerAttr attr = odsAttrs.get("table_id").cast<::mlir::IntegerAttr>();
  return attr;
}

::mlir::IntegerAttr TPUEmbeddingActivationsOpAdaptor::lookup_id() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::IntegerAttr attr = odsAttrs.get("lookup_id").cast<::mlir::IntegerAttr>();
  return attr;
}

::mlir::LogicalResult TPUEmbeddingActivationsOpAdaptor::verify(::mlir::Location loc) {
  {
  auto tblgen_table_id = odsAttrs.get("table_id");
  if (!tblgen_table_id) return emitError(loc, "'tf.TPUEmbeddingActivations' op ""requires attribute 'table_id'");
    if (!((((tblgen_table_id.isa<::mlir::IntegerAttr>())) && ((tblgen_table_id.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(64)))) && ((tblgen_table_id.cast<::mlir::IntegerAttr>().getInt() >= 0)))) return emitError(loc, "'tf.TPUEmbeddingActivations' op ""attribute 'table_id' failed to satisfy constraint: 64-bit signless integer attribute whose minimum value is 0");
  }
  {
  auto tblgen_lookup_id = odsAttrs.get("lookup_id");
  if (!tblgen_lookup_id) return emitError(loc, "'tf.TPUEmbeddingActivations' op ""requires attribute 'lookup_id'");
    if (!((((tblgen_lookup_id.isa<::mlir::IntegerAttr>())) && ((tblgen_lookup_id.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(64)))) && ((tblgen_lookup_id.cast<::mlir::IntegerAttr>().getInt() >= 0)))) return emitError(loc, "'tf.TPUEmbeddingActivations' op ""attribute 'lookup_id' failed to satisfy constraint: 64-bit signless integer attribute whose minimum value is 0");
  }
  return ::mlir::success();
}

::llvm::StringRef TPUEmbeddingActivationsOp::getOperationName() {
  return "tf.TPUEmbeddingActivations";
}

std::pair<unsigned, unsigned> TPUEmbeddingActivationsOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range TPUEmbeddingActivationsOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value TPUEmbeddingActivationsOp::embedding_variable() {
  return *getODSOperands(0).begin();
}

::mlir::Value TPUEmbeddingActivationsOp::sliced_activations() {
  return *getODSOperands(1).begin();
}

::mlir::MutableOperandRange TPUEmbeddingActivationsOp::embedding_variableMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange TPUEmbeddingActivationsOp::sliced_activationsMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> TPUEmbeddingActivationsOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range TPUEmbeddingActivationsOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value TPUEmbeddingActivationsOp::output() {
  return *getODSResults(0).begin();
}

::mlir::IntegerAttr TPUEmbeddingActivationsOp::table_idAttr() {
  return this->getAttr("table_id").cast<::mlir::IntegerAttr>();
}

uint64_t TPUEmbeddingActivationsOp::table_id() {
  auto attr = table_idAttr();
  return attr.getValue().getZExtValue();
}

::mlir::IntegerAttr TPUEmbeddingActivationsOp::lookup_idAttr() {
  return this->getAttr("lookup_id").cast<::mlir::IntegerAttr>();
}

uint64_t TPUEmbeddingActivationsOp::lookup_id() {
  auto attr = lookup_idAttr();
  return attr.getValue().getZExtValue();
}

void TPUEmbeddingActivationsOp::table_idAttr(::mlir::IntegerAttr attr) {
  this->getOperation()->setAttr("table_id", attr);
}

void TPUEmbeddingActivationsOp::lookup_idAttr(::mlir::IntegerAttr attr) {
  this->getOperation()->setAttr("lookup_id", attr);
}

void TPUEmbeddingActivationsOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value embedding_variable, ::mlir::Value sliced_activations, ::mlir::IntegerAttr table_id, ::mlir::IntegerAttr lookup_id) {
  odsState.addOperands(embedding_variable);
  odsState.addOperands(sliced_activations);
  odsState.addAttribute("table_id", table_id);
  odsState.addAttribute("lookup_id", lookup_id);
  odsState.addTypes(output);
}

void TPUEmbeddingActivationsOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value embedding_variable, ::mlir::Value sliced_activations, ::mlir::IntegerAttr table_id, ::mlir::IntegerAttr lookup_id) {
  odsState.addOperands(embedding_variable);
  odsState.addOperands(sliced_activations);
  odsState.addAttribute("table_id", table_id);
  odsState.addAttribute("lookup_id", lookup_id);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void TPUEmbeddingActivationsOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value embedding_variable, ::mlir::Value sliced_activations, uint64_t table_id, uint64_t lookup_id) {
  odsState.addOperands(embedding_variable);
  odsState.addOperands(sliced_activations);
  odsState.addAttribute("table_id", odsBuilder.getIntegerAttr(odsBuilder.getIntegerType(64), table_id));
  odsState.addAttribute("lookup_id", odsBuilder.getIntegerAttr(odsBuilder.getIntegerType(64), lookup_id));
  odsState.addTypes(output);
}

void TPUEmbeddingActivationsOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value embedding_variable, ::mlir::Value sliced_activations, uint64_t table_id, uint64_t lookup_id) {
  odsState.addOperands(embedding_variable);
  odsState.addOperands(sliced_activations);
  odsState.addAttribute("table_id", odsBuilder.getIntegerAttr(odsBuilder.getIntegerType(64), table_id));
  odsState.addAttribute("lookup_id", odsBuilder.getIntegerAttr(odsBuilder.getIntegerType(64), lookup_id));
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void TPUEmbeddingActivationsOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult TPUEmbeddingActivationsOp::verify() {
  if (failed(TPUEmbeddingActivationsOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of 32-bit float values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of 32-bit float values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))))) {
        return emitOpError("result #") << index << " must be tensor of 32-bit float values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void TPUEmbeddingActivationsOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::TPUExecuteAndUpdateVariablesOp definitions
//===----------------------------------------------------------------------===//

TPUExecuteAndUpdateVariablesOpAdaptor::TPUExecuteAndUpdateVariablesOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

TPUExecuteAndUpdateVariablesOpAdaptor::TPUExecuteAndUpdateVariablesOpAdaptor(TPUExecuteAndUpdateVariablesOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> TPUExecuteAndUpdateVariablesOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  bool isVariadic[] = {true, false};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (odsOperands.size() - 1) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::mlir::ValueRange TPUExecuteAndUpdateVariablesOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::ValueRange TPUExecuteAndUpdateVariablesOpAdaptor::args() {
  return getODSOperands(0);
}

::mlir::Value TPUExecuteAndUpdateVariablesOpAdaptor::key() {
  return *getODSOperands(1).begin();
}

::mlir::ArrayAttr TPUExecuteAndUpdateVariablesOpAdaptor::device_var_reads_indices() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::ArrayAttr attr = odsAttrs.get("device_var_reads_indices").cast<::mlir::ArrayAttr>();
  return attr;
}

::mlir::ArrayAttr TPUExecuteAndUpdateVariablesOpAdaptor::device_var_updates_indices() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::ArrayAttr attr = odsAttrs.get("device_var_updates_indices").cast<::mlir::ArrayAttr>();
  return attr;
}

::mlir::LogicalResult TPUExecuteAndUpdateVariablesOpAdaptor::verify(::mlir::Location loc) {
  {
  auto tblgen_device_var_reads_indices = odsAttrs.get("device_var_reads_indices");
  if (!tblgen_device_var_reads_indices) return emitError(loc, "'tf.TPUExecuteAndUpdateVariables' op ""requires attribute 'device_var_reads_indices'");
    if (!(((tblgen_device_var_reads_indices.isa<::mlir::ArrayAttr>())) && (::llvm::all_of(tblgen_device_var_reads_indices.cast<::mlir::ArrayAttr>(), [](::mlir::Attribute attr) { return ((attr.isa<::mlir::IntegerAttr>())) && ((attr.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(64))); })))) return emitError(loc, "'tf.TPUExecuteAndUpdateVariables' op ""attribute 'device_var_reads_indices' failed to satisfy constraint: 64-bit integer array attribute");
  }
  {
  auto tblgen_device_var_updates_indices = odsAttrs.get("device_var_updates_indices");
  if (!tblgen_device_var_updates_indices) return emitError(loc, "'tf.TPUExecuteAndUpdateVariables' op ""requires attribute 'device_var_updates_indices'");
    if (!(((tblgen_device_var_updates_indices.isa<::mlir::ArrayAttr>())) && (::llvm::all_of(tblgen_device_var_updates_indices.cast<::mlir::ArrayAttr>(), [](::mlir::Attribute attr) { return ((attr.isa<::mlir::IntegerAttr>())) && ((attr.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(64))); })))) return emitError(loc, "'tf.TPUExecuteAndUpdateVariables' op ""attribute 'device_var_updates_indices' failed to satisfy constraint: 64-bit integer array attribute");
  }
  return ::mlir::success();
}

::llvm::StringRef TPUExecuteAndUpdateVariablesOp::getOperationName() {
  return "tf.TPUExecuteAndUpdateVariables";
}

std::pair<unsigned, unsigned> TPUExecuteAndUpdateVariablesOp::getODSOperandIndexAndLength(unsigned index) {
  bool isVariadic[] = {true, false};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (getOperation()->getNumOperands() - 1) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::mlir::Operation::operand_range TPUExecuteAndUpdateVariablesOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Operation::operand_range TPUExecuteAndUpdateVariablesOp::args() {
  return getODSOperands(0);
}

::mlir::Value TPUExecuteAndUpdateVariablesOp::key() {
  return *getODSOperands(1).begin();
}

::mlir::MutableOperandRange TPUExecuteAndUpdateVariablesOp::argsMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange TPUExecuteAndUpdateVariablesOp::keyMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> TPUExecuteAndUpdateVariablesOp::getODSResultIndexAndLength(unsigned index) {
  bool isVariadic[] = {true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (getOperation()->getNumResults() - 0) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::mlir::Operation::result_range TPUExecuteAndUpdateVariablesOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Operation::result_range TPUExecuteAndUpdateVariablesOp::results() {
  return getODSResults(0);
}

::mlir::ArrayAttr TPUExecuteAndUpdateVariablesOp::device_var_reads_indicesAttr() {
  return this->getAttr("device_var_reads_indices").cast<::mlir::ArrayAttr>();
}

::mlir::ArrayAttr TPUExecuteAndUpdateVariablesOp::device_var_reads_indices() {
  auto attr = device_var_reads_indicesAttr();
  return attr;
}

::mlir::ArrayAttr TPUExecuteAndUpdateVariablesOp::device_var_updates_indicesAttr() {
  return this->getAttr("device_var_updates_indices").cast<::mlir::ArrayAttr>();
}

::mlir::ArrayAttr TPUExecuteAndUpdateVariablesOp::device_var_updates_indices() {
  auto attr = device_var_updates_indicesAttr();
  return attr;
}

mlir::OperandElementTypeRange TPUExecuteAndUpdateVariablesOp::Targs() {
  auto values = getODSOperands(0);
return {mlir::OperandElementTypeIterator(values.begin()), mlir::OperandElementTypeIterator(values.end())};
}

mlir::ResultElementTypeRange TPUExecuteAndUpdateVariablesOp::Tresults() {
  auto values = getODSResults(0);
return {mlir::ResultElementTypeIterator(values.begin()), mlir::ResultElementTypeIterator(values.end())};
}

bool TPUExecuteAndUpdateVariablesOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "Targs") return true;
  if (name == "Tresults") return true;
 return false;
}

::mlir::DictionaryAttr TPUExecuteAndUpdateVariablesOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("Targs", ctx),
ArrayAttr::get(
    [&]() {
      llvm::SmallVector<Attribute, 4> ret;
      for (auto t : Targs())
        ret.push_back(TypeAttr::get(t));
      return ret;
    }(), ctx)},
    {::mlir::Identifier::get("Tresults", ctx),
ArrayAttr::get(
    [&]() {
      llvm::SmallVector<Attribute, 4> ret;
      for (auto t : Tresults())
        ret.push_back(TypeAttr::get(t));
      return ret;
    }(), ctx)}
    }, ctx);
}

void TPUExecuteAndUpdateVariablesOp::device_var_reads_indicesAttr(::mlir::ArrayAttr attr) {
  this->getOperation()->setAttr("device_var_reads_indices", attr);
}

void TPUExecuteAndUpdateVariablesOp::device_var_updates_indicesAttr(::mlir::ArrayAttr attr) {
  this->getOperation()->setAttr("device_var_updates_indices", attr);
}

void TPUExecuteAndUpdateVariablesOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange results, ::mlir::ValueRange args, ::mlir::Value key, ::mlir::ArrayAttr device_var_reads_indices, ::mlir::ArrayAttr device_var_updates_indices) {
  odsState.addOperands(args);
  odsState.addOperands(key);
  odsState.addAttribute("device_var_reads_indices", device_var_reads_indices);
  odsState.addAttribute("device_var_updates_indices", device_var_updates_indices);
  odsState.addTypes(results);
}

void TPUExecuteAndUpdateVariablesOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() >= 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult TPUExecuteAndUpdateVariablesOp::verify() {
  if (failed(TPUExecuteAndUpdateVariablesOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>())))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::TensorFlowType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of tf.dtype values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::StringType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::StringRefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of string values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>())))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::TensorFlowType>()))))) {
        return emitOpError("result #") << index << " must be tensor of tf.dtype values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::TPUExecuteOp definitions
//===----------------------------------------------------------------------===//

TPUExecuteOpAdaptor::TPUExecuteOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

TPUExecuteOpAdaptor::TPUExecuteOpAdaptor(TPUExecuteOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> TPUExecuteOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  bool isVariadic[] = {true, false};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (odsOperands.size() - 1) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::mlir::ValueRange TPUExecuteOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::ValueRange TPUExecuteOpAdaptor::args() {
  return getODSOperands(0);
}

::mlir::Value TPUExecuteOpAdaptor::key() {
  return *getODSOperands(1).begin();
}

::mlir::LogicalResult TPUExecuteOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

::llvm::StringRef TPUExecuteOp::getOperationName() {
  return "tf.TPUExecute";
}

std::pair<unsigned, unsigned> TPUExecuteOp::getODSOperandIndexAndLength(unsigned index) {
  bool isVariadic[] = {true, false};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (getOperation()->getNumOperands() - 1) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::mlir::Operation::operand_range TPUExecuteOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Operation::operand_range TPUExecuteOp::args() {
  return getODSOperands(0);
}

::mlir::Value TPUExecuteOp::key() {
  return *getODSOperands(1).begin();
}

::mlir::MutableOperandRange TPUExecuteOp::argsMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange TPUExecuteOp::keyMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> TPUExecuteOp::getODSResultIndexAndLength(unsigned index) {
  bool isVariadic[] = {true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (getOperation()->getNumResults() - 0) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::mlir::Operation::result_range TPUExecuteOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Operation::result_range TPUExecuteOp::results() {
  return getODSResults(0);
}

mlir::OperandElementTypeRange TPUExecuteOp::Targs() {
  auto values = getODSOperands(0);
return {mlir::OperandElementTypeIterator(values.begin()), mlir::OperandElementTypeIterator(values.end())};
}

mlir::ResultElementTypeRange TPUExecuteOp::Tresults() {
  auto values = getODSResults(0);
return {mlir::ResultElementTypeIterator(values.begin()), mlir::ResultElementTypeIterator(values.end())};
}

bool TPUExecuteOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "Targs") return true;
  if (name == "Tresults") return true;
 return false;
}

::mlir::DictionaryAttr TPUExecuteOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("Targs", ctx),
ArrayAttr::get(
    [&]() {
      llvm::SmallVector<Attribute, 4> ret;
      for (auto t : Targs())
        ret.push_back(TypeAttr::get(t));
      return ret;
    }(), ctx)},
    {::mlir::Identifier::get("Tresults", ctx),
ArrayAttr::get(
    [&]() {
      llvm::SmallVector<Attribute, 4> ret;
      for (auto t : Tresults())
        ret.push_back(TypeAttr::get(t));
      return ret;
    }(), ctx)}
    }, ctx);
}

void TPUExecuteOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange results, ::mlir::ValueRange args, ::mlir::Value key) {
  odsState.addOperands(args);
  odsState.addOperands(key);
  odsState.addTypes(results);
}

void TPUExecuteOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() >= 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult TPUExecuteOp::verify() {
  if (failed(TPUExecuteOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>())))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::TensorFlowType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of tf.dtype values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::StringType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::StringRefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of string values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>())))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::TensorFlowType>()))))) {
        return emitOpError("result #") << index << " must be tensor of tf.dtype values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::TPUGetLayoutOp definitions
//===----------------------------------------------------------------------===//

TPUGetLayoutOpAdaptor::TPUGetLayoutOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

TPUGetLayoutOpAdaptor::TPUGetLayoutOpAdaptor(TPUGetLayoutOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> TPUGetLayoutOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange TPUGetLayoutOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value TPUGetLayoutOpAdaptor::cache_key() {
  return *getODSOperands(0).begin();
}

::mlir::IntegerAttr TPUGetLayoutOpAdaptor::index() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::IntegerAttr attr = odsAttrs.get("index").cast<::mlir::IntegerAttr>();
  return attr;
}

::mlir::BoolAttr TPUGetLayoutOpAdaptor::is_output() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::BoolAttr attr = odsAttrs.get("is_output").cast<::mlir::BoolAttr>();
  return attr;
}

::mlir::LogicalResult TPUGetLayoutOpAdaptor::verify(::mlir::Location loc) {
  {
  auto tblgen_index = odsAttrs.get("index");
  if (!tblgen_index) return emitError(loc, "'tf.TPUGetLayoutOp' op ""requires attribute 'index'");
    if (!(((tblgen_index.isa<::mlir::IntegerAttr>())) && ((tblgen_index.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(64))))) return emitError(loc, "'tf.TPUGetLayoutOp' op ""attribute 'index' failed to satisfy constraint: 64-bit signless integer attribute");
  }
  {
  auto tblgen_is_output = odsAttrs.get("is_output");
  if (!tblgen_is_output) return emitError(loc, "'tf.TPUGetLayoutOp' op ""requires attribute 'is_output'");
    if (!((tblgen_is_output.isa<::mlir::BoolAttr>()))) return emitError(loc, "'tf.TPUGetLayoutOp' op ""attribute 'is_output' failed to satisfy constraint: bool attribute");
  }
  return ::mlir::success();
}

::llvm::StringRef TPUGetLayoutOp::getOperationName() {
  return "tf.TPUGetLayoutOp";
}

std::pair<unsigned, unsigned> TPUGetLayoutOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range TPUGetLayoutOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value TPUGetLayoutOp::cache_key() {
  return *getODSOperands(0).begin();
}

::mlir::MutableOperandRange TPUGetLayoutOp::cache_keyMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> TPUGetLayoutOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range TPUGetLayoutOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value TPUGetLayoutOp::layout() {
  return *getODSResults(0).begin();
}

::mlir::IntegerAttr TPUGetLayoutOp::indexAttr() {
  return this->getAttr("index").cast<::mlir::IntegerAttr>();
}

uint64_t TPUGetLayoutOp::index() {
  auto attr = indexAttr();
  return attr.getValue().getZExtValue();
}

::mlir::BoolAttr TPUGetLayoutOp::is_outputAttr() {
  return this->getAttr("is_output").cast<::mlir::BoolAttr>();
}

bool TPUGetLayoutOp::is_output() {
  auto attr = is_outputAttr();
  return attr.getValue();
}

void TPUGetLayoutOp::indexAttr(::mlir::IntegerAttr attr) {
  this->getOperation()->setAttr("index", attr);
}

void TPUGetLayoutOp::is_outputAttr(::mlir::BoolAttr attr) {
  this->getOperation()->setAttr("is_output", attr);
}

void TPUGetLayoutOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type layout, ::mlir::Value cache_key, ::mlir::IntegerAttr index, ::mlir::BoolAttr is_output) {
  odsState.addOperands(cache_key);
  odsState.addAttribute("index", index);
  odsState.addAttribute("is_output", is_output);
  odsState.addTypes(layout);
}

void TPUGetLayoutOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value cache_key, ::mlir::IntegerAttr index, ::mlir::BoolAttr is_output) {
  odsState.addOperands(cache_key);
  odsState.addAttribute("index", index);
  odsState.addAttribute("is_output", is_output);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void TPUGetLayoutOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type layout, ::mlir::Value cache_key, uint64_t index, bool is_output) {
  odsState.addOperands(cache_key);
  odsState.addAttribute("index", odsBuilder.getIntegerAttr(odsBuilder.getIntegerType(64), index));
  odsState.addAttribute("is_output", odsBuilder.getBoolAttr(is_output));
  odsState.addTypes(layout);
}

void TPUGetLayoutOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value cache_key, uint64_t index, bool is_output) {
  odsState.addOperands(cache_key);
  odsState.addAttribute("index", odsBuilder.getIntegerAttr(odsBuilder.getIntegerType(64), index));
  odsState.addAttribute("is_output", odsBuilder.getBoolAttr(is_output));
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void TPUGetLayoutOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult TPUGetLayoutOp::verify() {
  if (failed(TPUGetLayoutOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::StringType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::StringRefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of string values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))))) {
        return emitOpError("result #") << index << " must be tensor of 64-bit integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void TPUGetLayoutOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::TPUOrdinalSelectorOp definitions
//===----------------------------------------------------------------------===//

TPUOrdinalSelectorOpAdaptor::TPUOrdinalSelectorOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

TPUOrdinalSelectorOpAdaptor::TPUOrdinalSelectorOpAdaptor(TPUOrdinalSelectorOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> TPUOrdinalSelectorOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange TPUOrdinalSelectorOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::LogicalResult TPUOrdinalSelectorOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

::llvm::StringRef TPUOrdinalSelectorOp::getOperationName() {
  return "tf.TPUOrdinalSelector";
}

std::pair<unsigned, unsigned> TPUOrdinalSelectorOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range TPUOrdinalSelectorOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

std::pair<unsigned, unsigned> TPUOrdinalSelectorOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range TPUOrdinalSelectorOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value TPUOrdinalSelectorOp::device_ordinals() {
  return *getODSResults(0).begin();
}

void TPUOrdinalSelectorOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type device_ordinals) {
  odsState.addTypes(device_ordinals);
}

void TPUOrdinalSelectorOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes) {
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void TPUOrdinalSelectorOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 0u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult TPUOrdinalSelectorOp::verify() {
  if (failed(TPUOrdinalSelectorOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))))) {
        return emitOpError("result #") << index << " must be tensor of 32-bit integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::TPUPartitionedCallOp definitions
//===----------------------------------------------------------------------===//

TPUPartitionedCallOpAdaptor::TPUPartitionedCallOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

TPUPartitionedCallOpAdaptor::TPUPartitionedCallOpAdaptor(TPUPartitionedCallOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> TPUPartitionedCallOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  bool isVariadic[] = {true, false};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (odsOperands.size() - 1) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::mlir::ValueRange TPUPartitionedCallOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::ValueRange TPUPartitionedCallOpAdaptor::args() {
  return getODSOperands(0);
}

::mlir::Value TPUPartitionedCallOpAdaptor::device_ordinal() {
  return *getODSOperands(1).begin();
}

::mlir::SymbolRefAttr TPUPartitionedCallOpAdaptor::f() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::SymbolRefAttr attr = odsAttrs.get("f").cast<::mlir::SymbolRefAttr>();
  return attr;
}

::mlir::IntegerAttr TPUPartitionedCallOpAdaptor::autotuner_thresh() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::IntegerAttr attr = odsAttrs.get("autotuner_thresh").dyn_cast_or_null<::mlir::IntegerAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getIntegerAttr(::mlir::Builder(odsAttrs.getContext()).getIntegerType(64), 0);
  return attr;
}

::mlir::LogicalResult TPUPartitionedCallOpAdaptor::verify(::mlir::Location loc) {
  {
  auto tblgen_f = odsAttrs.get("f");
  if (!tblgen_f) return emitError(loc, "'tf.TPUPartitionedCall' op ""requires attribute 'f'");
    if (!((tblgen_f.isa<::mlir::SymbolRefAttr>()))) return emitError(loc, "'tf.TPUPartitionedCall' op ""attribute 'f' failed to satisfy constraint: symbol reference attribute");
  }
  {
  auto tblgen_autotuner_thresh = odsAttrs.get("autotuner_thresh");
  if (tblgen_autotuner_thresh) {
    if (!(((tblgen_autotuner_thresh.isa<::mlir::IntegerAttr>())) && ((tblgen_autotuner_thresh.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(64))))) return emitError(loc, "'tf.TPUPartitionedCall' op ""attribute 'autotuner_thresh' failed to satisfy constraint: 64-bit signless integer attribute");
  }
  }
  return ::mlir::success();
}

::llvm::StringRef TPUPartitionedCallOp::getOperationName() {
  return "tf.TPUPartitionedCall";
}

std::pair<unsigned, unsigned> TPUPartitionedCallOp::getODSOperandIndexAndLength(unsigned index) {
  bool isVariadic[] = {true, false};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (getOperation()->getNumOperands() - 1) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::mlir::Operation::operand_range TPUPartitionedCallOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Operation::operand_range TPUPartitionedCallOp::args() {
  return getODSOperands(0);
}

::mlir::Value TPUPartitionedCallOp::device_ordinal() {
  return *getODSOperands(1).begin();
}

::mlir::MutableOperandRange TPUPartitionedCallOp::argsMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange TPUPartitionedCallOp::device_ordinalMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> TPUPartitionedCallOp::getODSResultIndexAndLength(unsigned index) {
  bool isVariadic[] = {true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (getOperation()->getNumResults() - 0) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::mlir::Operation::result_range TPUPartitionedCallOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Operation::result_range TPUPartitionedCallOp::output() {
  return getODSResults(0);
}

::mlir::SymbolRefAttr TPUPartitionedCallOp::fAttr() {
  return this->getAttr("f").cast<::mlir::SymbolRefAttr>();
}

::mlir::SymbolRefAttr TPUPartitionedCallOp::f() {
  auto attr = fAttr();
  return attr;
}

::mlir::IntegerAttr TPUPartitionedCallOp::autotuner_threshAttr() {
  return this->getAttr("autotuner_thresh").dyn_cast_or_null<::mlir::IntegerAttr>();
}

uint64_t TPUPartitionedCallOp::autotuner_thresh() {
  auto attr = autotuner_threshAttr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getIntegerAttr(::mlir::Builder(this->getContext()).getIntegerType(64), 0).getValue().getZExtValue();
  return attr.getValue().getZExtValue();
}

mlir::OperandElementTypeRange TPUPartitionedCallOp::Tin() {
  auto values = getODSOperands(0);
return {mlir::OperandElementTypeIterator(values.begin()), mlir::OperandElementTypeIterator(values.end())};
}

mlir::ResultElementTypeRange TPUPartitionedCallOp::Tout() {
  auto values = getODSResults(0);
return {mlir::ResultElementTypeIterator(values.begin()), mlir::ResultElementTypeIterator(values.end())};
}

bool TPUPartitionedCallOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "Tin") return true;
  if (name == "Tout") return true;
 return false;
}

::mlir::DictionaryAttr TPUPartitionedCallOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("Tin", ctx),
ArrayAttr::get(
    [&]() {
      llvm::SmallVector<Attribute, 4> ret;
      for (auto t : Tin())
        ret.push_back(TypeAttr::get(t));
      return ret;
    }(), ctx)},
    {::mlir::Identifier::get("Tout", ctx),
ArrayAttr::get(
    [&]() {
      llvm::SmallVector<Attribute, 4> ret;
      for (auto t : Tout())
        ret.push_back(TypeAttr::get(t));
      return ret;
    }(), ctx)}
    }, ctx);
}

void TPUPartitionedCallOp::fAttr(::mlir::SymbolRefAttr attr) {
  this->getOperation()->setAttr("f", attr);
}

void TPUPartitionedCallOp::autotuner_threshAttr(::mlir::IntegerAttr attr) {
  this->getOperation()->setAttr("autotuner_thresh", attr);
}

void TPUPartitionedCallOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange output, ::mlir::ValueRange args, ::mlir::Value device_ordinal, ::mlir::SymbolRefAttr f, ::mlir::IntegerAttr autotuner_thresh) {
  odsState.addOperands(args);
  odsState.addOperands(device_ordinal);
  odsState.addAttribute("f", f);
  odsState.addAttribute("autotuner_thresh", autotuner_thresh);
  odsState.addTypes(output);
}

void TPUPartitionedCallOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange output, ::mlir::ValueRange args, ::mlir::Value device_ordinal, ::mlir::SymbolRefAttr f, uint64_t autotuner_thresh) {
  odsState.addOperands(args);
  odsState.addOperands(device_ordinal);
  odsState.addAttribute("f", f);
  odsState.addAttribute("autotuner_thresh", odsBuilder.getIntegerAttr(odsBuilder.getIntegerType(64), autotuner_thresh));
  odsState.addTypes(output);
}

void TPUPartitionedCallOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() >= 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult TPUPartitionedCallOp::verify() {
  if (failed(TPUPartitionedCallOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>())))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::TensorFlowType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of tf.dtype values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of 32-bit integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>())))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::TensorFlowType>()))))) {
        return emitOpError("result #") << index << " must be tensor of tf.dtype values, but got " << v.getType();
      }
      ++index;
    }
  }
  return VerifyPartitionedCall(*this);
}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::TPUReplicateMetadataOp definitions
//===----------------------------------------------------------------------===//

TPUReplicateMetadataOpAdaptor::TPUReplicateMetadataOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

TPUReplicateMetadataOpAdaptor::TPUReplicateMetadataOpAdaptor(TPUReplicateMetadataOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> TPUReplicateMetadataOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange TPUReplicateMetadataOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::IntegerAttr TPUReplicateMetadataOpAdaptor::num_replicas() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::IntegerAttr attr = odsAttrs.get("num_replicas").cast<::mlir::IntegerAttr>();
  return attr;
}

::mlir::IntegerAttr TPUReplicateMetadataOpAdaptor::num_cores_per_replica() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::IntegerAttr attr = odsAttrs.get("num_cores_per_replica").dyn_cast_or_null<::mlir::IntegerAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getIntegerAttr(::mlir::Builder(odsAttrs.getContext()).getIntegerType(64), 1);
  return attr;
}

::mlir::StringAttr TPUReplicateMetadataOpAdaptor::topology() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::StringAttr attr = odsAttrs.get("topology").cast<::mlir::StringAttr>();
  return attr;
}

::mlir::BoolAttr TPUReplicateMetadataOpAdaptor::use_tpu() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::BoolAttr attr = odsAttrs.get("use_tpu").dyn_cast_or_null<::mlir::BoolAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getBoolAttr(true);
  return attr;
}

::mlir::ArrayAttr TPUReplicateMetadataOpAdaptor::device_assignment() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::ArrayAttr attr = odsAttrs.get("device_assignment").dyn_cast_or_null<::mlir::ArrayAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getI64ArrayAttr({});
  return attr;
}

::mlir::ArrayAttr TPUReplicateMetadataOpAdaptor::computation_shape() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::ArrayAttr attr = odsAttrs.get("computation_shape").dyn_cast_or_null<::mlir::ArrayAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getI64ArrayAttr({});
  return attr;
}

::mlir::ArrayAttr TPUReplicateMetadataOpAdaptor::host_compute_core() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::ArrayAttr attr = odsAttrs.get("host_compute_core").dyn_cast_or_null<::mlir::ArrayAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getStrArrayAttr({});
  return attr;
}

::mlir::ArrayAttr TPUReplicateMetadataOpAdaptor::padding_map() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::ArrayAttr attr = odsAttrs.get("padding_map").dyn_cast_or_null<::mlir::ArrayAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getStrArrayAttr({});
  return attr;
}

::mlir::StringAttr TPUReplicateMetadataOpAdaptor::step_marker_location() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::StringAttr attr = odsAttrs.get("step_marker_location").dyn_cast_or_null<::mlir::StringAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getStringAttr("STEP_MARK_AT_ENTRY");
  return attr;
}

::mlir::BoolAttr TPUReplicateMetadataOpAdaptor::allow_soft_placement() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::BoolAttr attr = odsAttrs.get("allow_soft_placement").dyn_cast_or_null<::mlir::BoolAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getBoolAttr(false);
  return attr;
}

::mlir::BoolAttr TPUReplicateMetadataOpAdaptor::use_spmd_for_xla_partitioning() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::BoolAttr attr = odsAttrs.get("use_spmd_for_xla_partitioning").dyn_cast_or_null<::mlir::BoolAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getBoolAttr(false);
  return attr;
}

::mlir::LogicalResult TPUReplicateMetadataOpAdaptor::verify(::mlir::Location loc) {
  {
  auto tblgen_num_replicas = odsAttrs.get("num_replicas");
  if (!tblgen_num_replicas) return emitError(loc, "'tf.TPUReplicateMetadata' op ""requires attribute 'num_replicas'");
    if (!((((tblgen_num_replicas.isa<::mlir::IntegerAttr>())) && ((tblgen_num_replicas.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(64)))) && ((tblgen_num_replicas.cast<::mlir::IntegerAttr>().getInt() >= 0)))) return emitError(loc, "'tf.TPUReplicateMetadata' op ""attribute 'num_replicas' failed to satisfy constraint: 64-bit signless integer attribute whose minimum value is 0");
  }
  {
  auto tblgen_num_cores_per_replica = odsAttrs.get("num_cores_per_replica");
  if (tblgen_num_cores_per_replica) {
    if (!(((tblgen_num_cores_per_replica.isa<::mlir::IntegerAttr>())) && ((tblgen_num_cores_per_replica.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(64))))) return emitError(loc, "'tf.TPUReplicateMetadata' op ""attribute 'num_cores_per_replica' failed to satisfy constraint: 64-bit signless integer attribute");
  }
  }
  {
  auto tblgen_topology = odsAttrs.get("topology");
  if (!tblgen_topology) return emitError(loc, "'tf.TPUReplicateMetadata' op ""requires attribute 'topology'");
    if (!((tblgen_topology.isa<::mlir::StringAttr>()))) return emitError(loc, "'tf.TPUReplicateMetadata' op ""attribute 'topology' failed to satisfy constraint: string attribute");
  }
  {
  auto tblgen_use_tpu = odsAttrs.get("use_tpu");
  if (tblgen_use_tpu) {
    if (!((tblgen_use_tpu.isa<::mlir::BoolAttr>()))) return emitError(loc, "'tf.TPUReplicateMetadata' op ""attribute 'use_tpu' failed to satisfy constraint: bool attribute");
  }
  }
  {
  auto tblgen_device_assignment = odsAttrs.get("device_assignment");
  if (tblgen_device_assignment) {
    if (!(((tblgen_device_assignment.isa<::mlir::ArrayAttr>())) && (::llvm::all_of(tblgen_device_assignment.cast<::mlir::ArrayAttr>(), [](::mlir::Attribute attr) { return ((attr.isa<::mlir::IntegerAttr>())) && ((attr.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(64))); })))) return emitError(loc, "'tf.TPUReplicateMetadata' op ""attribute 'device_assignment' failed to satisfy constraint: 64-bit integer array attribute");
  }
  }
  {
  auto tblgen_computation_shape = odsAttrs.get("computation_shape");
  if (tblgen_computation_shape) {
    if (!(((tblgen_computation_shape.isa<::mlir::ArrayAttr>())) && (::llvm::all_of(tblgen_computation_shape.cast<::mlir::ArrayAttr>(), [](::mlir::Attribute attr) { return ((attr.isa<::mlir::IntegerAttr>())) && ((attr.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(64))); })))) return emitError(loc, "'tf.TPUReplicateMetadata' op ""attribute 'computation_shape' failed to satisfy constraint: 64-bit integer array attribute");
  }
  }
  {
  auto tblgen_host_compute_core = odsAttrs.get("host_compute_core");
  if (tblgen_host_compute_core) {
    if (!(((tblgen_host_compute_core.isa<::mlir::ArrayAttr>())) && (::llvm::all_of(tblgen_host_compute_core.cast<::mlir::ArrayAttr>(), [](::mlir::Attribute attr) { return (attr.isa<::mlir::StringAttr>()); })))) return emitError(loc, "'tf.TPUReplicateMetadata' op ""attribute 'host_compute_core' failed to satisfy constraint: string array attribute");
  }
  }
  {
  auto tblgen_padding_map = odsAttrs.get("padding_map");
  if (tblgen_padding_map) {
    if (!(((tblgen_padding_map.isa<::mlir::ArrayAttr>())) && (::llvm::all_of(tblgen_padding_map.cast<::mlir::ArrayAttr>(), [](::mlir::Attribute attr) { return (attr.isa<::mlir::StringAttr>()); })))) return emitError(loc, "'tf.TPUReplicateMetadata' op ""attribute 'padding_map' failed to satisfy constraint: string array attribute");
  }
  }
  {
  auto tblgen_step_marker_location = odsAttrs.get("step_marker_location");
  if (tblgen_step_marker_location) {
    if (!((tblgen_step_marker_location.isa<::mlir::StringAttr>()))) return emitError(loc, "'tf.TPUReplicateMetadata' op ""attribute 'step_marker_location' failed to satisfy constraint: string attribute");
  }
  }
  {
  auto tblgen_allow_soft_placement = odsAttrs.get("allow_soft_placement");
  if (tblgen_allow_soft_placement) {
    if (!((tblgen_allow_soft_placement.isa<::mlir::BoolAttr>()))) return emitError(loc, "'tf.TPUReplicateMetadata' op ""attribute 'allow_soft_placement' failed to satisfy constraint: bool attribute");
  }
  }
  {
  auto tblgen_use_spmd_for_xla_partitioning = odsAttrs.get("use_spmd_for_xla_partitioning");
  if (tblgen_use_spmd_for_xla_partitioning) {
    if (!((tblgen_use_spmd_for_xla_partitioning.isa<::mlir::BoolAttr>()))) return emitError(loc, "'tf.TPUReplicateMetadata' op ""attribute 'use_spmd_for_xla_partitioning' failed to satisfy constraint: bool attribute");
  }
  }
  return ::mlir::success();
}

::llvm::StringRef TPUReplicateMetadataOp::getOperationName() {
  return "tf.TPUReplicateMetadata";
}

std::pair<unsigned, unsigned> TPUReplicateMetadataOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range TPUReplicateMetadataOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

std::pair<unsigned, unsigned> TPUReplicateMetadataOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range TPUReplicateMetadataOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::IntegerAttr TPUReplicateMetadataOp::num_replicasAttr() {
  return this->getAttr("num_replicas").cast<::mlir::IntegerAttr>();
}

uint64_t TPUReplicateMetadataOp::num_replicas() {
  auto attr = num_replicasAttr();
  return attr.getValue().getZExtValue();
}

::mlir::IntegerAttr TPUReplicateMetadataOp::num_cores_per_replicaAttr() {
  return this->getAttr("num_cores_per_replica").dyn_cast_or_null<::mlir::IntegerAttr>();
}

uint64_t TPUReplicateMetadataOp::num_cores_per_replica() {
  auto attr = num_cores_per_replicaAttr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getIntegerAttr(::mlir::Builder(this->getContext()).getIntegerType(64), 1).getValue().getZExtValue();
  return attr.getValue().getZExtValue();
}

::mlir::StringAttr TPUReplicateMetadataOp::topologyAttr() {
  return this->getAttr("topology").cast<::mlir::StringAttr>();
}

::llvm::StringRef TPUReplicateMetadataOp::topology() {
  auto attr = topologyAttr();
  return attr.getValue();
}

::mlir::BoolAttr TPUReplicateMetadataOp::use_tpuAttr() {
  return this->getAttr("use_tpu").dyn_cast_or_null<::mlir::BoolAttr>();
}

bool TPUReplicateMetadataOp::use_tpu() {
  auto attr = use_tpuAttr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getBoolAttr(true).getValue();
  return attr.getValue();
}

::mlir::ArrayAttr TPUReplicateMetadataOp::device_assignmentAttr() {
  return this->getAttr("device_assignment").dyn_cast_or_null<::mlir::ArrayAttr>();
}

::mlir::ArrayAttr TPUReplicateMetadataOp::device_assignment() {
  auto attr = device_assignmentAttr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getI64ArrayAttr({});
  return attr;
}

::mlir::ArrayAttr TPUReplicateMetadataOp::computation_shapeAttr() {
  return this->getAttr("computation_shape").dyn_cast_or_null<::mlir::ArrayAttr>();
}

::mlir::ArrayAttr TPUReplicateMetadataOp::computation_shape() {
  auto attr = computation_shapeAttr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getI64ArrayAttr({});
  return attr;
}

::mlir::ArrayAttr TPUReplicateMetadataOp::host_compute_coreAttr() {
  return this->getAttr("host_compute_core").dyn_cast_or_null<::mlir::ArrayAttr>();
}

::mlir::ArrayAttr TPUReplicateMetadataOp::host_compute_core() {
  auto attr = host_compute_coreAttr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getStrArrayAttr({});
  return attr;
}

::mlir::ArrayAttr TPUReplicateMetadataOp::padding_mapAttr() {
  return this->getAttr("padding_map").dyn_cast_or_null<::mlir::ArrayAttr>();
}

::mlir::ArrayAttr TPUReplicateMetadataOp::padding_map() {
  auto attr = padding_mapAttr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getStrArrayAttr({});
  return attr;
}

::mlir::StringAttr TPUReplicateMetadataOp::step_marker_locationAttr() {
  return this->getAttr("step_marker_location").dyn_cast_or_null<::mlir::StringAttr>();
}

::llvm::StringRef TPUReplicateMetadataOp::step_marker_location() {
  auto attr = step_marker_locationAttr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getStringAttr("STEP_MARK_AT_ENTRY").getValue();
  return attr.getValue();
}

::mlir::BoolAttr TPUReplicateMetadataOp::allow_soft_placementAttr() {
  return this->getAttr("allow_soft_placement").dyn_cast_or_null<::mlir::BoolAttr>();
}

bool TPUReplicateMetadataOp::allow_soft_placement() {
  auto attr = allow_soft_placementAttr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getBoolAttr(false).getValue();
  return attr.getValue();
}

::mlir::BoolAttr TPUReplicateMetadataOp::use_spmd_for_xla_partitioningAttr() {
  return this->getAttr("use_spmd_for_xla_partitioning").dyn_cast_or_null<::mlir::BoolAttr>();
}

bool TPUReplicateMetadataOp::use_spmd_for_xla_partitioning() {
  auto attr = use_spmd_for_xla_partitioningAttr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getBoolAttr(false).getValue();
  return attr.getValue();
}

void TPUReplicateMetadataOp::num_replicasAttr(::mlir::IntegerAttr attr) {
  this->getOperation()->setAttr("num_replicas", attr);
}

void TPUReplicateMetadataOp::num_cores_per_replicaAttr(::mlir::IntegerAttr attr) {
  this->getOperation()->setAttr("num_cores_per_replica", attr);
}

void TPUReplicateMetadataOp::topologyAttr(::mlir::StringAttr attr) {
  this->getOperation()->setAttr("topology", attr);
}

void TPUReplicateMetadataOp::use_tpuAttr(::mlir::BoolAttr attr) {
  this->getOperation()->setAttr("use_tpu", attr);
}

void TPUReplicateMetadataOp::device_assignmentAttr(::mlir::ArrayAttr attr) {
  this->getOperation()->setAttr("device_assignment", attr);
}

void TPUReplicateMetadataOp::computation_shapeAttr(::mlir::ArrayAttr attr) {
  this->getOperation()->setAttr("computation_shape", attr);
}

void TPUReplicateMetadataOp::host_compute_coreAttr(::mlir::ArrayAttr attr) {
  this->getOperation()->setAttr("host_compute_core", attr);
}

void TPUReplicateMetadataOp::padding_mapAttr(::mlir::ArrayAttr attr) {
  this->getOperation()->setAttr("padding_map", attr);
}

void TPUReplicateMetadataOp::step_marker_locationAttr(::mlir::StringAttr attr) {
  this->getOperation()->setAttr("step_marker_location", attr);
}

void TPUReplicateMetadataOp::allow_soft_placementAttr(::mlir::BoolAttr attr) {
  this->getOperation()->setAttr("allow_soft_placement", attr);
}

void TPUReplicateMetadataOp::use_spmd_for_xla_partitioningAttr(::mlir::BoolAttr attr) {
  this->getOperation()->setAttr("use_spmd_for_xla_partitioning", attr);
}

void TPUReplicateMetadataOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::IntegerAttr num_replicas, ::mlir::IntegerAttr num_cores_per_replica, ::mlir::StringAttr topology, ::mlir::BoolAttr use_tpu, ::mlir::ArrayAttr device_assignment, ::mlir::ArrayAttr computation_shape, ::mlir::ArrayAttr host_compute_core, ::mlir::ArrayAttr padding_map, ::mlir::StringAttr step_marker_location, ::mlir::BoolAttr allow_soft_placement, ::mlir::BoolAttr use_spmd_for_xla_partitioning) {
  odsState.addAttribute("num_replicas", num_replicas);
  odsState.addAttribute("num_cores_per_replica", num_cores_per_replica);
  odsState.addAttribute("topology", topology);
  odsState.addAttribute("use_tpu", use_tpu);
  odsState.addAttribute("device_assignment", device_assignment);
  odsState.addAttribute("computation_shape", computation_shape);
  odsState.addAttribute("host_compute_core", host_compute_core);
  odsState.addAttribute("padding_map", padding_map);
  odsState.addAttribute("step_marker_location", step_marker_location);
  odsState.addAttribute("allow_soft_placement", allow_soft_placement);
  odsState.addAttribute("use_spmd_for_xla_partitioning", use_spmd_for_xla_partitioning);
}

void TPUReplicateMetadataOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::IntegerAttr num_replicas, ::mlir::IntegerAttr num_cores_per_replica, ::mlir::StringAttr topology, ::mlir::BoolAttr use_tpu, ::mlir::ArrayAttr device_assignment, ::mlir::ArrayAttr computation_shape, ::mlir::ArrayAttr host_compute_core, ::mlir::ArrayAttr padding_map, ::mlir::StringAttr step_marker_location, ::mlir::BoolAttr allow_soft_placement, ::mlir::BoolAttr use_spmd_for_xla_partitioning) {
  odsState.addAttribute("num_replicas", num_replicas);
  odsState.addAttribute("num_cores_per_replica", num_cores_per_replica);
  odsState.addAttribute("topology", topology);
  odsState.addAttribute("use_tpu", use_tpu);
  odsState.addAttribute("device_assignment", device_assignment);
  odsState.addAttribute("computation_shape", computation_shape);
  odsState.addAttribute("host_compute_core", host_compute_core);
  odsState.addAttribute("padding_map", padding_map);
  odsState.addAttribute("step_marker_location", step_marker_location);
  odsState.addAttribute("allow_soft_placement", allow_soft_placement);
  odsState.addAttribute("use_spmd_for_xla_partitioning", use_spmd_for_xla_partitioning);
  assert(resultTypes.size() == 0u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void TPUReplicateMetadataOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, uint64_t num_replicas, uint64_t num_cores_per_replica, ::llvm::StringRef topology, bool use_tpu, ::mlir::ArrayAttr device_assignment, ::mlir::ArrayAttr computation_shape, ::mlir::ArrayAttr host_compute_core, ::mlir::ArrayAttr padding_map, ::llvm::StringRef step_marker_location, bool allow_soft_placement, bool use_spmd_for_xla_partitioning) {
  odsState.addAttribute("num_replicas", odsBuilder.getIntegerAttr(odsBuilder.getIntegerType(64), num_replicas));
  odsState.addAttribute("num_cores_per_replica", odsBuilder.getIntegerAttr(odsBuilder.getIntegerType(64), num_cores_per_replica));
  odsState.addAttribute("topology", odsBuilder.getStringAttr(topology));
  odsState.addAttribute("use_tpu", odsBuilder.getBoolAttr(use_tpu));
  odsState.addAttribute("device_assignment", device_assignment);
  odsState.addAttribute("computation_shape", computation_shape);
  odsState.addAttribute("host_compute_core", host_compute_core);
  odsState.addAttribute("padding_map", padding_map);
  odsState.addAttribute("step_marker_location", odsBuilder.getStringAttr(step_marker_location));
  odsState.addAttribute("allow_soft_placement", odsBuilder.getBoolAttr(allow_soft_placement));
  odsState.addAttribute("use_spmd_for_xla_partitioning", odsBuilder.getBoolAttr(use_spmd_for_xla_partitioning));
}

void TPUReplicateMetadataOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, uint64_t num_replicas, uint64_t num_cores_per_replica, ::llvm::StringRef topology, bool use_tpu, ::mlir::ArrayAttr device_assignment, ::mlir::ArrayAttr computation_shape, ::mlir::ArrayAttr host_compute_core, ::mlir::ArrayAttr padding_map, ::llvm::StringRef step_marker_location, bool allow_soft_placement, bool use_spmd_for_xla_partitioning) {
  odsState.addAttribute("num_replicas", odsBuilder.getIntegerAttr(odsBuilder.getIntegerType(64), num_replicas));
  odsState.addAttribute("num_cores_per_replica", odsBuilder.getIntegerAttr(odsBuilder.getIntegerType(64), num_cores_per_replica));
  odsState.addAttribute("topology", odsBuilder.getStringAttr(topology));
  odsState.addAttribute("use_tpu", odsBuilder.getBoolAttr(use_tpu));
  odsState.addAttribute("device_assignment", device_assignment);
  odsState.addAttribute("computation_shape", computation_shape);
  odsState.addAttribute("host_compute_core", host_compute_core);
  odsState.addAttribute("padding_map", padding_map);
  odsState.addAttribute("step_marker_location", odsBuilder.getStringAttr(step_marker_location));
  odsState.addAttribute("allow_soft_placement", odsBuilder.getBoolAttr(allow_soft_placement));
  odsState.addAttribute("use_spmd_for_xla_partitioning", odsBuilder.getBoolAttr(use_spmd_for_xla_partitioning));
  assert(resultTypes.size() == 0u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void TPUReplicateMetadataOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 0u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 0u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult TPUReplicateMetadataOp::verify() {
  if (failed(TPUReplicateMetadataOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
  }
  {
    unsigned index = 0; (void)index;
  }
  return ::mlir::success();
}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::TPUReplicatedInputOp definitions
//===----------------------------------------------------------------------===//

TPUReplicatedInputOpAdaptor::TPUReplicatedInputOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

TPUReplicatedInputOpAdaptor::TPUReplicatedInputOpAdaptor(TPUReplicatedInputOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> TPUReplicatedInputOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  bool isVariadic[] = {true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (odsOperands.size() - 0) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::mlir::ValueRange TPUReplicatedInputOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::ValueRange TPUReplicatedInputOpAdaptor::inputs() {
  return getODSOperands(0);
}

::mlir::BoolAttr TPUReplicatedInputOpAdaptor::is_mirrored_variable() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::BoolAttr attr = odsAttrs.get("is_mirrored_variable").dyn_cast_or_null<::mlir::BoolAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getBoolAttr(false);
  return attr;
}

::mlir::IntegerAttr TPUReplicatedInputOpAdaptor::index() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::IntegerAttr attr = odsAttrs.get("index").dyn_cast_or_null<::mlir::IntegerAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getIntegerAttr(::mlir::Builder(odsAttrs.getContext()).getIntegerType(64), -1);
  return attr;
}

::mlir::BoolAttr TPUReplicatedInputOpAdaptor::is_packed() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::BoolAttr attr = odsAttrs.get("is_packed").dyn_cast_or_null<::mlir::BoolAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getBoolAttr(false);
  return attr;
}

::mlir::LogicalResult TPUReplicatedInputOpAdaptor::verify(::mlir::Location loc) {
  {
  auto tblgen_is_mirrored_variable = odsAttrs.get("is_mirrored_variable");
  if (tblgen_is_mirrored_variable) {
    if (!((tblgen_is_mirrored_variable.isa<::mlir::BoolAttr>()))) return emitError(loc, "'tf.TPUReplicatedInput' op ""attribute 'is_mirrored_variable' failed to satisfy constraint: bool attribute");
  }
  }
  {
  auto tblgen_index = odsAttrs.get("index");
  if (tblgen_index) {
    if (!(((tblgen_index.isa<::mlir::IntegerAttr>())) && ((tblgen_index.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(64))))) return emitError(loc, "'tf.TPUReplicatedInput' op ""attribute 'index' failed to satisfy constraint: 64-bit signless integer attribute");
  }
  }
  {
  auto tblgen_is_packed = odsAttrs.get("is_packed");
  if (tblgen_is_packed) {
    if (!((tblgen_is_packed.isa<::mlir::BoolAttr>()))) return emitError(loc, "'tf.TPUReplicatedInput' op ""attribute 'is_packed' failed to satisfy constraint: bool attribute");
  }
  }
  return ::mlir::success();
}

::llvm::StringRef TPUReplicatedInputOp::getOperationName() {
  return "tf.TPUReplicatedInput";
}

std::pair<unsigned, unsigned> TPUReplicatedInputOp::getODSOperandIndexAndLength(unsigned index) {
  bool isVariadic[] = {true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (getOperation()->getNumOperands() - 0) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::mlir::Operation::operand_range TPUReplicatedInputOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Operation::operand_range TPUReplicatedInputOp::inputs() {
  return getODSOperands(0);
}

::mlir::MutableOperandRange TPUReplicatedInputOp::inputsMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> TPUReplicatedInputOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range TPUReplicatedInputOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value TPUReplicatedInputOp::output() {
  return *getODSResults(0).begin();
}

::mlir::BoolAttr TPUReplicatedInputOp::is_mirrored_variableAttr() {
  return this->getAttr("is_mirrored_variable").dyn_cast_or_null<::mlir::BoolAttr>();
}

bool TPUReplicatedInputOp::is_mirrored_variable() {
  auto attr = is_mirrored_variableAttr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getBoolAttr(false).getValue();
  return attr.getValue();
}

::mlir::IntegerAttr TPUReplicatedInputOp::indexAttr() {
  return this->getAttr("index").dyn_cast_or_null<::mlir::IntegerAttr>();
}

uint64_t TPUReplicatedInputOp::index() {
  auto attr = indexAttr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getIntegerAttr(::mlir::Builder(this->getContext()).getIntegerType(64), -1).getValue().getZExtValue();
  return attr.getValue().getZExtValue();
}

::mlir::BoolAttr TPUReplicatedInputOp::is_packedAttr() {
  return this->getAttr("is_packed").dyn_cast_or_null<::mlir::BoolAttr>();
}

bool TPUReplicatedInputOp::is_packed() {
  auto attr = is_packedAttr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getBoolAttr(false).getValue();
  return attr.getValue();
}

Type TPUReplicatedInputOp::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

size_t TPUReplicatedInputOp::N() {
  auto range = getODSOperands(0);
return std::distance(range.begin(), range.end());
}

bool TPUReplicatedInputOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "T") return true;
  if (name == "N") return true;
 return false;
}

::mlir::DictionaryAttr TPUReplicatedInputOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())},
    {::mlir::Identifier::get("N", ctx),
odsBuilder.getI64IntegerAttr(N())}
    }, ctx);
}

void TPUReplicatedInputOp::is_mirrored_variableAttr(::mlir::BoolAttr attr) {
  this->getOperation()->setAttr("is_mirrored_variable", attr);
}

void TPUReplicatedInputOp::indexAttr(::mlir::IntegerAttr attr) {
  this->getOperation()->setAttr("index", attr);
}

void TPUReplicatedInputOp::is_packedAttr(::mlir::BoolAttr attr) {
  this->getOperation()->setAttr("is_packed", attr);
}

void TPUReplicatedInputOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::ValueRange inputs, ::mlir::BoolAttr is_mirrored_variable, ::mlir::IntegerAttr index, ::mlir::BoolAttr is_packed) {
  odsState.addOperands(inputs);
  odsState.addAttribute("is_mirrored_variable", is_mirrored_variable);
  odsState.addAttribute("index", index);
  odsState.addAttribute("is_packed", is_packed);
  odsState.addTypes(output);
}

void TPUReplicatedInputOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange inputs, ::mlir::BoolAttr is_mirrored_variable, ::mlir::IntegerAttr index, ::mlir::BoolAttr is_packed) {
  odsState.addOperands(inputs);
  odsState.addAttribute("is_mirrored_variable", is_mirrored_variable);
  odsState.addAttribute("index", index);
  odsState.addAttribute("is_packed", is_packed);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void TPUReplicatedInputOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::ValueRange inputs, bool is_mirrored_variable, uint64_t index, bool is_packed) {
  odsState.addOperands(inputs);
  odsState.addAttribute("is_mirrored_variable", odsBuilder.getBoolAttr(is_mirrored_variable));
  odsState.addAttribute("index", odsBuilder.getIntegerAttr(odsBuilder.getIntegerType(64), index));
  odsState.addAttribute("is_packed", odsBuilder.getBoolAttr(is_packed));
  odsState.addTypes(output);
}

void TPUReplicatedInputOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange inputs, bool is_mirrored_variable, uint64_t index, bool is_packed) {
  odsState.addOperands(inputs);
  odsState.addAttribute("is_mirrored_variable", odsBuilder.getBoolAttr(is_mirrored_variable));
  odsState.addAttribute("index", odsBuilder.getIntegerAttr(odsBuilder.getIntegerType(64), index));
  odsState.addAttribute("is_packed", odsBuilder.getBoolAttr(is_packed));
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void TPUReplicatedInputOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult TPUReplicatedInputOp::verify() {
  if (failed(TPUReplicatedInputOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>())))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::TensorFlowType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of tf.dtype values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>())))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::TensorFlowType>()))))) {
        return emitOpError("result #") << index << " must be tensor of tf.dtype values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void TPUReplicatedInputOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::TPUReplicatedOutputOp definitions
//===----------------------------------------------------------------------===//

TPUReplicatedOutputOpAdaptor::TPUReplicatedOutputOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

TPUReplicatedOutputOpAdaptor::TPUReplicatedOutputOpAdaptor(TPUReplicatedOutputOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> TPUReplicatedOutputOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange TPUReplicatedOutputOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value TPUReplicatedOutputOpAdaptor::input() {
  return *getODSOperands(0).begin();
}

::mlir::LogicalResult TPUReplicatedOutputOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

::llvm::StringRef TPUReplicatedOutputOp::getOperationName() {
  return "tf.TPUReplicatedOutput";
}

std::pair<unsigned, unsigned> TPUReplicatedOutputOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range TPUReplicatedOutputOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value TPUReplicatedOutputOp::input() {
  return *getODSOperands(0).begin();
}

::mlir::MutableOperandRange TPUReplicatedOutputOp::inputMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> TPUReplicatedOutputOp::getODSResultIndexAndLength(unsigned index) {
  bool isVariadic[] = {true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (getOperation()->getNumResults() - 0) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::mlir::Operation::result_range TPUReplicatedOutputOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Operation::result_range TPUReplicatedOutputOp::outputs() {
  return getODSResults(0);
}

size_t TPUReplicatedOutputOp::num_replicas() {
  auto range = getODSResults(0);
return std::distance(range.begin(), range.end());
}

Type TPUReplicatedOutputOp::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

bool TPUReplicatedOutputOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "num_replicas") return true;
  if (name == "T") return true;
 return false;
}

::mlir::DictionaryAttr TPUReplicatedOutputOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("num_replicas", ctx),
odsBuilder.getI64IntegerAttr(num_replicas())},
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())}
    }, ctx);
}

void TPUReplicatedOutputOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange outputs, ::mlir::Value input) {
  odsState.addOperands(input);
  odsState.addTypes(outputs);
}

void TPUReplicatedOutputOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult TPUReplicatedOutputOp::verify() {
  if (failed(TPUReplicatedOutputOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>())))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::TensorFlowType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of tf.dtype values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>())))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::TensorFlowType>()))))) {
        return emitOpError("result #") << index << " must be tensor of tf.dtype values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void TPUReplicatedOutputOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::TPUReshardVariablesOp definitions
//===----------------------------------------------------------------------===//

TPUReshardVariablesOpAdaptor::TPUReshardVariablesOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

TPUReshardVariablesOpAdaptor::TPUReshardVariablesOpAdaptor(TPUReshardVariablesOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> TPUReshardVariablesOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  bool isVariadic[] = {true, false, false};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (odsOperands.size() - 2) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::mlir::ValueRange TPUReshardVariablesOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::ValueRange TPUReshardVariablesOpAdaptor::vars() {
  return getODSOperands(0);
}

::mlir::Value TPUReshardVariablesOpAdaptor::new_format_key() {
  return *getODSOperands(1).begin();
}

::mlir::Value TPUReshardVariablesOpAdaptor::format_state_var() {
  return *getODSOperands(2).begin();
}

::mlir::LogicalResult TPUReshardVariablesOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

::llvm::StringRef TPUReshardVariablesOp::getOperationName() {
  return "tf.TPUReshardVariables";
}

std::pair<unsigned, unsigned> TPUReshardVariablesOp::getODSOperandIndexAndLength(unsigned index) {
  bool isVariadic[] = {true, false, false};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (getOperation()->getNumOperands() - 2) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::mlir::Operation::operand_range TPUReshardVariablesOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Operation::operand_range TPUReshardVariablesOp::vars() {
  return getODSOperands(0);
}

::mlir::Value TPUReshardVariablesOp::new_format_key() {
  return *getODSOperands(1).begin();
}

::mlir::Value TPUReshardVariablesOp::format_state_var() {
  return *getODSOperands(2).begin();
}

::mlir::MutableOperandRange TPUReshardVariablesOp::varsMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange TPUReshardVariablesOp::new_format_keyMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange TPUReshardVariablesOp::format_state_varMutable() {
  auto range = getODSOperandIndexAndLength(2);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> TPUReshardVariablesOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range TPUReshardVariablesOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

size_t TPUReshardVariablesOp::N() {
  auto range = getODSOperands(0);
return std::distance(range.begin(), range.end());
}

bool TPUReshardVariablesOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "N") return true;
 return false;
}

::mlir::DictionaryAttr TPUReshardVariablesOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("N", ctx),
odsBuilder.getI64IntegerAttr(N())}
    }, ctx);
}

void TPUReshardVariablesOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange vars, ::mlir::Value new_format_key, ::mlir::Value format_state_var) {
  odsState.addOperands(vars);
  odsState.addOperands(new_format_key);
  odsState.addOperands(format_state_var);
}

void TPUReshardVariablesOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange vars, ::mlir::Value new_format_key, ::mlir::Value format_state_var) {
  odsState.addOperands(vars);
  odsState.addOperands(new_format_key);
  odsState.addOperands(format_state_var);
  assert(resultTypes.size() == 0u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void TPUReshardVariablesOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() >= 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 0u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult TPUReshardVariablesOp::verify() {
  if (failed(TPUReshardVariablesOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::ResourceType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::ResourceRefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of resource values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::StringType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::StringRefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of string values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup2 = getODSOperands(2);
    for (::mlir::Value v : valueGroup2) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::ResourceType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::ResourceRefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of resource values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
  }
  return ::mlir::success();
}

void TPUReshardVariablesOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
  for (::mlir::Value value : getODSOperands(0))
    effects.emplace_back(MemoryEffects::Read::get(), value, ::mlir::TF::ResourceEffects::Variable::get());
  for (::mlir::Value value : getODSOperands(0))
    effects.emplace_back(MemoryEffects::Write::get(), value, ::mlir::TF::ResourceEffects::Variable::get());
  for (::mlir::Value value : getODSOperands(2))
    effects.emplace_back(MemoryEffects::Read::get(), value, ::mlir::TF::ResourceEffects::Variable::get());
  for (::mlir::Value value : getODSOperands(2))
    effects.emplace_back(MemoryEffects::Write::get(), value, ::mlir::TF::ResourceEffects::Variable::get());
}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::TanOp definitions
//===----------------------------------------------------------------------===//

TanOpAdaptor::TanOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

TanOpAdaptor::TanOpAdaptor(TanOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> TanOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange TanOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value TanOpAdaptor::x() {
  return *getODSOperands(0).begin();
}

::mlir::LogicalResult TanOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

::llvm::StringRef TanOp::getOperationName() {
  return "tf.Tan";
}

std::pair<unsigned, unsigned> TanOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range TanOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value TanOp::x() {
  return *getODSOperands(0).begin();
}

::mlir::MutableOperandRange TanOp::xMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> TanOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range TanOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value TanOp::y() {
  return *getODSResults(0).begin();
}

Type TanOp::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

bool TanOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "T") return true;
 return false;
}

::mlir::DictionaryAttr TanOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())}
    }, ctx);
}

void TanOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type y, ::mlir::Value x) {
  odsState.addOperands(x);
  odsState.addTypes(y);
}

void TanOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value x) {
  odsState.addOperands(x);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void TanOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

void TanOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value x) {
  odsState.addOperands(x);
  odsState.addTypes({x.getType()});

}

void TanOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  odsState.addTypes({operands[0].getType()});

}

::mlir::LogicalResult TanOp::verify() {
  if (failed(TanOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of bfloat16 or 128-bit complex or 64-bit complex or 16-bit float or 32-bit float or 64-bit float or 16-bit integer or 32-bit integer or 64-bit integer or 8-bit integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>())))))) {
        return emitOpError("result #") << index << " must be tensor of bfloat16 or 128-bit complex or 64-bit complex or 16-bit float or 32-bit float or 64-bit float or 16-bit integer or 32-bit integer or 64-bit integer or 8-bit integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void TanOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::TanhGradOp definitions
//===----------------------------------------------------------------------===//

TanhGradOpAdaptor::TanhGradOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

TanhGradOpAdaptor::TanhGradOpAdaptor(TanhGradOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> TanhGradOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange TanhGradOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value TanhGradOpAdaptor::y() {
  return *getODSOperands(0).begin();
}

::mlir::Value TanhGradOpAdaptor::dy() {
  return *getODSOperands(1).begin();
}

::mlir::LogicalResult TanhGradOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

::llvm::StringRef TanhGradOp::getOperationName() {
  return "tf.TanhGrad";
}

std::pair<unsigned, unsigned> TanhGradOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range TanhGradOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value TanhGradOp::y() {
  return *getODSOperands(0).begin();
}

::mlir::Value TanhGradOp::dy() {
  return *getODSOperands(1).begin();
}

::mlir::MutableOperandRange TanhGradOp::yMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange TanhGradOp::dyMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> TanhGradOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range TanhGradOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value TanhGradOp::z() {
  return *getODSResults(0).begin();
}

Type TanhGradOp::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

bool TanhGradOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "T") return true;
 return false;
}

::mlir::DictionaryAttr TanhGradOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())}
    }, ctx);
}

void TanhGradOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type z, ::mlir::Value y, ::mlir::Value dy) {
  odsState.addOperands(y);
  odsState.addOperands(dy);
  odsState.addTypes(z);
}

void TanhGradOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value y, ::mlir::Value dy) {
  odsState.addOperands(y);
  odsState.addOperands(dy);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void TanhGradOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

void TanhGradOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value y, ::mlir::Value dy) {
  odsState.addOperands(y);
  odsState.addOperands(dy);
  odsState.addTypes({y.getType()});

}

void TanhGradOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  odsState.addTypes({operands[0].getType()});

}

::mlir::LogicalResult TanhGradOp::verify() {
  if (failed(TanhGradOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))))))) {
        return emitOpError("operand #") << index << " must be tensor of floating-point or complex values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))))))) {
        return emitOpError("operand #") << index << " must be tensor of floating-point or complex values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))))))) {
        return emitOpError("result #") << index << " must be tensor of floating-point or complex values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void TanhGradOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::TanhOp definitions
//===----------------------------------------------------------------------===//

TanhOpAdaptor::TanhOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

TanhOpAdaptor::TanhOpAdaptor(TanhOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> TanhOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange TanhOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value TanhOpAdaptor::x() {
  return *getODSOperands(0).begin();
}

::mlir::LogicalResult TanhOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

::llvm::StringRef TanhOp::getOperationName() {
  return "tf.Tanh";
}

std::pair<unsigned, unsigned> TanhOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range TanhOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value TanhOp::x() {
  return *getODSOperands(0).begin();
}

::mlir::MutableOperandRange TanhOp::xMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> TanhOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range TanhOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value TanhOp::y() {
  return *getODSResults(0).begin();
}

Type TanhOp::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

bool TanhOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "T") return true;
 return false;
}

::mlir::DictionaryAttr TanhOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())}
    }, ctx);
}

void TanhOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type y, ::mlir::Value x) {
  odsState.addOperands(x);
  odsState.addTypes(y);
}

void TanhOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value x) {
  odsState.addOperands(x);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void TanhOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

void TanhOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value x) {
  odsState.addOperands(x);
  odsState.addTypes({x.getType()});

}

void TanhOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  odsState.addTypes({operands[0].getType()});

}

::mlir::LogicalResult TanhOp::verify() {
  if (failed(TanhOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))))))) {
        return emitOpError("operand #") << index << " must be tensor of floating-point or complex values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))))))) {
        return emitOpError("result #") << index << " must be tensor of floating-point or complex values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void TanhOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::TensorArrayCloseV3Op definitions
//===----------------------------------------------------------------------===//

TensorArrayCloseV3OpAdaptor::TensorArrayCloseV3OpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

TensorArrayCloseV3OpAdaptor::TensorArrayCloseV3OpAdaptor(TensorArrayCloseV3Op&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> TensorArrayCloseV3OpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange TensorArrayCloseV3OpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value TensorArrayCloseV3OpAdaptor::handle() {
  return *getODSOperands(0).begin();
}

::mlir::LogicalResult TensorArrayCloseV3OpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

::llvm::StringRef TensorArrayCloseV3Op::getOperationName() {
  return "tf.TensorArrayCloseV3";
}

std::pair<unsigned, unsigned> TensorArrayCloseV3Op::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range TensorArrayCloseV3Op::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value TensorArrayCloseV3Op::handle() {
  return *getODSOperands(0).begin();
}

::mlir::MutableOperandRange TensorArrayCloseV3Op::handleMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> TensorArrayCloseV3Op::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range TensorArrayCloseV3Op::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

void TensorArrayCloseV3Op::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value handle) {
  odsState.addOperands(handle);
}

void TensorArrayCloseV3Op::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value handle) {
  odsState.addOperands(handle);
  assert(resultTypes.size() == 0u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void TensorArrayCloseV3Op::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 0u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult TensorArrayCloseV3Op::verify() {
  if (failed(TensorArrayCloseV3OpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::ResourceType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::ResourceRefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of resource values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
  }
  return ::mlir::success();
}

void TensorArrayCloseV3Op::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
  for (::mlir::Value value : getODSOperands(0))
    effects.emplace_back(MemoryEffects::Free::get(), value, ::mlir::TF::ResourceEffects::TensorArray::get());
}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::TensorArrayConcatV3Op definitions
//===----------------------------------------------------------------------===//

TensorArrayConcatV3OpAdaptor::TensorArrayConcatV3OpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

TensorArrayConcatV3OpAdaptor::TensorArrayConcatV3OpAdaptor(TensorArrayConcatV3Op&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> TensorArrayConcatV3OpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange TensorArrayConcatV3OpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value TensorArrayConcatV3OpAdaptor::handle() {
  return *getODSOperands(0).begin();
}

::mlir::Value TensorArrayConcatV3OpAdaptor::flow_in() {
  return *getODSOperands(1).begin();
}

Attribute TensorArrayConcatV3OpAdaptor::element_shape_except0() {
  assert(odsAttrs && "no attributes when constructing adapter");
  Attribute attr = odsAttrs.get("element_shape_except0").dyn_cast_or_null<Attribute>();
  if (!attr)
    attr = mlir::TF::ShapeAttr::get(::mlir::Builder(odsAttrs.getContext()).getContext(), llvm::None);
  return attr;
}

::mlir::LogicalResult TensorArrayConcatV3OpAdaptor::verify(::mlir::Location loc) {
  {
  auto tblgen_element_shape_except0 = odsAttrs.get("element_shape_except0");
  if (tblgen_element_shape_except0) {
    if (!((tblgen_element_shape_except0.isa<mlir::TF::ShapeAttr>()))) return emitError(loc, "'tf.TensorArrayConcatV3' op ""attribute 'element_shape_except0' failed to satisfy constraint: TensorFlow shape attribute");
  }
  }
  return ::mlir::success();
}

void TensorArrayConcatV3Op::getAsmResultNames(::mlir::OpAsmSetValueNameFn setNameFn) {
  auto resultGroup0 = getODSResults(0);
  if (!llvm::empty(resultGroup0))
    setNameFn(*resultGroup0.begin(), "value");
  auto resultGroup1 = getODSResults(1);
  if (!llvm::empty(resultGroup1))
    setNameFn(*resultGroup1.begin(), "lengths");
}

::llvm::StringRef TensorArrayConcatV3Op::getOperationName() {
  return "tf.TensorArrayConcatV3";
}

std::pair<unsigned, unsigned> TensorArrayConcatV3Op::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range TensorArrayConcatV3Op::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value TensorArrayConcatV3Op::handle() {
  return *getODSOperands(0).begin();
}

::mlir::Value TensorArrayConcatV3Op::flow_in() {
  return *getODSOperands(1).begin();
}

::mlir::MutableOperandRange TensorArrayConcatV3Op::handleMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange TensorArrayConcatV3Op::flow_inMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> TensorArrayConcatV3Op::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range TensorArrayConcatV3Op::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value TensorArrayConcatV3Op::value() {
  return *getODSResults(0).begin();
}

::mlir::Value TensorArrayConcatV3Op::lengths() {
  return *getODSResults(1).begin();
}

Attribute TensorArrayConcatV3Op::element_shape_except0Attr() {
  return this->getAttr("element_shape_except0").dyn_cast_or_null<Attribute>();
}

llvm::Optional<llvm::ArrayRef<int64_t>> TensorArrayConcatV3Op::element_shape_except0() {
  auto attr = element_shape_except0Attr();
    if (!attr)
      return mlir::TF::ShapeAttr::get(::mlir::Builder(this->getContext()).getContext(), llvm::None).cast<mlir::TF::ShapeAttr>().getValue();
  return attr.cast<mlir::TF::ShapeAttr>().getValue();
}

Type TensorArrayConcatV3Op::dtype() {
  return mlir::getElementTypeOrSelf(*getODSResults(0).begin());
}

bool TensorArrayConcatV3Op::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "dtype") return true;
 return false;
}

::mlir::DictionaryAttr TensorArrayConcatV3Op::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("dtype", ctx),
::mlir::TypeAttr::get(dtype())}
    }, ctx);
}

void TensorArrayConcatV3Op::element_shape_except0Attr(Attribute attr) {
  this->getOperation()->setAttr("element_shape_except0", attr);
}

void TensorArrayConcatV3Op::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type value, ::mlir::Type lengths, ::mlir::Value handle, ::mlir::Value flow_in, Attribute element_shape_except0) {
  odsState.addOperands(handle);
  odsState.addOperands(flow_in);
  odsState.addAttribute("element_shape_except0", element_shape_except0);
  odsState.addTypes(value);
  odsState.addTypes(lengths);
}

void TensorArrayConcatV3Op::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value handle, ::mlir::Value flow_in, Attribute element_shape_except0) {
  odsState.addOperands(handle);
  odsState.addOperands(flow_in);
  odsState.addAttribute("element_shape_except0", element_shape_except0);
  assert(resultTypes.size() == 2u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void TensorArrayConcatV3Op::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type value, ::mlir::Type lengths, ::mlir::Value handle, ::mlir::Value flow_in, llvm::Optional<llvm::ArrayRef<int64_t>> element_shape_except0) {
  odsState.addOperands(handle);
  odsState.addOperands(flow_in);
  odsState.addAttribute("element_shape_except0", mlir::TF::ShapeAttr::get(odsBuilder.getContext(), element_shape_except0));
  odsState.addTypes(value);
  odsState.addTypes(lengths);
}

void TensorArrayConcatV3Op::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value handle, ::mlir::Value flow_in, llvm::Optional<llvm::ArrayRef<int64_t>> element_shape_except0) {
  odsState.addOperands(handle);
  odsState.addOperands(flow_in);
  odsState.addAttribute("element_shape_except0", mlir::TF::ShapeAttr::get(odsBuilder.getContext(), element_shape_except0));
  assert(resultTypes.size() == 2u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void TensorArrayConcatV3Op::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 2u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult TensorArrayConcatV3Op::verify() {
  if (failed(TensorArrayConcatV3OpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::ResourceType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::ResourceRefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of resource values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of 32-bit float values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>())))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::TensorFlowType>()))))) {
        return emitOpError("result #") << index << " must be tensor of tf.dtype values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSResults(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))))) {
        return emitOpError("result #") << index << " must be tensor of 64-bit integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void TensorArrayConcatV3Op::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
  for (::mlir::Value value : getODSOperands(0))
    effects.emplace_back(MemoryEffects::Read::get(), value, ::mlir::TF::ResourceEffects::TensorArray::get());
}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::TensorArrayGatherV3Op definitions
//===----------------------------------------------------------------------===//

TensorArrayGatherV3OpAdaptor::TensorArrayGatherV3OpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

TensorArrayGatherV3OpAdaptor::TensorArrayGatherV3OpAdaptor(TensorArrayGatherV3Op&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> TensorArrayGatherV3OpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange TensorArrayGatherV3OpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value TensorArrayGatherV3OpAdaptor::handle() {
  return *getODSOperands(0).begin();
}

::mlir::Value TensorArrayGatherV3OpAdaptor::indices() {
  return *getODSOperands(1).begin();
}

::mlir::Value TensorArrayGatherV3OpAdaptor::flow_in() {
  return *getODSOperands(2).begin();
}

Attribute TensorArrayGatherV3OpAdaptor::element_shape() {
  assert(odsAttrs && "no attributes when constructing adapter");
  Attribute attr = odsAttrs.get("element_shape").dyn_cast_or_null<Attribute>();
  if (!attr)
    attr = mlir::TF::ShapeAttr::get(::mlir::Builder(odsAttrs.getContext()).getContext(), llvm::None);
  return attr;
}

::mlir::LogicalResult TensorArrayGatherV3OpAdaptor::verify(::mlir::Location loc) {
  {
  auto tblgen_element_shape = odsAttrs.get("element_shape");
  if (tblgen_element_shape) {
    if (!((tblgen_element_shape.isa<mlir::TF::ShapeAttr>()))) return emitError(loc, "'tf.TensorArrayGatherV3' op ""attribute 'element_shape' failed to satisfy constraint: TensorFlow shape attribute");
  }
  }
  return ::mlir::success();
}

::llvm::StringRef TensorArrayGatherV3Op::getOperationName() {
  return "tf.TensorArrayGatherV3";
}

std::pair<unsigned, unsigned> TensorArrayGatherV3Op::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range TensorArrayGatherV3Op::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value TensorArrayGatherV3Op::handle() {
  return *getODSOperands(0).begin();
}

::mlir::Value TensorArrayGatherV3Op::indices() {
  return *getODSOperands(1).begin();
}

::mlir::Value TensorArrayGatherV3Op::flow_in() {
  return *getODSOperands(2).begin();
}

::mlir::MutableOperandRange TensorArrayGatherV3Op::handleMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange TensorArrayGatherV3Op::indicesMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange TensorArrayGatherV3Op::flow_inMutable() {
  auto range = getODSOperandIndexAndLength(2);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> TensorArrayGatherV3Op::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range TensorArrayGatherV3Op::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value TensorArrayGatherV3Op::value() {
  return *getODSResults(0).begin();
}

Attribute TensorArrayGatherV3Op::element_shapeAttr() {
  return this->getAttr("element_shape").dyn_cast_or_null<Attribute>();
}

llvm::Optional<llvm::ArrayRef<int64_t>> TensorArrayGatherV3Op::element_shape() {
  auto attr = element_shapeAttr();
    if (!attr)
      return mlir::TF::ShapeAttr::get(::mlir::Builder(this->getContext()).getContext(), llvm::None).cast<mlir::TF::ShapeAttr>().getValue();
  return attr.cast<mlir::TF::ShapeAttr>().getValue();
}

Type TensorArrayGatherV3Op::dtype() {
  return mlir::getElementTypeOrSelf(*getODSResults(0).begin());
}

bool TensorArrayGatherV3Op::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "dtype") return true;
 return false;
}

::mlir::DictionaryAttr TensorArrayGatherV3Op::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("dtype", ctx),
::mlir::TypeAttr::get(dtype())}
    }, ctx);
}

void TensorArrayGatherV3Op::element_shapeAttr(Attribute attr) {
  this->getOperation()->setAttr("element_shape", attr);
}

void TensorArrayGatherV3Op::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type value, ::mlir::Value handle, ::mlir::Value indices, ::mlir::Value flow_in, Attribute element_shape) {
  odsState.addOperands(handle);
  odsState.addOperands(indices);
  odsState.addOperands(flow_in);
  odsState.addAttribute("element_shape", element_shape);
  odsState.addTypes(value);
}

void TensorArrayGatherV3Op::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value handle, ::mlir::Value indices, ::mlir::Value flow_in, Attribute element_shape) {
  odsState.addOperands(handle);
  odsState.addOperands(indices);
  odsState.addOperands(flow_in);
  odsState.addAttribute("element_shape", element_shape);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void TensorArrayGatherV3Op::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type value, ::mlir::Value handle, ::mlir::Value indices, ::mlir::Value flow_in, llvm::Optional<llvm::ArrayRef<int64_t>> element_shape) {
  odsState.addOperands(handle);
  odsState.addOperands(indices);
  odsState.addOperands(flow_in);
  odsState.addAttribute("element_shape", mlir::TF::ShapeAttr::get(odsBuilder.getContext(), element_shape));
  odsState.addTypes(value);
}

void TensorArrayGatherV3Op::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value handle, ::mlir::Value indices, ::mlir::Value flow_in, llvm::Optional<llvm::ArrayRef<int64_t>> element_shape) {
  odsState.addOperands(handle);
  odsState.addOperands(indices);
  odsState.addOperands(flow_in);
  odsState.addAttribute("element_shape", mlir::TF::ShapeAttr::get(odsBuilder.getContext(), element_shape));
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void TensorArrayGatherV3Op::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 3u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult TensorArrayGatherV3Op::verify() {
  if (failed(TensorArrayGatherV3OpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::ResourceType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::ResourceRefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of resource values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of 32-bit integer values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup2 = getODSOperands(2);
    for (::mlir::Value v : valueGroup2) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of 32-bit float values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>())))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::TensorFlowType>()))))) {
        return emitOpError("result #") << index << " must be tensor of tf.dtype values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void TensorArrayGatherV3Op::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
  for (::mlir::Value value : getODSOperands(0))
    effects.emplace_back(MemoryEffects::Read::get(), value, ::mlir::TF::ResourceEffects::TensorArray::get());
}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::TensorArrayGradV3Op definitions
//===----------------------------------------------------------------------===//

TensorArrayGradV3OpAdaptor::TensorArrayGradV3OpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

TensorArrayGradV3OpAdaptor::TensorArrayGradV3OpAdaptor(TensorArrayGradV3Op&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> TensorArrayGradV3OpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange TensorArrayGradV3OpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value TensorArrayGradV3OpAdaptor::handle() {
  return *getODSOperands(0).begin();
}

::mlir::Value TensorArrayGradV3OpAdaptor::flow_in() {
  return *getODSOperands(1).begin();
}

::mlir::StringAttr TensorArrayGradV3OpAdaptor::source() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::StringAttr attr = odsAttrs.get("source").cast<::mlir::StringAttr>();
  return attr;
}

::mlir::LogicalResult TensorArrayGradV3OpAdaptor::verify(::mlir::Location loc) {
  {
  auto tblgen_source = odsAttrs.get("source");
  if (!tblgen_source) return emitError(loc, "'tf.TensorArrayGradV3' op ""requires attribute 'source'");
    if (!((tblgen_source.isa<::mlir::StringAttr>()))) return emitError(loc, "'tf.TensorArrayGradV3' op ""attribute 'source' failed to satisfy constraint: string attribute");
  }
  return ::mlir::success();
}

void TensorArrayGradV3Op::getAsmResultNames(::mlir::OpAsmSetValueNameFn setNameFn) {
  auto resultGroup0 = getODSResults(0);
  if (!llvm::empty(resultGroup0))
    setNameFn(*resultGroup0.begin(), "grad_handle");
  auto resultGroup1 = getODSResults(1);
  if (!llvm::empty(resultGroup1))
    setNameFn(*resultGroup1.begin(), "flow_out");
}

::llvm::StringRef TensorArrayGradV3Op::getOperationName() {
  return "tf.TensorArrayGradV3";
}

std::pair<unsigned, unsigned> TensorArrayGradV3Op::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range TensorArrayGradV3Op::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value TensorArrayGradV3Op::handle() {
  return *getODSOperands(0).begin();
}

::mlir::Value TensorArrayGradV3Op::flow_in() {
  return *getODSOperands(1).begin();
}

::mlir::MutableOperandRange TensorArrayGradV3Op::handleMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange TensorArrayGradV3Op::flow_inMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> TensorArrayGradV3Op::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range TensorArrayGradV3Op::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value TensorArrayGradV3Op::grad_handle() {
  return *getODSResults(0).begin();
}

::mlir::Value TensorArrayGradV3Op::flow_out() {
  return *getODSResults(1).begin();
}

::mlir::StringAttr TensorArrayGradV3Op::sourceAttr() {
  return this->getAttr("source").cast<::mlir::StringAttr>();
}

::llvm::StringRef TensorArrayGradV3Op::source() {
  auto attr = sourceAttr();
  return attr.getValue();
}

void TensorArrayGradV3Op::sourceAttr(::mlir::StringAttr attr) {
  this->getOperation()->setAttr("source", attr);
}

void TensorArrayGradV3Op::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type grad_handle, ::mlir::Type flow_out, ::mlir::Value handle, ::mlir::Value flow_in, ::mlir::StringAttr source) {
  odsState.addOperands(handle);
  odsState.addOperands(flow_in);
  odsState.addAttribute("source", source);
  odsState.addTypes(grad_handle);
  odsState.addTypes(flow_out);
}

void TensorArrayGradV3Op::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value handle, ::mlir::Value flow_in, ::mlir::StringAttr source) {
  odsState.addOperands(handle);
  odsState.addOperands(flow_in);
  odsState.addAttribute("source", source);
  assert(resultTypes.size() == 2u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void TensorArrayGradV3Op::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type grad_handle, ::mlir::Type flow_out, ::mlir::Value handle, ::mlir::Value flow_in, ::llvm::StringRef source) {
  odsState.addOperands(handle);
  odsState.addOperands(flow_in);
  odsState.addAttribute("source", odsBuilder.getStringAttr(source));
  odsState.addTypes(grad_handle);
  odsState.addTypes(flow_out);
}

void TensorArrayGradV3Op::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value handle, ::mlir::Value flow_in, ::llvm::StringRef source) {
  odsState.addOperands(handle);
  odsState.addOperands(flow_in);
  odsState.addAttribute("source", odsBuilder.getStringAttr(source));
  assert(resultTypes.size() == 2u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void TensorArrayGradV3Op::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 2u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult TensorArrayGradV3Op::verify() {
  if (failed(TensorArrayGradV3OpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::ResourceType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::ResourceRefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of resource values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of 32-bit float values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::ResourceType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::ResourceRefType>()))))) {
        return emitOpError("result #") << index << " must be tensor of resource values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSResults(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))))) {
        return emitOpError("result #") << index << " must be tensor of 32-bit float values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void TensorArrayGradV3Op::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
  for (::mlir::Value value : getODSOperands(0))
    effects.emplace_back(MemoryEffects::Read::get(), value, ::mlir::TF::ResourceEffects::TensorArray::get());
  for (::mlir::Value value : getODSOperands(0))
    effects.emplace_back(MemoryEffects::Write::get(), value, ::mlir::TF::ResourceEffects::TensorArray::get());
  for (::mlir::Value value : getODSResults(0))
    effects.emplace_back(MemoryEffects::Allocate::get(), value, ::mlir::TF::ResourceEffects::TensorArray::get());
}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::TensorArrayReadV3Op definitions
//===----------------------------------------------------------------------===//

TensorArrayReadV3OpAdaptor::TensorArrayReadV3OpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

TensorArrayReadV3OpAdaptor::TensorArrayReadV3OpAdaptor(TensorArrayReadV3Op&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> TensorArrayReadV3OpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange TensorArrayReadV3OpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value TensorArrayReadV3OpAdaptor::handle() {
  return *getODSOperands(0).begin();
}

::mlir::Value TensorArrayReadV3OpAdaptor::index() {
  return *getODSOperands(1).begin();
}

::mlir::Value TensorArrayReadV3OpAdaptor::flow_in() {
  return *getODSOperands(2).begin();
}

::mlir::LogicalResult TensorArrayReadV3OpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

::llvm::StringRef TensorArrayReadV3Op::getOperationName() {
  return "tf.TensorArrayReadV3";
}

std::pair<unsigned, unsigned> TensorArrayReadV3Op::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range TensorArrayReadV3Op::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value TensorArrayReadV3Op::handle() {
  return *getODSOperands(0).begin();
}

::mlir::Value TensorArrayReadV3Op::index() {
  return *getODSOperands(1).begin();
}

::mlir::Value TensorArrayReadV3Op::flow_in() {
  return *getODSOperands(2).begin();
}

::mlir::MutableOperandRange TensorArrayReadV3Op::handleMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange TensorArrayReadV3Op::indexMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange TensorArrayReadV3Op::flow_inMutable() {
  auto range = getODSOperandIndexAndLength(2);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> TensorArrayReadV3Op::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range TensorArrayReadV3Op::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value TensorArrayReadV3Op::value() {
  return *getODSResults(0).begin();
}

Type TensorArrayReadV3Op::dtype() {
  return mlir::getElementTypeOrSelf(*getODSResults(0).begin());
}

bool TensorArrayReadV3Op::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "dtype") return true;
 return false;
}

::mlir::DictionaryAttr TensorArrayReadV3Op::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("dtype", ctx),
::mlir::TypeAttr::get(dtype())}
    }, ctx);
}

void TensorArrayReadV3Op::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type value, ::mlir::Value handle, ::mlir::Value index, ::mlir::Value flow_in) {
  odsState.addOperands(handle);
  odsState.addOperands(index);
  odsState.addOperands(flow_in);
  odsState.addTypes(value);
}

void TensorArrayReadV3Op::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value handle, ::mlir::Value index, ::mlir::Value flow_in) {
  odsState.addOperands(handle);
  odsState.addOperands(index);
  odsState.addOperands(flow_in);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void TensorArrayReadV3Op::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 3u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult TensorArrayReadV3Op::verify() {
  if (failed(TensorArrayReadV3OpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::ResourceType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::ResourceRefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of resource values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of 32-bit integer values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup2 = getODSOperands(2);
    for (::mlir::Value v : valueGroup2) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of 32-bit float values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>())))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::TensorFlowType>()))))) {
        return emitOpError("result #") << index << " must be tensor of tf.dtype values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void TensorArrayReadV3Op::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
  for (::mlir::Value value : getODSOperands(0))
    effects.emplace_back(MemoryEffects::Read::get(), value, ::mlir::TF::ResourceEffects::TensorArray::get());
}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::TensorArrayScatterV3Op definitions
//===----------------------------------------------------------------------===//

TensorArrayScatterV3OpAdaptor::TensorArrayScatterV3OpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

TensorArrayScatterV3OpAdaptor::TensorArrayScatterV3OpAdaptor(TensorArrayScatterV3Op&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> TensorArrayScatterV3OpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange TensorArrayScatterV3OpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value TensorArrayScatterV3OpAdaptor::handle() {
  return *getODSOperands(0).begin();
}

::mlir::Value TensorArrayScatterV3OpAdaptor::indices() {
  return *getODSOperands(1).begin();
}

::mlir::Value TensorArrayScatterV3OpAdaptor::value() {
  return *getODSOperands(2).begin();
}

::mlir::Value TensorArrayScatterV3OpAdaptor::flow_in() {
  return *getODSOperands(3).begin();
}

::mlir::LogicalResult TensorArrayScatterV3OpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

::llvm::StringRef TensorArrayScatterV3Op::getOperationName() {
  return "tf.TensorArrayScatterV3";
}

std::pair<unsigned, unsigned> TensorArrayScatterV3Op::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range TensorArrayScatterV3Op::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value TensorArrayScatterV3Op::handle() {
  return *getODSOperands(0).begin();
}

::mlir::Value TensorArrayScatterV3Op::indices() {
  return *getODSOperands(1).begin();
}

::mlir::Value TensorArrayScatterV3Op::value() {
  return *getODSOperands(2).begin();
}

::mlir::Value TensorArrayScatterV3Op::flow_in() {
  return *getODSOperands(3).begin();
}

::mlir::MutableOperandRange TensorArrayScatterV3Op::handleMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange TensorArrayScatterV3Op::indicesMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange TensorArrayScatterV3Op::valueMutable() {
  auto range = getODSOperandIndexAndLength(2);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange TensorArrayScatterV3Op::flow_inMutable() {
  auto range = getODSOperandIndexAndLength(3);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> TensorArrayScatterV3Op::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range TensorArrayScatterV3Op::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value TensorArrayScatterV3Op::flow_out() {
  return *getODSResults(0).begin();
}

Type TensorArrayScatterV3Op::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(2).begin());
}

bool TensorArrayScatterV3Op::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "T") return true;
 return false;
}

::mlir::DictionaryAttr TensorArrayScatterV3Op::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())}
    }, ctx);
}

void TensorArrayScatterV3Op::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type flow_out, ::mlir::Value handle, ::mlir::Value indices, ::mlir::Value value, ::mlir::Value flow_in) {
  odsState.addOperands(handle);
  odsState.addOperands(indices);
  odsState.addOperands(value);
  odsState.addOperands(flow_in);
  odsState.addTypes(flow_out);
}

void TensorArrayScatterV3Op::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value handle, ::mlir::Value indices, ::mlir::Value value, ::mlir::Value flow_in) {
  odsState.addOperands(handle);
  odsState.addOperands(indices);
  odsState.addOperands(value);
  odsState.addOperands(flow_in);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void TensorArrayScatterV3Op::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 4u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult TensorArrayScatterV3Op::verify() {
  if (failed(TensorArrayScatterV3OpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::ResourceType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::ResourceRefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of resource values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of 32-bit integer values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup2 = getODSOperands(2);
    for (::mlir::Value v : valueGroup2) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>())))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::TensorFlowType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of tf.dtype values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup3 = getODSOperands(3);
    for (::mlir::Value v : valueGroup3) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of 32-bit float values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))))) {
        return emitOpError("result #") << index << " must be tensor of 32-bit float values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void TensorArrayScatterV3Op::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
  for (::mlir::Value value : getODSOperands(0))
    effects.emplace_back(MemoryEffects::Read::get(), value, ::mlir::TF::ResourceEffects::TensorArray::get());
  for (::mlir::Value value : getODSOperands(0))
    effects.emplace_back(MemoryEffects::Write::get(), value, ::mlir::TF::ResourceEffects::TensorArray::get());
}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::TensorArraySizeV3Op definitions
//===----------------------------------------------------------------------===//

TensorArraySizeV3OpAdaptor::TensorArraySizeV3OpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

TensorArraySizeV3OpAdaptor::TensorArraySizeV3OpAdaptor(TensorArraySizeV3Op&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> TensorArraySizeV3OpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange TensorArraySizeV3OpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value TensorArraySizeV3OpAdaptor::handle() {
  return *getODSOperands(0).begin();
}

::mlir::Value TensorArraySizeV3OpAdaptor::flow_in() {
  return *getODSOperands(1).begin();
}

::mlir::LogicalResult TensorArraySizeV3OpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

::llvm::StringRef TensorArraySizeV3Op::getOperationName() {
  return "tf.TensorArraySizeV3";
}

std::pair<unsigned, unsigned> TensorArraySizeV3Op::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range TensorArraySizeV3Op::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value TensorArraySizeV3Op::handle() {
  return *getODSOperands(0).begin();
}

::mlir::Value TensorArraySizeV3Op::flow_in() {
  return *getODSOperands(1).begin();
}

::mlir::MutableOperandRange TensorArraySizeV3Op::handleMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange TensorArraySizeV3Op::flow_inMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> TensorArraySizeV3Op::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range TensorArraySizeV3Op::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value TensorArraySizeV3Op::size() {
  return *getODSResults(0).begin();
}

void TensorArraySizeV3Op::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type size, ::mlir::Value handle, ::mlir::Value flow_in) {
  odsState.addOperands(handle);
  odsState.addOperands(flow_in);
  odsState.addTypes(size);
}

void TensorArraySizeV3Op::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value handle, ::mlir::Value flow_in) {
  odsState.addOperands(handle);
  odsState.addOperands(flow_in);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void TensorArraySizeV3Op::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult TensorArraySizeV3Op::verify() {
  if (failed(TensorArraySizeV3OpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::ResourceType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::ResourceRefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of resource values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of 32-bit float values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))))) {
        return emitOpError("result #") << index << " must be tensor of 32-bit integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void TensorArraySizeV3Op::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
  for (::mlir::Value value : getODSOperands(0))
    effects.emplace_back(MemoryEffects::Read::get(), value, ::mlir::TF::ResourceEffects::TensorArray::get());
}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::TensorArraySplitV3Op definitions
//===----------------------------------------------------------------------===//

TensorArraySplitV3OpAdaptor::TensorArraySplitV3OpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

TensorArraySplitV3OpAdaptor::TensorArraySplitV3OpAdaptor(TensorArraySplitV3Op&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> TensorArraySplitV3OpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange TensorArraySplitV3OpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value TensorArraySplitV3OpAdaptor::handle() {
  return *getODSOperands(0).begin();
}

::mlir::Value TensorArraySplitV3OpAdaptor::value() {
  return *getODSOperands(1).begin();
}

::mlir::Value TensorArraySplitV3OpAdaptor::lengths() {
  return *getODSOperands(2).begin();
}

::mlir::Value TensorArraySplitV3OpAdaptor::flow_in() {
  return *getODSOperands(3).begin();
}

::mlir::LogicalResult TensorArraySplitV3OpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

::llvm::StringRef TensorArraySplitV3Op::getOperationName() {
  return "tf.TensorArraySplitV3";
}

std::pair<unsigned, unsigned> TensorArraySplitV3Op::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range TensorArraySplitV3Op::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value TensorArraySplitV3Op::handle() {
  return *getODSOperands(0).begin();
}

::mlir::Value TensorArraySplitV3Op::value() {
  return *getODSOperands(1).begin();
}

::mlir::Value TensorArraySplitV3Op::lengths() {
  return *getODSOperands(2).begin();
}

::mlir::Value TensorArraySplitV3Op::flow_in() {
  return *getODSOperands(3).begin();
}

::mlir::MutableOperandRange TensorArraySplitV3Op::handleMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange TensorArraySplitV3Op::valueMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange TensorArraySplitV3Op::lengthsMutable() {
  auto range = getODSOperandIndexAndLength(2);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange TensorArraySplitV3Op::flow_inMutable() {
  auto range = getODSOperandIndexAndLength(3);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> TensorArraySplitV3Op::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range TensorArraySplitV3Op::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value TensorArraySplitV3Op::flow_out() {
  return *getODSResults(0).begin();
}

Type TensorArraySplitV3Op::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(1).begin());
}

bool TensorArraySplitV3Op::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "T") return true;
 return false;
}

::mlir::DictionaryAttr TensorArraySplitV3Op::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())}
    }, ctx);
}

void TensorArraySplitV3Op::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type flow_out, ::mlir::Value handle, ::mlir::Value value, ::mlir::Value lengths, ::mlir::Value flow_in) {
  odsState.addOperands(handle);
  odsState.addOperands(value);
  odsState.addOperands(lengths);
  odsState.addOperands(flow_in);
  odsState.addTypes(flow_out);
}

void TensorArraySplitV3Op::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value handle, ::mlir::Value value, ::mlir::Value lengths, ::mlir::Value flow_in) {
  odsState.addOperands(handle);
  odsState.addOperands(value);
  odsState.addOperands(lengths);
  odsState.addOperands(flow_in);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void TensorArraySplitV3Op::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 4u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult TensorArraySplitV3Op::verify() {
  if (failed(TensorArraySplitV3OpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::ResourceType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::ResourceRefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of resource values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>())))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::TensorFlowType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of tf.dtype values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup2 = getODSOperands(2);
    for (::mlir::Value v : valueGroup2) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of 64-bit integer values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup3 = getODSOperands(3);
    for (::mlir::Value v : valueGroup3) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of 32-bit float values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))))) {
        return emitOpError("result #") << index << " must be tensor of 32-bit float values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void TensorArraySplitV3Op::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
  for (::mlir::Value value : getODSOperands(0))
    effects.emplace_back(MemoryEffects::Read::get(), value, ::mlir::TF::ResourceEffects::TensorArray::get());
  for (::mlir::Value value : getODSOperands(0))
    effects.emplace_back(MemoryEffects::Write::get(), value, ::mlir::TF::ResourceEffects::TensorArray::get());
}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::TensorArrayV3Op definitions
//===----------------------------------------------------------------------===//

TensorArrayV3OpAdaptor::TensorArrayV3OpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

TensorArrayV3OpAdaptor::TensorArrayV3OpAdaptor(TensorArrayV3Op&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> TensorArrayV3OpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange TensorArrayV3OpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value TensorArrayV3OpAdaptor::size() {
  return *getODSOperands(0).begin();
}

::mlir::TypeAttr TensorArrayV3OpAdaptor::dtype() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::TypeAttr attr = odsAttrs.get("dtype").cast<::mlir::TypeAttr>();
  return attr;
}

Attribute TensorArrayV3OpAdaptor::element_shape() {
  assert(odsAttrs && "no attributes when constructing adapter");
  Attribute attr = odsAttrs.get("element_shape").dyn_cast_or_null<Attribute>();
  if (!attr)
    attr = mlir::TF::ShapeAttr::get(::mlir::Builder(odsAttrs.getContext()).getContext(), llvm::None);
  return attr;
}

::mlir::BoolAttr TensorArrayV3OpAdaptor::dynamic_size() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::BoolAttr attr = odsAttrs.get("dynamic_size").dyn_cast_or_null<::mlir::BoolAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getBoolAttr(false);
  return attr;
}

::mlir::BoolAttr TensorArrayV3OpAdaptor::clear_after_read() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::BoolAttr attr = odsAttrs.get("clear_after_read").dyn_cast_or_null<::mlir::BoolAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getBoolAttr(true);
  return attr;
}

::mlir::BoolAttr TensorArrayV3OpAdaptor::identical_element_shapes() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::BoolAttr attr = odsAttrs.get("identical_element_shapes").dyn_cast_or_null<::mlir::BoolAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getBoolAttr(false);
  return attr;
}

::mlir::StringAttr TensorArrayV3OpAdaptor::tensor_array_name() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::StringAttr attr = odsAttrs.get("tensor_array_name").cast<::mlir::StringAttr>();
  return attr;
}

::mlir::LogicalResult TensorArrayV3OpAdaptor::verify(::mlir::Location loc) {
  {
  auto tblgen_dtype = odsAttrs.get("dtype");
  if (!tblgen_dtype) return emitError(loc, "'tf.TensorArrayV3' op ""requires attribute 'dtype'");
    if (!(((tblgen_dtype.isa<::mlir::TypeAttr>())) && ((tblgen_dtype.cast<::mlir::TypeAttr>().getValue().isa<::mlir::Type>())))) return emitError(loc, "'tf.TensorArrayV3' op ""attribute 'dtype' failed to satisfy constraint: any type attribute");
  }
  {
  auto tblgen_element_shape = odsAttrs.get("element_shape");
  if (tblgen_element_shape) {
    if (!((tblgen_element_shape.isa<mlir::TF::ShapeAttr>()))) return emitError(loc, "'tf.TensorArrayV3' op ""attribute 'element_shape' failed to satisfy constraint: TensorFlow shape attribute");
  }
  }
  {
  auto tblgen_dynamic_size = odsAttrs.get("dynamic_size");
  if (tblgen_dynamic_size) {
    if (!((tblgen_dynamic_size.isa<::mlir::BoolAttr>()))) return emitError(loc, "'tf.TensorArrayV3' op ""attribute 'dynamic_size' failed to satisfy constraint: bool attribute");
  }
  }
  {
  auto tblgen_clear_after_read = odsAttrs.get("clear_after_read");
  if (tblgen_clear_after_read) {
    if (!((tblgen_clear_after_read.isa<::mlir::BoolAttr>()))) return emitError(loc, "'tf.TensorArrayV3' op ""attribute 'clear_after_read' failed to satisfy constraint: bool attribute");
  }
  }
  {
  auto tblgen_identical_element_shapes = odsAttrs.get("identical_element_shapes");
  if (tblgen_identical_element_shapes) {
    if (!((tblgen_identical_element_shapes.isa<::mlir::BoolAttr>()))) return emitError(loc, "'tf.TensorArrayV3' op ""attribute 'identical_element_shapes' failed to satisfy constraint: bool attribute");
  }
  }
  {
  auto tblgen_tensor_array_name = odsAttrs.get("tensor_array_name");
  if (!tblgen_tensor_array_name) return emitError(loc, "'tf.TensorArrayV3' op ""requires attribute 'tensor_array_name'");
    if (!((tblgen_tensor_array_name.isa<::mlir::StringAttr>()))) return emitError(loc, "'tf.TensorArrayV3' op ""attribute 'tensor_array_name' failed to satisfy constraint: string attribute");
  }
  return ::mlir::success();
}

void TensorArrayV3Op::getAsmResultNames(::mlir::OpAsmSetValueNameFn setNameFn) {
  auto resultGroup0 = getODSResults(0);
  if (!llvm::empty(resultGroup0))
    setNameFn(*resultGroup0.begin(), "handle");
  auto resultGroup1 = getODSResults(1);
  if (!llvm::empty(resultGroup1))
    setNameFn(*resultGroup1.begin(), "flow");
}

::llvm::StringRef TensorArrayV3Op::getOperationName() {
  return "tf.TensorArrayV3";
}

std::pair<unsigned, unsigned> TensorArrayV3Op::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range TensorArrayV3Op::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value TensorArrayV3Op::size() {
  return *getODSOperands(0).begin();
}

::mlir::MutableOperandRange TensorArrayV3Op::sizeMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> TensorArrayV3Op::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range TensorArrayV3Op::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value TensorArrayV3Op::handle() {
  return *getODSResults(0).begin();
}

::mlir::Value TensorArrayV3Op::flow() {
  return *getODSResults(1).begin();
}

::mlir::TypeAttr TensorArrayV3Op::dtypeAttr() {
  return this->getAttr("dtype").cast<::mlir::TypeAttr>();
}

::mlir::Type TensorArrayV3Op::dtype() {
  auto attr = dtypeAttr();
  return attr.getValue().cast<::mlir::Type>();
}

Attribute TensorArrayV3Op::element_shapeAttr() {
  return this->getAttr("element_shape").dyn_cast_or_null<Attribute>();
}

llvm::Optional<llvm::ArrayRef<int64_t>> TensorArrayV3Op::element_shape() {
  auto attr = element_shapeAttr();
    if (!attr)
      return mlir::TF::ShapeAttr::get(::mlir::Builder(this->getContext()).getContext(), llvm::None).cast<mlir::TF::ShapeAttr>().getValue();
  return attr.cast<mlir::TF::ShapeAttr>().getValue();
}

::mlir::BoolAttr TensorArrayV3Op::dynamic_sizeAttr() {
  return this->getAttr("dynamic_size").dyn_cast_or_null<::mlir::BoolAttr>();
}

bool TensorArrayV3Op::dynamic_size() {
  auto attr = dynamic_sizeAttr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getBoolAttr(false).getValue();
  return attr.getValue();
}

::mlir::BoolAttr TensorArrayV3Op::clear_after_readAttr() {
  return this->getAttr("clear_after_read").dyn_cast_or_null<::mlir::BoolAttr>();
}

bool TensorArrayV3Op::clear_after_read() {
  auto attr = clear_after_readAttr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getBoolAttr(true).getValue();
  return attr.getValue();
}

::mlir::BoolAttr TensorArrayV3Op::identical_element_shapesAttr() {
  return this->getAttr("identical_element_shapes").dyn_cast_or_null<::mlir::BoolAttr>();
}

bool TensorArrayV3Op::identical_element_shapes() {
  auto attr = identical_element_shapesAttr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getBoolAttr(false).getValue();
  return attr.getValue();
}

::mlir::StringAttr TensorArrayV3Op::tensor_array_nameAttr() {
  return this->getAttr("tensor_array_name").cast<::mlir::StringAttr>();
}

::llvm::StringRef TensorArrayV3Op::tensor_array_name() {
  auto attr = tensor_array_nameAttr();
  return attr.getValue();
}

void TensorArrayV3Op::dtypeAttr(::mlir::TypeAttr attr) {
  this->getOperation()->setAttr("dtype", attr);
}

void TensorArrayV3Op::element_shapeAttr(Attribute attr) {
  this->getOperation()->setAttr("element_shape", attr);
}

void TensorArrayV3Op::dynamic_sizeAttr(::mlir::BoolAttr attr) {
  this->getOperation()->setAttr("dynamic_size", attr);
}

void TensorArrayV3Op::clear_after_readAttr(::mlir::BoolAttr attr) {
  this->getOperation()->setAttr("clear_after_read", attr);
}

void TensorArrayV3Op::identical_element_shapesAttr(::mlir::BoolAttr attr) {
  this->getOperation()->setAttr("identical_element_shapes", attr);
}

void TensorArrayV3Op::tensor_array_nameAttr(::mlir::StringAttr attr) {
  this->getOperation()->setAttr("tensor_array_name", attr);
}

void TensorArrayV3Op::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type handle, ::mlir::Type flow, ::mlir::Value size, ::mlir::TypeAttr dtype, Attribute element_shape, ::mlir::BoolAttr dynamic_size, ::mlir::BoolAttr clear_after_read, ::mlir::BoolAttr identical_element_shapes, ::mlir::StringAttr tensor_array_name) {
  odsState.addOperands(size);
  odsState.addAttribute("dtype", dtype);
  odsState.addAttribute("element_shape", element_shape);
  odsState.addAttribute("dynamic_size", dynamic_size);
  odsState.addAttribute("clear_after_read", clear_after_read);
  odsState.addAttribute("identical_element_shapes", identical_element_shapes);
  odsState.addAttribute("tensor_array_name", tensor_array_name);
  odsState.addTypes(handle);
  odsState.addTypes(flow);
}

void TensorArrayV3Op::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value size, ::mlir::TypeAttr dtype, Attribute element_shape, ::mlir::BoolAttr dynamic_size, ::mlir::BoolAttr clear_after_read, ::mlir::BoolAttr identical_element_shapes, ::mlir::StringAttr tensor_array_name) {
  odsState.addOperands(size);
  odsState.addAttribute("dtype", dtype);
  odsState.addAttribute("element_shape", element_shape);
  odsState.addAttribute("dynamic_size", dynamic_size);
  odsState.addAttribute("clear_after_read", clear_after_read);
  odsState.addAttribute("identical_element_shapes", identical_element_shapes);
  odsState.addAttribute("tensor_array_name", tensor_array_name);
  assert(resultTypes.size() == 2u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void TensorArrayV3Op::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type handle, ::mlir::Type flow, ::mlir::Value size, ::mlir::TypeAttr dtype, llvm::Optional<llvm::ArrayRef<int64_t>> element_shape, bool dynamic_size, bool clear_after_read, bool identical_element_shapes, ::llvm::StringRef tensor_array_name) {
  odsState.addOperands(size);
  odsState.addAttribute("dtype", dtype);
  odsState.addAttribute("element_shape", mlir::TF::ShapeAttr::get(odsBuilder.getContext(), element_shape));
  odsState.addAttribute("dynamic_size", odsBuilder.getBoolAttr(dynamic_size));
  odsState.addAttribute("clear_after_read", odsBuilder.getBoolAttr(clear_after_read));
  odsState.addAttribute("identical_element_shapes", odsBuilder.getBoolAttr(identical_element_shapes));
  odsState.addAttribute("tensor_array_name", odsBuilder.getStringAttr(tensor_array_name));
  odsState.addTypes(handle);
  odsState.addTypes(flow);
}

void TensorArrayV3Op::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value size, ::mlir::TypeAttr dtype, llvm::Optional<llvm::ArrayRef<int64_t>> element_shape, bool dynamic_size, bool clear_after_read, bool identical_element_shapes, ::llvm::StringRef tensor_array_name) {
  odsState.addOperands(size);
  odsState.addAttribute("dtype", dtype);
  odsState.addAttribute("element_shape", mlir::TF::ShapeAttr::get(odsBuilder.getContext(), element_shape));
  odsState.addAttribute("dynamic_size", odsBuilder.getBoolAttr(dynamic_size));
  odsState.addAttribute("clear_after_read", odsBuilder.getBoolAttr(clear_after_read));
  odsState.addAttribute("identical_element_shapes", odsBuilder.getBoolAttr(identical_element_shapes));
  odsState.addAttribute("tensor_array_name", odsBuilder.getStringAttr(tensor_array_name));
  assert(resultTypes.size() == 2u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void TensorArrayV3Op::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 2u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult TensorArrayV3Op::verify() {
  if (failed(TensorArrayV3OpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of 32-bit integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::ResourceType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::ResourceRefType>()))))) {
        return emitOpError("result #") << index << " must be tensor of resource values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSResults(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))))) {
        return emitOpError("result #") << index << " must be tensor of 32-bit float values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void TensorArrayV3Op::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
  for (::mlir::Value value : getODSResults(0))
    effects.emplace_back(MemoryEffects::Allocate::get(), value, ::mlir::TF::ResourceEffects::TensorArray::get());
}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::TensorArrayWriteV3Op definitions
//===----------------------------------------------------------------------===//

TensorArrayWriteV3OpAdaptor::TensorArrayWriteV3OpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

TensorArrayWriteV3OpAdaptor::TensorArrayWriteV3OpAdaptor(TensorArrayWriteV3Op&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> TensorArrayWriteV3OpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange TensorArrayWriteV3OpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value TensorArrayWriteV3OpAdaptor::handle() {
  return *getODSOperands(0).begin();
}

::mlir::Value TensorArrayWriteV3OpAdaptor::index() {
  return *getODSOperands(1).begin();
}

::mlir::Value TensorArrayWriteV3OpAdaptor::value() {
  return *getODSOperands(2).begin();
}

::mlir::Value TensorArrayWriteV3OpAdaptor::flow_in() {
  return *getODSOperands(3).begin();
}

::mlir::LogicalResult TensorArrayWriteV3OpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

::llvm::StringRef TensorArrayWriteV3Op::getOperationName() {
  return "tf.TensorArrayWriteV3";
}

std::pair<unsigned, unsigned> TensorArrayWriteV3Op::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range TensorArrayWriteV3Op::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value TensorArrayWriteV3Op::handle() {
  return *getODSOperands(0).begin();
}

::mlir::Value TensorArrayWriteV3Op::index() {
  return *getODSOperands(1).begin();
}

::mlir::Value TensorArrayWriteV3Op::value() {
  return *getODSOperands(2).begin();
}

::mlir::Value TensorArrayWriteV3Op::flow_in() {
  return *getODSOperands(3).begin();
}

::mlir::MutableOperandRange TensorArrayWriteV3Op::handleMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange TensorArrayWriteV3Op::indexMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange TensorArrayWriteV3Op::valueMutable() {
  auto range = getODSOperandIndexAndLength(2);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange TensorArrayWriteV3Op::flow_inMutable() {
  auto range = getODSOperandIndexAndLength(3);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> TensorArrayWriteV3Op::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range TensorArrayWriteV3Op::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value TensorArrayWriteV3Op::flow_out() {
  return *getODSResults(0).begin();
}

Type TensorArrayWriteV3Op::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(2).begin());
}

bool TensorArrayWriteV3Op::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "T") return true;
 return false;
}

::mlir::DictionaryAttr TensorArrayWriteV3Op::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())}
    }, ctx);
}

void TensorArrayWriteV3Op::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type flow_out, ::mlir::Value handle, ::mlir::Value index, ::mlir::Value value, ::mlir::Value flow_in) {
  odsState.addOperands(handle);
  odsState.addOperands(index);
  odsState.addOperands(value);
  odsState.addOperands(flow_in);
  odsState.addTypes(flow_out);
}

void TensorArrayWriteV3Op::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value handle, ::mlir::Value index, ::mlir::Value value, ::mlir::Value flow_in) {
  odsState.addOperands(handle);
  odsState.addOperands(index);
  odsState.addOperands(value);
  odsState.addOperands(flow_in);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void TensorArrayWriteV3Op::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 4u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult TensorArrayWriteV3Op::verify() {
  if (failed(TensorArrayWriteV3OpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::ResourceType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::ResourceRefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of resource values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of 32-bit integer values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup2 = getODSOperands(2);
    for (::mlir::Value v : valueGroup2) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>())))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::TensorFlowType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of tf.dtype values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup3 = getODSOperands(3);
    for (::mlir::Value v : valueGroup3) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of 32-bit float values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))))) {
        return emitOpError("result #") << index << " must be tensor of 32-bit float values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void TensorArrayWriteV3Op::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
  for (::mlir::Value value : getODSOperands(0))
    effects.emplace_back(MemoryEffects::Read::get(), value, ::mlir::TF::ResourceEffects::TensorArray::get());
  for (::mlir::Value value : getODSOperands(0))
    effects.emplace_back(MemoryEffects::Write::get(), value, ::mlir::TF::ResourceEffects::TensorArray::get());
}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::TensorListConcatV2Op definitions
//===----------------------------------------------------------------------===//

TensorListConcatV2OpAdaptor::TensorListConcatV2OpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

TensorListConcatV2OpAdaptor::TensorListConcatV2OpAdaptor(TensorListConcatV2Op&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> TensorListConcatV2OpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange TensorListConcatV2OpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value TensorListConcatV2OpAdaptor::input_handle() {
  return *getODSOperands(0).begin();
}

::mlir::Value TensorListConcatV2OpAdaptor::element_shape() {
  return *getODSOperands(1).begin();
}

::mlir::Value TensorListConcatV2OpAdaptor::leading_dims() {
  return *getODSOperands(2).begin();
}

::mlir::LogicalResult TensorListConcatV2OpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

void TensorListConcatV2Op::getAsmResultNames(::mlir::OpAsmSetValueNameFn setNameFn) {
  auto resultGroup0 = getODSResults(0);
  if (!llvm::empty(resultGroup0))
    setNameFn(*resultGroup0.begin(), "tensor");
  auto resultGroup1 = getODSResults(1);
  if (!llvm::empty(resultGroup1))
    setNameFn(*resultGroup1.begin(), "lengths");
}

::llvm::StringRef TensorListConcatV2Op::getOperationName() {
  return "tf.TensorListConcatV2";
}

std::pair<unsigned, unsigned> TensorListConcatV2Op::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range TensorListConcatV2Op::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value TensorListConcatV2Op::input_handle() {
  return *getODSOperands(0).begin();
}

::mlir::Value TensorListConcatV2Op::element_shape() {
  return *getODSOperands(1).begin();
}

::mlir::Value TensorListConcatV2Op::leading_dims() {
  return *getODSOperands(2).begin();
}

::mlir::MutableOperandRange TensorListConcatV2Op::input_handleMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange TensorListConcatV2Op::element_shapeMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange TensorListConcatV2Op::leading_dimsMutable() {
  auto range = getODSOperandIndexAndLength(2);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> TensorListConcatV2Op::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range TensorListConcatV2Op::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value TensorListConcatV2Op::tensor() {
  return *getODSResults(0).begin();
}

::mlir::Value TensorListConcatV2Op::lengths() {
  return *getODSResults(1).begin();
}

Type TensorListConcatV2Op::shape_type() {
  return mlir::getElementTypeOrSelf(*getODSOperands(1).begin());
}

Type TensorListConcatV2Op::element_dtype() {
  return mlir::getElementTypeOrSelf(*getODSResults(0).begin());
}

bool TensorListConcatV2Op::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "shape_type") return true;
  if (name == "element_dtype") return true;
 return false;
}

::mlir::DictionaryAttr TensorListConcatV2Op::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("shape_type", ctx),
::mlir::TypeAttr::get(shape_type())},
    {::mlir::Identifier::get("element_dtype", ctx),
::mlir::TypeAttr::get(element_dtype())}
    }, ctx);
}

void TensorListConcatV2Op::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type tensor, ::mlir::Type lengths, ::mlir::Value input_handle, ::mlir::Value element_shape, ::mlir::Value leading_dims) {
  odsState.addOperands(input_handle);
  odsState.addOperands(element_shape);
  odsState.addOperands(leading_dims);
  odsState.addTypes(tensor);
  odsState.addTypes(lengths);
}

void TensorListConcatV2Op::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input_handle, ::mlir::Value element_shape, ::mlir::Value leading_dims) {
  odsState.addOperands(input_handle);
  odsState.addOperands(element_shape);
  odsState.addOperands(leading_dims);
  assert(resultTypes.size() == 2u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void TensorListConcatV2Op::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 3u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 2u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult TensorListConcatV2Op::verify() {
  if (failed(TensorListConcatV2OpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::VariantType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::VariantRefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of variant values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of 32/64-bit signed integer values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup2 = getODSOperands(2);
    for (::mlir::Value v : valueGroup2) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of 64-bit integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>())))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::TensorFlowType>()))))) {
        return emitOpError("result #") << index << " must be tensor of tf.dtype values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSResults(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))))) {
        return emitOpError("result #") << index << " must be tensor of 64-bit integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void TensorListConcatV2Op::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::TensorListElementShapeOp definitions
//===----------------------------------------------------------------------===//

TensorListElementShapeOpAdaptor::TensorListElementShapeOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

TensorListElementShapeOpAdaptor::TensorListElementShapeOpAdaptor(TensorListElementShapeOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> TensorListElementShapeOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange TensorListElementShapeOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value TensorListElementShapeOpAdaptor::input_handle() {
  return *getODSOperands(0).begin();
}

::mlir::LogicalResult TensorListElementShapeOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

::llvm::StringRef TensorListElementShapeOp::getOperationName() {
  return "tf.TensorListElementShape";
}

std::pair<unsigned, unsigned> TensorListElementShapeOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range TensorListElementShapeOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value TensorListElementShapeOp::input_handle() {
  return *getODSOperands(0).begin();
}

::mlir::MutableOperandRange TensorListElementShapeOp::input_handleMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> TensorListElementShapeOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range TensorListElementShapeOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value TensorListElementShapeOp::element_shape() {
  return *getODSResults(0).begin();
}

Type TensorListElementShapeOp::shape_type() {
  return mlir::getElementTypeOrSelf(*getODSResults(0).begin());
}

bool TensorListElementShapeOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "shape_type") return true;
 return false;
}

::mlir::DictionaryAttr TensorListElementShapeOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("shape_type", ctx),
::mlir::TypeAttr::get(shape_type())}
    }, ctx);
}

void TensorListElementShapeOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type element_shape, ::mlir::Value input_handle) {
  odsState.addOperands(input_handle);
  odsState.addTypes(element_shape);
}

void TensorListElementShapeOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input_handle) {
  odsState.addOperands(input_handle);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void TensorListElementShapeOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult TensorListElementShapeOp::verify() {
  if (failed(TensorListElementShapeOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::VariantType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::VariantRefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of variant values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))))) {
        return emitOpError("result #") << index << " must be tensor of 32/64-bit signed integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}



void TensorListElementShapeOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::TensorListFromTensorOp definitions
//===----------------------------------------------------------------------===//

TensorListFromTensorOpAdaptor::TensorListFromTensorOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

TensorListFromTensorOpAdaptor::TensorListFromTensorOpAdaptor(TensorListFromTensorOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> TensorListFromTensorOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange TensorListFromTensorOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value TensorListFromTensorOpAdaptor::tensor() {
  return *getODSOperands(0).begin();
}

::mlir::Value TensorListFromTensorOpAdaptor::element_shape() {
  return *getODSOperands(1).begin();
}

::mlir::LogicalResult TensorListFromTensorOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

::llvm::StringRef TensorListFromTensorOp::getOperationName() {
  return "tf.TensorListFromTensor";
}

std::pair<unsigned, unsigned> TensorListFromTensorOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range TensorListFromTensorOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value TensorListFromTensorOp::tensor() {
  return *getODSOperands(0).begin();
}

::mlir::Value TensorListFromTensorOp::element_shape() {
  return *getODSOperands(1).begin();
}

::mlir::MutableOperandRange TensorListFromTensorOp::tensorMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange TensorListFromTensorOp::element_shapeMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> TensorListFromTensorOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range TensorListFromTensorOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value TensorListFromTensorOp::output_handle() {
  return *getODSResults(0).begin();
}

Type TensorListFromTensorOp::shape_type() {
  return mlir::getElementTypeOrSelf(*getODSOperands(1).begin());
}

Type TensorListFromTensorOp::element_dtype() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

bool TensorListFromTensorOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "shape_type") return true;
  if (name == "element_dtype") return true;
 return false;
}

::mlir::DictionaryAttr TensorListFromTensorOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("shape_type", ctx),
::mlir::TypeAttr::get(shape_type())},
    {::mlir::Identifier::get("element_dtype", ctx),
::mlir::TypeAttr::get(element_dtype())}
    }, ctx);
}

void TensorListFromTensorOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output_handle, ::mlir::Value tensor, ::mlir::Value element_shape) {
  odsState.addOperands(tensor);
  odsState.addOperands(element_shape);
  odsState.addTypes(output_handle);
}

void TensorListFromTensorOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value tensor, ::mlir::Value element_shape) {
  odsState.addOperands(tensor);
  odsState.addOperands(element_shape);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void TensorListFromTensorOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult TensorListFromTensorOp::verify() {
  if (failed(TensorListFromTensorOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>())))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::TensorFlowType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of tf.dtype values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of 32/64-bit signed integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::VariantType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::VariantRefType>()))))) {
        return emitOpError("result #") << index << " must be tensor of variant values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void TensorListFromTensorOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::TensorListGatherOp definitions
//===----------------------------------------------------------------------===//

TensorListGatherOpAdaptor::TensorListGatherOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

TensorListGatherOpAdaptor::TensorListGatherOpAdaptor(TensorListGatherOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> TensorListGatherOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange TensorListGatherOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value TensorListGatherOpAdaptor::input_handle() {
  return *getODSOperands(0).begin();
}

::mlir::Value TensorListGatherOpAdaptor::indices() {
  return *getODSOperands(1).begin();
}

::mlir::Value TensorListGatherOpAdaptor::element_shape() {
  return *getODSOperands(2).begin();
}

::mlir::LogicalResult TensorListGatherOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

::llvm::StringRef TensorListGatherOp::getOperationName() {
  return "tf.TensorListGather";
}

std::pair<unsigned, unsigned> TensorListGatherOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range TensorListGatherOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value TensorListGatherOp::input_handle() {
  return *getODSOperands(0).begin();
}

::mlir::Value TensorListGatherOp::indices() {
  return *getODSOperands(1).begin();
}

::mlir::Value TensorListGatherOp::element_shape() {
  return *getODSOperands(2).begin();
}

::mlir::MutableOperandRange TensorListGatherOp::input_handleMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange TensorListGatherOp::indicesMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange TensorListGatherOp::element_shapeMutable() {
  auto range = getODSOperandIndexAndLength(2);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> TensorListGatherOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range TensorListGatherOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value TensorListGatherOp::values() {
  return *getODSResults(0).begin();
}

Type TensorListGatherOp::element_dtype() {
  return mlir::getElementTypeOrSelf(*getODSResults(0).begin());
}

bool TensorListGatherOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "element_dtype") return true;
 return false;
}

::mlir::DictionaryAttr TensorListGatherOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("element_dtype", ctx),
::mlir::TypeAttr::get(element_dtype())}
    }, ctx);
}

void TensorListGatherOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type values, ::mlir::Value input_handle, ::mlir::Value indices, ::mlir::Value element_shape) {
  odsState.addOperands(input_handle);
  odsState.addOperands(indices);
  odsState.addOperands(element_shape);
  odsState.addTypes(values);
}

void TensorListGatherOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input_handle, ::mlir::Value indices, ::mlir::Value element_shape) {
  odsState.addOperands(input_handle);
  odsState.addOperands(indices);
  odsState.addOperands(element_shape);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void TensorListGatherOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 3u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult TensorListGatherOp::verify() {
  if (failed(TensorListGatherOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::VariantType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::VariantRefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of variant values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of 32-bit integer values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup2 = getODSOperands(2);
    for (::mlir::Value v : valueGroup2) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of 32-bit integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>())))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::TensorFlowType>()))))) {
        return emitOpError("result #") << index << " must be tensor of tf.dtype values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void TensorListGatherOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::TensorListGetItemOp definitions
//===----------------------------------------------------------------------===//

TensorListGetItemOpAdaptor::TensorListGetItemOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

TensorListGetItemOpAdaptor::TensorListGetItemOpAdaptor(TensorListGetItemOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> TensorListGetItemOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange TensorListGetItemOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value TensorListGetItemOpAdaptor::input_handle() {
  return *getODSOperands(0).begin();
}

::mlir::Value TensorListGetItemOpAdaptor::index() {
  return *getODSOperands(1).begin();
}

::mlir::Value TensorListGetItemOpAdaptor::element_shape() {
  return *getODSOperands(2).begin();
}

::mlir::LogicalResult TensorListGetItemOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

::llvm::StringRef TensorListGetItemOp::getOperationName() {
  return "tf.TensorListGetItem";
}

std::pair<unsigned, unsigned> TensorListGetItemOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range TensorListGetItemOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value TensorListGetItemOp::input_handle() {
  return *getODSOperands(0).begin();
}

::mlir::Value TensorListGetItemOp::index() {
  return *getODSOperands(1).begin();
}

::mlir::Value TensorListGetItemOp::element_shape() {
  return *getODSOperands(2).begin();
}

::mlir::MutableOperandRange TensorListGetItemOp::input_handleMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange TensorListGetItemOp::indexMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange TensorListGetItemOp::element_shapeMutable() {
  auto range = getODSOperandIndexAndLength(2);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> TensorListGetItemOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range TensorListGetItemOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value TensorListGetItemOp::item() {
  return *getODSResults(0).begin();
}

Type TensorListGetItemOp::element_dtype() {
  return mlir::getElementTypeOrSelf(*getODSResults(0).begin());
}

bool TensorListGetItemOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "element_dtype") return true;
 return false;
}

::mlir::DictionaryAttr TensorListGetItemOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("element_dtype", ctx),
::mlir::TypeAttr::get(element_dtype())}
    }, ctx);
}

void TensorListGetItemOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type item, ::mlir::Value input_handle, ::mlir::Value index, ::mlir::Value element_shape) {
  odsState.addOperands(input_handle);
  odsState.addOperands(index);
  odsState.addOperands(element_shape);
  odsState.addTypes(item);
}

void TensorListGetItemOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input_handle, ::mlir::Value index, ::mlir::Value element_shape) {
  odsState.addOperands(input_handle);
  odsState.addOperands(index);
  odsState.addOperands(element_shape);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void TensorListGetItemOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 3u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult TensorListGetItemOp::verify() {
  if (failed(TensorListGetItemOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::VariantType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::VariantRefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of variant values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of 32-bit integer values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup2 = getODSOperands(2);
    for (::mlir::Value v : valueGroup2) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of 32-bit integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>())))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::TensorFlowType>()))))) {
        return emitOpError("result #") << index << " must be tensor of tf.dtype values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void TensorListGetItemOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::TensorListLengthOp definitions
//===----------------------------------------------------------------------===//

TensorListLengthOpAdaptor::TensorListLengthOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

TensorListLengthOpAdaptor::TensorListLengthOpAdaptor(TensorListLengthOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> TensorListLengthOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange TensorListLengthOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value TensorListLengthOpAdaptor::input_handle() {
  return *getODSOperands(0).begin();
}

::mlir::LogicalResult TensorListLengthOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

::llvm::StringRef TensorListLengthOp::getOperationName() {
  return "tf.TensorListLength";
}

std::pair<unsigned, unsigned> TensorListLengthOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range TensorListLengthOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value TensorListLengthOp::input_handle() {
  return *getODSOperands(0).begin();
}

::mlir::MutableOperandRange TensorListLengthOp::input_handleMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> TensorListLengthOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range TensorListLengthOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value TensorListLengthOp::length() {
  return *getODSResults(0).begin();
}

void TensorListLengthOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type length, ::mlir::Value input_handle) {
  odsState.addOperands(input_handle);
  odsState.addTypes(length);
}

void TensorListLengthOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input_handle) {
  odsState.addOperands(input_handle);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void TensorListLengthOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult TensorListLengthOp::verify() {
  if (failed(TensorListLengthOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::VariantType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::VariantRefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of variant values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))))) {
        return emitOpError("result #") << index << " must be tensor of 32-bit integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void TensorListLengthOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::TensorListPopBackOp definitions
//===----------------------------------------------------------------------===//

TensorListPopBackOpAdaptor::TensorListPopBackOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

TensorListPopBackOpAdaptor::TensorListPopBackOpAdaptor(TensorListPopBackOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> TensorListPopBackOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange TensorListPopBackOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value TensorListPopBackOpAdaptor::input_handle() {
  return *getODSOperands(0).begin();
}

::mlir::Value TensorListPopBackOpAdaptor::element_shape() {
  return *getODSOperands(1).begin();
}

::mlir::LogicalResult TensorListPopBackOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

void TensorListPopBackOp::getAsmResultNames(::mlir::OpAsmSetValueNameFn setNameFn) {
  auto resultGroup0 = getODSResults(0);
  if (!llvm::empty(resultGroup0))
    setNameFn(*resultGroup0.begin(), "output_handle");
  auto resultGroup1 = getODSResults(1);
  if (!llvm::empty(resultGroup1))
    setNameFn(*resultGroup1.begin(), "tensor");
}

::llvm::StringRef TensorListPopBackOp::getOperationName() {
  return "tf.TensorListPopBack";
}

std::pair<unsigned, unsigned> TensorListPopBackOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range TensorListPopBackOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value TensorListPopBackOp::input_handle() {
  return *getODSOperands(0).begin();
}

::mlir::Value TensorListPopBackOp::element_shape() {
  return *getODSOperands(1).begin();
}

::mlir::MutableOperandRange TensorListPopBackOp::input_handleMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange TensorListPopBackOp::element_shapeMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> TensorListPopBackOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range TensorListPopBackOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value TensorListPopBackOp::output_handle() {
  return *getODSResults(0).begin();
}

::mlir::Value TensorListPopBackOp::tensor() {
  return *getODSResults(1).begin();
}

Type TensorListPopBackOp::element_dtype() {
  return mlir::getElementTypeOrSelf(*getODSResults(1).begin());
}

bool TensorListPopBackOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "element_dtype") return true;
 return false;
}

::mlir::DictionaryAttr TensorListPopBackOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("element_dtype", ctx),
::mlir::TypeAttr::get(element_dtype())}
    }, ctx);
}

void TensorListPopBackOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output_handle, ::mlir::Type tensor, ::mlir::Value input_handle, ::mlir::Value element_shape) {
  odsState.addOperands(input_handle);
  odsState.addOperands(element_shape);
  odsState.addTypes(output_handle);
  odsState.addTypes(tensor);
}

void TensorListPopBackOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input_handle, ::mlir::Value element_shape) {
  odsState.addOperands(input_handle);
  odsState.addOperands(element_shape);
  assert(resultTypes.size() == 2u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void TensorListPopBackOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 2u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult TensorListPopBackOp::verify() {
  if (failed(TensorListPopBackOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::VariantType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::VariantRefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of variant values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of 32-bit integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::VariantType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::VariantRefType>()))))) {
        return emitOpError("result #") << index << " must be tensor of variant values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSResults(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>())))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::TensorFlowType>()))))) {
        return emitOpError("result #") << index << " must be tensor of tf.dtype values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void TensorListPopBackOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::TensorListPushBackOp definitions
//===----------------------------------------------------------------------===//

TensorListPushBackOpAdaptor::TensorListPushBackOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

TensorListPushBackOpAdaptor::TensorListPushBackOpAdaptor(TensorListPushBackOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> TensorListPushBackOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange TensorListPushBackOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value TensorListPushBackOpAdaptor::input_handle() {
  return *getODSOperands(0).begin();
}

::mlir::Value TensorListPushBackOpAdaptor::tensor() {
  return *getODSOperands(1).begin();
}

::mlir::LogicalResult TensorListPushBackOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

::llvm::StringRef TensorListPushBackOp::getOperationName() {
  return "tf.TensorListPushBack";
}

std::pair<unsigned, unsigned> TensorListPushBackOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range TensorListPushBackOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value TensorListPushBackOp::input_handle() {
  return *getODSOperands(0).begin();
}

::mlir::Value TensorListPushBackOp::tensor() {
  return *getODSOperands(1).begin();
}

::mlir::MutableOperandRange TensorListPushBackOp::input_handleMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange TensorListPushBackOp::tensorMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> TensorListPushBackOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range TensorListPushBackOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value TensorListPushBackOp::output_handle() {
  return *getODSResults(0).begin();
}

Type TensorListPushBackOp::element_dtype() {
  return mlir::getElementTypeOrSelf(*getODSOperands(1).begin());
}

bool TensorListPushBackOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "element_dtype") return true;
 return false;
}

::mlir::DictionaryAttr TensorListPushBackOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("element_dtype", ctx),
::mlir::TypeAttr::get(element_dtype())}
    }, ctx);
}

void TensorListPushBackOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output_handle, ::mlir::Value input_handle, ::mlir::Value tensor) {
  odsState.addOperands(input_handle);
  odsState.addOperands(tensor);
  odsState.addTypes(output_handle);
}

void TensorListPushBackOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input_handle, ::mlir::Value tensor) {
  odsState.addOperands(input_handle);
  odsState.addOperands(tensor);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void TensorListPushBackOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult TensorListPushBackOp::verify() {
  if (failed(TensorListPushBackOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::VariantType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::VariantRefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of variant values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>())))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::TensorFlowType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of tf.dtype values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::VariantType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::VariantRefType>()))))) {
        return emitOpError("result #") << index << " must be tensor of variant values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void TensorListPushBackOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::TensorListReserveOp definitions
//===----------------------------------------------------------------------===//

TensorListReserveOpAdaptor::TensorListReserveOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

TensorListReserveOpAdaptor::TensorListReserveOpAdaptor(TensorListReserveOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> TensorListReserveOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange TensorListReserveOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value TensorListReserveOpAdaptor::element_shape() {
  return *getODSOperands(0).begin();
}

::mlir::Value TensorListReserveOpAdaptor::num_elements() {
  return *getODSOperands(1).begin();
}

::mlir::LogicalResult TensorListReserveOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

::llvm::StringRef TensorListReserveOp::getOperationName() {
  return "tf.TensorListReserve";
}

std::pair<unsigned, unsigned> TensorListReserveOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range TensorListReserveOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value TensorListReserveOp::element_shape() {
  return *getODSOperands(0).begin();
}

::mlir::Value TensorListReserveOp::num_elements() {
  return *getODSOperands(1).begin();
}

::mlir::MutableOperandRange TensorListReserveOp::element_shapeMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange TensorListReserveOp::num_elementsMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> TensorListReserveOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range TensorListReserveOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value TensorListReserveOp::handle() {
  return *getODSResults(0).begin();
}

Type TensorListReserveOp::shape_type() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

Type TensorListReserveOp::element_dtype() {
  return getElementTypeOrSelf(element_type());
}

bool TensorListReserveOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "shape_type") return true;
  if (name == "element_dtype") return true;
 return false;
}

::mlir::DictionaryAttr TensorListReserveOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("shape_type", ctx),
::mlir::TypeAttr::get(shape_type())},
    {::mlir::Identifier::get("element_dtype", ctx),
::mlir::TypeAttr::get(element_dtype())}
    }, ctx);
}

void TensorListReserveOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type handle, ::mlir::Value element_shape, ::mlir::Value num_elements) {
  odsState.addOperands(element_shape);
  odsState.addOperands(num_elements);
  odsState.addTypes(handle);
}

void TensorListReserveOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value element_shape, ::mlir::Value num_elements) {
  odsState.addOperands(element_shape);
  odsState.addOperands(num_elements);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void TensorListReserveOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult TensorListReserveOp::verify() {
  if (failed(TensorListReserveOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of 32/64-bit signed integer values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of 32-bit integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::VariantType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::VariantRefType>()))))) {
        return emitOpError("result #") << index << " must be tensor of variant values, but got " << v.getType();
      }
      ++index;
    }
  }
  // This is required to populate derived attributes during export in a
    // meaningful way. Else during export to GraphDef element_type() query
    // will result in out of bounds access/assert.
    if (handle_dtype().getSubtypes().size() != 1) {
      return emitOpError(
          "must have exactly one subtype in the result variant type");
    }

    return Verify(*this);
}

void TensorListReserveOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::TensorListResizeOp definitions
//===----------------------------------------------------------------------===//

TensorListResizeOpAdaptor::TensorListResizeOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

TensorListResizeOpAdaptor::TensorListResizeOpAdaptor(TensorListResizeOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> TensorListResizeOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange TensorListResizeOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value TensorListResizeOpAdaptor::input_handle() {
  return *getODSOperands(0).begin();
}

::mlir::Value TensorListResizeOpAdaptor::size() {
  return *getODSOperands(1).begin();
}

::mlir::LogicalResult TensorListResizeOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

::llvm::StringRef TensorListResizeOp::getOperationName() {
  return "tf.TensorListResize";
}

std::pair<unsigned, unsigned> TensorListResizeOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range TensorListResizeOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value TensorListResizeOp::input_handle() {
  return *getODSOperands(0).begin();
}

::mlir::Value TensorListResizeOp::size() {
  return *getODSOperands(1).begin();
}

::mlir::MutableOperandRange TensorListResizeOp::input_handleMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange TensorListResizeOp::sizeMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> TensorListResizeOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range TensorListResizeOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value TensorListResizeOp::output_handle() {
  return *getODSResults(0).begin();
}

void TensorListResizeOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output_handle, ::mlir::Value input_handle, ::mlir::Value size) {
  odsState.addOperands(input_handle);
  odsState.addOperands(size);
  odsState.addTypes(output_handle);
}

void TensorListResizeOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input_handle, ::mlir::Value size) {
  odsState.addOperands(input_handle);
  odsState.addOperands(size);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void TensorListResizeOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult TensorListResizeOp::verify() {
  if (failed(TensorListResizeOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::VariantType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::VariantRefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of variant values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of 32-bit integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::VariantType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::VariantRefType>()))))) {
        return emitOpError("result #") << index << " must be tensor of variant values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void TensorListResizeOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::TensorListScatterIntoExistingListOp definitions
//===----------------------------------------------------------------------===//

TensorListScatterIntoExistingListOpAdaptor::TensorListScatterIntoExistingListOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

TensorListScatterIntoExistingListOpAdaptor::TensorListScatterIntoExistingListOpAdaptor(TensorListScatterIntoExistingListOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> TensorListScatterIntoExistingListOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange TensorListScatterIntoExistingListOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value TensorListScatterIntoExistingListOpAdaptor::input_handle() {
  return *getODSOperands(0).begin();
}

::mlir::Value TensorListScatterIntoExistingListOpAdaptor::tensor() {
  return *getODSOperands(1).begin();
}

::mlir::Value TensorListScatterIntoExistingListOpAdaptor::indices() {
  return *getODSOperands(2).begin();
}

::mlir::LogicalResult TensorListScatterIntoExistingListOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

::llvm::StringRef TensorListScatterIntoExistingListOp::getOperationName() {
  return "tf.TensorListScatterIntoExistingList";
}

std::pair<unsigned, unsigned> TensorListScatterIntoExistingListOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range TensorListScatterIntoExistingListOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value TensorListScatterIntoExistingListOp::input_handle() {
  return *getODSOperands(0).begin();
}

::mlir::Value TensorListScatterIntoExistingListOp::tensor() {
  return *getODSOperands(1).begin();
}

::mlir::Value TensorListScatterIntoExistingListOp::indices() {
  return *getODSOperands(2).begin();
}

::mlir::MutableOperandRange TensorListScatterIntoExistingListOp::input_handleMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange TensorListScatterIntoExistingListOp::tensorMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange TensorListScatterIntoExistingListOp::indicesMutable() {
  auto range = getODSOperandIndexAndLength(2);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> TensorListScatterIntoExistingListOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range TensorListScatterIntoExistingListOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value TensorListScatterIntoExistingListOp::output_handle() {
  return *getODSResults(0).begin();
}

Type TensorListScatterIntoExistingListOp::element_dtype() {
  return mlir::getElementTypeOrSelf(*getODSOperands(1).begin());
}

bool TensorListScatterIntoExistingListOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "element_dtype") return true;
 return false;
}

::mlir::DictionaryAttr TensorListScatterIntoExistingListOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("element_dtype", ctx),
::mlir::TypeAttr::get(element_dtype())}
    }, ctx);
}

void TensorListScatterIntoExistingListOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output_handle, ::mlir::Value input_handle, ::mlir::Value tensor, ::mlir::Value indices) {
  odsState.addOperands(input_handle);
  odsState.addOperands(tensor);
  odsState.addOperands(indices);
  odsState.addTypes(output_handle);
}

void TensorListScatterIntoExistingListOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input_handle, ::mlir::Value tensor, ::mlir::Value indices) {
  odsState.addOperands(input_handle);
  odsState.addOperands(tensor);
  odsState.addOperands(indices);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void TensorListScatterIntoExistingListOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 3u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult TensorListScatterIntoExistingListOp::verify() {
  if (failed(TensorListScatterIntoExistingListOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::VariantType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::VariantRefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of variant values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>())))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::TensorFlowType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of tf.dtype values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup2 = getODSOperands(2);
    for (::mlir::Value v : valueGroup2) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of 32-bit integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::VariantType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::VariantRefType>()))))) {
        return emitOpError("result #") << index << " must be tensor of variant values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void TensorListScatterIntoExistingListOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::TensorListSetItemOp definitions
//===----------------------------------------------------------------------===//

TensorListSetItemOpAdaptor::TensorListSetItemOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

TensorListSetItemOpAdaptor::TensorListSetItemOpAdaptor(TensorListSetItemOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> TensorListSetItemOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange TensorListSetItemOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value TensorListSetItemOpAdaptor::input_handle() {
  return *getODSOperands(0).begin();
}

::mlir::Value TensorListSetItemOpAdaptor::index() {
  return *getODSOperands(1).begin();
}

::mlir::Value TensorListSetItemOpAdaptor::item() {
  return *getODSOperands(2).begin();
}

::mlir::LogicalResult TensorListSetItemOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

::llvm::StringRef TensorListSetItemOp::getOperationName() {
  return "tf.TensorListSetItem";
}

std::pair<unsigned, unsigned> TensorListSetItemOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range TensorListSetItemOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value TensorListSetItemOp::input_handle() {
  return *getODSOperands(0).begin();
}

::mlir::Value TensorListSetItemOp::index() {
  return *getODSOperands(1).begin();
}

::mlir::Value TensorListSetItemOp::item() {
  return *getODSOperands(2).begin();
}

::mlir::MutableOperandRange TensorListSetItemOp::input_handleMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange TensorListSetItemOp::indexMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange TensorListSetItemOp::itemMutable() {
  auto range = getODSOperandIndexAndLength(2);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> TensorListSetItemOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range TensorListSetItemOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value TensorListSetItemOp::output_handle() {
  return *getODSResults(0).begin();
}

Type TensorListSetItemOp::element_dtype() {
  return mlir::getElementTypeOrSelf(*getODSOperands(2).begin());
}

bool TensorListSetItemOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "element_dtype") return true;
 return false;
}

::mlir::DictionaryAttr TensorListSetItemOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("element_dtype", ctx),
::mlir::TypeAttr::get(element_dtype())}
    }, ctx);
}

void TensorListSetItemOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output_handle, ::mlir::Value input_handle, ::mlir::Value index, ::mlir::Value item) {
  odsState.addOperands(input_handle);
  odsState.addOperands(index);
  odsState.addOperands(item);
  odsState.addTypes(output_handle);
}

void TensorListSetItemOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input_handle, ::mlir::Value index, ::mlir::Value item) {
  odsState.addOperands(input_handle);
  odsState.addOperands(index);
  odsState.addOperands(item);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void TensorListSetItemOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 3u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult TensorListSetItemOp::verify() {
  if (failed(TensorListSetItemOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::VariantType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::VariantRefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of variant values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of 32-bit integer values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup2 = getODSOperands(2);
    for (::mlir::Value v : valueGroup2) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>())))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::TensorFlowType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of tf.dtype values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::VariantType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::VariantRefType>()))))) {
        return emitOpError("result #") << index << " must be tensor of variant values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void TensorListSetItemOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::TensorListStackOp definitions
//===----------------------------------------------------------------------===//

TensorListStackOpAdaptor::TensorListStackOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

TensorListStackOpAdaptor::TensorListStackOpAdaptor(TensorListStackOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> TensorListStackOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange TensorListStackOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value TensorListStackOpAdaptor::input_handle() {
  return *getODSOperands(0).begin();
}

::mlir::Value TensorListStackOpAdaptor::element_shape() {
  return *getODSOperands(1).begin();
}

::mlir::IntegerAttr TensorListStackOpAdaptor::num_elements() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::IntegerAttr attr = odsAttrs.get("num_elements").dyn_cast_or_null<::mlir::IntegerAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getIntegerAttr(::mlir::Builder(odsAttrs.getContext()).getIntegerType(64), -1);
  return attr;
}

::mlir::LogicalResult TensorListStackOpAdaptor::verify(::mlir::Location loc) {
  {
  auto tblgen_num_elements = odsAttrs.get("num_elements");
  if (tblgen_num_elements) {
    if (!(((tblgen_num_elements.isa<::mlir::IntegerAttr>())) && ((tblgen_num_elements.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(64))))) return emitError(loc, "'tf.TensorListStack' op ""attribute 'num_elements' failed to satisfy constraint: 64-bit signless integer attribute");
  }
  }
  return ::mlir::success();
}

::llvm::StringRef TensorListStackOp::getOperationName() {
  return "tf.TensorListStack";
}

std::pair<unsigned, unsigned> TensorListStackOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range TensorListStackOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value TensorListStackOp::input_handle() {
  return *getODSOperands(0).begin();
}

::mlir::Value TensorListStackOp::element_shape() {
  return *getODSOperands(1).begin();
}

::mlir::MutableOperandRange TensorListStackOp::input_handleMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange TensorListStackOp::element_shapeMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> TensorListStackOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range TensorListStackOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value TensorListStackOp::tensor() {
  return *getODSResults(0).begin();
}

::mlir::IntegerAttr TensorListStackOp::num_elementsAttr() {
  return this->getAttr("num_elements").dyn_cast_or_null<::mlir::IntegerAttr>();
}

uint64_t TensorListStackOp::num_elements() {
  auto attr = num_elementsAttr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getIntegerAttr(::mlir::Builder(this->getContext()).getIntegerType(64), -1).getValue().getZExtValue();
  return attr.getValue().getZExtValue();
}

Type TensorListStackOp::element_dtype() {
  return mlir::getElementTypeOrSelf(*getODSResults(0).begin());
}

bool TensorListStackOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "element_dtype") return true;
 return false;
}

::mlir::DictionaryAttr TensorListStackOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("element_dtype", ctx),
::mlir::TypeAttr::get(element_dtype())}
    }, ctx);
}

void TensorListStackOp::num_elementsAttr(::mlir::IntegerAttr attr) {
  this->getOperation()->setAttr("num_elements", attr);
}

void TensorListStackOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type tensor, ::mlir::Value input_handle, ::mlir::Value element_shape, ::mlir::IntegerAttr num_elements) {
  odsState.addOperands(input_handle);
  odsState.addOperands(element_shape);
  odsState.addAttribute("num_elements", num_elements);
  odsState.addTypes(tensor);
}

void TensorListStackOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input_handle, ::mlir::Value element_shape, ::mlir::IntegerAttr num_elements) {
  odsState.addOperands(input_handle);
  odsState.addOperands(element_shape);
  odsState.addAttribute("num_elements", num_elements);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void TensorListStackOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type tensor, ::mlir::Value input_handle, ::mlir::Value element_shape, uint64_t num_elements) {
  odsState.addOperands(input_handle);
  odsState.addOperands(element_shape);
  odsState.addAttribute("num_elements", odsBuilder.getIntegerAttr(odsBuilder.getIntegerType(64), num_elements));
  odsState.addTypes(tensor);
}

void TensorListStackOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input_handle, ::mlir::Value element_shape, uint64_t num_elements) {
  odsState.addOperands(input_handle);
  odsState.addOperands(element_shape);
  odsState.addAttribute("num_elements", odsBuilder.getIntegerAttr(odsBuilder.getIntegerType(64), num_elements));
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void TensorListStackOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult TensorListStackOp::verify() {
  if (failed(TensorListStackOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::VariantType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::VariantRefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of variant values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of 32-bit integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>())))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::TensorFlowType>()))))) {
        return emitOpError("result #") << index << " must be tensor of tf.dtype values, but got " << v.getType();
      }
      ++index;
    }
  }
  return Verify(*this);
}

void TensorListStackOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::TensorScatterAddOp definitions
//===----------------------------------------------------------------------===//

TensorScatterAddOpAdaptor::TensorScatterAddOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

TensorScatterAddOpAdaptor::TensorScatterAddOpAdaptor(TensorScatterAddOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> TensorScatterAddOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange TensorScatterAddOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value TensorScatterAddOpAdaptor::tensor() {
  return *getODSOperands(0).begin();
}

::mlir::Value TensorScatterAddOpAdaptor::indices() {
  return *getODSOperands(1).begin();
}

::mlir::Value TensorScatterAddOpAdaptor::updates() {
  return *getODSOperands(2).begin();
}

::mlir::LogicalResult TensorScatterAddOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

::llvm::StringRef TensorScatterAddOp::getOperationName() {
  return "tf.TensorScatterAdd";
}

std::pair<unsigned, unsigned> TensorScatterAddOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range TensorScatterAddOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value TensorScatterAddOp::tensor() {
  return *getODSOperands(0).begin();
}

::mlir::Value TensorScatterAddOp::indices() {
  return *getODSOperands(1).begin();
}

::mlir::Value TensorScatterAddOp::updates() {
  return *getODSOperands(2).begin();
}

::mlir::MutableOperandRange TensorScatterAddOp::tensorMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange TensorScatterAddOp::indicesMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange TensorScatterAddOp::updatesMutable() {
  auto range = getODSOperandIndexAndLength(2);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> TensorScatterAddOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range TensorScatterAddOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value TensorScatterAddOp::output() {
  return *getODSResults(0).begin();
}

Type TensorScatterAddOp::Tindices() {
  return mlir::getElementTypeOrSelf(*getODSOperands(1).begin());
}

Type TensorScatterAddOp::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

bool TensorScatterAddOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "Tindices") return true;
  if (name == "T") return true;
 return false;
}

::mlir::DictionaryAttr TensorScatterAddOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("Tindices", ctx),
::mlir::TypeAttr::get(Tindices())},
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())}
    }, ctx);
}

void TensorScatterAddOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value tensor, ::mlir::Value indices, ::mlir::Value updates) {
  odsState.addOperands(tensor);
  odsState.addOperands(indices);
  odsState.addOperands(updates);
  odsState.addTypes(output);
}

void TensorScatterAddOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value tensor, ::mlir::Value indices, ::mlir::Value updates) {
  odsState.addOperands(tensor);
  odsState.addOperands(indices);
  odsState.addOperands(updates);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void TensorScatterAddOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 3u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult TensorScatterAddOp::verify() {
  if (failed(TensorScatterAddOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>())))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::TensorFlowType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of tf.dtype values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of 32/64-bit signed integer values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup2 = getODSOperands(2);
    for (::mlir::Value v : valueGroup2) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>())))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::TensorFlowType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of tf.dtype values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>())))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::TensorFlowType>()))))) {
        return emitOpError("result #") << index << " must be tensor of tf.dtype values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void TensorScatterAddOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::TensorScatterSubOp definitions
//===----------------------------------------------------------------------===//

TensorScatterSubOpAdaptor::TensorScatterSubOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

TensorScatterSubOpAdaptor::TensorScatterSubOpAdaptor(TensorScatterSubOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> TensorScatterSubOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange TensorScatterSubOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value TensorScatterSubOpAdaptor::tensor() {
  return *getODSOperands(0).begin();
}

::mlir::Value TensorScatterSubOpAdaptor::indices() {
  return *getODSOperands(1).begin();
}

::mlir::Value TensorScatterSubOpAdaptor::updates() {
  return *getODSOperands(2).begin();
}

::mlir::LogicalResult TensorScatterSubOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

::llvm::StringRef TensorScatterSubOp::getOperationName() {
  return "tf.TensorScatterSub";
}

std::pair<unsigned, unsigned> TensorScatterSubOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range TensorScatterSubOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value TensorScatterSubOp::tensor() {
  return *getODSOperands(0).begin();
}

::mlir::Value TensorScatterSubOp::indices() {
  return *getODSOperands(1).begin();
}

::mlir::Value TensorScatterSubOp::updates() {
  return *getODSOperands(2).begin();
}

::mlir::MutableOperandRange TensorScatterSubOp::tensorMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange TensorScatterSubOp::indicesMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange TensorScatterSubOp::updatesMutable() {
  auto range = getODSOperandIndexAndLength(2);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> TensorScatterSubOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range TensorScatterSubOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value TensorScatterSubOp::output() {
  return *getODSResults(0).begin();
}

Type TensorScatterSubOp::Tindices() {
  return mlir::getElementTypeOrSelf(*getODSOperands(1).begin());
}

Type TensorScatterSubOp::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

bool TensorScatterSubOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "Tindices") return true;
  if (name == "T") return true;
 return false;
}

::mlir::DictionaryAttr TensorScatterSubOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("Tindices", ctx),
::mlir::TypeAttr::get(Tindices())},
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())}
    }, ctx);
}

void TensorScatterSubOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value tensor, ::mlir::Value indices, ::mlir::Value updates) {
  odsState.addOperands(tensor);
  odsState.addOperands(indices);
  odsState.addOperands(updates);
  odsState.addTypes(output);
}

void TensorScatterSubOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value tensor, ::mlir::Value indices, ::mlir::Value updates) {
  odsState.addOperands(tensor);
  odsState.addOperands(indices);
  odsState.addOperands(updates);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void TensorScatterSubOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 3u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult TensorScatterSubOp::verify() {
  if (failed(TensorScatterSubOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>())))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::TensorFlowType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of tf.dtype values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of 32/64-bit signed integer values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup2 = getODSOperands(2);
    for (::mlir::Value v : valueGroup2) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>())))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::TensorFlowType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of tf.dtype values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>())))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::TensorFlowType>()))))) {
        return emitOpError("result #") << index << " must be tensor of tf.dtype values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void TensorScatterSubOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::TensorScatterUpdateOp definitions
//===----------------------------------------------------------------------===//

TensorScatterUpdateOpAdaptor::TensorScatterUpdateOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

TensorScatterUpdateOpAdaptor::TensorScatterUpdateOpAdaptor(TensorScatterUpdateOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> TensorScatterUpdateOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange TensorScatterUpdateOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value TensorScatterUpdateOpAdaptor::tensor() {
  return *getODSOperands(0).begin();
}

::mlir::Value TensorScatterUpdateOpAdaptor::indices() {
  return *getODSOperands(1).begin();
}

::mlir::Value TensorScatterUpdateOpAdaptor::updates() {
  return *getODSOperands(2).begin();
}

::mlir::LogicalResult TensorScatterUpdateOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

::llvm::StringRef TensorScatterUpdateOp::getOperationName() {
  return "tf.TensorScatterUpdate";
}

std::pair<unsigned, unsigned> TensorScatterUpdateOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range TensorScatterUpdateOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value TensorScatterUpdateOp::tensor() {
  return *getODSOperands(0).begin();
}

::mlir::Value TensorScatterUpdateOp::indices() {
  return *getODSOperands(1).begin();
}

::mlir::Value TensorScatterUpdateOp::updates() {
  return *getODSOperands(2).begin();
}

::mlir::MutableOperandRange TensorScatterUpdateOp::tensorMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange TensorScatterUpdateOp::indicesMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange TensorScatterUpdateOp::updatesMutable() {
  auto range = getODSOperandIndexAndLength(2);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> TensorScatterUpdateOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range TensorScatterUpdateOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value TensorScatterUpdateOp::output() {
  return *getODSResults(0).begin();
}

Type TensorScatterUpdateOp::Tindices() {
  return mlir::getElementTypeOrSelf(*getODSOperands(1).begin());
}

Type TensorScatterUpdateOp::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

bool TensorScatterUpdateOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "Tindices") return true;
  if (name == "T") return true;
 return false;
}

::mlir::DictionaryAttr TensorScatterUpdateOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("Tindices", ctx),
::mlir::TypeAttr::get(Tindices())},
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())}
    }, ctx);
}

void TensorScatterUpdateOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, Value tensor, Value indices, Value updates) {
build(odsBuilder, odsState, tensor.getType(), tensor, indices, updates);
}

void TensorScatterUpdateOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value tensor, ::mlir::Value indices, ::mlir::Value updates) {
  odsState.addOperands(tensor);
  odsState.addOperands(indices);
  odsState.addOperands(updates);
  odsState.addTypes(output);
}

void TensorScatterUpdateOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value tensor, ::mlir::Value indices, ::mlir::Value updates) {
  odsState.addOperands(tensor);
  odsState.addOperands(indices);
  odsState.addOperands(updates);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void TensorScatterUpdateOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 3u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult TensorScatterUpdateOp::verify() {
  if (failed(TensorScatterUpdateOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>())))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::TensorFlowType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of tf.dtype values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of 32/64-bit signed integer values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup2 = getODSOperands(2);
    for (::mlir::Value v : valueGroup2) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>())))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::TensorFlowType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of tf.dtype values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>())))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::TensorFlowType>()))))) {
        return emitOpError("result #") << index << " must be tensor of tf.dtype values, but got " << v.getType();
      }
      ++index;
    }
  }
  return Verify(*this);
}

void TensorScatterUpdateOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::TensorSliceDatasetOp definitions
//===----------------------------------------------------------------------===//

TensorSliceDatasetOpAdaptor::TensorSliceDatasetOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

TensorSliceDatasetOpAdaptor::TensorSliceDatasetOpAdaptor(TensorSliceDatasetOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> TensorSliceDatasetOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  bool isVariadic[] = {true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (odsOperands.size() - 0) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::mlir::ValueRange TensorSliceDatasetOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::ValueRange TensorSliceDatasetOpAdaptor::components() {
  return getODSOperands(0);
}

::mlir::ArrayAttr TensorSliceDatasetOpAdaptor::output_shapes() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::ArrayAttr attr = odsAttrs.get("output_shapes").cast<::mlir::ArrayAttr>();
  return attr;
}

::mlir::LogicalResult TensorSliceDatasetOpAdaptor::verify(::mlir::Location loc) {
  {
  auto tblgen_output_shapes = odsAttrs.get("output_shapes");
  if (!tblgen_output_shapes) return emitError(loc, "'tf.TensorSliceDataset' op ""requires attribute 'output_shapes'");
    if (!((((tblgen_output_shapes.isa<::mlir::ArrayAttr>())) && (::llvm::all_of(tblgen_output_shapes.cast<::mlir::ArrayAttr>(), [](::mlir::Attribute attr) { return (attr.isa<mlir::TF::ShapeAttr>()); }))) && ((tblgen_output_shapes.cast<::mlir::ArrayAttr>().size() >= 1)))) return emitError(loc, "'tf.TensorSliceDataset' op ""attribute 'output_shapes' failed to satisfy constraint: tensorflow shape attribute array with at least 1 elements");
  }
  return ::mlir::success();
}

::llvm::StringRef TensorSliceDatasetOp::getOperationName() {
  return "tf.TensorSliceDataset";
}

std::pair<unsigned, unsigned> TensorSliceDatasetOp::getODSOperandIndexAndLength(unsigned index) {
  bool isVariadic[] = {true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (getOperation()->getNumOperands() - 0) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::mlir::Operation::operand_range TensorSliceDatasetOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Operation::operand_range TensorSliceDatasetOp::components() {
  return getODSOperands(0);
}

::mlir::MutableOperandRange TensorSliceDatasetOp::componentsMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> TensorSliceDatasetOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range TensorSliceDatasetOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value TensorSliceDatasetOp::handle() {
  return *getODSResults(0).begin();
}

::mlir::ArrayAttr TensorSliceDatasetOp::output_shapesAttr() {
  return this->getAttr("output_shapes").cast<::mlir::ArrayAttr>();
}

::mlir::ArrayAttr TensorSliceDatasetOp::output_shapes() {
  auto attr = output_shapesAttr();
  return attr;
}

mlir::OperandElementTypeRange TensorSliceDatasetOp::Toutput_types() {
  auto values = getODSOperands(0);
return {mlir::OperandElementTypeIterator(values.begin()), mlir::OperandElementTypeIterator(values.end())};
}

bool TensorSliceDatasetOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "Toutput_types") return true;
 return false;
}

::mlir::DictionaryAttr TensorSliceDatasetOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("Toutput_types", ctx),
ArrayAttr::get(
    [&]() {
      llvm::SmallVector<Attribute, 4> ret;
      for (auto t : Toutput_types())
        ret.push_back(TypeAttr::get(t));
      return ret;
    }(), ctx)}
    }, ctx);
}

void TensorSliceDatasetOp::output_shapesAttr(::mlir::ArrayAttr attr) {
  this->getOperation()->setAttr("output_shapes", attr);
}

void TensorSliceDatasetOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type handle, ::mlir::ValueRange components, ::mlir::ArrayAttr output_shapes) {
  odsState.addOperands(components);
  odsState.addAttribute("output_shapes", output_shapes);
  odsState.addTypes(handle);
}

void TensorSliceDatasetOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange components, ::mlir::ArrayAttr output_shapes) {
  odsState.addOperands(components);
  odsState.addAttribute("output_shapes", output_shapes);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void TensorSliceDatasetOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult TensorSliceDatasetOp::verify() {
  if (failed(TensorSliceDatasetOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>())))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::TensorFlowType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of tf.dtype values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::VariantType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::VariantRefType>()))))) {
        return emitOpError("result #") << index << " must be tensor of variant values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::TensorStridedSliceUpdateOp definitions
//===----------------------------------------------------------------------===//

TensorStridedSliceUpdateOpAdaptor::TensorStridedSliceUpdateOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

TensorStridedSliceUpdateOpAdaptor::TensorStridedSliceUpdateOpAdaptor(TensorStridedSliceUpdateOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> TensorStridedSliceUpdateOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange TensorStridedSliceUpdateOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value TensorStridedSliceUpdateOpAdaptor::input() {
  return *getODSOperands(0).begin();
}

::mlir::Value TensorStridedSliceUpdateOpAdaptor::begin() {
  return *getODSOperands(1).begin();
}

::mlir::Value TensorStridedSliceUpdateOpAdaptor::end() {
  return *getODSOperands(2).begin();
}

::mlir::Value TensorStridedSliceUpdateOpAdaptor::strides() {
  return *getODSOperands(3).begin();
}

::mlir::Value TensorStridedSliceUpdateOpAdaptor::value() {
  return *getODSOperands(4).begin();
}

::mlir::IntegerAttr TensorStridedSliceUpdateOpAdaptor::begin_mask() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::IntegerAttr attr = odsAttrs.get("begin_mask").dyn_cast_or_null<::mlir::IntegerAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getIntegerAttr(::mlir::Builder(odsAttrs.getContext()).getIntegerType(64), 0);
  return attr;
}

::mlir::IntegerAttr TensorStridedSliceUpdateOpAdaptor::end_mask() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::IntegerAttr attr = odsAttrs.get("end_mask").dyn_cast_or_null<::mlir::IntegerAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getIntegerAttr(::mlir::Builder(odsAttrs.getContext()).getIntegerType(64), 0);
  return attr;
}

::mlir::IntegerAttr TensorStridedSliceUpdateOpAdaptor::ellipsis_mask() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::IntegerAttr attr = odsAttrs.get("ellipsis_mask").dyn_cast_or_null<::mlir::IntegerAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getIntegerAttr(::mlir::Builder(odsAttrs.getContext()).getIntegerType(64), 0);
  return attr;
}

::mlir::IntegerAttr TensorStridedSliceUpdateOpAdaptor::new_axis_mask() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::IntegerAttr attr = odsAttrs.get("new_axis_mask").dyn_cast_or_null<::mlir::IntegerAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getIntegerAttr(::mlir::Builder(odsAttrs.getContext()).getIntegerType(64), 0);
  return attr;
}

::mlir::IntegerAttr TensorStridedSliceUpdateOpAdaptor::shrink_axis_mask() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::IntegerAttr attr = odsAttrs.get("shrink_axis_mask").dyn_cast_or_null<::mlir::IntegerAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getIntegerAttr(::mlir::Builder(odsAttrs.getContext()).getIntegerType(64), 0);
  return attr;
}

::mlir::LogicalResult TensorStridedSliceUpdateOpAdaptor::verify(::mlir::Location loc) {
  {
  auto tblgen_begin_mask = odsAttrs.get("begin_mask");
  if (tblgen_begin_mask) {
    if (!(((tblgen_begin_mask.isa<::mlir::IntegerAttr>())) && ((tblgen_begin_mask.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(64))))) return emitError(loc, "'tf.TensorStridedSliceUpdate' op ""attribute 'begin_mask' failed to satisfy constraint: 64-bit signless integer attribute");
  }
  }
  {
  auto tblgen_end_mask = odsAttrs.get("end_mask");
  if (tblgen_end_mask) {
    if (!(((tblgen_end_mask.isa<::mlir::IntegerAttr>())) && ((tblgen_end_mask.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(64))))) return emitError(loc, "'tf.TensorStridedSliceUpdate' op ""attribute 'end_mask' failed to satisfy constraint: 64-bit signless integer attribute");
  }
  }
  {
  auto tblgen_ellipsis_mask = odsAttrs.get("ellipsis_mask");
  if (tblgen_ellipsis_mask) {
    if (!(((tblgen_ellipsis_mask.isa<::mlir::IntegerAttr>())) && ((tblgen_ellipsis_mask.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(64))))) return emitError(loc, "'tf.TensorStridedSliceUpdate' op ""attribute 'ellipsis_mask' failed to satisfy constraint: 64-bit signless integer attribute");
  }
  }
  {
  auto tblgen_new_axis_mask = odsAttrs.get("new_axis_mask");
  if (tblgen_new_axis_mask) {
    if (!(((tblgen_new_axis_mask.isa<::mlir::IntegerAttr>())) && ((tblgen_new_axis_mask.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(64))))) return emitError(loc, "'tf.TensorStridedSliceUpdate' op ""attribute 'new_axis_mask' failed to satisfy constraint: 64-bit signless integer attribute");
  }
  }
  {
  auto tblgen_shrink_axis_mask = odsAttrs.get("shrink_axis_mask");
  if (tblgen_shrink_axis_mask) {
    if (!(((tblgen_shrink_axis_mask.isa<::mlir::IntegerAttr>())) && ((tblgen_shrink_axis_mask.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(64))))) return emitError(loc, "'tf.TensorStridedSliceUpdate' op ""attribute 'shrink_axis_mask' failed to satisfy constraint: 64-bit signless integer attribute");
  }
  }
  return ::mlir::success();
}

::llvm::StringRef TensorStridedSliceUpdateOp::getOperationName() {
  return "tf.TensorStridedSliceUpdate";
}

std::pair<unsigned, unsigned> TensorStridedSliceUpdateOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range TensorStridedSliceUpdateOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value TensorStridedSliceUpdateOp::input() {
  return *getODSOperands(0).begin();
}

::mlir::Value TensorStridedSliceUpdateOp::begin() {
  return *getODSOperands(1).begin();
}

::mlir::Value TensorStridedSliceUpdateOp::end() {
  return *getODSOperands(2).begin();
}

::mlir::Value TensorStridedSliceUpdateOp::strides() {
  return *getODSOperands(3).begin();
}

::mlir::Value TensorStridedSliceUpdateOp::value() {
  return *getODSOperands(4).begin();
}

::mlir::MutableOperandRange TensorStridedSliceUpdateOp::inputMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange TensorStridedSliceUpdateOp::beginMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange TensorStridedSliceUpdateOp::endMutable() {
  auto range = getODSOperandIndexAndLength(2);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange TensorStridedSliceUpdateOp::stridesMutable() {
  auto range = getODSOperandIndexAndLength(3);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange TensorStridedSliceUpdateOp::valueMutable() {
  auto range = getODSOperandIndexAndLength(4);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> TensorStridedSliceUpdateOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range TensorStridedSliceUpdateOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value TensorStridedSliceUpdateOp::output() {
  return *getODSResults(0).begin();
}

::mlir::IntegerAttr TensorStridedSliceUpdateOp::begin_maskAttr() {
  return this->getAttr("begin_mask").dyn_cast_or_null<::mlir::IntegerAttr>();
}

uint64_t TensorStridedSliceUpdateOp::begin_mask() {
  auto attr = begin_maskAttr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getIntegerAttr(::mlir::Builder(this->getContext()).getIntegerType(64), 0).getValue().getZExtValue();
  return attr.getValue().getZExtValue();
}

::mlir::IntegerAttr TensorStridedSliceUpdateOp::end_maskAttr() {
  return this->getAttr("end_mask").dyn_cast_or_null<::mlir::IntegerAttr>();
}

uint64_t TensorStridedSliceUpdateOp::end_mask() {
  auto attr = end_maskAttr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getIntegerAttr(::mlir::Builder(this->getContext()).getIntegerType(64), 0).getValue().getZExtValue();
  return attr.getValue().getZExtValue();
}

::mlir::IntegerAttr TensorStridedSliceUpdateOp::ellipsis_maskAttr() {
  return this->getAttr("ellipsis_mask").dyn_cast_or_null<::mlir::IntegerAttr>();
}

uint64_t TensorStridedSliceUpdateOp::ellipsis_mask() {
  auto attr = ellipsis_maskAttr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getIntegerAttr(::mlir::Builder(this->getContext()).getIntegerType(64), 0).getValue().getZExtValue();
  return attr.getValue().getZExtValue();
}

::mlir::IntegerAttr TensorStridedSliceUpdateOp::new_axis_maskAttr() {
  return this->getAttr("new_axis_mask").dyn_cast_or_null<::mlir::IntegerAttr>();
}

uint64_t TensorStridedSliceUpdateOp::new_axis_mask() {
  auto attr = new_axis_maskAttr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getIntegerAttr(::mlir::Builder(this->getContext()).getIntegerType(64), 0).getValue().getZExtValue();
  return attr.getValue().getZExtValue();
}

::mlir::IntegerAttr TensorStridedSliceUpdateOp::shrink_axis_maskAttr() {
  return this->getAttr("shrink_axis_mask").dyn_cast_or_null<::mlir::IntegerAttr>();
}

uint64_t TensorStridedSliceUpdateOp::shrink_axis_mask() {
  auto attr = shrink_axis_maskAttr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getIntegerAttr(::mlir::Builder(this->getContext()).getIntegerType(64), 0).getValue().getZExtValue();
  return attr.getValue().getZExtValue();
}

Type TensorStridedSliceUpdateOp::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

Type TensorStridedSliceUpdateOp::Index() {
  return mlir::getElementTypeOrSelf(*getODSOperands(1).begin());
}

bool TensorStridedSliceUpdateOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "T") return true;
  if (name == "Index") return true;
 return false;
}

::mlir::DictionaryAttr TensorStridedSliceUpdateOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())},
    {::mlir::Identifier::get("Index", ctx),
::mlir::TypeAttr::get(Index())}
    }, ctx);
}

void TensorStridedSliceUpdateOp::begin_maskAttr(::mlir::IntegerAttr attr) {
  this->getOperation()->setAttr("begin_mask", attr);
}

void TensorStridedSliceUpdateOp::end_maskAttr(::mlir::IntegerAttr attr) {
  this->getOperation()->setAttr("end_mask", attr);
}

void TensorStridedSliceUpdateOp::ellipsis_maskAttr(::mlir::IntegerAttr attr) {
  this->getOperation()->setAttr("ellipsis_mask", attr);
}

void TensorStridedSliceUpdateOp::new_axis_maskAttr(::mlir::IntegerAttr attr) {
  this->getOperation()->setAttr("new_axis_mask", attr);
}

void TensorStridedSliceUpdateOp::shrink_axis_maskAttr(::mlir::IntegerAttr attr) {
  this->getOperation()->setAttr("shrink_axis_mask", attr);
}

void TensorStridedSliceUpdateOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value input, ::mlir::Value begin, ::mlir::Value end, ::mlir::Value strides, ::mlir::Value value, ::mlir::IntegerAttr begin_mask, ::mlir::IntegerAttr end_mask, ::mlir::IntegerAttr ellipsis_mask, ::mlir::IntegerAttr new_axis_mask, ::mlir::IntegerAttr shrink_axis_mask) {
  odsState.addOperands(input);
  odsState.addOperands(begin);
  odsState.addOperands(end);
  odsState.addOperands(strides);
  odsState.addOperands(value);
  odsState.addAttribute("begin_mask", begin_mask);
  odsState.addAttribute("end_mask", end_mask);
  odsState.addAttribute("ellipsis_mask", ellipsis_mask);
  odsState.addAttribute("new_axis_mask", new_axis_mask);
  odsState.addAttribute("shrink_axis_mask", shrink_axis_mask);
  odsState.addTypes(output);
}

void TensorStridedSliceUpdateOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input, ::mlir::Value begin, ::mlir::Value end, ::mlir::Value strides, ::mlir::Value value, ::mlir::IntegerAttr begin_mask, ::mlir::IntegerAttr end_mask, ::mlir::IntegerAttr ellipsis_mask, ::mlir::IntegerAttr new_axis_mask, ::mlir::IntegerAttr shrink_axis_mask) {
  odsState.addOperands(input);
  odsState.addOperands(begin);
  odsState.addOperands(end);
  odsState.addOperands(strides);
  odsState.addOperands(value);
  odsState.addAttribute("begin_mask", begin_mask);
  odsState.addAttribute("end_mask", end_mask);
  odsState.addAttribute("ellipsis_mask", ellipsis_mask);
  odsState.addAttribute("new_axis_mask", new_axis_mask);
  odsState.addAttribute("shrink_axis_mask", shrink_axis_mask);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void TensorStridedSliceUpdateOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value input, ::mlir::Value begin, ::mlir::Value end, ::mlir::Value strides, ::mlir::Value value, uint64_t begin_mask, uint64_t end_mask, uint64_t ellipsis_mask, uint64_t new_axis_mask, uint64_t shrink_axis_mask) {
  odsState.addOperands(input);
  odsState.addOperands(begin);
  odsState.addOperands(end);
  odsState.addOperands(strides);
  odsState.addOperands(value);
  odsState.addAttribute("begin_mask", odsBuilder.getIntegerAttr(odsBuilder.getIntegerType(64), begin_mask));
  odsState.addAttribute("end_mask", odsBuilder.getIntegerAttr(odsBuilder.getIntegerType(64), end_mask));
  odsState.addAttribute("ellipsis_mask", odsBuilder.getIntegerAttr(odsBuilder.getIntegerType(64), ellipsis_mask));
  odsState.addAttribute("new_axis_mask", odsBuilder.getIntegerAttr(odsBuilder.getIntegerType(64), new_axis_mask));
  odsState.addAttribute("shrink_axis_mask", odsBuilder.getIntegerAttr(odsBuilder.getIntegerType(64), shrink_axis_mask));
  odsState.addTypes(output);
}

void TensorStridedSliceUpdateOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input, ::mlir::Value begin, ::mlir::Value end, ::mlir::Value strides, ::mlir::Value value, uint64_t begin_mask, uint64_t end_mask, uint64_t ellipsis_mask, uint64_t new_axis_mask, uint64_t shrink_axis_mask) {
  odsState.addOperands(input);
  odsState.addOperands(begin);
  odsState.addOperands(end);
  odsState.addOperands(strides);
  odsState.addOperands(value);
  odsState.addAttribute("begin_mask", odsBuilder.getIntegerAttr(odsBuilder.getIntegerType(64), begin_mask));
  odsState.addAttribute("end_mask", odsBuilder.getIntegerAttr(odsBuilder.getIntegerType(64), end_mask));
  odsState.addAttribute("ellipsis_mask", odsBuilder.getIntegerAttr(odsBuilder.getIntegerType(64), ellipsis_mask));
  odsState.addAttribute("new_axis_mask", odsBuilder.getIntegerAttr(odsBuilder.getIntegerType(64), new_axis_mask));
  odsState.addAttribute("shrink_axis_mask", odsBuilder.getIntegerAttr(odsBuilder.getIntegerType(64), shrink_axis_mask));
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void TensorStridedSliceUpdateOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 5u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult TensorStridedSliceUpdateOp::verify() {
  if (failed(TensorStridedSliceUpdateOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>())))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::TensorFlowType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of tf.dtype values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of 32/64-bit signed integer values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup2 = getODSOperands(2);
    for (::mlir::Value v : valueGroup2) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of 32/64-bit signed integer values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup3 = getODSOperands(3);
    for (::mlir::Value v : valueGroup3) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of 32/64-bit signed integer values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup4 = getODSOperands(4);
    for (::mlir::Value v : valueGroup4) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>())))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::TensorFlowType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of tf.dtype values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>())))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::TensorFlowType>()))))) {
        return emitOpError("result #") << index << " must be tensor of tf.dtype values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void TensorStridedSliceUpdateOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::TileOp definitions
//===----------------------------------------------------------------------===//

TileOpAdaptor::TileOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

TileOpAdaptor::TileOpAdaptor(TileOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> TileOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange TileOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value TileOpAdaptor::input() {
  return *getODSOperands(0).begin();
}

::mlir::Value TileOpAdaptor::multiples() {
  return *getODSOperands(1).begin();
}

::mlir::LogicalResult TileOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

::llvm::StringRef TileOp::getOperationName() {
  return "tf.Tile";
}

std::pair<unsigned, unsigned> TileOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range TileOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value TileOp::input() {
  return *getODSOperands(0).begin();
}

::mlir::Value TileOp::multiples() {
  return *getODSOperands(1).begin();
}

::mlir::MutableOperandRange TileOp::inputMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange TileOp::multiplesMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> TileOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range TileOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value TileOp::output() {
  return *getODSResults(0).begin();
}

Type TileOp::Tmultiples() {
  return mlir::getElementTypeOrSelf(*getODSOperands(1).begin());
}

Type TileOp::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

bool TileOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "Tmultiples") return true;
  if (name == "T") return true;
 return false;
}

::mlir::DictionaryAttr TileOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("Tmultiples", ctx),
::mlir::TypeAttr::get(Tmultiples())},
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())}
    }, ctx);
}

void TileOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value input, ::mlir::Value multiples) {
  odsState.addOperands(input);
  odsState.addOperands(multiples);
  odsState.addTypes(output);
}

void TileOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input, ::mlir::Value multiples) {
  odsState.addOperands(input);
  odsState.addOperands(multiples);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void TileOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult TileOp::verify() {
  if (failed(TileOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>())))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::TensorFlowType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of tf.dtype values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of 32/64-bit signed integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>())))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::TensorFlowType>()))))) {
        return emitOpError("result #") << index << " must be tensor of tf.dtype values, but got " << v.getType();
      }
      ++index;
    }
  }
  return Verify(*this);
}



void TileOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::ToBoolOp definitions
//===----------------------------------------------------------------------===//

ToBoolOpAdaptor::ToBoolOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

ToBoolOpAdaptor::ToBoolOpAdaptor(ToBoolOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> ToBoolOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange ToBoolOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value ToBoolOpAdaptor::input() {
  return *getODSOperands(0).begin();
}

::mlir::LogicalResult ToBoolOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

::llvm::StringRef ToBoolOp::getOperationName() {
  return "tf.ToBool";
}

std::pair<unsigned, unsigned> ToBoolOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range ToBoolOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value ToBoolOp::input() {
  return *getODSOperands(0).begin();
}

::mlir::MutableOperandRange ToBoolOp::inputMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> ToBoolOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range ToBoolOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value ToBoolOp::output() {
  return *getODSResults(0).begin();
}

Type ToBoolOp::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

bool ToBoolOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "T") return true;
 return false;
}

::mlir::DictionaryAttr ToBoolOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())}
    }, ctx);
}

void ToBoolOp::build(OpBuilder &builder, OperationState &result, Value value) {
      build(builder, result, RankedTensorType::get({}, builder.getI1Type()),
            value);
    
}

void ToBoolOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value input) {
  odsState.addOperands(input);
  odsState.addTypes(output);
}

void ToBoolOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input) {
  odsState.addOperands(input);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void ToBoolOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult ToBoolOp::verify() {
  if (failed(ToBoolOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>())))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::TensorFlowType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of tf.dtype values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!((((v.getType().isa<::mlir::TensorType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1)))) && (((v.getType().cast<::mlir::ShapedType>().hasRank())) && ((v.getType().cast<::mlir::ShapedType>().getRank()
                         == 0))))) {
        return emitOpError("result #") << index << " must be 0D tensor of 1-bit signless integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}



void ToBoolOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::TopKV2Op definitions
//===----------------------------------------------------------------------===//

TopKV2OpAdaptor::TopKV2OpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

TopKV2OpAdaptor::TopKV2OpAdaptor(TopKV2Op&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> TopKV2OpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange TopKV2OpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value TopKV2OpAdaptor::input() {
  return *getODSOperands(0).begin();
}

::mlir::Value TopKV2OpAdaptor::k() {
  return *getODSOperands(1).begin();
}

::mlir::BoolAttr TopKV2OpAdaptor::sorted() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::BoolAttr attr = odsAttrs.get("sorted").dyn_cast_or_null<::mlir::BoolAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getBoolAttr(true);
  return attr;
}

::mlir::LogicalResult TopKV2OpAdaptor::verify(::mlir::Location loc) {
  {
  auto tblgen_sorted = odsAttrs.get("sorted");
  if (tblgen_sorted) {
    if (!((tblgen_sorted.isa<::mlir::BoolAttr>()))) return emitError(loc, "'tf.TopKV2' op ""attribute 'sorted' failed to satisfy constraint: bool attribute");
  }
  }
  return ::mlir::success();
}

void TopKV2Op::getAsmResultNames(::mlir::OpAsmSetValueNameFn setNameFn) {
  auto resultGroup0 = getODSResults(0);
  if (!llvm::empty(resultGroup0))
    setNameFn(*resultGroup0.begin(), "values");
  auto resultGroup1 = getODSResults(1);
  if (!llvm::empty(resultGroup1))
    setNameFn(*resultGroup1.begin(), "indices");
}

::llvm::StringRef TopKV2Op::getOperationName() {
  return "tf.TopKV2";
}

std::pair<unsigned, unsigned> TopKV2Op::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range TopKV2Op::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value TopKV2Op::input() {
  return *getODSOperands(0).begin();
}

::mlir::Value TopKV2Op::k() {
  return *getODSOperands(1).begin();
}

::mlir::MutableOperandRange TopKV2Op::inputMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange TopKV2Op::kMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> TopKV2Op::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range TopKV2Op::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value TopKV2Op::values() {
  return *getODSResults(0).begin();
}

::mlir::Value TopKV2Op::indices() {
  return *getODSResults(1).begin();
}

::mlir::BoolAttr TopKV2Op::sortedAttr() {
  return this->getAttr("sorted").dyn_cast_or_null<::mlir::BoolAttr>();
}

bool TopKV2Op::sorted() {
  auto attr = sortedAttr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getBoolAttr(true).getValue();
  return attr.getValue();
}

Type TopKV2Op::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

bool TopKV2Op::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "T") return true;
 return false;
}

::mlir::DictionaryAttr TopKV2Op::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())}
    }, ctx);
}

void TopKV2Op::sortedAttr(::mlir::BoolAttr attr) {
  this->getOperation()->setAttr("sorted", attr);
}

void TopKV2Op::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type values, ::mlir::Type indices, ::mlir::Value input, ::mlir::Value k, ::mlir::BoolAttr sorted) {
  odsState.addOperands(input);
  odsState.addOperands(k);
  odsState.addAttribute("sorted", sorted);
  odsState.addTypes(values);
  odsState.addTypes(indices);
}

void TopKV2Op::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input, ::mlir::Value k, ::mlir::BoolAttr sorted) {
  odsState.addOperands(input);
  odsState.addOperands(k);
  odsState.addAttribute("sorted", sorted);
  assert(resultTypes.size() == 2u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void TopKV2Op::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type values, ::mlir::Type indices, ::mlir::Value input, ::mlir::Value k, bool sorted) {
  odsState.addOperands(input);
  odsState.addOperands(k);
  odsState.addAttribute("sorted", odsBuilder.getBoolAttr(sorted));
  odsState.addTypes(values);
  odsState.addTypes(indices);
}

void TopKV2Op::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input, ::mlir::Value k, bool sorted) {
  odsState.addOperands(input);
  odsState.addOperands(k);
  odsState.addAttribute("sorted", odsBuilder.getBoolAttr(sorted));
  assert(resultTypes.size() == 2u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void TopKV2Op::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 2u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult TopKV2Op::verify() {
  if (failed(TopKV2OpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of integer or floating-point values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of 32-bit integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>())))))) {
        return emitOpError("result #") << index << " must be tensor of integer or floating-point values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSResults(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))))) {
        return emitOpError("result #") << index << " must be tensor of 32-bit integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  return Verify(*this);
}

void TopKV2Op::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::TransposeOp definitions
//===----------------------------------------------------------------------===//

TransposeOpAdaptor::TransposeOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

TransposeOpAdaptor::TransposeOpAdaptor(TransposeOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> TransposeOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange TransposeOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value TransposeOpAdaptor::x() {
  return *getODSOperands(0).begin();
}

::mlir::Value TransposeOpAdaptor::perm() {
  return *getODSOperands(1).begin();
}

::mlir::LogicalResult TransposeOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

::llvm::StringRef TransposeOp::getOperationName() {
  return "tf.Transpose";
}

std::pair<unsigned, unsigned> TransposeOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range TransposeOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value TransposeOp::x() {
  return *getODSOperands(0).begin();
}

::mlir::Value TransposeOp::perm() {
  return *getODSOperands(1).begin();
}

::mlir::MutableOperandRange TransposeOp::xMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange TransposeOp::permMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> TransposeOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range TransposeOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value TransposeOp::y() {
  return *getODSResults(0).begin();
}

Type TransposeOp::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

Type TransposeOp::Tperm() {
  return mlir::getElementTypeOrSelf(*getODSOperands(1).begin());
}

bool TransposeOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "T") return true;
  if (name == "Tperm") return true;
 return false;
}

::mlir::DictionaryAttr TransposeOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())},
    {::mlir::Identifier::get("Tperm", ctx),
::mlir::TypeAttr::get(Tperm())}
    }, ctx);
}



void TransposeOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type y, ::mlir::Value x, ::mlir::Value perm) {
  odsState.addOperands(x);
  odsState.addOperands(perm);
  odsState.addTypes(y);
}

void TransposeOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value x, ::mlir::Value perm) {
  odsState.addOperands(x);
  odsState.addOperands(perm);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void TransposeOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult TransposeOp::verify() {
  if (failed(TransposeOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>())))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::TensorFlowType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of tf.dtype values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of 32/64-bit signed integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>())))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::TensorFlowType>()))))) {
        return emitOpError("result #") << index << " must be tensor of tf.dtype values, but got " << v.getType();
      }
      ++index;
    }
  }
  return Verify(*this);
}



void TransposeOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::TridiagonalSolveOp definitions
//===----------------------------------------------------------------------===//

TridiagonalSolveOpAdaptor::TridiagonalSolveOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

TridiagonalSolveOpAdaptor::TridiagonalSolveOpAdaptor(TridiagonalSolveOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> TridiagonalSolveOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange TridiagonalSolveOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value TridiagonalSolveOpAdaptor::diagonals() {
  return *getODSOperands(0).begin();
}

::mlir::Value TridiagonalSolveOpAdaptor::rhs() {
  return *getODSOperands(1).begin();
}

::mlir::BoolAttr TridiagonalSolveOpAdaptor::partial_pivoting() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::BoolAttr attr = odsAttrs.get("partial_pivoting").dyn_cast_or_null<::mlir::BoolAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getBoolAttr(true);
  return attr;
}

::mlir::LogicalResult TridiagonalSolveOpAdaptor::verify(::mlir::Location loc) {
  {
  auto tblgen_partial_pivoting = odsAttrs.get("partial_pivoting");
  if (tblgen_partial_pivoting) {
    if (!((tblgen_partial_pivoting.isa<::mlir::BoolAttr>()))) return emitError(loc, "'tf.TridiagonalSolve' op ""attribute 'partial_pivoting' failed to satisfy constraint: bool attribute");
  }
  }
  return ::mlir::success();
}

::llvm::StringRef TridiagonalSolveOp::getOperationName() {
  return "tf.TridiagonalSolve";
}

std::pair<unsigned, unsigned> TridiagonalSolveOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range TridiagonalSolveOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value TridiagonalSolveOp::diagonals() {
  return *getODSOperands(0).begin();
}

::mlir::Value TridiagonalSolveOp::rhs() {
  return *getODSOperands(1).begin();
}

::mlir::MutableOperandRange TridiagonalSolveOp::diagonalsMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange TridiagonalSolveOp::rhsMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> TridiagonalSolveOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range TridiagonalSolveOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value TridiagonalSolveOp::output() {
  return *getODSResults(0).begin();
}

::mlir::BoolAttr TridiagonalSolveOp::partial_pivotingAttr() {
  return this->getAttr("partial_pivoting").dyn_cast_or_null<::mlir::BoolAttr>();
}

bool TridiagonalSolveOp::partial_pivoting() {
  auto attr = partial_pivotingAttr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getBoolAttr(true).getValue();
  return attr.getValue();
}

Type TridiagonalSolveOp::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

bool TridiagonalSolveOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "T") return true;
 return false;
}

::mlir::DictionaryAttr TridiagonalSolveOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())}
    }, ctx);
}

void TridiagonalSolveOp::partial_pivotingAttr(::mlir::BoolAttr attr) {
  this->getOperation()->setAttr("partial_pivoting", attr);
}

void TridiagonalSolveOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value diagonals, ::mlir::Value rhs, ::mlir::BoolAttr partial_pivoting) {
  odsState.addOperands(diagonals);
  odsState.addOperands(rhs);
  odsState.addAttribute("partial_pivoting", partial_pivoting);
  odsState.addTypes(output);
}

void TridiagonalSolveOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value diagonals, ::mlir::Value rhs, ::mlir::BoolAttr partial_pivoting) {
  odsState.addOperands(diagonals);
  odsState.addOperands(rhs);
  odsState.addAttribute("partial_pivoting", partial_pivoting);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void TridiagonalSolveOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value diagonals, ::mlir::Value rhs, bool partial_pivoting) {
  odsState.addOperands(diagonals);
  odsState.addOperands(rhs);
  odsState.addAttribute("partial_pivoting", odsBuilder.getBoolAttr(partial_pivoting));
  odsState.addTypes(output);
}

void TridiagonalSolveOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value diagonals, ::mlir::Value rhs, bool partial_pivoting) {
  odsState.addOperands(diagonals);
  odsState.addOperands(rhs);
  odsState.addAttribute("partial_pivoting", odsBuilder.getBoolAttr(partial_pivoting));
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void TridiagonalSolveOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult TridiagonalSolveOp::verify() {
  if (failed(TridiagonalSolveOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of 128-bit complex or 64-bit complex or 32-bit float or 64-bit float values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of 128-bit complex or 64-bit complex or 32-bit float or 64-bit float values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())))))) {
        return emitOpError("result #") << index << " must be tensor of 128-bit complex or 64-bit complex or 32-bit float or 64-bit float values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void TridiagonalSolveOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::TruncateDivOp definitions
//===----------------------------------------------------------------------===//

TruncateDivOpAdaptor::TruncateDivOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

TruncateDivOpAdaptor::TruncateDivOpAdaptor(TruncateDivOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> TruncateDivOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange TruncateDivOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value TruncateDivOpAdaptor::x() {
  return *getODSOperands(0).begin();
}

::mlir::Value TruncateDivOpAdaptor::y() {
  return *getODSOperands(1).begin();
}

::mlir::LogicalResult TruncateDivOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

::llvm::StringRef TruncateDivOp::getOperationName() {
  return "tf.TruncateDiv";
}

std::pair<unsigned, unsigned> TruncateDivOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range TruncateDivOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value TruncateDivOp::x() {
  return *getODSOperands(0).begin();
}

::mlir::Value TruncateDivOp::y() {
  return *getODSOperands(1).begin();
}

::mlir::MutableOperandRange TruncateDivOp::xMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange TruncateDivOp::yMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> TruncateDivOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range TruncateDivOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value TruncateDivOp::z() {
  return *getODSResults(0).begin();
}

Type TruncateDivOp::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

bool TruncateDivOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "T") return true;
 return false;
}

::mlir::DictionaryAttr TruncateDivOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())}
    }, ctx);
}

void TruncateDivOp::build(OpBuilder &builder, OperationState &result, Value  x, Value  y) {
  auto resultType =
      OpTrait::util::getBroadcastedType(x.getType(), y.getType());
  if (!resultType)
    mlir::emitError(result.location, "non-broadcastable operands");
  return build(builder, result, resultType, x, y);
}

void TruncateDivOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type z, ::mlir::Value x, ::mlir::Value y) {
  odsState.addOperands(x);
  odsState.addOperands(y);
  odsState.addTypes(z);
}

void TruncateDivOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value x, ::mlir::Value y) {
  odsState.addOperands(x);
  odsState.addOperands(y);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void TruncateDivOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult TruncateDivOp::verify() {
  if (failed(TruncateDivOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of bfloat16 or 128-bit complex or 64-bit complex or 16-bit float or 32-bit float or 64-bit float or 16-bit integer or 32-bit integer or 64-bit integer or 8-bit integer or 16-bit unsigned integer or 8-bit unsigned integer values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of bfloat16 or 128-bit complex or 64-bit complex or 16-bit float or 32-bit float or 64-bit float or 16-bit integer or 32-bit integer or 64-bit integer or 8-bit integer or 16-bit unsigned integer or 8-bit unsigned integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>())))))) {
        return emitOpError("result #") << index << " must be tensor of bfloat16 or 128-bit complex or 64-bit complex or 16-bit float or 32-bit float or 64-bit float or 16-bit integer or 32-bit integer or 64-bit integer or 8-bit integer or 16-bit unsigned integer or 8-bit unsigned integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}



void TruncateDivOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::TruncateModOp definitions
//===----------------------------------------------------------------------===//

TruncateModOpAdaptor::TruncateModOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

TruncateModOpAdaptor::TruncateModOpAdaptor(TruncateModOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> TruncateModOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange TruncateModOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value TruncateModOpAdaptor::x() {
  return *getODSOperands(0).begin();
}

::mlir::Value TruncateModOpAdaptor::y() {
  return *getODSOperands(1).begin();
}

::mlir::LogicalResult TruncateModOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

::llvm::StringRef TruncateModOp::getOperationName() {
  return "tf.TruncateMod";
}

std::pair<unsigned, unsigned> TruncateModOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range TruncateModOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value TruncateModOp::x() {
  return *getODSOperands(0).begin();
}

::mlir::Value TruncateModOp::y() {
  return *getODSOperands(1).begin();
}

::mlir::MutableOperandRange TruncateModOp::xMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange TruncateModOp::yMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> TruncateModOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range TruncateModOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value TruncateModOp::z() {
  return *getODSResults(0).begin();
}

Type TruncateModOp::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

bool TruncateModOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "T") return true;
 return false;
}

::mlir::DictionaryAttr TruncateModOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())}
    }, ctx);
}

void TruncateModOp::build(OpBuilder &builder, OperationState &result, Value  x, Value  y) {
  auto resultType =
      OpTrait::util::getBroadcastedType(x.getType(), y.getType());
  if (!resultType)
    mlir::emitError(result.location, "non-broadcastable operands");
  return build(builder, result, resultType, x, y);
}

void TruncateModOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type z, ::mlir::Value x, ::mlir::Value y) {
  odsState.addOperands(x);
  odsState.addOperands(y);
  odsState.addTypes(z);
}

void TruncateModOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value x, ::mlir::Value y) {
  odsState.addOperands(x);
  odsState.addOperands(y);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void TruncateModOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult TruncateModOp::verify() {
  if (failed(TruncateModOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of floating-point or 32/64-bit signed integer values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of floating-point or 32/64-bit signed integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))))) {
        return emitOpError("result #") << index << " must be tensor of floating-point or 32/64-bit signed integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void TruncateModOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::TruncatedNormalOp definitions
//===----------------------------------------------------------------------===//

TruncatedNormalOpAdaptor::TruncatedNormalOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

TruncatedNormalOpAdaptor::TruncatedNormalOpAdaptor(TruncatedNormalOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> TruncatedNormalOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange TruncatedNormalOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value TruncatedNormalOpAdaptor::shape() {
  return *getODSOperands(0).begin();
}

::mlir::IntegerAttr TruncatedNormalOpAdaptor::seed() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::IntegerAttr attr = odsAttrs.get("seed").dyn_cast_or_null<::mlir::IntegerAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getIntegerAttr(::mlir::Builder(odsAttrs.getContext()).getIntegerType(64), 0);
  return attr;
}

::mlir::IntegerAttr TruncatedNormalOpAdaptor::seed2() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::IntegerAttr attr = odsAttrs.get("seed2").dyn_cast_or_null<::mlir::IntegerAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getIntegerAttr(::mlir::Builder(odsAttrs.getContext()).getIntegerType(64), 0);
  return attr;
}

::mlir::LogicalResult TruncatedNormalOpAdaptor::verify(::mlir::Location loc) {
  {
  auto tblgen_seed = odsAttrs.get("seed");
  if (tblgen_seed) {
    if (!(((tblgen_seed.isa<::mlir::IntegerAttr>())) && ((tblgen_seed.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(64))))) return emitError(loc, "'tf.TruncatedNormal' op ""attribute 'seed' failed to satisfy constraint: 64-bit signless integer attribute");
  }
  }
  {
  auto tblgen_seed2 = odsAttrs.get("seed2");
  if (tblgen_seed2) {
    if (!(((tblgen_seed2.isa<::mlir::IntegerAttr>())) && ((tblgen_seed2.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(64))))) return emitError(loc, "'tf.TruncatedNormal' op ""attribute 'seed2' failed to satisfy constraint: 64-bit signless integer attribute");
  }
  }
  return ::mlir::success();
}

::llvm::StringRef TruncatedNormalOp::getOperationName() {
  return "tf.TruncatedNormal";
}

std::pair<unsigned, unsigned> TruncatedNormalOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range TruncatedNormalOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value TruncatedNormalOp::shape() {
  return *getODSOperands(0).begin();
}

::mlir::MutableOperandRange TruncatedNormalOp::shapeMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> TruncatedNormalOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range TruncatedNormalOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value TruncatedNormalOp::output() {
  return *getODSResults(0).begin();
}

::mlir::IntegerAttr TruncatedNormalOp::seedAttr() {
  return this->getAttr("seed").dyn_cast_or_null<::mlir::IntegerAttr>();
}

uint64_t TruncatedNormalOp::seed() {
  auto attr = seedAttr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getIntegerAttr(::mlir::Builder(this->getContext()).getIntegerType(64), 0).getValue().getZExtValue();
  return attr.getValue().getZExtValue();
}

::mlir::IntegerAttr TruncatedNormalOp::seed2Attr() {
  return this->getAttr("seed2").dyn_cast_or_null<::mlir::IntegerAttr>();
}

uint64_t TruncatedNormalOp::seed2() {
  auto attr = seed2Attr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getIntegerAttr(::mlir::Builder(this->getContext()).getIntegerType(64), 0).getValue().getZExtValue();
  return attr.getValue().getZExtValue();
}

Type TruncatedNormalOp::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

Type TruncatedNormalOp::dtype() {
  return mlir::getElementTypeOrSelf(*getODSResults(0).begin());
}

bool TruncatedNormalOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "T") return true;
  if (name == "dtype") return true;
 return false;
}

::mlir::DictionaryAttr TruncatedNormalOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())},
    {::mlir::Identifier::get("dtype", ctx),
::mlir::TypeAttr::get(dtype())}
    }, ctx);
}

void TruncatedNormalOp::seedAttr(::mlir::IntegerAttr attr) {
  this->getOperation()->setAttr("seed", attr);
}

void TruncatedNormalOp::seed2Attr(::mlir::IntegerAttr attr) {
  this->getOperation()->setAttr("seed2", attr);
}

void TruncatedNormalOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value shape, ::mlir::IntegerAttr seed, ::mlir::IntegerAttr seed2) {
  odsState.addOperands(shape);
  odsState.addAttribute("seed", seed);
  odsState.addAttribute("seed2", seed2);
  odsState.addTypes(output);
}

void TruncatedNormalOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value shape, ::mlir::IntegerAttr seed, ::mlir::IntegerAttr seed2) {
  odsState.addOperands(shape);
  odsState.addAttribute("seed", seed);
  odsState.addAttribute("seed2", seed2);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void TruncatedNormalOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value shape, uint64_t seed, uint64_t seed2) {
  odsState.addOperands(shape);
  odsState.addAttribute("seed", odsBuilder.getIntegerAttr(odsBuilder.getIntegerType(64), seed));
  odsState.addAttribute("seed2", odsBuilder.getIntegerAttr(odsBuilder.getIntegerType(64), seed2));
  odsState.addTypes(output);
}

void TruncatedNormalOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value shape, uint64_t seed, uint64_t seed2) {
  odsState.addOperands(shape);
  odsState.addAttribute("seed", odsBuilder.getIntegerAttr(odsBuilder.getIntegerType(64), seed));
  odsState.addAttribute("seed2", odsBuilder.getIntegerAttr(odsBuilder.getIntegerType(64), seed2));
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void TruncatedNormalOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult TruncatedNormalOp::verify() {
  if (failed(TruncatedNormalOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of 32/64-bit signed integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))))) {
        return emitOpError("result #") << index << " must be tensor of floating-point values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::UniqueOp definitions
//===----------------------------------------------------------------------===//

UniqueOpAdaptor::UniqueOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

UniqueOpAdaptor::UniqueOpAdaptor(UniqueOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> UniqueOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange UniqueOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value UniqueOpAdaptor::x() {
  return *getODSOperands(0).begin();
}

::mlir::LogicalResult UniqueOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

void UniqueOp::getAsmResultNames(::mlir::OpAsmSetValueNameFn setNameFn) {
  auto resultGroup0 = getODSResults(0);
  if (!llvm::empty(resultGroup0))
    setNameFn(*resultGroup0.begin(), "y");
  auto resultGroup1 = getODSResults(1);
  if (!llvm::empty(resultGroup1))
    setNameFn(*resultGroup1.begin(), "idx");
}

::llvm::StringRef UniqueOp::getOperationName() {
  return "tf.Unique";
}

std::pair<unsigned, unsigned> UniqueOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range UniqueOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value UniqueOp::x() {
  return *getODSOperands(0).begin();
}

::mlir::MutableOperandRange UniqueOp::xMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> UniqueOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range UniqueOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value UniqueOp::y() {
  return *getODSResults(0).begin();
}

::mlir::Value UniqueOp::idx() {
  return *getODSResults(1).begin();
}

Type UniqueOp::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

Type UniqueOp::out_idx() {
  return mlir::getElementTypeOrSelf(*getODSResults(1).begin());
}

bool UniqueOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "T") return true;
  if (name == "out_idx") return true;
 return false;
}

::mlir::DictionaryAttr UniqueOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())},
    {::mlir::Identifier::get("out_idx", ctx),
::mlir::TypeAttr::get(out_idx())}
    }, ctx);
}

void UniqueOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type y, ::mlir::Type idx, ::mlir::Value x) {
  odsState.addOperands(x);
  odsState.addTypes(y);
  odsState.addTypes(idx);
}

void UniqueOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value x) {
  odsState.addOperands(x);
  assert(resultTypes.size() == 2u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void UniqueOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 2u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult UniqueOp::verify() {
  if (failed(UniqueOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>())))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::TensorFlowType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of tf.dtype values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>())))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::TensorFlowType>()))))) {
        return emitOpError("result #") << index << " must be tensor of tf.dtype values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSResults(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))))) {
        return emitOpError("result #") << index << " must be tensor of 32/64-bit signed integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void UniqueOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::UnpackOp definitions
//===----------------------------------------------------------------------===//

UnpackOpAdaptor::UnpackOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

UnpackOpAdaptor::UnpackOpAdaptor(UnpackOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> UnpackOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange UnpackOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value UnpackOpAdaptor::value() {
  return *getODSOperands(0).begin();
}

::mlir::IntegerAttr UnpackOpAdaptor::axis() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::IntegerAttr attr = odsAttrs.get("axis").dyn_cast_or_null<::mlir::IntegerAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getIntegerAttr(::mlir::Builder(odsAttrs.getContext()).getIntegerType(64), 0);
  return attr;
}

::mlir::LogicalResult UnpackOpAdaptor::verify(::mlir::Location loc) {
  {
  auto tblgen_axis = odsAttrs.get("axis");
  if (tblgen_axis) {
    if (!(((tblgen_axis.isa<::mlir::IntegerAttr>())) && ((tblgen_axis.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(64))))) return emitError(loc, "'tf.Unpack' op ""attribute 'axis' failed to satisfy constraint: 64-bit signless integer attribute");
  }
  }
  return ::mlir::success();
}

::llvm::StringRef UnpackOp::getOperationName() {
  return "tf.Unpack";
}

std::pair<unsigned, unsigned> UnpackOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range UnpackOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value UnpackOp::value() {
  return *getODSOperands(0).begin();
}

::mlir::MutableOperandRange UnpackOp::valueMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> UnpackOp::getODSResultIndexAndLength(unsigned index) {
  bool isVariadic[] = {true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (getOperation()->getNumResults() - 0) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::mlir::Operation::result_range UnpackOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Operation::result_range UnpackOp::output() {
  return getODSResults(0);
}

::mlir::IntegerAttr UnpackOp::axisAttr() {
  return this->getAttr("axis").dyn_cast_or_null<::mlir::IntegerAttr>();
}

uint64_t UnpackOp::axis() {
  auto attr = axisAttr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getIntegerAttr(::mlir::Builder(this->getContext()).getIntegerType(64), 0).getValue().getZExtValue();
  return attr.getValue().getZExtValue();
}

size_t UnpackOp::num() {
  auto range = getODSResults(0);
return std::distance(range.begin(), range.end());
}

Type UnpackOp::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

bool UnpackOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "num") return true;
  if (name == "T") return true;
 return false;
}

::mlir::DictionaryAttr UnpackOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("num", ctx),
odsBuilder.getI64IntegerAttr(num())},
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())}
    }, ctx);
}

void UnpackOp::axisAttr(::mlir::IntegerAttr attr) {
  this->getOperation()->setAttr("axis", attr);
}

void UnpackOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange output, ::mlir::Value value, ::mlir::IntegerAttr axis) {
  odsState.addOperands(value);
  odsState.addAttribute("axis", axis);
  odsState.addTypes(output);
}

void UnpackOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange output, ::mlir::Value value, uint64_t axis) {
  odsState.addOperands(value);
  odsState.addAttribute("axis", odsBuilder.getIntegerAttr(odsBuilder.getIntegerType(64), axis));
  odsState.addTypes(output);
}

void UnpackOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult UnpackOp::verify() {
  if (failed(UnpackOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>())))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::TensorFlowType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of tf.dtype values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>())))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::TensorFlowType>()))))) {
        return emitOpError("result #") << index << " must be tensor of tf.dtype values, but got " << v.getType();
      }
      ++index;
    }
  }
  return Verify(*this);
}

void UnpackOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::UnsortedSegmentMaxOp definitions
//===----------------------------------------------------------------------===//

UnsortedSegmentMaxOpAdaptor::UnsortedSegmentMaxOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

UnsortedSegmentMaxOpAdaptor::UnsortedSegmentMaxOpAdaptor(UnsortedSegmentMaxOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> UnsortedSegmentMaxOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange UnsortedSegmentMaxOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value UnsortedSegmentMaxOpAdaptor::data() {
  return *getODSOperands(0).begin();
}

::mlir::Value UnsortedSegmentMaxOpAdaptor::segment_ids() {
  return *getODSOperands(1).begin();
}

::mlir::Value UnsortedSegmentMaxOpAdaptor::num_segments() {
  return *getODSOperands(2).begin();
}

::mlir::LogicalResult UnsortedSegmentMaxOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

::llvm::StringRef UnsortedSegmentMaxOp::getOperationName() {
  return "tf.UnsortedSegmentMax";
}

std::pair<unsigned, unsigned> UnsortedSegmentMaxOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range UnsortedSegmentMaxOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value UnsortedSegmentMaxOp::data() {
  return *getODSOperands(0).begin();
}

::mlir::Value UnsortedSegmentMaxOp::segment_ids() {
  return *getODSOperands(1).begin();
}

::mlir::Value UnsortedSegmentMaxOp::num_segments() {
  return *getODSOperands(2).begin();
}

::mlir::MutableOperandRange UnsortedSegmentMaxOp::dataMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange UnsortedSegmentMaxOp::segment_idsMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange UnsortedSegmentMaxOp::num_segmentsMutable() {
  auto range = getODSOperandIndexAndLength(2);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> UnsortedSegmentMaxOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range UnsortedSegmentMaxOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value UnsortedSegmentMaxOp::output() {
  return *getODSResults(0).begin();
}

Type UnsortedSegmentMaxOp::Tindices() {
  return mlir::getElementTypeOrSelf(*getODSOperands(1).begin());
}

Type UnsortedSegmentMaxOp::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

Type UnsortedSegmentMaxOp::Tnumsegments() {
  return mlir::getElementTypeOrSelf(*getODSOperands(2).begin());
}

bool UnsortedSegmentMaxOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "Tindices") return true;
  if (name == "T") return true;
  if (name == "Tnumsegments") return true;
 return false;
}

::mlir::DictionaryAttr UnsortedSegmentMaxOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("Tindices", ctx),
::mlir::TypeAttr::get(Tindices())},
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())},
    {::mlir::Identifier::get("Tnumsegments", ctx),
::mlir::TypeAttr::get(Tnumsegments())}
    }, ctx);
}

void UnsortedSegmentMaxOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value data, ::mlir::Value segment_ids, ::mlir::Value num_segments) {
  odsState.addOperands(data);
  odsState.addOperands(segment_ids);
  odsState.addOperands(num_segments);
  odsState.addTypes(output);
}

void UnsortedSegmentMaxOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value data, ::mlir::Value segment_ids, ::mlir::Value num_segments) {
  odsState.addOperands(data);
  odsState.addOperands(segment_ids);
  odsState.addOperands(num_segments);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void UnsortedSegmentMaxOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 3u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult UnsortedSegmentMaxOp::verify() {
  if (failed(UnsortedSegmentMaxOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of integer or floating-point values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of 32/64-bit signed integer values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup2 = getODSOperands(2);
    for (::mlir::Value v : valueGroup2) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of 32/64-bit signed integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>())))))) {
        return emitOpError("result #") << index << " must be tensor of integer or floating-point values, but got " << v.getType();
      }
      ++index;
    }
  }
  return VerifyUnsortedSegmentReduction(*this);
}

void UnsortedSegmentMaxOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::UnsortedSegmentMinOp definitions
//===----------------------------------------------------------------------===//

UnsortedSegmentMinOpAdaptor::UnsortedSegmentMinOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

UnsortedSegmentMinOpAdaptor::UnsortedSegmentMinOpAdaptor(UnsortedSegmentMinOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> UnsortedSegmentMinOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange UnsortedSegmentMinOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value UnsortedSegmentMinOpAdaptor::data() {
  return *getODSOperands(0).begin();
}

::mlir::Value UnsortedSegmentMinOpAdaptor::segment_ids() {
  return *getODSOperands(1).begin();
}

::mlir::Value UnsortedSegmentMinOpAdaptor::num_segments() {
  return *getODSOperands(2).begin();
}

::mlir::LogicalResult UnsortedSegmentMinOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

::llvm::StringRef UnsortedSegmentMinOp::getOperationName() {
  return "tf.UnsortedSegmentMin";
}

std::pair<unsigned, unsigned> UnsortedSegmentMinOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range UnsortedSegmentMinOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value UnsortedSegmentMinOp::data() {
  return *getODSOperands(0).begin();
}

::mlir::Value UnsortedSegmentMinOp::segment_ids() {
  return *getODSOperands(1).begin();
}

::mlir::Value UnsortedSegmentMinOp::num_segments() {
  return *getODSOperands(2).begin();
}

::mlir::MutableOperandRange UnsortedSegmentMinOp::dataMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange UnsortedSegmentMinOp::segment_idsMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange UnsortedSegmentMinOp::num_segmentsMutable() {
  auto range = getODSOperandIndexAndLength(2);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> UnsortedSegmentMinOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range UnsortedSegmentMinOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value UnsortedSegmentMinOp::output() {
  return *getODSResults(0).begin();
}

Type UnsortedSegmentMinOp::Tindices() {
  return mlir::getElementTypeOrSelf(*getODSOperands(1).begin());
}

Type UnsortedSegmentMinOp::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

Type UnsortedSegmentMinOp::Tnumsegments() {
  return mlir::getElementTypeOrSelf(*getODSOperands(2).begin());
}

bool UnsortedSegmentMinOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "Tindices") return true;
  if (name == "T") return true;
  if (name == "Tnumsegments") return true;
 return false;
}

::mlir::DictionaryAttr UnsortedSegmentMinOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("Tindices", ctx),
::mlir::TypeAttr::get(Tindices())},
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())},
    {::mlir::Identifier::get("Tnumsegments", ctx),
::mlir::TypeAttr::get(Tnumsegments())}
    }, ctx);
}

void UnsortedSegmentMinOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value data, ::mlir::Value segment_ids, ::mlir::Value num_segments) {
  odsState.addOperands(data);
  odsState.addOperands(segment_ids);
  odsState.addOperands(num_segments);
  odsState.addTypes(output);
}

void UnsortedSegmentMinOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value data, ::mlir::Value segment_ids, ::mlir::Value num_segments) {
  odsState.addOperands(data);
  odsState.addOperands(segment_ids);
  odsState.addOperands(num_segments);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void UnsortedSegmentMinOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 3u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult UnsortedSegmentMinOp::verify() {
  if (failed(UnsortedSegmentMinOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of integer or floating-point values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of 32/64-bit signed integer values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup2 = getODSOperands(2);
    for (::mlir::Value v : valueGroup2) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of 32/64-bit signed integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>())))))) {
        return emitOpError("result #") << index << " must be tensor of integer or floating-point values, but got " << v.getType();
      }
      ++index;
    }
  }
  return VerifyUnsortedSegmentReduction(*this);
}

void UnsortedSegmentMinOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::UnsortedSegmentProdOp definitions
//===----------------------------------------------------------------------===//

UnsortedSegmentProdOpAdaptor::UnsortedSegmentProdOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

UnsortedSegmentProdOpAdaptor::UnsortedSegmentProdOpAdaptor(UnsortedSegmentProdOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> UnsortedSegmentProdOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange UnsortedSegmentProdOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value UnsortedSegmentProdOpAdaptor::data() {
  return *getODSOperands(0).begin();
}

::mlir::Value UnsortedSegmentProdOpAdaptor::segment_ids() {
  return *getODSOperands(1).begin();
}

::mlir::Value UnsortedSegmentProdOpAdaptor::num_segments() {
  return *getODSOperands(2).begin();
}

::mlir::LogicalResult UnsortedSegmentProdOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

::llvm::StringRef UnsortedSegmentProdOp::getOperationName() {
  return "tf.UnsortedSegmentProd";
}

std::pair<unsigned, unsigned> UnsortedSegmentProdOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range UnsortedSegmentProdOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value UnsortedSegmentProdOp::data() {
  return *getODSOperands(0).begin();
}

::mlir::Value UnsortedSegmentProdOp::segment_ids() {
  return *getODSOperands(1).begin();
}

::mlir::Value UnsortedSegmentProdOp::num_segments() {
  return *getODSOperands(2).begin();
}

::mlir::MutableOperandRange UnsortedSegmentProdOp::dataMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange UnsortedSegmentProdOp::segment_idsMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange UnsortedSegmentProdOp::num_segmentsMutable() {
  auto range = getODSOperandIndexAndLength(2);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> UnsortedSegmentProdOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range UnsortedSegmentProdOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value UnsortedSegmentProdOp::output() {
  return *getODSResults(0).begin();
}

Type UnsortedSegmentProdOp::Tindices() {
  return mlir::getElementTypeOrSelf(*getODSOperands(1).begin());
}

Type UnsortedSegmentProdOp::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

Type UnsortedSegmentProdOp::Tnumsegments() {
  return mlir::getElementTypeOrSelf(*getODSOperands(2).begin());
}

bool UnsortedSegmentProdOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "Tindices") return true;
  if (name == "T") return true;
  if (name == "Tnumsegments") return true;
 return false;
}

::mlir::DictionaryAttr UnsortedSegmentProdOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("Tindices", ctx),
::mlir::TypeAttr::get(Tindices())},
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())},
    {::mlir::Identifier::get("Tnumsegments", ctx),
::mlir::TypeAttr::get(Tnumsegments())}
    }, ctx);
}

void UnsortedSegmentProdOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value data, ::mlir::Value segment_ids, ::mlir::Value num_segments) {
  odsState.addOperands(data);
  odsState.addOperands(segment_ids);
  odsState.addOperands(num_segments);
  odsState.addTypes(output);
}

void UnsortedSegmentProdOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value data, ::mlir::Value segment_ids, ::mlir::Value num_segments) {
  odsState.addOperands(data);
  odsState.addOperands(segment_ids);
  odsState.addOperands(num_segments);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void UnsortedSegmentProdOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 3u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult UnsortedSegmentProdOp::verify() {
  if (failed(UnsortedSegmentProdOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of bfloat16 or 128-bit complex or 64-bit complex or 16-bit float or 32-bit float or 64-bit float or 16-bit integer or 32-bit integer or 64-bit integer or 8-bit integer or 32-bit quantized integer or 8-bit quantized integer or 8-bit quantized unsigned integer or 16-bit unsigned integer or 32-bit unsigned integer or 64-bit unsigned integer or 8-bit unsigned integer values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of 32/64-bit signed integer values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup2 = getODSOperands(2);
    for (::mlir::Value v : valueGroup2) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of 32/64-bit signed integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>())))))) {
        return emitOpError("result #") << index << " must be tensor of bfloat16 or 128-bit complex or 64-bit complex or 16-bit float or 32-bit float or 64-bit float or 16-bit integer or 32-bit integer or 64-bit integer or 8-bit integer or 32-bit quantized integer or 8-bit quantized integer or 8-bit quantized unsigned integer or 16-bit unsigned integer or 32-bit unsigned integer or 64-bit unsigned integer or 8-bit unsigned integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  return VerifyUnsortedSegmentReduction(*this);
}

void UnsortedSegmentProdOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::UnsortedSegmentSumOp definitions
//===----------------------------------------------------------------------===//

UnsortedSegmentSumOpAdaptor::UnsortedSegmentSumOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

UnsortedSegmentSumOpAdaptor::UnsortedSegmentSumOpAdaptor(UnsortedSegmentSumOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> UnsortedSegmentSumOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange UnsortedSegmentSumOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value UnsortedSegmentSumOpAdaptor::data() {
  return *getODSOperands(0).begin();
}

::mlir::Value UnsortedSegmentSumOpAdaptor::segment_ids() {
  return *getODSOperands(1).begin();
}

::mlir::Value UnsortedSegmentSumOpAdaptor::num_segments() {
  return *getODSOperands(2).begin();
}

::mlir::LogicalResult UnsortedSegmentSumOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

::llvm::StringRef UnsortedSegmentSumOp::getOperationName() {
  return "tf.UnsortedSegmentSum";
}

std::pair<unsigned, unsigned> UnsortedSegmentSumOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range UnsortedSegmentSumOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value UnsortedSegmentSumOp::data() {
  return *getODSOperands(0).begin();
}

::mlir::Value UnsortedSegmentSumOp::segment_ids() {
  return *getODSOperands(1).begin();
}

::mlir::Value UnsortedSegmentSumOp::num_segments() {
  return *getODSOperands(2).begin();
}

::mlir::MutableOperandRange UnsortedSegmentSumOp::dataMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange UnsortedSegmentSumOp::segment_idsMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange UnsortedSegmentSumOp::num_segmentsMutable() {
  auto range = getODSOperandIndexAndLength(2);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> UnsortedSegmentSumOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range UnsortedSegmentSumOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value UnsortedSegmentSumOp::output() {
  return *getODSResults(0).begin();
}

Type UnsortedSegmentSumOp::Tindices() {
  return mlir::getElementTypeOrSelf(*getODSOperands(1).begin());
}

Type UnsortedSegmentSumOp::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

Type UnsortedSegmentSumOp::Tnumsegments() {
  return mlir::getElementTypeOrSelf(*getODSOperands(2).begin());
}

bool UnsortedSegmentSumOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "Tindices") return true;
  if (name == "T") return true;
  if (name == "Tnumsegments") return true;
 return false;
}

::mlir::DictionaryAttr UnsortedSegmentSumOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("Tindices", ctx),
::mlir::TypeAttr::get(Tindices())},
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())},
    {::mlir::Identifier::get("Tnumsegments", ctx),
::mlir::TypeAttr::get(Tnumsegments())}
    }, ctx);
}

void UnsortedSegmentSumOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value data, ::mlir::Value segment_ids, ::mlir::Value num_segments) {
  odsState.addOperands(data);
  odsState.addOperands(segment_ids);
  odsState.addOperands(num_segments);
  odsState.addTypes(output);
}

void UnsortedSegmentSumOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value data, ::mlir::Value segment_ids, ::mlir::Value num_segments) {
  odsState.addOperands(data);
  odsState.addOperands(segment_ids);
  odsState.addOperands(num_segments);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void UnsortedSegmentSumOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 3u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult UnsortedSegmentSumOp::verify() {
  if (failed(UnsortedSegmentSumOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of bfloat16 or 128-bit complex or 64-bit complex or 16-bit float or 32-bit float or 64-bit float or 16-bit integer or 32-bit integer or 64-bit integer or 8-bit integer or 32-bit quantized integer or 8-bit quantized integer or 8-bit quantized unsigned integer or 16-bit unsigned integer or 32-bit unsigned integer or 64-bit unsigned integer or 8-bit unsigned integer values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of 32/64-bit signed integer values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup2 = getODSOperands(2);
    for (::mlir::Value v : valueGroup2) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of 32/64-bit signed integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>())))))) {
        return emitOpError("result #") << index << " must be tensor of bfloat16 or 128-bit complex or 64-bit complex or 16-bit float or 32-bit float or 64-bit float or 16-bit integer or 32-bit integer or 64-bit integer or 8-bit integer or 32-bit quantized integer or 8-bit quantized integer or 8-bit quantized unsigned integer or 16-bit unsigned integer or 32-bit unsigned integer or 64-bit unsigned integer or 8-bit unsigned integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  return VerifyUnsortedSegmentReduction(*this);
}

void UnsortedSegmentSumOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::UpperBoundOp definitions
//===----------------------------------------------------------------------===//

UpperBoundOpAdaptor::UpperBoundOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

UpperBoundOpAdaptor::UpperBoundOpAdaptor(UpperBoundOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> UpperBoundOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange UpperBoundOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value UpperBoundOpAdaptor::sorted_inputs() {
  return *getODSOperands(0).begin();
}

::mlir::Value UpperBoundOpAdaptor::values() {
  return *getODSOperands(1).begin();
}

::mlir::LogicalResult UpperBoundOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

::llvm::StringRef UpperBoundOp::getOperationName() {
  return "tf.UpperBound";
}

std::pair<unsigned, unsigned> UpperBoundOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range UpperBoundOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value UpperBoundOp::sorted_inputs() {
  return *getODSOperands(0).begin();
}

::mlir::Value UpperBoundOp::values() {
  return *getODSOperands(1).begin();
}

::mlir::MutableOperandRange UpperBoundOp::sorted_inputsMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange UpperBoundOp::valuesMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> UpperBoundOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range UpperBoundOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value UpperBoundOp::output() {
  return *getODSResults(0).begin();
}

Type UpperBoundOp::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

Type UpperBoundOp::out_type() {
  return mlir::getElementTypeOrSelf(*getODSResults(0).begin());
}

bool UpperBoundOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "T") return true;
  if (name == "out_type") return true;
 return false;
}

::mlir::DictionaryAttr UpperBoundOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())},
    {::mlir::Identifier::get("out_type", ctx),
::mlir::TypeAttr::get(out_type())}
    }, ctx);
}

void UpperBoundOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value sorted_inputs, ::mlir::Value values) {
  odsState.addOperands(sorted_inputs);
  odsState.addOperands(values);
  odsState.addTypes(output);
}

void UpperBoundOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value sorted_inputs, ::mlir::Value values) {
  odsState.addOperands(sorted_inputs);
  odsState.addOperands(values);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void UpperBoundOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult UpperBoundOp::verify() {
  if (failed(UpperBoundOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>())))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::TensorFlowType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of tf.dtype values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>())))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::TensorFlowType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of tf.dtype values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))))) {
        return emitOpError("result #") << index << " must be tensor of 32/64-bit signed integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void UpperBoundOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::VarHandleOp definitions
//===----------------------------------------------------------------------===//

VarHandleOpAdaptor::VarHandleOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

VarHandleOpAdaptor::VarHandleOpAdaptor(VarHandleOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> VarHandleOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange VarHandleOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::StringAttr VarHandleOpAdaptor::container() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::StringAttr attr = odsAttrs.get("container").cast<::mlir::StringAttr>();
  return attr;
}

::mlir::StringAttr VarHandleOpAdaptor::shared_name() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::StringAttr attr = odsAttrs.get("shared_name").cast<::mlir::StringAttr>();
  return attr;
}

::mlir::LogicalResult VarHandleOpAdaptor::verify(::mlir::Location loc) {
  {
  auto tblgen_container = odsAttrs.get("container");
  if (!tblgen_container) return emitError(loc, "'tf.VarHandleOp' op ""requires attribute 'container'");
    if (!((tblgen_container.isa<::mlir::StringAttr>()))) return emitError(loc, "'tf.VarHandleOp' op ""attribute 'container' failed to satisfy constraint: string attribute");
  }
  {
  auto tblgen_shared_name = odsAttrs.get("shared_name");
  if (!tblgen_shared_name) return emitError(loc, "'tf.VarHandleOp' op ""requires attribute 'shared_name'");
    if (!((tblgen_shared_name.isa<::mlir::StringAttr>()))) return emitError(loc, "'tf.VarHandleOp' op ""attribute 'shared_name' failed to satisfy constraint: string attribute");
  }
  return ::mlir::success();
}

::llvm::StringRef VarHandleOp::getOperationName() {
  return "tf.VarHandleOp";
}

std::pair<unsigned, unsigned> VarHandleOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range VarHandleOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

std::pair<unsigned, unsigned> VarHandleOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range VarHandleOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value VarHandleOp::resource() {
  return *getODSResults(0).begin();
}

::mlir::StringAttr VarHandleOp::containerAttr() {
  return this->getAttr("container").cast<::mlir::StringAttr>();
}

::llvm::StringRef VarHandleOp::container() {
  auto attr = containerAttr();
  return attr.getValue();
}

::mlir::StringAttr VarHandleOp::shared_nameAttr() {
  return this->getAttr("shared_name").cast<::mlir::StringAttr>();
}

::llvm::StringRef VarHandleOp::shared_name() {
  auto attr = shared_nameAttr();
  return attr.getValue();
}

Type VarHandleOp::dtype() {
  auto resource_type =
  mlir::getElementTypeOrSelf(this->resource())
  .cast<TF::ResourceType>();
assert(!resource_type.getSubtypes().empty() && "unknown type");
return mlir::getElementTypeOrSelf(*resource_type.getSubtypes().begin());
}

ShapedType VarHandleOp::shape() {
  auto resource_type =
  mlir::getElementTypeOrSelf(this->resource())
  .cast<TF::ResourceType>();
assert(!resource_type.getSubtypes().empty() && "unknown shape");
return resource_type.getSubtypes().begin()->cast<ShapedType>();
}

bool VarHandleOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "dtype") return true;
  if (name == "shape") return true;
 return false;
}

::mlir::DictionaryAttr VarHandleOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("dtype", ctx),
::mlir::TypeAttr::get(dtype())},
    {::mlir::Identifier::get("shape", ctx),
mlir::TF::ShapeAttr::get(ctx, shape())}
    }, ctx);
}

void VarHandleOp::containerAttr(::mlir::StringAttr attr) {
  this->getOperation()->setAttr("container", attr);
}

void VarHandleOp::shared_nameAttr(::mlir::StringAttr attr) {
  this->getOperation()->setAttr("shared_name", attr);
}

void VarHandleOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type resource, ::mlir::StringAttr container, ::mlir::StringAttr shared_name) {
  odsState.addAttribute("container", container);
  odsState.addAttribute("shared_name", shared_name);
  odsState.addTypes(resource);
}

void VarHandleOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::StringAttr container, ::mlir::StringAttr shared_name) {
  odsState.addAttribute("container", container);
  odsState.addAttribute("shared_name", shared_name);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void VarHandleOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type resource, ::llvm::StringRef container, ::llvm::StringRef shared_name) {
  odsState.addAttribute("container", odsBuilder.getStringAttr(container));
  odsState.addAttribute("shared_name", odsBuilder.getStringAttr(shared_name));
  odsState.addTypes(resource);
}

void VarHandleOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::llvm::StringRef container, ::llvm::StringRef shared_name) {
  odsState.addAttribute("container", odsBuilder.getStringAttr(container));
  odsState.addAttribute("shared_name", odsBuilder.getStringAttr(shared_name));
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void VarHandleOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 0u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult VarHandleOp::verify() {
  if (failed(VarHandleOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::ResourceType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::ResourceRefType>()))))) {
        return emitOpError("result #") << index << " must be tensor of resource values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void VarHandleOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
  for (::mlir::Value value : getODSResults(0))
    effects.emplace_back(MemoryEffects::Allocate::get(), value, ::mlir::TF::ResourceEffects::Variable::get());
}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::VarIsInitializedOp definitions
//===----------------------------------------------------------------------===//

VarIsInitializedOpAdaptor::VarIsInitializedOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

VarIsInitializedOpAdaptor::VarIsInitializedOpAdaptor(VarIsInitializedOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> VarIsInitializedOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange VarIsInitializedOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value VarIsInitializedOpAdaptor::resource() {
  return *getODSOperands(0).begin();
}

::mlir::LogicalResult VarIsInitializedOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

::llvm::StringRef VarIsInitializedOp::getOperationName() {
  return "tf.VarIsInitializedOp";
}

std::pair<unsigned, unsigned> VarIsInitializedOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range VarIsInitializedOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value VarIsInitializedOp::resource() {
  return *getODSOperands(0).begin();
}

::mlir::MutableOperandRange VarIsInitializedOp::resourceMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> VarIsInitializedOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range VarIsInitializedOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value VarIsInitializedOp::is_initialized() {
  return *getODSResults(0).begin();
}

void VarIsInitializedOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type is_initialized, ::mlir::Value resource) {
  odsState.addOperands(resource);
  odsState.addTypes(is_initialized);
}

void VarIsInitializedOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value resource) {
  odsState.addOperands(resource);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void VarIsInitializedOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult VarIsInitializedOp::verify() {
  if (failed(VarIsInitializedOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::ResourceType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::ResourceRefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of resource values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))))) {
        return emitOpError("result #") << index << " must be tensor of bool values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}



void VarIsInitializedOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
  for (::mlir::Value value : getODSOperands(0))
    effects.emplace_back(MemoryEffects::Read::get(), value, ::mlir::TF::ResourceEffects::Variable::get());
}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::VariableShapeOp definitions
//===----------------------------------------------------------------------===//

VariableShapeOpAdaptor::VariableShapeOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

VariableShapeOpAdaptor::VariableShapeOpAdaptor(VariableShapeOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> VariableShapeOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange VariableShapeOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value VariableShapeOpAdaptor::input() {
  return *getODSOperands(0).begin();
}

::mlir::LogicalResult VariableShapeOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

::llvm::StringRef VariableShapeOp::getOperationName() {
  return "tf.VariableShape";
}

std::pair<unsigned, unsigned> VariableShapeOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range VariableShapeOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value VariableShapeOp::input() {
  return *getODSOperands(0).begin();
}

::mlir::MutableOperandRange VariableShapeOp::inputMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> VariableShapeOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range VariableShapeOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value VariableShapeOp::output() {
  return *getODSResults(0).begin();
}

Type VariableShapeOp::out_type() {
  return mlir::getElementTypeOrSelf(*getODSResults(0).begin());
}

bool VariableShapeOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "out_type") return true;
 return false;
}

::mlir::DictionaryAttr VariableShapeOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("out_type", ctx),
::mlir::TypeAttr::get(out_type())}
    }, ctx);
}

void VariableShapeOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value input) {
  odsState.addOperands(input);
  odsState.addTypes(output);
}

void VariableShapeOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input) {
  odsState.addOperands(input);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void VariableShapeOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult VariableShapeOp::verify() {
  if (failed(VariableShapeOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::ResourceType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::ResourceRefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of resource values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))))) {
        return emitOpError("result #") << index << " must be tensor of 32/64-bit signed integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  return Verify(*this);
}



void VariableShapeOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
  for (::mlir::Value value : getODSOperands(0))
    effects.emplace_back(MemoryEffects::Read::get(), value, ::mlir::TF::ResourceEffects::Variable::get());
}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::VariableV2Op definitions
//===----------------------------------------------------------------------===//

VariableV2OpAdaptor::VariableV2OpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

VariableV2OpAdaptor::VariableV2OpAdaptor(VariableV2Op&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> VariableV2OpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange VariableV2OpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

Attribute VariableV2OpAdaptor::shape() {
  assert(odsAttrs && "no attributes when constructing adapter");
  Attribute attr = odsAttrs.get("shape").cast<Attribute>();
  return attr;
}

::mlir::StringAttr VariableV2OpAdaptor::container() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::StringAttr attr = odsAttrs.get("container").cast<::mlir::StringAttr>();
  return attr;
}

::mlir::StringAttr VariableV2OpAdaptor::shared_name() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::StringAttr attr = odsAttrs.get("shared_name").cast<::mlir::StringAttr>();
  return attr;
}

::mlir::LogicalResult VariableV2OpAdaptor::verify(::mlir::Location loc) {
  {
  auto tblgen_shape = odsAttrs.get("shape");
  if (!tblgen_shape) return emitError(loc, "'tf.VariableV2' op ""requires attribute 'shape'");
    if (!((tblgen_shape.isa<mlir::TF::ShapeAttr>()))) return emitError(loc, "'tf.VariableV2' op ""attribute 'shape' failed to satisfy constraint: TensorFlow shape attribute");
  }
  {
  auto tblgen_container = odsAttrs.get("container");
  if (!tblgen_container) return emitError(loc, "'tf.VariableV2' op ""requires attribute 'container'");
    if (!((tblgen_container.isa<::mlir::StringAttr>()))) return emitError(loc, "'tf.VariableV2' op ""attribute 'container' failed to satisfy constraint: string attribute");
  }
  {
  auto tblgen_shared_name = odsAttrs.get("shared_name");
  if (!tblgen_shared_name) return emitError(loc, "'tf.VariableV2' op ""requires attribute 'shared_name'");
    if (!((tblgen_shared_name.isa<::mlir::StringAttr>()))) return emitError(loc, "'tf.VariableV2' op ""attribute 'shared_name' failed to satisfy constraint: string attribute");
  }
  return ::mlir::success();
}

::llvm::StringRef VariableV2Op::getOperationName() {
  return "tf.VariableV2";
}

std::pair<unsigned, unsigned> VariableV2Op::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range VariableV2Op::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

std::pair<unsigned, unsigned> VariableV2Op::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range VariableV2Op::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value VariableV2Op::ref() {
  return *getODSResults(0).begin();
}

Attribute VariableV2Op::shapeAttr() {
  return this->getAttr("shape").cast<Attribute>();
}

llvm::Optional<llvm::ArrayRef<int64_t>> VariableV2Op::shape() {
  auto attr = shapeAttr();
  return attr.cast<mlir::TF::ShapeAttr>().getValue();
}

::mlir::StringAttr VariableV2Op::containerAttr() {
  return this->getAttr("container").cast<::mlir::StringAttr>();
}

::llvm::StringRef VariableV2Op::container() {
  auto attr = containerAttr();
  return attr.getValue();
}

::mlir::StringAttr VariableV2Op::shared_nameAttr() {
  return this->getAttr("shared_name").cast<::mlir::StringAttr>();
}

::llvm::StringRef VariableV2Op::shared_name() {
  auto attr = shared_nameAttr();
  return attr.getValue();
}

Type VariableV2Op::dtype() {
  return mlir::getElementTypeOrSelf(*getODSResults(0).begin());
}

bool VariableV2Op::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "dtype") return true;
 return false;
}

::mlir::DictionaryAttr VariableV2Op::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("dtype", ctx),
::mlir::TypeAttr::get(dtype())}
    }, ctx);
}

void VariableV2Op::shapeAttr(Attribute attr) {
  this->getOperation()->setAttr("shape", attr);
}

void VariableV2Op::containerAttr(::mlir::StringAttr attr) {
  this->getOperation()->setAttr("container", attr);
}

void VariableV2Op::shared_nameAttr(::mlir::StringAttr attr) {
  this->getOperation()->setAttr("shared_name", attr);
}

void VariableV2Op::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type ref, Attribute shape, ::mlir::StringAttr container, ::mlir::StringAttr shared_name) {
  odsState.addAttribute("shape", shape);
  odsState.addAttribute("container", container);
  odsState.addAttribute("shared_name", shared_name);
  odsState.addTypes(ref);
}

void VariableV2Op::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, Attribute shape, ::mlir::StringAttr container, ::mlir::StringAttr shared_name) {
  odsState.addAttribute("shape", shape);
  odsState.addAttribute("container", container);
  odsState.addAttribute("shared_name", shared_name);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void VariableV2Op::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type ref, llvm::Optional<llvm::ArrayRef<int64_t>> shape, ::llvm::StringRef container, ::llvm::StringRef shared_name) {
  odsState.addAttribute("shape", mlir::TF::ShapeAttr::get(odsBuilder.getContext(), shape));
  odsState.addAttribute("container", odsBuilder.getStringAttr(container));
  odsState.addAttribute("shared_name", odsBuilder.getStringAttr(shared_name));
  odsState.addTypes(ref);
}

void VariableV2Op::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, llvm::Optional<llvm::ArrayRef<int64_t>> shape, ::llvm::StringRef container, ::llvm::StringRef shared_name) {
  odsState.addAttribute("shape", mlir::TF::ShapeAttr::get(odsBuilder.getContext(), shape));
  odsState.addAttribute("container", odsBuilder.getStringAttr(container));
  odsState.addAttribute("shared_name", odsBuilder.getStringAttr(shared_name));
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void VariableV2Op::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 0u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult VariableV2Op::verify() {
  if (failed(VariableV2OpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>())))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::TensorFlowType>()))))) {
        return emitOpError("result #") << index << " must be tensor of tf.dtype values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::WhereOp definitions
//===----------------------------------------------------------------------===//

WhereOpAdaptor::WhereOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

WhereOpAdaptor::WhereOpAdaptor(WhereOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> WhereOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange WhereOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value WhereOpAdaptor::input() {
  return *getODSOperands(0).begin();
}

::mlir::LogicalResult WhereOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

::llvm::StringRef WhereOp::getOperationName() {
  return "tf.Where";
}

std::pair<unsigned, unsigned> WhereOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range WhereOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value WhereOp::input() {
  return *getODSOperands(0).begin();
}

::mlir::MutableOperandRange WhereOp::inputMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> WhereOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range WhereOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value WhereOp::index() {
  return *getODSResults(0).begin();
}

Type WhereOp::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

bool WhereOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "T") return true;
 return false;
}

::mlir::DictionaryAttr WhereOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())}
    }, ctx);
}

void WhereOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type index, ::mlir::Value input) {
  odsState.addOperands(input);
  odsState.addTypes(index);
}

void WhereOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input) {
  odsState.addOperands(input);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void WhereOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult WhereOp::verify() {
  if (failed(WhereOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of bfloat16 or bool or 128-bit complex or 64-bit complex or 16-bit float or 32-bit float or 64-bit float or 16-bit integer or 32-bit integer or 64-bit integer or 8-bit integer or 32-bit quantized integer or 8-bit quantized integer or 8-bit quantized unsigned integer or 16-bit unsigned integer or 32-bit unsigned integer or 64-bit unsigned integer or 8-bit unsigned integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))))) {
        return emitOpError("result #") << index << " must be tensor of 64-bit integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void WhereOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::WhileOp definitions
//===----------------------------------------------------------------------===//

WhileOpAdaptor::WhileOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

WhileOpAdaptor::WhileOpAdaptor(WhileOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> WhileOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  bool isVariadic[] = {true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (odsOperands.size() - 0) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::mlir::ValueRange WhileOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::ValueRange WhileOpAdaptor::input() {
  return getODSOperands(0);
}

::mlir::FlatSymbolRefAttr WhileOpAdaptor::cond() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::FlatSymbolRefAttr attr = odsAttrs.get("cond").cast<::mlir::FlatSymbolRefAttr>();
  return attr;
}

::mlir::FlatSymbolRefAttr WhileOpAdaptor::body() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::FlatSymbolRefAttr attr = odsAttrs.get("body").cast<::mlir::FlatSymbolRefAttr>();
  return attr;
}

::mlir::IntegerAttr WhileOpAdaptor::parallel_iterations() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::IntegerAttr attr = odsAttrs.get("parallel_iterations").dyn_cast_or_null<::mlir::IntegerAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getIntegerAttr(::mlir::Builder(odsAttrs.getContext()).getIntegerType(64), 10);
  return attr;
}

::mlir::BoolAttr WhileOpAdaptor::is_stateless() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::BoolAttr attr = odsAttrs.get("is_stateless").cast<::mlir::BoolAttr>();
  return attr;
}

::mlir::LogicalResult WhileOpAdaptor::verify(::mlir::Location loc) {
  {
  auto tblgen_cond = odsAttrs.get("cond");
  if (!tblgen_cond) return emitError(loc, "'tf.While' op ""requires attribute 'cond'");
    if (!((tblgen_cond.isa<::mlir::FlatSymbolRefAttr>()))) return emitError(loc, "'tf.While' op ""attribute 'cond' failed to satisfy constraint: flat symbol reference attribute");
  }
  {
  auto tblgen_body = odsAttrs.get("body");
  if (!tblgen_body) return emitError(loc, "'tf.While' op ""requires attribute 'body'");
    if (!((tblgen_body.isa<::mlir::FlatSymbolRefAttr>()))) return emitError(loc, "'tf.While' op ""attribute 'body' failed to satisfy constraint: flat symbol reference attribute");
  }
  {
  auto tblgen_parallel_iterations = odsAttrs.get("parallel_iterations");
  if (tblgen_parallel_iterations) {
    if (!(((tblgen_parallel_iterations.isa<::mlir::IntegerAttr>())) && ((tblgen_parallel_iterations.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(64))))) return emitError(loc, "'tf.While' op ""attribute 'parallel_iterations' failed to satisfy constraint: 64-bit signless integer attribute");
  }
  }
  {
  auto tblgen_is_stateless = odsAttrs.get("is_stateless");
  if (!tblgen_is_stateless) return emitError(loc, "'tf.While' op ""requires attribute 'is_stateless'");
    if (!((tblgen_is_stateless.isa<::mlir::BoolAttr>()))) return emitError(loc, "'tf.While' op ""attribute 'is_stateless' failed to satisfy constraint: bool attribute");
  }
  return ::mlir::success();
}

::llvm::StringRef WhileOp::getOperationName() {
  return "tf.While";
}

std::pair<unsigned, unsigned> WhileOp::getODSOperandIndexAndLength(unsigned index) {
  bool isVariadic[] = {true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (getOperation()->getNumOperands() - 0) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::mlir::Operation::operand_range WhileOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Operation::operand_range WhileOp::input() {
  return getODSOperands(0);
}

::mlir::MutableOperandRange WhileOp::inputMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> WhileOp::getODSResultIndexAndLength(unsigned index) {
  bool isVariadic[] = {true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (getOperation()->getNumResults() - 0) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::mlir::Operation::result_range WhileOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Operation::result_range WhileOp::output() {
  return getODSResults(0);
}

::mlir::FlatSymbolRefAttr WhileOp::condAttr() {
  return this->getAttr("cond").cast<::mlir::FlatSymbolRefAttr>();
}

::llvm::StringRef WhileOp::cond() {
  auto attr = condAttr();
  return attr.getValue();
}

::mlir::FlatSymbolRefAttr WhileOp::bodyAttr() {
  return this->getAttr("body").cast<::mlir::FlatSymbolRefAttr>();
}

::llvm::StringRef WhileOp::body() {
  auto attr = bodyAttr();
  return attr.getValue();
}

::mlir::IntegerAttr WhileOp::parallel_iterationsAttr() {
  return this->getAttr("parallel_iterations").dyn_cast_or_null<::mlir::IntegerAttr>();
}

uint64_t WhileOp::parallel_iterations() {
  auto attr = parallel_iterationsAttr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getIntegerAttr(::mlir::Builder(this->getContext()).getIntegerType(64), 10).getValue().getZExtValue();
  return attr.getValue().getZExtValue();
}

::mlir::BoolAttr WhileOp::is_statelessAttr() {
  return this->getAttr("is_stateless").cast<::mlir::BoolAttr>();
}

bool WhileOp::is_stateless() {
  auto attr = is_statelessAttr();
  return attr.getValue();
}

mlir::OperandElementTypeRange WhileOp::T() {
  auto values = getODSOperands(0);
return {mlir::OperandElementTypeIterator(values.begin()), mlir::OperandElementTypeIterator(values.end())};
}

mlir::TF::ResultShapeRange WhileOp::output_shapes() {
  auto values = getODSResults(0);
return {mlir::TF::ResultShapeIterator(values.begin()), mlir::TF::ResultShapeIterator(values.end())};
}

bool WhileOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "T") return true;
  if (name == "output_shapes") return true;
 return false;
}

::mlir::DictionaryAttr WhileOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("T", ctx),
ArrayAttr::get(
    [&]() {
      llvm::SmallVector<Attribute, 4> ret;
      for (auto t : T())
        ret.push_back(TypeAttr::get(t));
      return ret;
    }(), ctx)},
    {::mlir::Identifier::get("output_shapes", ctx),
ArrayAttr::get(
      [&](){
        llvm::SmallVector<Attribute, 4> ret;
        for (auto shape : output_shapes())
          ret.push_back(mlir::TF::ShapeAttr::get(ctx, shape));
        return ret;
      }(), ctx)}
    }, ctx);
}

void WhileOp::condAttr(::mlir::FlatSymbolRefAttr attr) {
  this->getOperation()->setAttr("cond", attr);
}

void WhileOp::bodyAttr(::mlir::FlatSymbolRefAttr attr) {
  this->getOperation()->setAttr("body", attr);
}

void WhileOp::parallel_iterationsAttr(::mlir::IntegerAttr attr) {
  this->getOperation()->setAttr("parallel_iterations", attr);
}

void WhileOp::is_statelessAttr(::mlir::BoolAttr attr) {
  this->getOperation()->setAttr("is_stateless", attr);
}

void WhileOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange output, ::mlir::ValueRange input, ::mlir::FlatSymbolRefAttr cond, ::mlir::FlatSymbolRefAttr body, ::mlir::IntegerAttr parallel_iterations, ::mlir::BoolAttr is_stateless) {
  odsState.addOperands(input);
  odsState.addAttribute("cond", cond);
  odsState.addAttribute("body", body);
  odsState.addAttribute("parallel_iterations", parallel_iterations);
  odsState.addAttribute("is_stateless", is_stateless);
  odsState.addTypes(output);
}

void WhileOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange output, ::mlir::ValueRange input, ::llvm::StringRef cond, ::llvm::StringRef body, uint64_t parallel_iterations, bool is_stateless) {
  odsState.addOperands(input);
  odsState.addAttribute("cond", odsBuilder.getSymbolRefAttr(cond));
  odsState.addAttribute("body", odsBuilder.getSymbolRefAttr(body));
  odsState.addAttribute("parallel_iterations", odsBuilder.getIntegerAttr(odsBuilder.getIntegerType(64), parallel_iterations));
  odsState.addAttribute("is_stateless", odsBuilder.getBoolAttr(is_stateless));
  odsState.addTypes(output);
}

void WhileOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult WhileOp::verify() {
  if (failed(WhileOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>())))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::TensorFlowType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of tf.dtype values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>())))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::TensorFlowType>()))))) {
        return emitOpError("result #") << index << " must be tensor of tf.dtype values, but got " << v.getType();
      }
      ++index;
    }
  }
  return Verify(*this);
}



} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::WhileRegionOp definitions
//===----------------------------------------------------------------------===//

WhileRegionOpAdaptor::WhileRegionOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

WhileRegionOpAdaptor::WhileRegionOpAdaptor(WhileRegionOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> WhileRegionOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  bool isVariadic[] = {true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (odsOperands.size() - 0) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::mlir::ValueRange WhileRegionOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::ValueRange WhileRegionOpAdaptor::input() {
  return getODSOperands(0);
}

::mlir::BoolAttr WhileRegionOpAdaptor::is_stateless() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::BoolAttr attr = odsAttrs.get("is_stateless").dyn_cast_or_null<::mlir::BoolAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getBoolAttr(false);
  return attr;
}

::mlir::IntegerAttr WhileRegionOpAdaptor::parallel_iterations() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::IntegerAttr attr = odsAttrs.get("parallel_iterations").dyn_cast_or_null<::mlir::IntegerAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getIntegerAttr(::mlir::Builder(odsAttrs.getContext()).getIntegerType(64), 10);
  return attr;
}

::mlir::LogicalResult WhileRegionOpAdaptor::verify(::mlir::Location loc) {
  {
  auto tblgen_is_stateless = odsAttrs.get("is_stateless");
  if (tblgen_is_stateless) {
    if (!((tblgen_is_stateless.isa<::mlir::BoolAttr>()))) return emitError(loc, "'tf.WhileRegion' op ""attribute 'is_stateless' failed to satisfy constraint: bool attribute");
  }
  }
  {
  auto tblgen_parallel_iterations = odsAttrs.get("parallel_iterations");
  if (tblgen_parallel_iterations) {
    if (!(((tblgen_parallel_iterations.isa<::mlir::IntegerAttr>())) && ((tblgen_parallel_iterations.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(64))))) return emitError(loc, "'tf.WhileRegion' op ""attribute 'parallel_iterations' failed to satisfy constraint: 64-bit signless integer attribute");
  }
  }
  return ::mlir::success();
}

::llvm::StringRef WhileRegionOp::getOperationName() {
  return "tf.WhileRegion";
}

std::pair<unsigned, unsigned> WhileRegionOp::getODSOperandIndexAndLength(unsigned index) {
  bool isVariadic[] = {true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (getOperation()->getNumOperands() - 0) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::mlir::Operation::operand_range WhileRegionOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Operation::operand_range WhileRegionOp::input() {
  return getODSOperands(0);
}

::mlir::MutableOperandRange WhileRegionOp::inputMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> WhileRegionOp::getODSResultIndexAndLength(unsigned index) {
  bool isVariadic[] = {true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (getOperation()->getNumResults() - 0) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::mlir::Operation::result_range WhileRegionOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Operation::result_range WhileRegionOp::output() {
  return getODSResults(0);
}

::mlir::Region &WhileRegionOp::cond() {
  return this->getOperation()->getRegion(0);
}

::mlir::Region &WhileRegionOp::body() {
  return this->getOperation()->getRegion(1);
}

::mlir::BoolAttr WhileRegionOp::is_statelessAttr() {
  return this->getAttr("is_stateless").dyn_cast_or_null<::mlir::BoolAttr>();
}

bool WhileRegionOp::is_stateless() {
  auto attr = is_statelessAttr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getBoolAttr(false).getValue();
  return attr.getValue();
}

::mlir::IntegerAttr WhileRegionOp::parallel_iterationsAttr() {
  return this->getAttr("parallel_iterations").dyn_cast_or_null<::mlir::IntegerAttr>();
}

uint64_t WhileRegionOp::parallel_iterations() {
  auto attr = parallel_iterationsAttr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getIntegerAttr(::mlir::Builder(this->getContext()).getIntegerType(64), 10).getValue().getZExtValue();
  return attr.getValue().getZExtValue();
}

void WhileRegionOp::is_statelessAttr(::mlir::BoolAttr attr) {
  this->getOperation()->setAttr("is_stateless", attr);
}

void WhileRegionOp::parallel_iterationsAttr(::mlir::IntegerAttr attr) {
  this->getOperation()->setAttr("parallel_iterations", attr);
}

void WhileRegionOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange output, ::mlir::ValueRange input, ::mlir::BoolAttr is_stateless, ::mlir::IntegerAttr parallel_iterations) {
  odsState.addOperands(input);
  odsState.addAttribute("is_stateless", is_stateless);
  odsState.addAttribute("parallel_iterations", parallel_iterations);
  (void)odsState.addRegion();
  (void)odsState.addRegion();
  odsState.addTypes(output);
}

void WhileRegionOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange output, ::mlir::ValueRange input, bool is_stateless, uint64_t parallel_iterations) {
  odsState.addOperands(input);
  odsState.addAttribute("is_stateless", odsBuilder.getBoolAttr(is_stateless));
  odsState.addAttribute("parallel_iterations", odsBuilder.getIntegerAttr(odsBuilder.getIntegerType(64), parallel_iterations));
  (void)odsState.addRegion();
  (void)odsState.addRegion();
  odsState.addTypes(output);
}

void WhileRegionOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  for (unsigned i = 0; i != 2; ++i)
    (void)odsState.addRegion();
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult WhileRegionOp::verify() {
  if (failed(WhileRegionOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((true)))) {
        return emitOpError("operand #") << index << " must be tensor of any type values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((true)))) {
        return emitOpError("result #") << index << " must be tensor of any type values, but got " << v.getType();
      }
      ++index;
    }
  }
{
    unsigned index = 0; (void)index;
    for (::mlir::Region &region : ::mlir::MutableArrayRef<::mlir::Region>(this->getOperation()->getRegion(0))) {
      (void)region;
      if (!((::llvm::hasNItems(region, 1)))) {
        return emitOpError("region #") << index << " ('cond') failed to verify constraint: region with 1 blocks";
      }
      ++index;
    }
    for (::mlir::Region &region : ::mlir::MutableArrayRef<::mlir::Region>(this->getOperation()->getRegion(1))) {
      (void)region;
      if (!((::llvm::hasNItems(region, 1)))) {
        return emitOpError("region #") << index << " ('body') failed to verify constraint: region with 1 blocks";
      }
      ++index;
    }
  }
  return Verify(*this);
}









} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::WriteAudioSummaryOp definitions
//===----------------------------------------------------------------------===//

WriteAudioSummaryOpAdaptor::WriteAudioSummaryOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

WriteAudioSummaryOpAdaptor::WriteAudioSummaryOpAdaptor(WriteAudioSummaryOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> WriteAudioSummaryOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange WriteAudioSummaryOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value WriteAudioSummaryOpAdaptor::writer() {
  return *getODSOperands(0).begin();
}

::mlir::Value WriteAudioSummaryOpAdaptor::step() {
  return *getODSOperands(1).begin();
}

::mlir::Value WriteAudioSummaryOpAdaptor::tag() {
  return *getODSOperands(2).begin();
}

::mlir::Value WriteAudioSummaryOpAdaptor::tensor() {
  return *getODSOperands(3).begin();
}

::mlir::Value WriteAudioSummaryOpAdaptor::sample_rate() {
  return *getODSOperands(4).begin();
}

::mlir::IntegerAttr WriteAudioSummaryOpAdaptor::max_outputs() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::IntegerAttr attr = odsAttrs.get("max_outputs").dyn_cast_or_null<::mlir::IntegerAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getIntegerAttr(::mlir::Builder(odsAttrs.getContext()).getIntegerType(64), 3);
  return attr;
}

::mlir::LogicalResult WriteAudioSummaryOpAdaptor::verify(::mlir::Location loc) {
  {
  auto tblgen_max_outputs = odsAttrs.get("max_outputs");
  if (tblgen_max_outputs) {
    if (!((((tblgen_max_outputs.isa<::mlir::IntegerAttr>())) && ((tblgen_max_outputs.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(64)))) && ((tblgen_max_outputs.cast<::mlir::IntegerAttr>().getInt() >= 1)))) return emitError(loc, "'tf.WriteAudioSummary' op ""attribute 'max_outputs' failed to satisfy constraint: 64-bit signless integer attribute whose minimum value is 1");
  }
  }
  return ::mlir::success();
}

::llvm::StringRef WriteAudioSummaryOp::getOperationName() {
  return "tf.WriteAudioSummary";
}

std::pair<unsigned, unsigned> WriteAudioSummaryOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range WriteAudioSummaryOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value WriteAudioSummaryOp::writer() {
  return *getODSOperands(0).begin();
}

::mlir::Value WriteAudioSummaryOp::step() {
  return *getODSOperands(1).begin();
}

::mlir::Value WriteAudioSummaryOp::tag() {
  return *getODSOperands(2).begin();
}

::mlir::Value WriteAudioSummaryOp::tensor() {
  return *getODSOperands(3).begin();
}

::mlir::Value WriteAudioSummaryOp::sample_rate() {
  return *getODSOperands(4).begin();
}

::mlir::MutableOperandRange WriteAudioSummaryOp::writerMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange WriteAudioSummaryOp::stepMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange WriteAudioSummaryOp::tagMutable() {
  auto range = getODSOperandIndexAndLength(2);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange WriteAudioSummaryOp::tensorMutable() {
  auto range = getODSOperandIndexAndLength(3);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange WriteAudioSummaryOp::sample_rateMutable() {
  auto range = getODSOperandIndexAndLength(4);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> WriteAudioSummaryOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range WriteAudioSummaryOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::IntegerAttr WriteAudioSummaryOp::max_outputsAttr() {
  return this->getAttr("max_outputs").dyn_cast_or_null<::mlir::IntegerAttr>();
}

uint64_t WriteAudioSummaryOp::max_outputs() {
  auto attr = max_outputsAttr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getIntegerAttr(::mlir::Builder(this->getContext()).getIntegerType(64), 3).getValue().getZExtValue();
  return attr.getValue().getZExtValue();
}

void WriteAudioSummaryOp::max_outputsAttr(::mlir::IntegerAttr attr) {
  this->getOperation()->setAttr("max_outputs", attr);
}

void WriteAudioSummaryOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value writer, ::mlir::Value step, ::mlir::Value tag, ::mlir::Value tensor, ::mlir::Value sample_rate, ::mlir::IntegerAttr max_outputs) {
  odsState.addOperands(writer);
  odsState.addOperands(step);
  odsState.addOperands(tag);
  odsState.addOperands(tensor);
  odsState.addOperands(sample_rate);
  odsState.addAttribute("max_outputs", max_outputs);
}

void WriteAudioSummaryOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value writer, ::mlir::Value step, ::mlir::Value tag, ::mlir::Value tensor, ::mlir::Value sample_rate, ::mlir::IntegerAttr max_outputs) {
  odsState.addOperands(writer);
  odsState.addOperands(step);
  odsState.addOperands(tag);
  odsState.addOperands(tensor);
  odsState.addOperands(sample_rate);
  odsState.addAttribute("max_outputs", max_outputs);
  assert(resultTypes.size() == 0u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void WriteAudioSummaryOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value writer, ::mlir::Value step, ::mlir::Value tag, ::mlir::Value tensor, ::mlir::Value sample_rate, uint64_t max_outputs) {
  odsState.addOperands(writer);
  odsState.addOperands(step);
  odsState.addOperands(tag);
  odsState.addOperands(tensor);
  odsState.addOperands(sample_rate);
  odsState.addAttribute("max_outputs", odsBuilder.getIntegerAttr(odsBuilder.getIntegerType(64), max_outputs));
}

void WriteAudioSummaryOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value writer, ::mlir::Value step, ::mlir::Value tag, ::mlir::Value tensor, ::mlir::Value sample_rate, uint64_t max_outputs) {
  odsState.addOperands(writer);
  odsState.addOperands(step);
  odsState.addOperands(tag);
  odsState.addOperands(tensor);
  odsState.addOperands(sample_rate);
  odsState.addAttribute("max_outputs", odsBuilder.getIntegerAttr(odsBuilder.getIntegerType(64), max_outputs));
  assert(resultTypes.size() == 0u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void WriteAudioSummaryOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 5u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 0u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult WriteAudioSummaryOp::verify() {
  if (failed(WriteAudioSummaryOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::ResourceType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::ResourceRefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of resource values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of 64-bit integer values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup2 = getODSOperands(2);
    for (::mlir::Value v : valueGroup2) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::StringType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::StringRefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of string values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup3 = getODSOperands(3);
    for (::mlir::Value v : valueGroup3) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of 32-bit float values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup4 = getODSOperands(4);
    for (::mlir::Value v : valueGroup4) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of 32-bit float values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
  }
  return ::mlir::success();
}

void WriteAudioSummaryOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
  for (::mlir::Value value : getODSOperands(0))
    effects.emplace_back(MemoryEffects::Write::get(), value, ::mlir::TF::ResourceEffects::Summary::get());
}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::WriteGraphSummaryOp definitions
//===----------------------------------------------------------------------===//

WriteGraphSummaryOpAdaptor::WriteGraphSummaryOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

WriteGraphSummaryOpAdaptor::WriteGraphSummaryOpAdaptor(WriteGraphSummaryOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> WriteGraphSummaryOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange WriteGraphSummaryOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value WriteGraphSummaryOpAdaptor::writer() {
  return *getODSOperands(0).begin();
}

::mlir::Value WriteGraphSummaryOpAdaptor::step() {
  return *getODSOperands(1).begin();
}

::mlir::Value WriteGraphSummaryOpAdaptor::tensor() {
  return *getODSOperands(2).begin();
}

::mlir::LogicalResult WriteGraphSummaryOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

::llvm::StringRef WriteGraphSummaryOp::getOperationName() {
  return "tf.WriteGraphSummary";
}

std::pair<unsigned, unsigned> WriteGraphSummaryOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range WriteGraphSummaryOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value WriteGraphSummaryOp::writer() {
  return *getODSOperands(0).begin();
}

::mlir::Value WriteGraphSummaryOp::step() {
  return *getODSOperands(1).begin();
}

::mlir::Value WriteGraphSummaryOp::tensor() {
  return *getODSOperands(2).begin();
}

::mlir::MutableOperandRange WriteGraphSummaryOp::writerMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange WriteGraphSummaryOp::stepMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange WriteGraphSummaryOp::tensorMutable() {
  auto range = getODSOperandIndexAndLength(2);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> WriteGraphSummaryOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range WriteGraphSummaryOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

void WriteGraphSummaryOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value writer, ::mlir::Value step, ::mlir::Value tensor) {
  odsState.addOperands(writer);
  odsState.addOperands(step);
  odsState.addOperands(tensor);
}

void WriteGraphSummaryOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value writer, ::mlir::Value step, ::mlir::Value tensor) {
  odsState.addOperands(writer);
  odsState.addOperands(step);
  odsState.addOperands(tensor);
  assert(resultTypes.size() == 0u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void WriteGraphSummaryOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 3u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 0u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult WriteGraphSummaryOp::verify() {
  if (failed(WriteGraphSummaryOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::ResourceType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::ResourceRefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of resource values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of 64-bit integer values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup2 = getODSOperands(2);
    for (::mlir::Value v : valueGroup2) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::StringType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::StringRefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of string values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
  }
  return ::mlir::success();
}

void WriteGraphSummaryOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
  for (::mlir::Value value : getODSOperands(0))
    effects.emplace_back(MemoryEffects::Write::get(), value, ::mlir::TF::ResourceEffects::Summary::get());
}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::WriteHistogramSummaryOp definitions
//===----------------------------------------------------------------------===//

WriteHistogramSummaryOpAdaptor::WriteHistogramSummaryOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

WriteHistogramSummaryOpAdaptor::WriteHistogramSummaryOpAdaptor(WriteHistogramSummaryOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> WriteHistogramSummaryOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange WriteHistogramSummaryOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value WriteHistogramSummaryOpAdaptor::writer() {
  return *getODSOperands(0).begin();
}

::mlir::Value WriteHistogramSummaryOpAdaptor::step() {
  return *getODSOperands(1).begin();
}

::mlir::Value WriteHistogramSummaryOpAdaptor::tag() {
  return *getODSOperands(2).begin();
}

::mlir::Value WriteHistogramSummaryOpAdaptor::values() {
  return *getODSOperands(3).begin();
}

::mlir::LogicalResult WriteHistogramSummaryOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

::llvm::StringRef WriteHistogramSummaryOp::getOperationName() {
  return "tf.WriteHistogramSummary";
}

std::pair<unsigned, unsigned> WriteHistogramSummaryOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range WriteHistogramSummaryOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value WriteHistogramSummaryOp::writer() {
  return *getODSOperands(0).begin();
}

::mlir::Value WriteHistogramSummaryOp::step() {
  return *getODSOperands(1).begin();
}

::mlir::Value WriteHistogramSummaryOp::tag() {
  return *getODSOperands(2).begin();
}

::mlir::Value WriteHistogramSummaryOp::values() {
  return *getODSOperands(3).begin();
}

::mlir::MutableOperandRange WriteHistogramSummaryOp::writerMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange WriteHistogramSummaryOp::stepMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange WriteHistogramSummaryOp::tagMutable() {
  auto range = getODSOperandIndexAndLength(2);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange WriteHistogramSummaryOp::valuesMutable() {
  auto range = getODSOperandIndexAndLength(3);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> WriteHistogramSummaryOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range WriteHistogramSummaryOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

Type WriteHistogramSummaryOp::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(3).begin());
}

bool WriteHistogramSummaryOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "T") return true;
 return false;
}

::mlir::DictionaryAttr WriteHistogramSummaryOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())}
    }, ctx);
}

void WriteHistogramSummaryOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value writer, ::mlir::Value step, ::mlir::Value tag, ::mlir::Value values) {
  odsState.addOperands(writer);
  odsState.addOperands(step);
  odsState.addOperands(tag);
  odsState.addOperands(values);
}

void WriteHistogramSummaryOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value writer, ::mlir::Value step, ::mlir::Value tag, ::mlir::Value values) {
  odsState.addOperands(writer);
  odsState.addOperands(step);
  odsState.addOperands(tag);
  odsState.addOperands(values);
  assert(resultTypes.size() == 0u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void WriteHistogramSummaryOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 4u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 0u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult WriteHistogramSummaryOp::verify() {
  if (failed(WriteHistogramSummaryOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::ResourceType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::ResourceRefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of resource values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of 64-bit integer values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup2 = getODSOperands(2);
    for (::mlir::Value v : valueGroup2) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::StringType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::StringRefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of string values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup3 = getODSOperands(3);
    for (::mlir::Value v : valueGroup3) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of integer or floating-point values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
  }
  return ::mlir::success();
}

void WriteHistogramSummaryOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
  for (::mlir::Value value : getODSOperands(0))
    effects.emplace_back(MemoryEffects::Write::get(), value, ::mlir::TF::ResourceEffects::Summary::get());
}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::WriteImageSummaryOp definitions
//===----------------------------------------------------------------------===//

WriteImageSummaryOpAdaptor::WriteImageSummaryOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

WriteImageSummaryOpAdaptor::WriteImageSummaryOpAdaptor(WriteImageSummaryOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> WriteImageSummaryOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange WriteImageSummaryOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value WriteImageSummaryOpAdaptor::writer() {
  return *getODSOperands(0).begin();
}

::mlir::Value WriteImageSummaryOpAdaptor::step() {
  return *getODSOperands(1).begin();
}

::mlir::Value WriteImageSummaryOpAdaptor::tag() {
  return *getODSOperands(2).begin();
}

::mlir::Value WriteImageSummaryOpAdaptor::tensor() {
  return *getODSOperands(3).begin();
}

::mlir::Value WriteImageSummaryOpAdaptor::bad_color() {
  return *getODSOperands(4).begin();
}

::mlir::IntegerAttr WriteImageSummaryOpAdaptor::max_images() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::IntegerAttr attr = odsAttrs.get("max_images").dyn_cast_or_null<::mlir::IntegerAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getIntegerAttr(::mlir::Builder(odsAttrs.getContext()).getIntegerType(64), 3);
  return attr;
}

::mlir::LogicalResult WriteImageSummaryOpAdaptor::verify(::mlir::Location loc) {
  {
  auto tblgen_max_images = odsAttrs.get("max_images");
  if (tblgen_max_images) {
    if (!((((tblgen_max_images.isa<::mlir::IntegerAttr>())) && ((tblgen_max_images.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(64)))) && ((tblgen_max_images.cast<::mlir::IntegerAttr>().getInt() >= 1)))) return emitError(loc, "'tf.WriteImageSummary' op ""attribute 'max_images' failed to satisfy constraint: 64-bit signless integer attribute whose minimum value is 1");
  }
  }
  return ::mlir::success();
}

::llvm::StringRef WriteImageSummaryOp::getOperationName() {
  return "tf.WriteImageSummary";
}

std::pair<unsigned, unsigned> WriteImageSummaryOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range WriteImageSummaryOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value WriteImageSummaryOp::writer() {
  return *getODSOperands(0).begin();
}

::mlir::Value WriteImageSummaryOp::step() {
  return *getODSOperands(1).begin();
}

::mlir::Value WriteImageSummaryOp::tag() {
  return *getODSOperands(2).begin();
}

::mlir::Value WriteImageSummaryOp::tensor() {
  return *getODSOperands(3).begin();
}

::mlir::Value WriteImageSummaryOp::bad_color() {
  return *getODSOperands(4).begin();
}

::mlir::MutableOperandRange WriteImageSummaryOp::writerMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange WriteImageSummaryOp::stepMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange WriteImageSummaryOp::tagMutable() {
  auto range = getODSOperandIndexAndLength(2);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange WriteImageSummaryOp::tensorMutable() {
  auto range = getODSOperandIndexAndLength(3);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange WriteImageSummaryOp::bad_colorMutable() {
  auto range = getODSOperandIndexAndLength(4);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> WriteImageSummaryOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range WriteImageSummaryOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::IntegerAttr WriteImageSummaryOp::max_imagesAttr() {
  return this->getAttr("max_images").dyn_cast_or_null<::mlir::IntegerAttr>();
}

uint64_t WriteImageSummaryOp::max_images() {
  auto attr = max_imagesAttr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getIntegerAttr(::mlir::Builder(this->getContext()).getIntegerType(64), 3).getValue().getZExtValue();
  return attr.getValue().getZExtValue();
}

Type WriteImageSummaryOp::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(3).begin());
}

bool WriteImageSummaryOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "T") return true;
 return false;
}

::mlir::DictionaryAttr WriteImageSummaryOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())}
    }, ctx);
}

void WriteImageSummaryOp::max_imagesAttr(::mlir::IntegerAttr attr) {
  this->getOperation()->setAttr("max_images", attr);
}

void WriteImageSummaryOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value writer, ::mlir::Value step, ::mlir::Value tag, ::mlir::Value tensor, ::mlir::Value bad_color, ::mlir::IntegerAttr max_images) {
  odsState.addOperands(writer);
  odsState.addOperands(step);
  odsState.addOperands(tag);
  odsState.addOperands(tensor);
  odsState.addOperands(bad_color);
  odsState.addAttribute("max_images", max_images);
}

void WriteImageSummaryOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value writer, ::mlir::Value step, ::mlir::Value tag, ::mlir::Value tensor, ::mlir::Value bad_color, ::mlir::IntegerAttr max_images) {
  odsState.addOperands(writer);
  odsState.addOperands(step);
  odsState.addOperands(tag);
  odsState.addOperands(tensor);
  odsState.addOperands(bad_color);
  odsState.addAttribute("max_images", max_images);
  assert(resultTypes.size() == 0u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void WriteImageSummaryOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value writer, ::mlir::Value step, ::mlir::Value tag, ::mlir::Value tensor, ::mlir::Value bad_color, uint64_t max_images) {
  odsState.addOperands(writer);
  odsState.addOperands(step);
  odsState.addOperands(tag);
  odsState.addOperands(tensor);
  odsState.addOperands(bad_color);
  odsState.addAttribute("max_images", odsBuilder.getIntegerAttr(odsBuilder.getIntegerType(64), max_images));
}

void WriteImageSummaryOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value writer, ::mlir::Value step, ::mlir::Value tag, ::mlir::Value tensor, ::mlir::Value bad_color, uint64_t max_images) {
  odsState.addOperands(writer);
  odsState.addOperands(step);
  odsState.addOperands(tag);
  odsState.addOperands(tensor);
  odsState.addOperands(bad_color);
  odsState.addAttribute("max_images", odsBuilder.getIntegerAttr(odsBuilder.getIntegerType(64), max_images));
  assert(resultTypes.size() == 0u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void WriteImageSummaryOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 5u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 0u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult WriteImageSummaryOp::verify() {
  if (failed(WriteImageSummaryOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::ResourceType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::ResourceRefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of resource values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of 64-bit integer values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup2 = getODSOperands(2);
    for (::mlir::Value v : valueGroup2) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::StringType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::StringRefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of string values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup3 = getODSOperands(3);
    for (::mlir::Value v : valueGroup3) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of 16-bit float or 32-bit float or 8-bit unsigned integer values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup4 = getODSOperands(4);
    for (::mlir::Value v : valueGroup4) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of 8-bit unsigned integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
  }
  return ::mlir::success();
}

void WriteImageSummaryOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
  for (::mlir::Value value : getODSOperands(0))
    effects.emplace_back(MemoryEffects::Write::get(), value, ::mlir::TF::ResourceEffects::Summary::get());
}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::WriteRawProtoSummaryOp definitions
//===----------------------------------------------------------------------===//

WriteRawProtoSummaryOpAdaptor::WriteRawProtoSummaryOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

WriteRawProtoSummaryOpAdaptor::WriteRawProtoSummaryOpAdaptor(WriteRawProtoSummaryOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> WriteRawProtoSummaryOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange WriteRawProtoSummaryOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value WriteRawProtoSummaryOpAdaptor::writer() {
  return *getODSOperands(0).begin();
}

::mlir::Value WriteRawProtoSummaryOpAdaptor::step() {
  return *getODSOperands(1).begin();
}

::mlir::Value WriteRawProtoSummaryOpAdaptor::tensor() {
  return *getODSOperands(2).begin();
}

::mlir::LogicalResult WriteRawProtoSummaryOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

::llvm::StringRef WriteRawProtoSummaryOp::getOperationName() {
  return "tf.WriteRawProtoSummary";
}

std::pair<unsigned, unsigned> WriteRawProtoSummaryOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range WriteRawProtoSummaryOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value WriteRawProtoSummaryOp::writer() {
  return *getODSOperands(0).begin();
}

::mlir::Value WriteRawProtoSummaryOp::step() {
  return *getODSOperands(1).begin();
}

::mlir::Value WriteRawProtoSummaryOp::tensor() {
  return *getODSOperands(2).begin();
}

::mlir::MutableOperandRange WriteRawProtoSummaryOp::writerMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange WriteRawProtoSummaryOp::stepMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange WriteRawProtoSummaryOp::tensorMutable() {
  auto range = getODSOperandIndexAndLength(2);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> WriteRawProtoSummaryOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range WriteRawProtoSummaryOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

void WriteRawProtoSummaryOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value writer, ::mlir::Value step, ::mlir::Value tensor) {
  odsState.addOperands(writer);
  odsState.addOperands(step);
  odsState.addOperands(tensor);
}

void WriteRawProtoSummaryOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value writer, ::mlir::Value step, ::mlir::Value tensor) {
  odsState.addOperands(writer);
  odsState.addOperands(step);
  odsState.addOperands(tensor);
  assert(resultTypes.size() == 0u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void WriteRawProtoSummaryOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 3u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 0u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult WriteRawProtoSummaryOp::verify() {
  if (failed(WriteRawProtoSummaryOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::ResourceType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::ResourceRefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of resource values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of 64-bit integer values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup2 = getODSOperands(2);
    for (::mlir::Value v : valueGroup2) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::StringType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::StringRefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of string values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
  }
  return ::mlir::success();
}

void WriteRawProtoSummaryOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
  for (::mlir::Value value : getODSOperands(0))
    effects.emplace_back(MemoryEffects::Write::get(), value, ::mlir::TF::ResourceEffects::Summary::get());
}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::WriteScalarSummaryOp definitions
//===----------------------------------------------------------------------===//

WriteScalarSummaryOpAdaptor::WriteScalarSummaryOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

WriteScalarSummaryOpAdaptor::WriteScalarSummaryOpAdaptor(WriteScalarSummaryOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> WriteScalarSummaryOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange WriteScalarSummaryOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value WriteScalarSummaryOpAdaptor::writer() {
  return *getODSOperands(0).begin();
}

::mlir::Value WriteScalarSummaryOpAdaptor::step() {
  return *getODSOperands(1).begin();
}

::mlir::Value WriteScalarSummaryOpAdaptor::tag() {
  return *getODSOperands(2).begin();
}

::mlir::Value WriteScalarSummaryOpAdaptor::value() {
  return *getODSOperands(3).begin();
}

::mlir::LogicalResult WriteScalarSummaryOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

::llvm::StringRef WriteScalarSummaryOp::getOperationName() {
  return "tf.WriteScalarSummary";
}

std::pair<unsigned, unsigned> WriteScalarSummaryOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range WriteScalarSummaryOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value WriteScalarSummaryOp::writer() {
  return *getODSOperands(0).begin();
}

::mlir::Value WriteScalarSummaryOp::step() {
  return *getODSOperands(1).begin();
}

::mlir::Value WriteScalarSummaryOp::tag() {
  return *getODSOperands(2).begin();
}

::mlir::Value WriteScalarSummaryOp::value() {
  return *getODSOperands(3).begin();
}

::mlir::MutableOperandRange WriteScalarSummaryOp::writerMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange WriteScalarSummaryOp::stepMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange WriteScalarSummaryOp::tagMutable() {
  auto range = getODSOperandIndexAndLength(2);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange WriteScalarSummaryOp::valueMutable() {
  auto range = getODSOperandIndexAndLength(3);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> WriteScalarSummaryOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range WriteScalarSummaryOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

Type WriteScalarSummaryOp::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(3).begin());
}

bool WriteScalarSummaryOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "T") return true;
 return false;
}

::mlir::DictionaryAttr WriteScalarSummaryOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())}
    }, ctx);
}

void WriteScalarSummaryOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value writer, ::mlir::Value step, ::mlir::Value tag, ::mlir::Value value) {
  odsState.addOperands(writer);
  odsState.addOperands(step);
  odsState.addOperands(tag);
  odsState.addOperands(value);
}

void WriteScalarSummaryOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value writer, ::mlir::Value step, ::mlir::Value tag, ::mlir::Value value) {
  odsState.addOperands(writer);
  odsState.addOperands(step);
  odsState.addOperands(tag);
  odsState.addOperands(value);
  assert(resultTypes.size() == 0u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void WriteScalarSummaryOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 4u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 0u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult WriteScalarSummaryOp::verify() {
  if (failed(WriteScalarSummaryOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::ResourceType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::ResourceRefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of resource values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of 64-bit integer values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup2 = getODSOperands(2);
    for (::mlir::Value v : valueGroup2) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::StringType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::StringRefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of string values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup3 = getODSOperands(3);
    for (::mlir::Value v : valueGroup3) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of integer or floating-point values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
  }
  return ::mlir::success();
}

void WriteScalarSummaryOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
  for (::mlir::Value value : getODSOperands(0))
    effects.emplace_back(MemoryEffects::Write::get(), value, ::mlir::TF::ResourceEffects::Summary::get());
}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::WriteSummaryOp definitions
//===----------------------------------------------------------------------===//

WriteSummaryOpAdaptor::WriteSummaryOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

WriteSummaryOpAdaptor::WriteSummaryOpAdaptor(WriteSummaryOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> WriteSummaryOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange WriteSummaryOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value WriteSummaryOpAdaptor::writer() {
  return *getODSOperands(0).begin();
}

::mlir::Value WriteSummaryOpAdaptor::step() {
  return *getODSOperands(1).begin();
}

::mlir::Value WriteSummaryOpAdaptor::tensor() {
  return *getODSOperands(2).begin();
}

::mlir::Value WriteSummaryOpAdaptor::tag() {
  return *getODSOperands(3).begin();
}

::mlir::Value WriteSummaryOpAdaptor::summary_metadata() {
  return *getODSOperands(4).begin();
}

::mlir::LogicalResult WriteSummaryOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

::llvm::StringRef WriteSummaryOp::getOperationName() {
  return "tf.WriteSummary";
}

std::pair<unsigned, unsigned> WriteSummaryOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range WriteSummaryOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value WriteSummaryOp::writer() {
  return *getODSOperands(0).begin();
}

::mlir::Value WriteSummaryOp::step() {
  return *getODSOperands(1).begin();
}

::mlir::Value WriteSummaryOp::tensor() {
  return *getODSOperands(2).begin();
}

::mlir::Value WriteSummaryOp::tag() {
  return *getODSOperands(3).begin();
}

::mlir::Value WriteSummaryOp::summary_metadata() {
  return *getODSOperands(4).begin();
}

::mlir::MutableOperandRange WriteSummaryOp::writerMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange WriteSummaryOp::stepMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange WriteSummaryOp::tensorMutable() {
  auto range = getODSOperandIndexAndLength(2);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange WriteSummaryOp::tagMutable() {
  auto range = getODSOperandIndexAndLength(3);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange WriteSummaryOp::summary_metadataMutable() {
  auto range = getODSOperandIndexAndLength(4);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> WriteSummaryOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range WriteSummaryOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

Type WriteSummaryOp::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(2).begin());
}

bool WriteSummaryOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "T") return true;
 return false;
}

::mlir::DictionaryAttr WriteSummaryOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())}
    }, ctx);
}

void WriteSummaryOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value writer, ::mlir::Value step, ::mlir::Value tensor, ::mlir::Value tag, ::mlir::Value summary_metadata) {
  odsState.addOperands(writer);
  odsState.addOperands(step);
  odsState.addOperands(tensor);
  odsState.addOperands(tag);
  odsState.addOperands(summary_metadata);
}

void WriteSummaryOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value writer, ::mlir::Value step, ::mlir::Value tensor, ::mlir::Value tag, ::mlir::Value summary_metadata) {
  odsState.addOperands(writer);
  odsState.addOperands(step);
  odsState.addOperands(tensor);
  odsState.addOperands(tag);
  odsState.addOperands(summary_metadata);
  assert(resultTypes.size() == 0u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void WriteSummaryOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 5u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 0u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult WriteSummaryOp::verify() {
  if (failed(WriteSummaryOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::ResourceType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::ResourceRefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of resource values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of 64-bit integer values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup2 = getODSOperands(2);
    for (::mlir::Value v : valueGroup2) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>())))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::TensorFlowType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of tf.dtype values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup3 = getODSOperands(3);
    for (::mlir::Value v : valueGroup3) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::StringType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::StringRefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of string values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup4 = getODSOperands(4);
    for (::mlir::Value v : valueGroup4) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::StringType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::StringRefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of string values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
  }
  return ::mlir::success();
}

void WriteSummaryOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
  for (::mlir::Value value : getODSOperands(0))
    effects.emplace_back(MemoryEffects::Write::get(), value, ::mlir::TF::ResourceEffects::Summary::get());
}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::XdivyOp definitions
//===----------------------------------------------------------------------===//

XdivyOpAdaptor::XdivyOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

XdivyOpAdaptor::XdivyOpAdaptor(XdivyOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> XdivyOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange XdivyOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value XdivyOpAdaptor::x() {
  return *getODSOperands(0).begin();
}

::mlir::Value XdivyOpAdaptor::y() {
  return *getODSOperands(1).begin();
}

::mlir::LogicalResult XdivyOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

::llvm::StringRef XdivyOp::getOperationName() {
  return "tf.Xdivy";
}

std::pair<unsigned, unsigned> XdivyOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range XdivyOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value XdivyOp::x() {
  return *getODSOperands(0).begin();
}

::mlir::Value XdivyOp::y() {
  return *getODSOperands(1).begin();
}

::mlir::MutableOperandRange XdivyOp::xMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange XdivyOp::yMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> XdivyOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range XdivyOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value XdivyOp::z() {
  return *getODSResults(0).begin();
}

Type XdivyOp::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

bool XdivyOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "T") return true;
 return false;
}

::mlir::DictionaryAttr XdivyOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())}
    }, ctx);
}

void XdivyOp::build(OpBuilder &builder, OperationState &result, Value  x, Value  y) {
  auto resultType =
      OpTrait::util::getBroadcastedType(x.getType(), y.getType());
  if (!resultType)
    mlir::emitError(result.location, "non-broadcastable operands");
  return build(builder, result, resultType, x, y);
}

void XdivyOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type z, ::mlir::Value x, ::mlir::Value y) {
  odsState.addOperands(x);
  odsState.addOperands(y);
  odsState.addTypes(z);
}

void XdivyOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value x, ::mlir::Value y) {
  odsState.addOperands(x);
  odsState.addOperands(y);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void XdivyOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult XdivyOp::verify() {
  if (failed(XdivyOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of 128-bit complex or 64-bit complex or 16-bit float or 32-bit float or 64-bit float values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of 128-bit complex or 64-bit complex or 16-bit float or 32-bit float or 64-bit float values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())))))) {
        return emitOpError("result #") << index << " must be tensor of 128-bit complex or 64-bit complex or 16-bit float or 32-bit float or 64-bit float values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}



void XdivyOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::XlaBroadcastHelperOp definitions
//===----------------------------------------------------------------------===//

XlaBroadcastHelperOpAdaptor::XlaBroadcastHelperOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

XlaBroadcastHelperOpAdaptor::XlaBroadcastHelperOpAdaptor(XlaBroadcastHelperOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> XlaBroadcastHelperOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange XlaBroadcastHelperOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value XlaBroadcastHelperOpAdaptor::lhs() {
  return *getODSOperands(0).begin();
}

::mlir::Value XlaBroadcastHelperOpAdaptor::rhs() {
  return *getODSOperands(1).begin();
}

::mlir::Value XlaBroadcastHelperOpAdaptor::broadcast_dims() {
  return *getODSOperands(2).begin();
}

::mlir::LogicalResult XlaBroadcastHelperOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

void XlaBroadcastHelperOp::getAsmResultNames(::mlir::OpAsmSetValueNameFn setNameFn) {
  auto resultGroup0 = getODSResults(0);
  if (!llvm::empty(resultGroup0))
    setNameFn(*resultGroup0.begin(), "lhs_output");
  auto resultGroup1 = getODSResults(1);
  if (!llvm::empty(resultGroup1))
    setNameFn(*resultGroup1.begin(), "rhs_output");
}

::llvm::StringRef XlaBroadcastHelperOp::getOperationName() {
  return "tf.XlaBroadcastHelper";
}

std::pair<unsigned, unsigned> XlaBroadcastHelperOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range XlaBroadcastHelperOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value XlaBroadcastHelperOp::lhs() {
  return *getODSOperands(0).begin();
}

::mlir::Value XlaBroadcastHelperOp::rhs() {
  return *getODSOperands(1).begin();
}

::mlir::Value XlaBroadcastHelperOp::broadcast_dims() {
  return *getODSOperands(2).begin();
}

::mlir::MutableOperandRange XlaBroadcastHelperOp::lhsMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange XlaBroadcastHelperOp::rhsMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange XlaBroadcastHelperOp::broadcast_dimsMutable() {
  auto range = getODSOperandIndexAndLength(2);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> XlaBroadcastHelperOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range XlaBroadcastHelperOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value XlaBroadcastHelperOp::lhs_output() {
  return *getODSResults(0).begin();
}

::mlir::Value XlaBroadcastHelperOp::rhs_output() {
  return *getODSResults(1).begin();
}

Type XlaBroadcastHelperOp::Tindices() {
  return mlir::getElementTypeOrSelf(*getODSOperands(2).begin());
}

Type XlaBroadcastHelperOp::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

bool XlaBroadcastHelperOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "Tindices") return true;
  if (name == "T") return true;
 return false;
}

::mlir::DictionaryAttr XlaBroadcastHelperOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("Tindices", ctx),
::mlir::TypeAttr::get(Tindices())},
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())}
    }, ctx);
}

void XlaBroadcastHelperOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type lhs_output, ::mlir::Type rhs_output, ::mlir::Value lhs, ::mlir::Value rhs, ::mlir::Value broadcast_dims) {
  odsState.addOperands(lhs);
  odsState.addOperands(rhs);
  odsState.addOperands(broadcast_dims);
  odsState.addTypes(lhs_output);
  odsState.addTypes(rhs_output);
}

void XlaBroadcastHelperOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value lhs, ::mlir::Value rhs, ::mlir::Value broadcast_dims) {
  odsState.addOperands(lhs);
  odsState.addOperands(rhs);
  odsState.addOperands(broadcast_dims);
  assert(resultTypes.size() == 2u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void XlaBroadcastHelperOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 3u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 2u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult XlaBroadcastHelperOp::verify() {
  if (failed(XlaBroadcastHelperOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of bfloat16 or 128-bit complex or 64-bit complex or 16-bit float or 32-bit float or 64-bit float or 16-bit integer or 32-bit integer or 64-bit integer or 8-bit integer or 32-bit quantized integer or 8-bit quantized integer or 8-bit quantized unsigned integer or 16-bit unsigned integer or 32-bit unsigned integer or 64-bit unsigned integer or 8-bit unsigned integer values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of bfloat16 or 128-bit complex or 64-bit complex or 16-bit float or 32-bit float or 64-bit float or 16-bit integer or 32-bit integer or 64-bit integer or 8-bit integer or 32-bit quantized integer or 8-bit quantized integer or 8-bit quantized unsigned integer or 16-bit unsigned integer or 32-bit unsigned integer or 64-bit unsigned integer or 8-bit unsigned integer values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup2 = getODSOperands(2);
    for (::mlir::Value v : valueGroup2) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of 32/64-bit signed integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>())))))) {
        return emitOpError("result #") << index << " must be tensor of bfloat16 or 128-bit complex or 64-bit complex or 16-bit float or 32-bit float or 64-bit float or 16-bit integer or 32-bit integer or 64-bit integer or 8-bit integer or 32-bit quantized integer or 8-bit quantized integer or 8-bit quantized unsigned integer or 16-bit unsigned integer or 32-bit unsigned integer or 64-bit unsigned integer or 8-bit unsigned integer values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSResults(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>())))))) {
        return emitOpError("result #") << index << " must be tensor of bfloat16 or 128-bit complex or 64-bit complex or 16-bit float or 32-bit float or 64-bit float or 16-bit integer or 32-bit integer or 64-bit integer or 8-bit integer or 32-bit quantized integer or 8-bit quantized integer or 8-bit quantized unsigned integer or 16-bit unsigned integer or 32-bit unsigned integer or 64-bit unsigned integer or 8-bit unsigned integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void XlaBroadcastHelperOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::XlaConvOp definitions
//===----------------------------------------------------------------------===//

XlaConvOpAdaptor::XlaConvOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

XlaConvOpAdaptor::XlaConvOpAdaptor(XlaConvOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> XlaConvOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange XlaConvOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value XlaConvOpAdaptor::lhs() {
  return *getODSOperands(0).begin();
}

::mlir::Value XlaConvOpAdaptor::rhs() {
  return *getODSOperands(1).begin();
}

::mlir::Value XlaConvOpAdaptor::window_strides() {
  return *getODSOperands(2).begin();
}

::mlir::Value XlaConvOpAdaptor::padding() {
  return *getODSOperands(3).begin();
}

::mlir::Value XlaConvOpAdaptor::lhs_dilation() {
  return *getODSOperands(4).begin();
}

::mlir::Value XlaConvOpAdaptor::rhs_dilation() {
  return *getODSOperands(5).begin();
}

::mlir::Value XlaConvOpAdaptor::feature_group_count() {
  return *getODSOperands(6).begin();
}

::mlir::StringAttr XlaConvOpAdaptor::dimension_numbers() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::StringAttr attr = odsAttrs.get("dimension_numbers").cast<::mlir::StringAttr>();
  return attr;
}

::mlir::StringAttr XlaConvOpAdaptor::precision_config() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::StringAttr attr = odsAttrs.get("precision_config").cast<::mlir::StringAttr>();
  return attr;
}

::mlir::LogicalResult XlaConvOpAdaptor::verify(::mlir::Location loc) {
  {
  auto tblgen_dimension_numbers = odsAttrs.get("dimension_numbers");
  if (!tblgen_dimension_numbers) return emitError(loc, "'tf.XlaConv' op ""requires attribute 'dimension_numbers'");
    if (!((tblgen_dimension_numbers.isa<::mlir::StringAttr>()))) return emitError(loc, "'tf.XlaConv' op ""attribute 'dimension_numbers' failed to satisfy constraint: string attribute");
  }
  {
  auto tblgen_precision_config = odsAttrs.get("precision_config");
  if (!tblgen_precision_config) return emitError(loc, "'tf.XlaConv' op ""requires attribute 'precision_config'");
    if (!((tblgen_precision_config.isa<::mlir::StringAttr>()))) return emitError(loc, "'tf.XlaConv' op ""attribute 'precision_config' failed to satisfy constraint: string attribute");
  }
  return ::mlir::success();
}

::llvm::StringRef XlaConvOp::getOperationName() {
  return "tf.XlaConv";
}

std::pair<unsigned, unsigned> XlaConvOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range XlaConvOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value XlaConvOp::lhs() {
  return *getODSOperands(0).begin();
}

::mlir::Value XlaConvOp::rhs() {
  return *getODSOperands(1).begin();
}

::mlir::Value XlaConvOp::window_strides() {
  return *getODSOperands(2).begin();
}

::mlir::Value XlaConvOp::padding() {
  return *getODSOperands(3).begin();
}

::mlir::Value XlaConvOp::lhs_dilation() {
  return *getODSOperands(4).begin();
}

::mlir::Value XlaConvOp::rhs_dilation() {
  return *getODSOperands(5).begin();
}

::mlir::Value XlaConvOp::feature_group_count() {
  return *getODSOperands(6).begin();
}

::mlir::MutableOperandRange XlaConvOp::lhsMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange XlaConvOp::rhsMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange XlaConvOp::window_stridesMutable() {
  auto range = getODSOperandIndexAndLength(2);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange XlaConvOp::paddingMutable() {
  auto range = getODSOperandIndexAndLength(3);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange XlaConvOp::lhs_dilationMutable() {
  auto range = getODSOperandIndexAndLength(4);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange XlaConvOp::rhs_dilationMutable() {
  auto range = getODSOperandIndexAndLength(5);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange XlaConvOp::feature_group_countMutable() {
  auto range = getODSOperandIndexAndLength(6);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> XlaConvOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range XlaConvOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value XlaConvOp::output() {
  return *getODSResults(0).begin();
}

::mlir::StringAttr XlaConvOp::dimension_numbersAttr() {
  return this->getAttr("dimension_numbers").cast<::mlir::StringAttr>();
}

::llvm::StringRef XlaConvOp::dimension_numbers() {
  auto attr = dimension_numbersAttr();
  return attr.getValue();
}

::mlir::StringAttr XlaConvOp::precision_configAttr() {
  return this->getAttr("precision_config").cast<::mlir::StringAttr>();
}

::llvm::StringRef XlaConvOp::precision_config() {
  auto attr = precision_configAttr();
  return attr.getValue();
}

Type XlaConvOp::Tindices() {
  return mlir::getElementTypeOrSelf(*getODSOperands(2).begin());
}

Type XlaConvOp::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

bool XlaConvOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "Tindices") return true;
  if (name == "T") return true;
 return false;
}

::mlir::DictionaryAttr XlaConvOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("Tindices", ctx),
::mlir::TypeAttr::get(Tindices())},
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())}
    }, ctx);
}

void XlaConvOp::dimension_numbersAttr(::mlir::StringAttr attr) {
  this->getOperation()->setAttr("dimension_numbers", attr);
}

void XlaConvOp::precision_configAttr(::mlir::StringAttr attr) {
  this->getOperation()->setAttr("precision_config", attr);
}

void XlaConvOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value lhs, ::mlir::Value rhs, ::mlir::Value window_strides, ::mlir::Value padding, ::mlir::Value lhs_dilation, ::mlir::Value rhs_dilation, ::mlir::Value feature_group_count, ::mlir::StringAttr dimension_numbers, ::mlir::StringAttr precision_config) {
  odsState.addOperands(lhs);
  odsState.addOperands(rhs);
  odsState.addOperands(window_strides);
  odsState.addOperands(padding);
  odsState.addOperands(lhs_dilation);
  odsState.addOperands(rhs_dilation);
  odsState.addOperands(feature_group_count);
  odsState.addAttribute("dimension_numbers", dimension_numbers);
  odsState.addAttribute("precision_config", precision_config);
  odsState.addTypes(output);
}

void XlaConvOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value lhs, ::mlir::Value rhs, ::mlir::Value window_strides, ::mlir::Value padding, ::mlir::Value lhs_dilation, ::mlir::Value rhs_dilation, ::mlir::Value feature_group_count, ::mlir::StringAttr dimension_numbers, ::mlir::StringAttr precision_config) {
  odsState.addOperands(lhs);
  odsState.addOperands(rhs);
  odsState.addOperands(window_strides);
  odsState.addOperands(padding);
  odsState.addOperands(lhs_dilation);
  odsState.addOperands(rhs_dilation);
  odsState.addOperands(feature_group_count);
  odsState.addAttribute("dimension_numbers", dimension_numbers);
  odsState.addAttribute("precision_config", precision_config);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void XlaConvOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value lhs, ::mlir::Value rhs, ::mlir::Value window_strides, ::mlir::Value padding, ::mlir::Value lhs_dilation, ::mlir::Value rhs_dilation, ::mlir::Value feature_group_count, ::llvm::StringRef dimension_numbers, ::llvm::StringRef precision_config) {
  odsState.addOperands(lhs);
  odsState.addOperands(rhs);
  odsState.addOperands(window_strides);
  odsState.addOperands(padding);
  odsState.addOperands(lhs_dilation);
  odsState.addOperands(rhs_dilation);
  odsState.addOperands(feature_group_count);
  odsState.addAttribute("dimension_numbers", odsBuilder.getStringAttr(dimension_numbers));
  odsState.addAttribute("precision_config", odsBuilder.getStringAttr(precision_config));
  odsState.addTypes(output);
}

void XlaConvOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value lhs, ::mlir::Value rhs, ::mlir::Value window_strides, ::mlir::Value padding, ::mlir::Value lhs_dilation, ::mlir::Value rhs_dilation, ::mlir::Value feature_group_count, ::llvm::StringRef dimension_numbers, ::llvm::StringRef precision_config) {
  odsState.addOperands(lhs);
  odsState.addOperands(rhs);
  odsState.addOperands(window_strides);
  odsState.addOperands(padding);
  odsState.addOperands(lhs_dilation);
  odsState.addOperands(rhs_dilation);
  odsState.addOperands(feature_group_count);
  odsState.addAttribute("dimension_numbers", odsBuilder.getStringAttr(dimension_numbers));
  odsState.addAttribute("precision_config", odsBuilder.getStringAttr(precision_config));
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void XlaConvOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 7u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult XlaConvOp::verify() {
  if (failed(XlaConvOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of bfloat16 or 128-bit complex or 64-bit complex or 16-bit float or 32-bit float or 64-bit float or 16-bit integer or 32-bit integer or 64-bit integer or 8-bit integer or 32-bit quantized integer or 8-bit quantized integer or 8-bit quantized unsigned integer or 16-bit unsigned integer or 32-bit unsigned integer or 64-bit unsigned integer or 8-bit unsigned integer values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of bfloat16 or 128-bit complex or 64-bit complex or 16-bit float or 32-bit float or 64-bit float or 16-bit integer or 32-bit integer or 64-bit integer or 8-bit integer or 32-bit quantized integer or 8-bit quantized integer or 8-bit quantized unsigned integer or 16-bit unsigned integer or 32-bit unsigned integer or 64-bit unsigned integer or 8-bit unsigned integer values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup2 = getODSOperands(2);
    for (::mlir::Value v : valueGroup2) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of 32/64-bit signed integer values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup3 = getODSOperands(3);
    for (::mlir::Value v : valueGroup3) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of 32/64-bit signed integer values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup4 = getODSOperands(4);
    for (::mlir::Value v : valueGroup4) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of 32/64-bit signed integer values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup5 = getODSOperands(5);
    for (::mlir::Value v : valueGroup5) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of 32/64-bit signed integer values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup6 = getODSOperands(6);
    for (::mlir::Value v : valueGroup6) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of 32/64-bit signed integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>())))))) {
        return emitOpError("result #") << index << " must be tensor of bfloat16 or 128-bit complex or 64-bit complex or 16-bit float or 32-bit float or 64-bit float or 16-bit integer or 32-bit integer or 64-bit integer or 8-bit integer or 32-bit quantized integer or 8-bit quantized integer or 8-bit quantized unsigned integer or 16-bit unsigned integer or 32-bit unsigned integer or 64-bit unsigned integer or 8-bit unsigned integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void XlaConvOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::XlaDotOp definitions
//===----------------------------------------------------------------------===//

XlaDotOpAdaptor::XlaDotOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

XlaDotOpAdaptor::XlaDotOpAdaptor(XlaDotOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> XlaDotOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange XlaDotOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value XlaDotOpAdaptor::lhs() {
  return *getODSOperands(0).begin();
}

::mlir::Value XlaDotOpAdaptor::rhs() {
  return *getODSOperands(1).begin();
}

::mlir::StringAttr XlaDotOpAdaptor::dimension_numbers() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::StringAttr attr = odsAttrs.get("dimension_numbers").cast<::mlir::StringAttr>();
  return attr;
}

::mlir::StringAttr XlaDotOpAdaptor::precision_config() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::StringAttr attr = odsAttrs.get("precision_config").cast<::mlir::StringAttr>();
  return attr;
}

::mlir::LogicalResult XlaDotOpAdaptor::verify(::mlir::Location loc) {
  {
  auto tblgen_dimension_numbers = odsAttrs.get("dimension_numbers");
  if (!tblgen_dimension_numbers) return emitError(loc, "'tf.XlaDot' op ""requires attribute 'dimension_numbers'");
    if (!((tblgen_dimension_numbers.isa<::mlir::StringAttr>()))) return emitError(loc, "'tf.XlaDot' op ""attribute 'dimension_numbers' failed to satisfy constraint: string attribute");
  }
  {
  auto tblgen_precision_config = odsAttrs.get("precision_config");
  if (!tblgen_precision_config) return emitError(loc, "'tf.XlaDot' op ""requires attribute 'precision_config'");
    if (!((tblgen_precision_config.isa<::mlir::StringAttr>()))) return emitError(loc, "'tf.XlaDot' op ""attribute 'precision_config' failed to satisfy constraint: string attribute");
  }
  return ::mlir::success();
}

::llvm::StringRef XlaDotOp::getOperationName() {
  return "tf.XlaDot";
}

std::pair<unsigned, unsigned> XlaDotOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range XlaDotOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value XlaDotOp::lhs() {
  return *getODSOperands(0).begin();
}

::mlir::Value XlaDotOp::rhs() {
  return *getODSOperands(1).begin();
}

::mlir::MutableOperandRange XlaDotOp::lhsMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange XlaDotOp::rhsMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> XlaDotOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range XlaDotOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value XlaDotOp::output() {
  return *getODSResults(0).begin();
}

::mlir::StringAttr XlaDotOp::dimension_numbersAttr() {
  return this->getAttr("dimension_numbers").cast<::mlir::StringAttr>();
}

::llvm::StringRef XlaDotOp::dimension_numbers() {
  auto attr = dimension_numbersAttr();
  return attr.getValue();
}

::mlir::StringAttr XlaDotOp::precision_configAttr() {
  return this->getAttr("precision_config").cast<::mlir::StringAttr>();
}

::llvm::StringRef XlaDotOp::precision_config() {
  auto attr = precision_configAttr();
  return attr.getValue();
}

Type XlaDotOp::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

bool XlaDotOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "T") return true;
 return false;
}

::mlir::DictionaryAttr XlaDotOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())}
    }, ctx);
}

void XlaDotOp::dimension_numbersAttr(::mlir::StringAttr attr) {
  this->getOperation()->setAttr("dimension_numbers", attr);
}

void XlaDotOp::precision_configAttr(::mlir::StringAttr attr) {
  this->getOperation()->setAttr("precision_config", attr);
}

void XlaDotOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value lhs, ::mlir::Value rhs, ::mlir::StringAttr dimension_numbers, ::mlir::StringAttr precision_config) {
  odsState.addOperands(lhs);
  odsState.addOperands(rhs);
  odsState.addAttribute("dimension_numbers", dimension_numbers);
  odsState.addAttribute("precision_config", precision_config);
  odsState.addTypes(output);
}

void XlaDotOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value lhs, ::mlir::Value rhs, ::mlir::StringAttr dimension_numbers, ::mlir::StringAttr precision_config) {
  odsState.addOperands(lhs);
  odsState.addOperands(rhs);
  odsState.addAttribute("dimension_numbers", dimension_numbers);
  odsState.addAttribute("precision_config", precision_config);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void XlaDotOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value lhs, ::mlir::Value rhs, ::llvm::StringRef dimension_numbers, ::llvm::StringRef precision_config) {
  odsState.addOperands(lhs);
  odsState.addOperands(rhs);
  odsState.addAttribute("dimension_numbers", odsBuilder.getStringAttr(dimension_numbers));
  odsState.addAttribute("precision_config", odsBuilder.getStringAttr(precision_config));
  odsState.addTypes(output);
}

void XlaDotOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value lhs, ::mlir::Value rhs, ::llvm::StringRef dimension_numbers, ::llvm::StringRef precision_config) {
  odsState.addOperands(lhs);
  odsState.addOperands(rhs);
  odsState.addAttribute("dimension_numbers", odsBuilder.getStringAttr(dimension_numbers));
  odsState.addAttribute("precision_config", odsBuilder.getStringAttr(precision_config));
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void XlaDotOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult XlaDotOp::verify() {
  if (failed(XlaDotOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of bfloat16 or 128-bit complex or 64-bit complex or 16-bit float or 32-bit float or 64-bit float or 16-bit integer or 32-bit integer or 64-bit integer or 8-bit integer or 32-bit quantized integer or 8-bit quantized integer or 8-bit quantized unsigned integer or 16-bit unsigned integer or 32-bit unsigned integer or 64-bit unsigned integer or 8-bit unsigned integer values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of bfloat16 or 128-bit complex or 64-bit complex or 16-bit float or 32-bit float or 64-bit float or 16-bit integer or 32-bit integer or 64-bit integer or 8-bit integer or 32-bit quantized integer or 8-bit quantized integer or 8-bit quantized unsigned integer or 16-bit unsigned integer or 32-bit unsigned integer or 64-bit unsigned integer or 8-bit unsigned integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>())))))) {
        return emitOpError("result #") << index << " must be tensor of bfloat16 or 128-bit complex or 64-bit complex or 16-bit float or 32-bit float or 64-bit float or 16-bit integer or 32-bit integer or 64-bit integer or 8-bit integer or 32-bit quantized integer or 8-bit quantized integer or 8-bit quantized unsigned integer or 16-bit unsigned integer or 32-bit unsigned integer or 64-bit unsigned integer or 8-bit unsigned integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void XlaDotOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::XlaDynamicSliceOp definitions
//===----------------------------------------------------------------------===//

XlaDynamicSliceOpAdaptor::XlaDynamicSliceOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

XlaDynamicSliceOpAdaptor::XlaDynamicSliceOpAdaptor(XlaDynamicSliceOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> XlaDynamicSliceOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange XlaDynamicSliceOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value XlaDynamicSliceOpAdaptor::input() {
  return *getODSOperands(0).begin();
}

::mlir::Value XlaDynamicSliceOpAdaptor::start_indices() {
  return *getODSOperands(1).begin();
}

::mlir::Value XlaDynamicSliceOpAdaptor::size_indices() {
  return *getODSOperands(2).begin();
}

::mlir::LogicalResult XlaDynamicSliceOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

::llvm::StringRef XlaDynamicSliceOp::getOperationName() {
  return "tf.XlaDynamicSlice";
}

std::pair<unsigned, unsigned> XlaDynamicSliceOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range XlaDynamicSliceOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value XlaDynamicSliceOp::input() {
  return *getODSOperands(0).begin();
}

::mlir::Value XlaDynamicSliceOp::start_indices() {
  return *getODSOperands(1).begin();
}

::mlir::Value XlaDynamicSliceOp::size_indices() {
  return *getODSOperands(2).begin();
}

::mlir::MutableOperandRange XlaDynamicSliceOp::inputMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange XlaDynamicSliceOp::start_indicesMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange XlaDynamicSliceOp::size_indicesMutable() {
  auto range = getODSOperandIndexAndLength(2);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> XlaDynamicSliceOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range XlaDynamicSliceOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value XlaDynamicSliceOp::output() {
  return *getODSResults(0).begin();
}

Type XlaDynamicSliceOp::Tindices() {
  return mlir::getElementTypeOrSelf(*getODSOperands(1).begin());
}

Type XlaDynamicSliceOp::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

bool XlaDynamicSliceOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "Tindices") return true;
  if (name == "T") return true;
 return false;
}

::mlir::DictionaryAttr XlaDynamicSliceOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("Tindices", ctx),
::mlir::TypeAttr::get(Tindices())},
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())}
    }, ctx);
}

void XlaDynamicSliceOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value input, ::mlir::Value start_indices, ::mlir::Value size_indices) {
  odsState.addOperands(input);
  odsState.addOperands(start_indices);
  odsState.addOperands(size_indices);
  odsState.addTypes(output);
}

void XlaDynamicSliceOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input, ::mlir::Value start_indices, ::mlir::Value size_indices) {
  odsState.addOperands(input);
  odsState.addOperands(start_indices);
  odsState.addOperands(size_indices);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void XlaDynamicSliceOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 3u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult XlaDynamicSliceOp::verify() {
  if (failed(XlaDynamicSliceOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>())))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::TensorFlowType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of tf.dtype values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of 32/64-bit signed integer values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup2 = getODSOperands(2);
    for (::mlir::Value v : valueGroup2) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of 32/64-bit signed integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>())))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::TensorFlowType>()))))) {
        return emitOpError("result #") << index << " must be tensor of tf.dtype values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void XlaDynamicSliceOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::XlaDynamicUpdateSliceOp definitions
//===----------------------------------------------------------------------===//

XlaDynamicUpdateSliceOpAdaptor::XlaDynamicUpdateSliceOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

XlaDynamicUpdateSliceOpAdaptor::XlaDynamicUpdateSliceOpAdaptor(XlaDynamicUpdateSliceOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> XlaDynamicUpdateSliceOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange XlaDynamicUpdateSliceOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value XlaDynamicUpdateSliceOpAdaptor::input() {
  return *getODSOperands(0).begin();
}

::mlir::Value XlaDynamicUpdateSliceOpAdaptor::update() {
  return *getODSOperands(1).begin();
}

::mlir::Value XlaDynamicUpdateSliceOpAdaptor::indices() {
  return *getODSOperands(2).begin();
}

::mlir::LogicalResult XlaDynamicUpdateSliceOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

::llvm::StringRef XlaDynamicUpdateSliceOp::getOperationName() {
  return "tf.XlaDynamicUpdateSlice";
}

std::pair<unsigned, unsigned> XlaDynamicUpdateSliceOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range XlaDynamicUpdateSliceOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value XlaDynamicUpdateSliceOp::input() {
  return *getODSOperands(0).begin();
}

::mlir::Value XlaDynamicUpdateSliceOp::update() {
  return *getODSOperands(1).begin();
}

::mlir::Value XlaDynamicUpdateSliceOp::indices() {
  return *getODSOperands(2).begin();
}

::mlir::MutableOperandRange XlaDynamicUpdateSliceOp::inputMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange XlaDynamicUpdateSliceOp::updateMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange XlaDynamicUpdateSliceOp::indicesMutable() {
  auto range = getODSOperandIndexAndLength(2);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> XlaDynamicUpdateSliceOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range XlaDynamicUpdateSliceOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value XlaDynamicUpdateSliceOp::output() {
  return *getODSResults(0).begin();
}

Type XlaDynamicUpdateSliceOp::Tindices() {
  return mlir::getElementTypeOrSelf(*getODSOperands(2).begin());
}

Type XlaDynamicUpdateSliceOp::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

bool XlaDynamicUpdateSliceOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "Tindices") return true;
  if (name == "T") return true;
 return false;
}

::mlir::DictionaryAttr XlaDynamicUpdateSliceOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("Tindices", ctx),
::mlir::TypeAttr::get(Tindices())},
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())}
    }, ctx);
}

void XlaDynamicUpdateSliceOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value input, ::mlir::Value update, ::mlir::Value indices) {
  odsState.addOperands(input);
  odsState.addOperands(update);
  odsState.addOperands(indices);
  odsState.addTypes(output);
}

void XlaDynamicUpdateSliceOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input, ::mlir::Value update, ::mlir::Value indices) {
  odsState.addOperands(input);
  odsState.addOperands(update);
  odsState.addOperands(indices);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void XlaDynamicUpdateSliceOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 3u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult XlaDynamicUpdateSliceOp::verify() {
  if (failed(XlaDynamicUpdateSliceOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>())))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::TensorFlowType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of tf.dtype values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>())))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::TensorFlowType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of tf.dtype values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup2 = getODSOperands(2);
    for (::mlir::Value v : valueGroup2) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of 32/64-bit signed integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>())))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::TensorFlowType>()))))) {
        return emitOpError("result #") << index << " must be tensor of tf.dtype values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void XlaDynamicUpdateSliceOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::XlaEinsumOp definitions
//===----------------------------------------------------------------------===//

XlaEinsumOpAdaptor::XlaEinsumOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

XlaEinsumOpAdaptor::XlaEinsumOpAdaptor(XlaEinsumOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> XlaEinsumOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange XlaEinsumOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value XlaEinsumOpAdaptor::a() {
  return *getODSOperands(0).begin();
}

::mlir::Value XlaEinsumOpAdaptor::b() {
  return *getODSOperands(1).begin();
}

::mlir::StringAttr XlaEinsumOpAdaptor::equation() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::StringAttr attr = odsAttrs.get("equation").cast<::mlir::StringAttr>();
  return attr;
}

::mlir::LogicalResult XlaEinsumOpAdaptor::verify(::mlir::Location loc) {
  {
  auto tblgen_equation = odsAttrs.get("equation");
  if (!tblgen_equation) return emitError(loc, "'tf.XlaEinsum' op ""requires attribute 'equation'");
    if (!((tblgen_equation.isa<::mlir::StringAttr>()))) return emitError(loc, "'tf.XlaEinsum' op ""attribute 'equation' failed to satisfy constraint: string attribute");
  }
  return ::mlir::success();
}

::llvm::StringRef XlaEinsumOp::getOperationName() {
  return "tf.XlaEinsum";
}

std::pair<unsigned, unsigned> XlaEinsumOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range XlaEinsumOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value XlaEinsumOp::a() {
  return *getODSOperands(0).begin();
}

::mlir::Value XlaEinsumOp::b() {
  return *getODSOperands(1).begin();
}

::mlir::MutableOperandRange XlaEinsumOp::aMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange XlaEinsumOp::bMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> XlaEinsumOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range XlaEinsumOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value XlaEinsumOp::product() {
  return *getODSResults(0).begin();
}

::mlir::StringAttr XlaEinsumOp::equationAttr() {
  return this->getAttr("equation").cast<::mlir::StringAttr>();
}

::llvm::StringRef XlaEinsumOp::equation() {
  auto attr = equationAttr();
  return attr.getValue();
}

Type XlaEinsumOp::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

bool XlaEinsumOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "T") return true;
 return false;
}

::mlir::DictionaryAttr XlaEinsumOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())}
    }, ctx);
}

void XlaEinsumOp::equationAttr(::mlir::StringAttr attr) {
  this->getOperation()->setAttr("equation", attr);
}

void XlaEinsumOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type product, ::mlir::Value a, ::mlir::Value b, ::mlir::StringAttr equation) {
  odsState.addOperands(a);
  odsState.addOperands(b);
  odsState.addAttribute("equation", equation);
  odsState.addTypes(product);
}

void XlaEinsumOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value a, ::mlir::Value b, ::mlir::StringAttr equation) {
  odsState.addOperands(a);
  odsState.addOperands(b);
  odsState.addAttribute("equation", equation);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void XlaEinsumOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type product, ::mlir::Value a, ::mlir::Value b, ::llvm::StringRef equation) {
  odsState.addOperands(a);
  odsState.addOperands(b);
  odsState.addAttribute("equation", odsBuilder.getStringAttr(equation));
  odsState.addTypes(product);
}

void XlaEinsumOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value a, ::mlir::Value b, ::llvm::StringRef equation) {
  odsState.addOperands(a);
  odsState.addOperands(b);
  odsState.addAttribute("equation", odsBuilder.getStringAttr(equation));
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void XlaEinsumOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult XlaEinsumOp::verify() {
  if (failed(XlaEinsumOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of bfloat16 or 64-bit complex or 32-bit float values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of bfloat16 or 64-bit complex or 32-bit float values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())))))) {
        return emitOpError("result #") << index << " must be tensor of bfloat16 or 64-bit complex or 32-bit float values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void XlaEinsumOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::XlaGatherOp definitions
//===----------------------------------------------------------------------===//

XlaGatherOpAdaptor::XlaGatherOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

XlaGatherOpAdaptor::XlaGatherOpAdaptor(XlaGatherOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> XlaGatherOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange XlaGatherOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value XlaGatherOpAdaptor::operand() {
  return *getODSOperands(0).begin();
}

::mlir::Value XlaGatherOpAdaptor::start_indices() {
  return *getODSOperands(1).begin();
}

::mlir::Value XlaGatherOpAdaptor::slice_sizes() {
  return *getODSOperands(2).begin();
}

::mlir::StringAttr XlaGatherOpAdaptor::dimension_numbers() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::StringAttr attr = odsAttrs.get("dimension_numbers").cast<::mlir::StringAttr>();
  return attr;
}

::mlir::BoolAttr XlaGatherOpAdaptor::indices_are_sorted() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::BoolAttr attr = odsAttrs.get("indices_are_sorted").cast<::mlir::BoolAttr>();
  return attr;
}

::mlir::LogicalResult XlaGatherOpAdaptor::verify(::mlir::Location loc) {
  {
  auto tblgen_dimension_numbers = odsAttrs.get("dimension_numbers");
  if (!tblgen_dimension_numbers) return emitError(loc, "'tf.XlaGather' op ""requires attribute 'dimension_numbers'");
    if (!((tblgen_dimension_numbers.isa<::mlir::StringAttr>()))) return emitError(loc, "'tf.XlaGather' op ""attribute 'dimension_numbers' failed to satisfy constraint: string attribute");
  }
  {
  auto tblgen_indices_are_sorted = odsAttrs.get("indices_are_sorted");
  if (!tblgen_indices_are_sorted) return emitError(loc, "'tf.XlaGather' op ""requires attribute 'indices_are_sorted'");
    if (!((tblgen_indices_are_sorted.isa<::mlir::BoolAttr>()))) return emitError(loc, "'tf.XlaGather' op ""attribute 'indices_are_sorted' failed to satisfy constraint: bool attribute");
  }
  return ::mlir::success();
}

::llvm::StringRef XlaGatherOp::getOperationName() {
  return "tf.XlaGather";
}

std::pair<unsigned, unsigned> XlaGatherOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range XlaGatherOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value XlaGatherOp::operand() {
  return *getODSOperands(0).begin();
}

::mlir::Value XlaGatherOp::start_indices() {
  return *getODSOperands(1).begin();
}

::mlir::Value XlaGatherOp::slice_sizes() {
  return *getODSOperands(2).begin();
}

::mlir::MutableOperandRange XlaGatherOp::operandMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange XlaGatherOp::start_indicesMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange XlaGatherOp::slice_sizesMutable() {
  auto range = getODSOperandIndexAndLength(2);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> XlaGatherOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range XlaGatherOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value XlaGatherOp::output() {
  return *getODSResults(0).begin();
}

::mlir::StringAttr XlaGatherOp::dimension_numbersAttr() {
  return this->getAttr("dimension_numbers").cast<::mlir::StringAttr>();
}

::llvm::StringRef XlaGatherOp::dimension_numbers() {
  auto attr = dimension_numbersAttr();
  return attr.getValue();
}

::mlir::BoolAttr XlaGatherOp::indices_are_sortedAttr() {
  return this->getAttr("indices_are_sorted").cast<::mlir::BoolAttr>();
}

bool XlaGatherOp::indices_are_sorted() {
  auto attr = indices_are_sortedAttr();
  return attr.getValue();
}

Type XlaGatherOp::Tindices() {
  return mlir::getElementTypeOrSelf(*getODSOperands(1).begin());
}

Type XlaGatherOp::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

bool XlaGatherOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "Tindices") return true;
  if (name == "T") return true;
 return false;
}

::mlir::DictionaryAttr XlaGatherOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("Tindices", ctx),
::mlir::TypeAttr::get(Tindices())},
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())}
    }, ctx);
}

void XlaGatherOp::dimension_numbersAttr(::mlir::StringAttr attr) {
  this->getOperation()->setAttr("dimension_numbers", attr);
}

void XlaGatherOp::indices_are_sortedAttr(::mlir::BoolAttr attr) {
  this->getOperation()->setAttr("indices_are_sorted", attr);
}

void XlaGatherOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value operand, ::mlir::Value start_indices, ::mlir::Value slice_sizes, ::mlir::StringAttr dimension_numbers, ::mlir::BoolAttr indices_are_sorted) {
  odsState.addOperands(operand);
  odsState.addOperands(start_indices);
  odsState.addOperands(slice_sizes);
  odsState.addAttribute("dimension_numbers", dimension_numbers);
  odsState.addAttribute("indices_are_sorted", indices_are_sorted);
  odsState.addTypes(output);
}

void XlaGatherOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operand, ::mlir::Value start_indices, ::mlir::Value slice_sizes, ::mlir::StringAttr dimension_numbers, ::mlir::BoolAttr indices_are_sorted) {
  odsState.addOperands(operand);
  odsState.addOperands(start_indices);
  odsState.addOperands(slice_sizes);
  odsState.addAttribute("dimension_numbers", dimension_numbers);
  odsState.addAttribute("indices_are_sorted", indices_are_sorted);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void XlaGatherOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value operand, ::mlir::Value start_indices, ::mlir::Value slice_sizes, ::llvm::StringRef dimension_numbers, bool indices_are_sorted) {
  odsState.addOperands(operand);
  odsState.addOperands(start_indices);
  odsState.addOperands(slice_sizes);
  odsState.addAttribute("dimension_numbers", odsBuilder.getStringAttr(dimension_numbers));
  odsState.addAttribute("indices_are_sorted", odsBuilder.getBoolAttr(indices_are_sorted));
  odsState.addTypes(output);
}

void XlaGatherOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operand, ::mlir::Value start_indices, ::mlir::Value slice_sizes, ::llvm::StringRef dimension_numbers, bool indices_are_sorted) {
  odsState.addOperands(operand);
  odsState.addOperands(start_indices);
  odsState.addOperands(slice_sizes);
  odsState.addAttribute("dimension_numbers", odsBuilder.getStringAttr(dimension_numbers));
  odsState.addAttribute("indices_are_sorted", odsBuilder.getBoolAttr(indices_are_sorted));
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void XlaGatherOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 3u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult XlaGatherOp::verify() {
  if (failed(XlaGatherOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of bfloat16 or 128-bit complex or 64-bit complex or 16-bit float or 32-bit float or 64-bit float or 16-bit integer or 32-bit integer or 64-bit integer or 8-bit integer or 32-bit quantized integer or 8-bit quantized integer or 8-bit quantized unsigned integer or 16-bit unsigned integer or 32-bit unsigned integer or 64-bit unsigned integer or 8-bit unsigned integer values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of 32/64-bit signed integer values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup2 = getODSOperands(2);
    for (::mlir::Value v : valueGroup2) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of 32/64-bit signed integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>())))))) {
        return emitOpError("result #") << index << " must be tensor of bfloat16 or 128-bit complex or 64-bit complex or 16-bit float or 32-bit float or 64-bit float or 16-bit integer or 32-bit integer or 64-bit integer or 8-bit integer or 32-bit quantized integer or 8-bit quantized integer or 8-bit quantized unsigned integer or 16-bit unsigned integer or 32-bit unsigned integer or 64-bit unsigned integer or 8-bit unsigned integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void XlaGatherOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::XlaHostComputeOp definitions
//===----------------------------------------------------------------------===//

XlaHostComputeOpAdaptor::XlaHostComputeOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

XlaHostComputeOpAdaptor::XlaHostComputeOpAdaptor(XlaHostComputeOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> XlaHostComputeOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  bool isVariadic[] = {true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (odsOperands.size() - 0) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::mlir::ValueRange XlaHostComputeOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::ValueRange XlaHostComputeOpAdaptor::inputs() {
  return getODSOperands(0);
}

::mlir::ArrayAttr XlaHostComputeOpAdaptor::ancestors() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::ArrayAttr attr = odsAttrs.get("ancestors").cast<::mlir::ArrayAttr>();
  return attr;
}

::mlir::ArrayAttr XlaHostComputeOpAdaptor::shapes() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::ArrayAttr attr = odsAttrs.get("shapes").cast<::mlir::ArrayAttr>();
  return attr;
}

::mlir::SymbolRefAttr XlaHostComputeOpAdaptor::shape_inference_graph() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::SymbolRefAttr attr = odsAttrs.get("shape_inference_graph").cast<::mlir::SymbolRefAttr>();
  return attr;
}

::mlir::StringAttr XlaHostComputeOpAdaptor::key() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::StringAttr attr = odsAttrs.get("key").cast<::mlir::StringAttr>();
  return attr;
}

::mlir::IntegerAttr XlaHostComputeOpAdaptor::cost_estimate_ns() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::IntegerAttr attr = odsAttrs.get("cost_estimate_ns").dyn_cast_or_null<::mlir::IntegerAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getIntegerAttr(::mlir::Builder(odsAttrs.getContext()).getIntegerType(64), 1000000);
  return attr;
}

::mlir::IntegerAttr XlaHostComputeOpAdaptor::tpu_core() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::IntegerAttr attr = odsAttrs.get("tpu_core").dyn_cast_or_null<::mlir::IntegerAttr>();
  if (!attr)
    attr = ::mlir::Builder(odsAttrs.getContext()).getIntegerAttr(::mlir::Builder(odsAttrs.getContext()).getIntegerType(64), 0);
  return attr;
}

::mlir::LogicalResult XlaHostComputeOpAdaptor::verify(::mlir::Location loc) {
  {
  auto tblgen_ancestors = odsAttrs.get("ancestors");
  if (!tblgen_ancestors) return emitError(loc, "'tf.XlaHostCompute' op ""requires attribute 'ancestors'");
    if (!(((tblgen_ancestors.isa<::mlir::ArrayAttr>())) && (::llvm::all_of(tblgen_ancestors.cast<::mlir::ArrayAttr>(), [](::mlir::Attribute attr) { return (attr.isa<::mlir::StringAttr>()); })))) return emitError(loc, "'tf.XlaHostCompute' op ""attribute 'ancestors' failed to satisfy constraint: string array attribute");
  }
  {
  auto tblgen_shapes = odsAttrs.get("shapes");
  if (!tblgen_shapes) return emitError(loc, "'tf.XlaHostCompute' op ""requires attribute 'shapes'");
    if (!(((tblgen_shapes.isa<::mlir::ArrayAttr>())) && (::llvm::all_of(tblgen_shapes.cast<::mlir::ArrayAttr>(), [](::mlir::Attribute attr) { return (attr.isa<mlir::TF::ShapeAttr>()); })))) return emitError(loc, "'tf.XlaHostCompute' op ""attribute 'shapes' failed to satisfy constraint: tensorflow shape attribute array");
  }
  {
  auto tblgen_shape_inference_graph = odsAttrs.get("shape_inference_graph");
  if (!tblgen_shape_inference_graph) return emitError(loc, "'tf.XlaHostCompute' op ""requires attribute 'shape_inference_graph'");
    if (!((tblgen_shape_inference_graph.isa<::mlir::SymbolRefAttr>()))) return emitError(loc, "'tf.XlaHostCompute' op ""attribute 'shape_inference_graph' failed to satisfy constraint: symbol reference attribute");
  }
  {
  auto tblgen_key = odsAttrs.get("key");
  if (!tblgen_key) return emitError(loc, "'tf.XlaHostCompute' op ""requires attribute 'key'");
    if (!((tblgen_key.isa<::mlir::StringAttr>()))) return emitError(loc, "'tf.XlaHostCompute' op ""attribute 'key' failed to satisfy constraint: string attribute");
  }
  {
  auto tblgen_cost_estimate_ns = odsAttrs.get("cost_estimate_ns");
  if (tblgen_cost_estimate_ns) {
    if (!(((tblgen_cost_estimate_ns.isa<::mlir::IntegerAttr>())) && ((tblgen_cost_estimate_ns.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(64))))) return emitError(loc, "'tf.XlaHostCompute' op ""attribute 'cost_estimate_ns' failed to satisfy constraint: 64-bit signless integer attribute");
  }
  }
  {
  auto tblgen_tpu_core = odsAttrs.get("tpu_core");
  if (tblgen_tpu_core) {
    if (!(((tblgen_tpu_core.isa<::mlir::IntegerAttr>())) && ((tblgen_tpu_core.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(64))))) return emitError(loc, "'tf.XlaHostCompute' op ""attribute 'tpu_core' failed to satisfy constraint: 64-bit signless integer attribute");
  }
  }
  return ::mlir::success();
}

::llvm::StringRef XlaHostComputeOp::getOperationName() {
  return "tf.XlaHostCompute";
}

std::pair<unsigned, unsigned> XlaHostComputeOp::getODSOperandIndexAndLength(unsigned index) {
  bool isVariadic[] = {true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (getOperation()->getNumOperands() - 0) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::mlir::Operation::operand_range XlaHostComputeOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Operation::operand_range XlaHostComputeOp::inputs() {
  return getODSOperands(0);
}

::mlir::MutableOperandRange XlaHostComputeOp::inputsMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> XlaHostComputeOp::getODSResultIndexAndLength(unsigned index) {
  bool isVariadic[] = {true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (getOperation()->getNumResults() - 0) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::mlir::Operation::result_range XlaHostComputeOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Operation::result_range XlaHostComputeOp::outputs() {
  return getODSResults(0);
}

::mlir::ArrayAttr XlaHostComputeOp::ancestorsAttr() {
  return this->getAttr("ancestors").cast<::mlir::ArrayAttr>();
}

::mlir::ArrayAttr XlaHostComputeOp::ancestors() {
  auto attr = ancestorsAttr();
  return attr;
}

::mlir::ArrayAttr XlaHostComputeOp::shapesAttr() {
  return this->getAttr("shapes").cast<::mlir::ArrayAttr>();
}

::mlir::ArrayAttr XlaHostComputeOp::shapes() {
  auto attr = shapesAttr();
  return attr;
}

::mlir::SymbolRefAttr XlaHostComputeOp::shape_inference_graphAttr() {
  return this->getAttr("shape_inference_graph").cast<::mlir::SymbolRefAttr>();
}

::mlir::SymbolRefAttr XlaHostComputeOp::shape_inference_graph() {
  auto attr = shape_inference_graphAttr();
  return attr;
}

::mlir::StringAttr XlaHostComputeOp::keyAttr() {
  return this->getAttr("key").cast<::mlir::StringAttr>();
}

::llvm::StringRef XlaHostComputeOp::key() {
  auto attr = keyAttr();
  return attr.getValue();
}

::mlir::IntegerAttr XlaHostComputeOp::cost_estimate_nsAttr() {
  return this->getAttr("cost_estimate_ns").dyn_cast_or_null<::mlir::IntegerAttr>();
}

uint64_t XlaHostComputeOp::cost_estimate_ns() {
  auto attr = cost_estimate_nsAttr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getIntegerAttr(::mlir::Builder(this->getContext()).getIntegerType(64), 1000000).getValue().getZExtValue();
  return attr.getValue().getZExtValue();
}

::mlir::IntegerAttr XlaHostComputeOp::tpu_coreAttr() {
  return this->getAttr("tpu_core").dyn_cast_or_null<::mlir::IntegerAttr>();
}

uint64_t XlaHostComputeOp::tpu_core() {
  auto attr = tpu_coreAttr();
    if (!attr)
      return ::mlir::Builder(this->getContext()).getIntegerAttr(::mlir::Builder(this->getContext()).getIntegerType(64), 0).getValue().getZExtValue();
  return attr.getValue().getZExtValue();
}

mlir::OperandElementTypeRange XlaHostComputeOp::Tinputs() {
  auto values = getODSOperands(0);
return {mlir::OperandElementTypeIterator(values.begin()), mlir::OperandElementTypeIterator(values.end())};
}

mlir::ResultElementTypeRange XlaHostComputeOp::Toutputs() {
  auto values = getODSResults(0);
return {mlir::ResultElementTypeIterator(values.begin()), mlir::ResultElementTypeIterator(values.end())};
}

bool XlaHostComputeOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "Tinputs") return true;
  if (name == "Toutputs") return true;
 return false;
}

::mlir::DictionaryAttr XlaHostComputeOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("Tinputs", ctx),
ArrayAttr::get(
    [&]() {
      llvm::SmallVector<Attribute, 4> ret;
      for (auto t : Tinputs())
        ret.push_back(TypeAttr::get(t));
      return ret;
    }(), ctx)},
    {::mlir::Identifier::get("Toutputs", ctx),
ArrayAttr::get(
    [&]() {
      llvm::SmallVector<Attribute, 4> ret;
      for (auto t : Toutputs())
        ret.push_back(TypeAttr::get(t));
      return ret;
    }(), ctx)}
    }, ctx);
}

void XlaHostComputeOp::ancestorsAttr(::mlir::ArrayAttr attr) {
  this->getOperation()->setAttr("ancestors", attr);
}

void XlaHostComputeOp::shapesAttr(::mlir::ArrayAttr attr) {
  this->getOperation()->setAttr("shapes", attr);
}

void XlaHostComputeOp::shape_inference_graphAttr(::mlir::SymbolRefAttr attr) {
  this->getOperation()->setAttr("shape_inference_graph", attr);
}

void XlaHostComputeOp::keyAttr(::mlir::StringAttr attr) {
  this->getOperation()->setAttr("key", attr);
}

void XlaHostComputeOp::cost_estimate_nsAttr(::mlir::IntegerAttr attr) {
  this->getOperation()->setAttr("cost_estimate_ns", attr);
}

void XlaHostComputeOp::tpu_coreAttr(::mlir::IntegerAttr attr) {
  this->getOperation()->setAttr("tpu_core", attr);
}

void XlaHostComputeOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange outputs, ::mlir::ValueRange inputs, ::mlir::ArrayAttr ancestors, ::mlir::ArrayAttr shapes, ::mlir::SymbolRefAttr shape_inference_graph, ::mlir::StringAttr key, ::mlir::IntegerAttr cost_estimate_ns, ::mlir::IntegerAttr tpu_core) {
  odsState.addOperands(inputs);
  odsState.addAttribute("ancestors", ancestors);
  odsState.addAttribute("shapes", shapes);
  odsState.addAttribute("shape_inference_graph", shape_inference_graph);
  odsState.addAttribute("key", key);
  odsState.addAttribute("cost_estimate_ns", cost_estimate_ns);
  odsState.addAttribute("tpu_core", tpu_core);
  odsState.addTypes(outputs);
}

void XlaHostComputeOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange outputs, ::mlir::ValueRange inputs, ::mlir::ArrayAttr ancestors, ::mlir::ArrayAttr shapes, ::mlir::SymbolRefAttr shape_inference_graph, ::llvm::StringRef key, uint64_t cost_estimate_ns, uint64_t tpu_core) {
  odsState.addOperands(inputs);
  odsState.addAttribute("ancestors", ancestors);
  odsState.addAttribute("shapes", shapes);
  odsState.addAttribute("shape_inference_graph", shape_inference_graph);
  odsState.addAttribute("key", odsBuilder.getStringAttr(key));
  odsState.addAttribute("cost_estimate_ns", odsBuilder.getIntegerAttr(odsBuilder.getIntegerType(64), cost_estimate_ns));
  odsState.addAttribute("tpu_core", odsBuilder.getIntegerAttr(odsBuilder.getIntegerType(64), tpu_core));
  odsState.addTypes(outputs);
}

void XlaHostComputeOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult XlaHostComputeOp::verify() {
  if (failed(XlaHostComputeOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>())))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::TensorFlowType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of tf.dtype values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>())))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::TensorFlowType>()))))) {
        return emitOpError("result #") << index << " must be tensor of tf.dtype values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::XlaKeyValueSortOp definitions
//===----------------------------------------------------------------------===//

XlaKeyValueSortOpAdaptor::XlaKeyValueSortOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

XlaKeyValueSortOpAdaptor::XlaKeyValueSortOpAdaptor(XlaKeyValueSortOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> XlaKeyValueSortOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange XlaKeyValueSortOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value XlaKeyValueSortOpAdaptor::keys() {
  return *getODSOperands(0).begin();
}

::mlir::Value XlaKeyValueSortOpAdaptor::values() {
  return *getODSOperands(1).begin();
}

::mlir::LogicalResult XlaKeyValueSortOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

void XlaKeyValueSortOp::getAsmResultNames(::mlir::OpAsmSetValueNameFn setNameFn) {
  auto resultGroup0 = getODSResults(0);
  if (!llvm::empty(resultGroup0))
    setNameFn(*resultGroup0.begin(), "sorted_keys");
  auto resultGroup1 = getODSResults(1);
  if (!llvm::empty(resultGroup1))
    setNameFn(*resultGroup1.begin(), "sorted_values");
}

::llvm::StringRef XlaKeyValueSortOp::getOperationName() {
  return "tf.XlaKeyValueSort";
}

std::pair<unsigned, unsigned> XlaKeyValueSortOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range XlaKeyValueSortOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value XlaKeyValueSortOp::keys() {
  return *getODSOperands(0).begin();
}

::mlir::Value XlaKeyValueSortOp::values() {
  return *getODSOperands(1).begin();
}

::mlir::MutableOperandRange XlaKeyValueSortOp::keysMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange XlaKeyValueSortOp::valuesMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> XlaKeyValueSortOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range XlaKeyValueSortOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value XlaKeyValueSortOp::sorted_keys() {
  return *getODSResults(0).begin();
}

::mlir::Value XlaKeyValueSortOp::sorted_values() {
  return *getODSResults(1).begin();
}

Type XlaKeyValueSortOp::V() {
  return mlir::getElementTypeOrSelf(*getODSOperands(1).begin());
}

Type XlaKeyValueSortOp::K() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

bool XlaKeyValueSortOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "V") return true;
  if (name == "K") return true;
 return false;
}

::mlir::DictionaryAttr XlaKeyValueSortOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("V", ctx),
::mlir::TypeAttr::get(V())},
    {::mlir::Identifier::get("K", ctx),
::mlir::TypeAttr::get(K())}
    }, ctx);
}

void XlaKeyValueSortOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type sorted_keys, ::mlir::Type sorted_values, ::mlir::Value keys, ::mlir::Value values) {
  odsState.addOperands(keys);
  odsState.addOperands(values);
  odsState.addTypes(sorted_keys);
  odsState.addTypes(sorted_values);
}

void XlaKeyValueSortOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value keys, ::mlir::Value values) {
  odsState.addOperands(keys);
  odsState.addOperands(values);
  assert(resultTypes.size() == 2u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void XlaKeyValueSortOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 2u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult XlaKeyValueSortOp::verify() {
  if (failed(XlaKeyValueSortOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of integer or floating-point values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>())))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::TensorFlowType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of tf.dtype values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>())))))) {
        return emitOpError("result #") << index << " must be tensor of integer or floating-point values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSResults(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>())))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::TensorFlowType>()))))) {
        return emitOpError("result #") << index << " must be tensor of tf.dtype values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void XlaKeyValueSortOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::XlaPadOp definitions
//===----------------------------------------------------------------------===//

XlaPadOpAdaptor::XlaPadOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

XlaPadOpAdaptor::XlaPadOpAdaptor(XlaPadOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> XlaPadOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange XlaPadOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value XlaPadOpAdaptor::input() {
  return *getODSOperands(0).begin();
}

::mlir::Value XlaPadOpAdaptor::padding_value() {
  return *getODSOperands(1).begin();
}

::mlir::Value XlaPadOpAdaptor::padding_low() {
  return *getODSOperands(2).begin();
}

::mlir::Value XlaPadOpAdaptor::padding_high() {
  return *getODSOperands(3).begin();
}

::mlir::Value XlaPadOpAdaptor::padding_interior() {
  return *getODSOperands(4).begin();
}

::mlir::LogicalResult XlaPadOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

::llvm::StringRef XlaPadOp::getOperationName() {
  return "tf.XlaPad";
}

std::pair<unsigned, unsigned> XlaPadOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range XlaPadOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value XlaPadOp::input() {
  return *getODSOperands(0).begin();
}

::mlir::Value XlaPadOp::padding_value() {
  return *getODSOperands(1).begin();
}

::mlir::Value XlaPadOp::padding_low() {
  return *getODSOperands(2).begin();
}

::mlir::Value XlaPadOp::padding_high() {
  return *getODSOperands(3).begin();
}

::mlir::Value XlaPadOp::padding_interior() {
  return *getODSOperands(4).begin();
}

::mlir::MutableOperandRange XlaPadOp::inputMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange XlaPadOp::padding_valueMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange XlaPadOp::padding_lowMutable() {
  auto range = getODSOperandIndexAndLength(2);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange XlaPadOp::padding_highMutable() {
  auto range = getODSOperandIndexAndLength(3);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange XlaPadOp::padding_interiorMutable() {
  auto range = getODSOperandIndexAndLength(4);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> XlaPadOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range XlaPadOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value XlaPadOp::output() {
  return *getODSResults(0).begin();
}

Type XlaPadOp::Tindices() {
  return mlir::getElementTypeOrSelf(*getODSOperands(2).begin());
}

Type XlaPadOp::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

bool XlaPadOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "Tindices") return true;
  if (name == "T") return true;
 return false;
}

::mlir::DictionaryAttr XlaPadOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("Tindices", ctx),
::mlir::TypeAttr::get(Tindices())},
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())}
    }, ctx);
}

void XlaPadOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value input, ::mlir::Value padding_value, ::mlir::Value padding_low, ::mlir::Value padding_high, ::mlir::Value padding_interior) {
  odsState.addOperands(input);
  odsState.addOperands(padding_value);
  odsState.addOperands(padding_low);
  odsState.addOperands(padding_high);
  odsState.addOperands(padding_interior);
  odsState.addTypes(output);
}

void XlaPadOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input, ::mlir::Value padding_value, ::mlir::Value padding_low, ::mlir::Value padding_high, ::mlir::Value padding_interior) {
  odsState.addOperands(input);
  odsState.addOperands(padding_value);
  odsState.addOperands(padding_low);
  odsState.addOperands(padding_high);
  odsState.addOperands(padding_interior);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void XlaPadOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 5u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult XlaPadOp::verify() {
  if (failed(XlaPadOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>())))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::TensorFlowType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of tf.dtype values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>())))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::TensorFlowType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of tf.dtype values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup2 = getODSOperands(2);
    for (::mlir::Value v : valueGroup2) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of 32/64-bit signed integer values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup3 = getODSOperands(3);
    for (::mlir::Value v : valueGroup3) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of 32/64-bit signed integer values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup4 = getODSOperands(4);
    for (::mlir::Value v : valueGroup4) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of 32/64-bit signed integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>())))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::TensorFlowType>()))))) {
        return emitOpError("result #") << index << " must be tensor of tf.dtype values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void XlaPadOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::XlaRecvFromHostOp definitions
//===----------------------------------------------------------------------===//

XlaRecvFromHostOpAdaptor::XlaRecvFromHostOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

XlaRecvFromHostOpAdaptor::XlaRecvFromHostOpAdaptor(XlaRecvFromHostOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> XlaRecvFromHostOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange XlaRecvFromHostOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

Attribute XlaRecvFromHostOpAdaptor::shape() {
  assert(odsAttrs && "no attributes when constructing adapter");
  Attribute attr = odsAttrs.get("shape").cast<Attribute>();
  return attr;
}

::mlir::StringAttr XlaRecvFromHostOpAdaptor::key() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::StringAttr attr = odsAttrs.get("key").cast<::mlir::StringAttr>();
  return attr;
}

::mlir::LogicalResult XlaRecvFromHostOpAdaptor::verify(::mlir::Location loc) {
  {
  auto tblgen_shape = odsAttrs.get("shape");
  if (!tblgen_shape) return emitError(loc, "'tf.XlaRecvFromHost' op ""requires attribute 'shape'");
    if (!((tblgen_shape.isa<mlir::TF::ShapeAttr>()))) return emitError(loc, "'tf.XlaRecvFromHost' op ""attribute 'shape' failed to satisfy constraint: TensorFlow shape attribute");
  }
  {
  auto tblgen_key = odsAttrs.get("key");
  if (!tblgen_key) return emitError(loc, "'tf.XlaRecvFromHost' op ""requires attribute 'key'");
    if (!((tblgen_key.isa<::mlir::StringAttr>()))) return emitError(loc, "'tf.XlaRecvFromHost' op ""attribute 'key' failed to satisfy constraint: string attribute");
  }
  return ::mlir::success();
}

::llvm::StringRef XlaRecvFromHostOp::getOperationName() {
  return "tf.XlaRecvFromHost";
}

std::pair<unsigned, unsigned> XlaRecvFromHostOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range XlaRecvFromHostOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

std::pair<unsigned, unsigned> XlaRecvFromHostOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range XlaRecvFromHostOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value XlaRecvFromHostOp::output() {
  return *getODSResults(0).begin();
}

Attribute XlaRecvFromHostOp::shapeAttr() {
  return this->getAttr("shape").cast<Attribute>();
}

llvm::Optional<llvm::ArrayRef<int64_t>> XlaRecvFromHostOp::shape() {
  auto attr = shapeAttr();
  return attr.cast<mlir::TF::ShapeAttr>().getValue();
}

::mlir::StringAttr XlaRecvFromHostOp::keyAttr() {
  return this->getAttr("key").cast<::mlir::StringAttr>();
}

::llvm::StringRef XlaRecvFromHostOp::key() {
  auto attr = keyAttr();
  return attr.getValue();
}

Type XlaRecvFromHostOp::Toutput() {
  return mlir::getElementTypeOrSelf(*getODSResults(0).begin());
}

bool XlaRecvFromHostOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "Toutput") return true;
 return false;
}

::mlir::DictionaryAttr XlaRecvFromHostOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("Toutput", ctx),
::mlir::TypeAttr::get(Toutput())}
    }, ctx);
}

void XlaRecvFromHostOp::shapeAttr(Attribute attr) {
  this->getOperation()->setAttr("shape", attr);
}

void XlaRecvFromHostOp::keyAttr(::mlir::StringAttr attr) {
  this->getOperation()->setAttr("key", attr);
}

void XlaRecvFromHostOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, Attribute shape, ::mlir::StringAttr key) {
  odsState.addAttribute("shape", shape);
  odsState.addAttribute("key", key);
  odsState.addTypes(output);
}

void XlaRecvFromHostOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, Attribute shape, ::mlir::StringAttr key) {
  odsState.addAttribute("shape", shape);
  odsState.addAttribute("key", key);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void XlaRecvFromHostOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, llvm::Optional<llvm::ArrayRef<int64_t>> shape, ::llvm::StringRef key) {
  odsState.addAttribute("shape", mlir::TF::ShapeAttr::get(odsBuilder.getContext(), shape));
  odsState.addAttribute("key", odsBuilder.getStringAttr(key));
  odsState.addTypes(output);
}

void XlaRecvFromHostOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, llvm::Optional<llvm::ArrayRef<int64_t>> shape, ::llvm::StringRef key) {
  odsState.addAttribute("shape", mlir::TF::ShapeAttr::get(odsBuilder.getContext(), shape));
  odsState.addAttribute("key", odsBuilder.getStringAttr(key));
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void XlaRecvFromHostOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 0u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult XlaRecvFromHostOp::verify() {
  if (failed(XlaRecvFromHostOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>())))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::TensorFlowType>()))))) {
        return emitOpError("result #") << index << " must be tensor of tf.dtype values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::XlaReduceOp definitions
//===----------------------------------------------------------------------===//

XlaReduceOpAdaptor::XlaReduceOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

XlaReduceOpAdaptor::XlaReduceOpAdaptor(XlaReduceOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> XlaReduceOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange XlaReduceOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value XlaReduceOpAdaptor::input() {
  return *getODSOperands(0).begin();
}

::mlir::Value XlaReduceOpAdaptor::init_value() {
  return *getODSOperands(1).begin();
}

::mlir::ArrayAttr XlaReduceOpAdaptor::dimensions_to_reduce() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::ArrayAttr attr = odsAttrs.get("dimensions_to_reduce").cast<::mlir::ArrayAttr>();
  return attr;
}

::mlir::SymbolRefAttr XlaReduceOpAdaptor::reducer() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::SymbolRefAttr attr = odsAttrs.get("reducer").cast<::mlir::SymbolRefAttr>();
  return attr;
}

::mlir::LogicalResult XlaReduceOpAdaptor::verify(::mlir::Location loc) {
  {
  auto tblgen_dimensions_to_reduce = odsAttrs.get("dimensions_to_reduce");
  if (!tblgen_dimensions_to_reduce) return emitError(loc, "'tf.XlaReduce' op ""requires attribute 'dimensions_to_reduce'");
    if (!(((tblgen_dimensions_to_reduce.isa<::mlir::ArrayAttr>())) && (::llvm::all_of(tblgen_dimensions_to_reduce.cast<::mlir::ArrayAttr>(), [](::mlir::Attribute attr) { return ((attr.isa<::mlir::IntegerAttr>())) && ((attr.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(64))); })))) return emitError(loc, "'tf.XlaReduce' op ""attribute 'dimensions_to_reduce' failed to satisfy constraint: 64-bit integer array attribute");
  }
  {
  auto tblgen_reducer = odsAttrs.get("reducer");
  if (!tblgen_reducer) return emitError(loc, "'tf.XlaReduce' op ""requires attribute 'reducer'");
    if (!((tblgen_reducer.isa<::mlir::SymbolRefAttr>()))) return emitError(loc, "'tf.XlaReduce' op ""attribute 'reducer' failed to satisfy constraint: symbol reference attribute");
  }
  return ::mlir::success();
}

::llvm::StringRef XlaReduceOp::getOperationName() {
  return "tf.XlaReduce";
}

std::pair<unsigned, unsigned> XlaReduceOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range XlaReduceOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value XlaReduceOp::input() {
  return *getODSOperands(0).begin();
}

::mlir::Value XlaReduceOp::init_value() {
  return *getODSOperands(1).begin();
}

::mlir::MutableOperandRange XlaReduceOp::inputMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange XlaReduceOp::init_valueMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> XlaReduceOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range XlaReduceOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value XlaReduceOp::output() {
  return *getODSResults(0).begin();
}

::mlir::ArrayAttr XlaReduceOp::dimensions_to_reduceAttr() {
  return this->getAttr("dimensions_to_reduce").cast<::mlir::ArrayAttr>();
}

::mlir::ArrayAttr XlaReduceOp::dimensions_to_reduce() {
  auto attr = dimensions_to_reduceAttr();
  return attr;
}

::mlir::SymbolRefAttr XlaReduceOp::reducerAttr() {
  return this->getAttr("reducer").cast<::mlir::SymbolRefAttr>();
}

::mlir::SymbolRefAttr XlaReduceOp::reducer() {
  auto attr = reducerAttr();
  return attr;
}

Type XlaReduceOp::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

bool XlaReduceOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "T") return true;
 return false;
}

::mlir::DictionaryAttr XlaReduceOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())}
    }, ctx);
}

void XlaReduceOp::dimensions_to_reduceAttr(::mlir::ArrayAttr attr) {
  this->getOperation()->setAttr("dimensions_to_reduce", attr);
}

void XlaReduceOp::reducerAttr(::mlir::SymbolRefAttr attr) {
  this->getOperation()->setAttr("reducer", attr);
}

void XlaReduceOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value input, ::mlir::Value init_value, ::mlir::ArrayAttr dimensions_to_reduce, ::mlir::SymbolRefAttr reducer) {
  odsState.addOperands(input);
  odsState.addOperands(init_value);
  odsState.addAttribute("dimensions_to_reduce", dimensions_to_reduce);
  odsState.addAttribute("reducer", reducer);
  odsState.addTypes(output);
}

void XlaReduceOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input, ::mlir::Value init_value, ::mlir::ArrayAttr dimensions_to_reduce, ::mlir::SymbolRefAttr reducer) {
  odsState.addOperands(input);
  odsState.addOperands(init_value);
  odsState.addAttribute("dimensions_to_reduce", dimensions_to_reduce);
  odsState.addAttribute("reducer", reducer);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void XlaReduceOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult XlaReduceOp::verify() {
  if (failed(XlaReduceOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of bfloat16 or 128-bit complex or 64-bit complex or 16-bit float or 32-bit float or 64-bit float or 16-bit integer or 32-bit integer or 64-bit integer or 8-bit integer or 32-bit quantized integer or 8-bit quantized integer or 8-bit quantized unsigned integer or 16-bit unsigned integer or 32-bit unsigned integer or 64-bit unsigned integer or 8-bit unsigned integer values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of bfloat16 or 128-bit complex or 64-bit complex or 16-bit float or 32-bit float or 64-bit float or 16-bit integer or 32-bit integer or 64-bit integer or 8-bit integer or 32-bit quantized integer or 8-bit quantized integer or 8-bit quantized unsigned integer or 16-bit unsigned integer or 32-bit unsigned integer or 64-bit unsigned integer or 8-bit unsigned integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>())))))) {
        return emitOpError("result #") << index << " must be tensor of bfloat16 or 128-bit complex or 64-bit complex or 16-bit float or 32-bit float or 64-bit float or 16-bit integer or 32-bit integer or 64-bit integer or 8-bit integer or 32-bit quantized integer or 8-bit quantized integer or 8-bit quantized unsigned integer or 16-bit unsigned integer or 32-bit unsigned integer or 64-bit unsigned integer or 8-bit unsigned integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void XlaReduceOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::XlaReplicaIdOp definitions
//===----------------------------------------------------------------------===//

XlaReplicaIdOpAdaptor::XlaReplicaIdOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

XlaReplicaIdOpAdaptor::XlaReplicaIdOpAdaptor(XlaReplicaIdOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> XlaReplicaIdOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange XlaReplicaIdOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::LogicalResult XlaReplicaIdOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

::llvm::StringRef XlaReplicaIdOp::getOperationName() {
  return "tf.XlaReplicaId";
}

std::pair<unsigned, unsigned> XlaReplicaIdOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range XlaReplicaIdOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

std::pair<unsigned, unsigned> XlaReplicaIdOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range XlaReplicaIdOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value XlaReplicaIdOp::id() {
  return *getODSResults(0).begin();
}

void XlaReplicaIdOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type id) {
  odsState.addTypes(id);
}

void XlaReplicaIdOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes) {
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void XlaReplicaIdOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 0u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult XlaReplicaIdOp::verify() {
  if (failed(XlaReplicaIdOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))))) {
        return emitOpError("result #") << index << " must be tensor of 32-bit integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void XlaReplicaIdOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::XlaScatterOp definitions
//===----------------------------------------------------------------------===//

XlaScatterOpAdaptor::XlaScatterOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

XlaScatterOpAdaptor::XlaScatterOpAdaptor(XlaScatterOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> XlaScatterOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange XlaScatterOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value XlaScatterOpAdaptor::operand() {
  return *getODSOperands(0).begin();
}

::mlir::Value XlaScatterOpAdaptor::scatter_indices() {
  return *getODSOperands(1).begin();
}

::mlir::Value XlaScatterOpAdaptor::updates() {
  return *getODSOperands(2).begin();
}

::mlir::SymbolRefAttr XlaScatterOpAdaptor::update_computation() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::SymbolRefAttr attr = odsAttrs.get("update_computation").cast<::mlir::SymbolRefAttr>();
  return attr;
}

::mlir::StringAttr XlaScatterOpAdaptor::dimension_numbers() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::StringAttr attr = odsAttrs.get("dimension_numbers").cast<::mlir::StringAttr>();
  return attr;
}

::mlir::BoolAttr XlaScatterOpAdaptor::indices_are_sorted() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::BoolAttr attr = odsAttrs.get("indices_are_sorted").cast<::mlir::BoolAttr>();
  return attr;
}

::mlir::LogicalResult XlaScatterOpAdaptor::verify(::mlir::Location loc) {
  {
  auto tblgen_update_computation = odsAttrs.get("update_computation");
  if (!tblgen_update_computation) return emitError(loc, "'tf.XlaScatter' op ""requires attribute 'update_computation'");
    if (!((tblgen_update_computation.isa<::mlir::SymbolRefAttr>()))) return emitError(loc, "'tf.XlaScatter' op ""attribute 'update_computation' failed to satisfy constraint: symbol reference attribute");
  }
  {
  auto tblgen_dimension_numbers = odsAttrs.get("dimension_numbers");
  if (!tblgen_dimension_numbers) return emitError(loc, "'tf.XlaScatter' op ""requires attribute 'dimension_numbers'");
    if (!((tblgen_dimension_numbers.isa<::mlir::StringAttr>()))) return emitError(loc, "'tf.XlaScatter' op ""attribute 'dimension_numbers' failed to satisfy constraint: string attribute");
  }
  {
  auto tblgen_indices_are_sorted = odsAttrs.get("indices_are_sorted");
  if (!tblgen_indices_are_sorted) return emitError(loc, "'tf.XlaScatter' op ""requires attribute 'indices_are_sorted'");
    if (!((tblgen_indices_are_sorted.isa<::mlir::BoolAttr>()))) return emitError(loc, "'tf.XlaScatter' op ""attribute 'indices_are_sorted' failed to satisfy constraint: bool attribute");
  }
  return ::mlir::success();
}

::llvm::StringRef XlaScatterOp::getOperationName() {
  return "tf.XlaScatter";
}

std::pair<unsigned, unsigned> XlaScatterOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range XlaScatterOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value XlaScatterOp::operand() {
  return *getODSOperands(0).begin();
}

::mlir::Value XlaScatterOp::scatter_indices() {
  return *getODSOperands(1).begin();
}

::mlir::Value XlaScatterOp::updates() {
  return *getODSOperands(2).begin();
}

::mlir::MutableOperandRange XlaScatterOp::operandMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange XlaScatterOp::scatter_indicesMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange XlaScatterOp::updatesMutable() {
  auto range = getODSOperandIndexAndLength(2);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> XlaScatterOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range XlaScatterOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value XlaScatterOp::output() {
  return *getODSResults(0).begin();
}

::mlir::SymbolRefAttr XlaScatterOp::update_computationAttr() {
  return this->getAttr("update_computation").cast<::mlir::SymbolRefAttr>();
}

::mlir::SymbolRefAttr XlaScatterOp::update_computation() {
  auto attr = update_computationAttr();
  return attr;
}

::mlir::StringAttr XlaScatterOp::dimension_numbersAttr() {
  return this->getAttr("dimension_numbers").cast<::mlir::StringAttr>();
}

::llvm::StringRef XlaScatterOp::dimension_numbers() {
  auto attr = dimension_numbersAttr();
  return attr.getValue();
}

::mlir::BoolAttr XlaScatterOp::indices_are_sortedAttr() {
  return this->getAttr("indices_are_sorted").cast<::mlir::BoolAttr>();
}

bool XlaScatterOp::indices_are_sorted() {
  auto attr = indices_are_sortedAttr();
  return attr.getValue();
}

Type XlaScatterOp::Tindices() {
  return mlir::getElementTypeOrSelf(*getODSOperands(1).begin());
}

Type XlaScatterOp::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

bool XlaScatterOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "Tindices") return true;
  if (name == "T") return true;
 return false;
}

::mlir::DictionaryAttr XlaScatterOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("Tindices", ctx),
::mlir::TypeAttr::get(Tindices())},
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())}
    }, ctx);
}

void XlaScatterOp::update_computationAttr(::mlir::SymbolRefAttr attr) {
  this->getOperation()->setAttr("update_computation", attr);
}

void XlaScatterOp::dimension_numbersAttr(::mlir::StringAttr attr) {
  this->getOperation()->setAttr("dimension_numbers", attr);
}

void XlaScatterOp::indices_are_sortedAttr(::mlir::BoolAttr attr) {
  this->getOperation()->setAttr("indices_are_sorted", attr);
}

void XlaScatterOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value operand, ::mlir::Value scatter_indices, ::mlir::Value updates, ::mlir::SymbolRefAttr update_computation, ::mlir::StringAttr dimension_numbers, ::mlir::BoolAttr indices_are_sorted) {
  odsState.addOperands(operand);
  odsState.addOperands(scatter_indices);
  odsState.addOperands(updates);
  odsState.addAttribute("update_computation", update_computation);
  odsState.addAttribute("dimension_numbers", dimension_numbers);
  odsState.addAttribute("indices_are_sorted", indices_are_sorted);
  odsState.addTypes(output);
}

void XlaScatterOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operand, ::mlir::Value scatter_indices, ::mlir::Value updates, ::mlir::SymbolRefAttr update_computation, ::mlir::StringAttr dimension_numbers, ::mlir::BoolAttr indices_are_sorted) {
  odsState.addOperands(operand);
  odsState.addOperands(scatter_indices);
  odsState.addOperands(updates);
  odsState.addAttribute("update_computation", update_computation);
  odsState.addAttribute("dimension_numbers", dimension_numbers);
  odsState.addAttribute("indices_are_sorted", indices_are_sorted);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void XlaScatterOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value operand, ::mlir::Value scatter_indices, ::mlir::Value updates, ::mlir::SymbolRefAttr update_computation, ::llvm::StringRef dimension_numbers, bool indices_are_sorted) {
  odsState.addOperands(operand);
  odsState.addOperands(scatter_indices);
  odsState.addOperands(updates);
  odsState.addAttribute("update_computation", update_computation);
  odsState.addAttribute("dimension_numbers", odsBuilder.getStringAttr(dimension_numbers));
  odsState.addAttribute("indices_are_sorted", odsBuilder.getBoolAttr(indices_are_sorted));
  odsState.addTypes(output);
}

void XlaScatterOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operand, ::mlir::Value scatter_indices, ::mlir::Value updates, ::mlir::SymbolRefAttr update_computation, ::llvm::StringRef dimension_numbers, bool indices_are_sorted) {
  odsState.addOperands(operand);
  odsState.addOperands(scatter_indices);
  odsState.addOperands(updates);
  odsState.addAttribute("update_computation", update_computation);
  odsState.addAttribute("dimension_numbers", odsBuilder.getStringAttr(dimension_numbers));
  odsState.addAttribute("indices_are_sorted", odsBuilder.getBoolAttr(indices_are_sorted));
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void XlaScatterOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 3u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult XlaScatterOp::verify() {
  if (failed(XlaScatterOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of bfloat16 or 128-bit complex or 64-bit complex or 16-bit float or 32-bit float or 64-bit float or 16-bit integer or 32-bit integer or 64-bit integer or 8-bit integer or 32-bit quantized integer or 8-bit quantized integer or 8-bit quantized unsigned integer or 16-bit unsigned integer or 32-bit unsigned integer or 64-bit unsigned integer or 8-bit unsigned integer values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of 32/64-bit signed integer values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup2 = getODSOperands(2);
    for (::mlir::Value v : valueGroup2) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of bfloat16 or 128-bit complex or 64-bit complex or 16-bit float or 32-bit float or 64-bit float or 16-bit integer or 32-bit integer or 64-bit integer or 8-bit integer or 32-bit quantized integer or 8-bit quantized integer or 8-bit quantized unsigned integer or 16-bit unsigned integer or 32-bit unsigned integer or 64-bit unsigned integer or 8-bit unsigned integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>())))))) {
        return emitOpError("result #") << index << " must be tensor of bfloat16 or 128-bit complex or 64-bit complex or 16-bit float or 32-bit float or 64-bit float or 16-bit integer or 32-bit integer or 64-bit integer or 8-bit integer or 32-bit quantized integer or 8-bit quantized integer or 8-bit quantized unsigned integer or 16-bit unsigned integer or 32-bit unsigned integer or 64-bit unsigned integer or 8-bit unsigned integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void XlaScatterOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::XlaSelfAdjointEigOp definitions
//===----------------------------------------------------------------------===//

XlaSelfAdjointEigOpAdaptor::XlaSelfAdjointEigOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

XlaSelfAdjointEigOpAdaptor::XlaSelfAdjointEigOpAdaptor(XlaSelfAdjointEigOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> XlaSelfAdjointEigOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange XlaSelfAdjointEigOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value XlaSelfAdjointEigOpAdaptor::a() {
  return *getODSOperands(0).begin();
}

::mlir::BoolAttr XlaSelfAdjointEigOpAdaptor::lower() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::BoolAttr attr = odsAttrs.get("lower").cast<::mlir::BoolAttr>();
  return attr;
}

::mlir::IntegerAttr XlaSelfAdjointEigOpAdaptor::max_iter() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::IntegerAttr attr = odsAttrs.get("max_iter").cast<::mlir::IntegerAttr>();
  return attr;
}

::mlir::FloatAttr XlaSelfAdjointEigOpAdaptor::epsilon() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::FloatAttr attr = odsAttrs.get("epsilon").cast<::mlir::FloatAttr>();
  return attr;
}

::mlir::LogicalResult XlaSelfAdjointEigOpAdaptor::verify(::mlir::Location loc) {
  {
  auto tblgen_lower = odsAttrs.get("lower");
  if (!tblgen_lower) return emitError(loc, "'tf.XlaSelfAdjointEig' op ""requires attribute 'lower'");
    if (!((tblgen_lower.isa<::mlir::BoolAttr>()))) return emitError(loc, "'tf.XlaSelfAdjointEig' op ""attribute 'lower' failed to satisfy constraint: bool attribute");
  }
  {
  auto tblgen_max_iter = odsAttrs.get("max_iter");
  if (!tblgen_max_iter) return emitError(loc, "'tf.XlaSelfAdjointEig' op ""requires attribute 'max_iter'");
    if (!(((tblgen_max_iter.isa<::mlir::IntegerAttr>())) && ((tblgen_max_iter.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(64))))) return emitError(loc, "'tf.XlaSelfAdjointEig' op ""attribute 'max_iter' failed to satisfy constraint: 64-bit signless integer attribute");
  }
  {
  auto tblgen_epsilon = odsAttrs.get("epsilon");
  if (!tblgen_epsilon) return emitError(loc, "'tf.XlaSelfAdjointEig' op ""requires attribute 'epsilon'");
    if (!(((tblgen_epsilon.isa<::mlir::FloatAttr>())) && ((tblgen_epsilon.cast<::mlir::FloatAttr>().getType().isF32())))) return emitError(loc, "'tf.XlaSelfAdjointEig' op ""attribute 'epsilon' failed to satisfy constraint: 32-bit float attribute");
  }
  return ::mlir::success();
}

void XlaSelfAdjointEigOp::getAsmResultNames(::mlir::OpAsmSetValueNameFn setNameFn) {
  auto resultGroup0 = getODSResults(0);
  if (!llvm::empty(resultGroup0))
    setNameFn(*resultGroup0.begin(), "w");
  auto resultGroup1 = getODSResults(1);
  if (!llvm::empty(resultGroup1))
    setNameFn(*resultGroup1.begin(), "v");
}

::llvm::StringRef XlaSelfAdjointEigOp::getOperationName() {
  return "tf.XlaSelfAdjointEig";
}

std::pair<unsigned, unsigned> XlaSelfAdjointEigOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range XlaSelfAdjointEigOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value XlaSelfAdjointEigOp::a() {
  return *getODSOperands(0).begin();
}

::mlir::MutableOperandRange XlaSelfAdjointEigOp::aMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> XlaSelfAdjointEigOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range XlaSelfAdjointEigOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value XlaSelfAdjointEigOp::w() {
  return *getODSResults(0).begin();
}

::mlir::Value XlaSelfAdjointEigOp::v() {
  return *getODSResults(1).begin();
}

::mlir::BoolAttr XlaSelfAdjointEigOp::lowerAttr() {
  return this->getAttr("lower").cast<::mlir::BoolAttr>();
}

bool XlaSelfAdjointEigOp::lower() {
  auto attr = lowerAttr();
  return attr.getValue();
}

::mlir::IntegerAttr XlaSelfAdjointEigOp::max_iterAttr() {
  return this->getAttr("max_iter").cast<::mlir::IntegerAttr>();
}

uint64_t XlaSelfAdjointEigOp::max_iter() {
  auto attr = max_iterAttr();
  return attr.getValue().getZExtValue();
}

::mlir::FloatAttr XlaSelfAdjointEigOp::epsilonAttr() {
  return this->getAttr("epsilon").cast<::mlir::FloatAttr>();
}

::llvm::APFloat XlaSelfAdjointEigOp::epsilon() {
  auto attr = epsilonAttr();
  return attr.getValue();
}

Type XlaSelfAdjointEigOp::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

bool XlaSelfAdjointEigOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "T") return true;
 return false;
}

::mlir::DictionaryAttr XlaSelfAdjointEigOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())}
    }, ctx);
}

void XlaSelfAdjointEigOp::lowerAttr(::mlir::BoolAttr attr) {
  this->getOperation()->setAttr("lower", attr);
}

void XlaSelfAdjointEigOp::max_iterAttr(::mlir::IntegerAttr attr) {
  this->getOperation()->setAttr("max_iter", attr);
}

void XlaSelfAdjointEigOp::epsilonAttr(::mlir::FloatAttr attr) {
  this->getOperation()->setAttr("epsilon", attr);
}

void XlaSelfAdjointEigOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type w, ::mlir::Type v, ::mlir::Value a, ::mlir::BoolAttr lower, ::mlir::IntegerAttr max_iter, ::mlir::FloatAttr epsilon) {
  odsState.addOperands(a);
  odsState.addAttribute("lower", lower);
  odsState.addAttribute("max_iter", max_iter);
  odsState.addAttribute("epsilon", epsilon);
  odsState.addTypes(w);
  odsState.addTypes(v);
}

void XlaSelfAdjointEigOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value a, ::mlir::BoolAttr lower, ::mlir::IntegerAttr max_iter, ::mlir::FloatAttr epsilon) {
  odsState.addOperands(a);
  odsState.addAttribute("lower", lower);
  odsState.addAttribute("max_iter", max_iter);
  odsState.addAttribute("epsilon", epsilon);
  assert(resultTypes.size() == 2u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void XlaSelfAdjointEigOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type w, ::mlir::Type v, ::mlir::Value a, bool lower, uint64_t max_iter, ::llvm::APFloat epsilon) {
  odsState.addOperands(a);
  odsState.addAttribute("lower", odsBuilder.getBoolAttr(lower));
  odsState.addAttribute("max_iter", odsBuilder.getIntegerAttr(odsBuilder.getIntegerType(64), max_iter));
  odsState.addAttribute("epsilon", odsBuilder.getFloatAttr(odsBuilder.getF32Type(), epsilon));
  odsState.addTypes(w);
  odsState.addTypes(v);
}

void XlaSelfAdjointEigOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value a, bool lower, uint64_t max_iter, ::llvm::APFloat epsilon) {
  odsState.addOperands(a);
  odsState.addAttribute("lower", odsBuilder.getBoolAttr(lower));
  odsState.addAttribute("max_iter", odsBuilder.getIntegerAttr(odsBuilder.getIntegerType(64), max_iter));
  odsState.addAttribute("epsilon", odsBuilder.getFloatAttr(odsBuilder.getF32Type(), epsilon));
  assert(resultTypes.size() == 2u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void XlaSelfAdjointEigOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 2u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult XlaSelfAdjointEigOp::verify() {
  if (failed(XlaSelfAdjointEigOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of bfloat16 or 128-bit complex or 64-bit complex or 16-bit float or 32-bit float or 64-bit float or 16-bit integer or 32-bit integer or 64-bit integer or 8-bit integer or 32-bit quantized integer or 8-bit quantized integer or 8-bit quantized unsigned integer or 16-bit unsigned integer or 32-bit unsigned integer or 64-bit unsigned integer or 8-bit unsigned integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>())))))) {
        return emitOpError("result #") << index << " must be tensor of bfloat16 or 128-bit complex or 64-bit complex or 16-bit float or 32-bit float or 64-bit float or 16-bit integer or 32-bit integer or 64-bit integer or 8-bit integer or 32-bit quantized integer or 8-bit quantized integer or 8-bit quantized unsigned integer or 16-bit unsigned integer or 32-bit unsigned integer or 64-bit unsigned integer or 8-bit unsigned integer values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSResults(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>())))))) {
        return emitOpError("result #") << index << " must be tensor of bfloat16 or 128-bit complex or 64-bit complex or 16-bit float or 32-bit float or 64-bit float or 16-bit integer or 32-bit integer or 64-bit integer or 8-bit integer or 32-bit quantized integer or 8-bit quantized integer or 8-bit quantized unsigned integer or 16-bit unsigned integer or 32-bit unsigned integer or 64-bit unsigned integer or 8-bit unsigned integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void XlaSelfAdjointEigOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::XlaSendToHostOp definitions
//===----------------------------------------------------------------------===//

XlaSendToHostOpAdaptor::XlaSendToHostOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

XlaSendToHostOpAdaptor::XlaSendToHostOpAdaptor(XlaSendToHostOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> XlaSendToHostOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange XlaSendToHostOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value XlaSendToHostOpAdaptor::input() {
  return *getODSOperands(0).begin();
}

::mlir::StringAttr XlaSendToHostOpAdaptor::key() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::StringAttr attr = odsAttrs.get("key").cast<::mlir::StringAttr>();
  return attr;
}

::mlir::LogicalResult XlaSendToHostOpAdaptor::verify(::mlir::Location loc) {
  {
  auto tblgen_key = odsAttrs.get("key");
  if (!tblgen_key) return emitError(loc, "'tf.XlaSendToHost' op ""requires attribute 'key'");
    if (!((tblgen_key.isa<::mlir::StringAttr>()))) return emitError(loc, "'tf.XlaSendToHost' op ""attribute 'key' failed to satisfy constraint: string attribute");
  }
  return ::mlir::success();
}

::llvm::StringRef XlaSendToHostOp::getOperationName() {
  return "tf.XlaSendToHost";
}

std::pair<unsigned, unsigned> XlaSendToHostOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range XlaSendToHostOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value XlaSendToHostOp::input() {
  return *getODSOperands(0).begin();
}

::mlir::MutableOperandRange XlaSendToHostOp::inputMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> XlaSendToHostOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range XlaSendToHostOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::StringAttr XlaSendToHostOp::keyAttr() {
  return this->getAttr("key").cast<::mlir::StringAttr>();
}

::llvm::StringRef XlaSendToHostOp::key() {
  auto attr = keyAttr();
  return attr.getValue();
}

Type XlaSendToHostOp::Tinput() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

bool XlaSendToHostOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "Tinput") return true;
 return false;
}

::mlir::DictionaryAttr XlaSendToHostOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("Tinput", ctx),
::mlir::TypeAttr::get(Tinput())}
    }, ctx);
}

void XlaSendToHostOp::keyAttr(::mlir::StringAttr attr) {
  this->getOperation()->setAttr("key", attr);
}

void XlaSendToHostOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value input, ::mlir::StringAttr key) {
  odsState.addOperands(input);
  odsState.addAttribute("key", key);
}

void XlaSendToHostOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input, ::mlir::StringAttr key) {
  odsState.addOperands(input);
  odsState.addAttribute("key", key);
  assert(resultTypes.size() == 0u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void XlaSendToHostOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value input, ::llvm::StringRef key) {
  odsState.addOperands(input);
  odsState.addAttribute("key", odsBuilder.getStringAttr(key));
}

void XlaSendToHostOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input, ::llvm::StringRef key) {
  odsState.addOperands(input);
  odsState.addAttribute("key", odsBuilder.getStringAttr(key));
  assert(resultTypes.size() == 0u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void XlaSendToHostOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 0u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult XlaSendToHostOp::verify() {
  if (failed(XlaSendToHostOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>())))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::TensorFlowType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of tf.dtype values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
  }
  return ::mlir::success();
}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::XlaShardingOp definitions
//===----------------------------------------------------------------------===//

XlaShardingOpAdaptor::XlaShardingOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

XlaShardingOpAdaptor::XlaShardingOpAdaptor(XlaShardingOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> XlaShardingOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange XlaShardingOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value XlaShardingOpAdaptor::input() {
  return *getODSOperands(0).begin();
}

::mlir::StringAttr XlaShardingOpAdaptor::_XlaSharding() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::StringAttr attr = odsAttrs.get("_XlaSharding").dyn_cast_or_null<::mlir::StringAttr>();
  return attr;
}

::mlir::LogicalResult XlaShardingOpAdaptor::verify(::mlir::Location loc) {
  {
  auto tblgen__XlaSharding = odsAttrs.get("_XlaSharding");
  if (tblgen__XlaSharding) {
    if (!((tblgen__XlaSharding.isa<::mlir::StringAttr>()))) return emitError(loc, "'tf.XlaSharding' op ""attribute '_XlaSharding' failed to satisfy constraint: string attribute");
  }
  }
  return ::mlir::success();
}

::llvm::StringRef XlaShardingOp::getOperationName() {
  return "tf.XlaSharding";
}

std::pair<unsigned, unsigned> XlaShardingOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range XlaShardingOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value XlaShardingOp::input() {
  return *getODSOperands(0).begin();
}

::mlir::MutableOperandRange XlaShardingOp::inputMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> XlaShardingOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range XlaShardingOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value XlaShardingOp::output() {
  return *getODSResults(0).begin();
}

::mlir::StringAttr XlaShardingOp::_XlaShardingAttr() {
  return this->getAttr("_XlaSharding").dyn_cast_or_null<::mlir::StringAttr>();
}

::llvm::Optional< ::llvm::StringRef > XlaShardingOp::_XlaSharding() {
  auto attr = _XlaShardingAttr();
  return attr ? ::llvm::Optional< ::llvm::StringRef >(attr.getValue()) : (::llvm::None);
}

Type XlaShardingOp::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

bool XlaShardingOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "T") return true;
 return false;
}

::mlir::DictionaryAttr XlaShardingOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())}
    }, ctx);
}

void XlaShardingOp::_XlaShardingAttr(::mlir::StringAttr attr) {
  this->getOperation()->setAttr("_XlaSharding", attr);
}

void XlaShardingOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value input, /*optional*/::mlir::StringAttr _XlaSharding) {
  odsState.addOperands(input);
  if (_XlaSharding) {
  odsState.addAttribute("_XlaSharding", _XlaSharding);
  }
  odsState.addTypes(output);
}

void XlaShardingOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input, /*optional*/::mlir::StringAttr _XlaSharding) {
  odsState.addOperands(input);
  if (_XlaSharding) {
  odsState.addAttribute("_XlaSharding", _XlaSharding);
  }
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void XlaShardingOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult XlaShardingOp::verify() {
  if (failed(XlaShardingOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>())))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::TensorFlowType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of tf.dtype values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>())))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::TensorFlowType>()))))) {
        return emitOpError("result #") << index << " must be tensor of tf.dtype values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void XlaShardingOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::XlaSortOp definitions
//===----------------------------------------------------------------------===//

XlaSortOpAdaptor::XlaSortOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

XlaSortOpAdaptor::XlaSortOpAdaptor(XlaSortOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> XlaSortOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange XlaSortOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value XlaSortOpAdaptor::input() {
  return *getODSOperands(0).begin();
}

::mlir::LogicalResult XlaSortOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

::llvm::StringRef XlaSortOp::getOperationName() {
  return "tf.XlaSort";
}

std::pair<unsigned, unsigned> XlaSortOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range XlaSortOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value XlaSortOp::input() {
  return *getODSOperands(0).begin();
}

::mlir::MutableOperandRange XlaSortOp::inputMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> XlaSortOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range XlaSortOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value XlaSortOp::output() {
  return *getODSResults(0).begin();
}

Type XlaSortOp::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

bool XlaSortOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "T") return true;
 return false;
}

::mlir::DictionaryAttr XlaSortOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())}
    }, ctx);
}

void XlaSortOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value input) {
  odsState.addOperands(input);
  odsState.addTypes(output);
}

void XlaSortOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input) {
  odsState.addOperands(input);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void XlaSortOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult XlaSortOp::verify() {
  if (failed(XlaSortOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>())))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::TensorFlowType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of tf.dtype values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>())))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::TensorFlowType>()))))) {
        return emitOpError("result #") << index << " must be tensor of tf.dtype values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void XlaSortOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::XlaSvdOp definitions
//===----------------------------------------------------------------------===//

XlaSvdOpAdaptor::XlaSvdOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

XlaSvdOpAdaptor::XlaSvdOpAdaptor(XlaSvdOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> XlaSvdOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange XlaSvdOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value XlaSvdOpAdaptor::a() {
  return *getODSOperands(0).begin();
}

::mlir::IntegerAttr XlaSvdOpAdaptor::max_iter() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::IntegerAttr attr = odsAttrs.get("max_iter").cast<::mlir::IntegerAttr>();
  return attr;
}

::mlir::FloatAttr XlaSvdOpAdaptor::epsilon() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::FloatAttr attr = odsAttrs.get("epsilon").cast<::mlir::FloatAttr>();
  return attr;
}

::mlir::StringAttr XlaSvdOpAdaptor::precision_config() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::StringAttr attr = odsAttrs.get("precision_config").cast<::mlir::StringAttr>();
  return attr;
}

::mlir::LogicalResult XlaSvdOpAdaptor::verify(::mlir::Location loc) {
  {
  auto tblgen_max_iter = odsAttrs.get("max_iter");
  if (!tblgen_max_iter) return emitError(loc, "'tf.XlaSvd' op ""requires attribute 'max_iter'");
    if (!(((tblgen_max_iter.isa<::mlir::IntegerAttr>())) && ((tblgen_max_iter.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(64))))) return emitError(loc, "'tf.XlaSvd' op ""attribute 'max_iter' failed to satisfy constraint: 64-bit signless integer attribute");
  }
  {
  auto tblgen_epsilon = odsAttrs.get("epsilon");
  if (!tblgen_epsilon) return emitError(loc, "'tf.XlaSvd' op ""requires attribute 'epsilon'");
    if (!(((tblgen_epsilon.isa<::mlir::FloatAttr>())) && ((tblgen_epsilon.cast<::mlir::FloatAttr>().getType().isF32())))) return emitError(loc, "'tf.XlaSvd' op ""attribute 'epsilon' failed to satisfy constraint: 32-bit float attribute");
  }
  {
  auto tblgen_precision_config = odsAttrs.get("precision_config");
  if (!tblgen_precision_config) return emitError(loc, "'tf.XlaSvd' op ""requires attribute 'precision_config'");
    if (!((tblgen_precision_config.isa<::mlir::StringAttr>()))) return emitError(loc, "'tf.XlaSvd' op ""attribute 'precision_config' failed to satisfy constraint: string attribute");
  }
  return ::mlir::success();
}

void XlaSvdOp::getAsmResultNames(::mlir::OpAsmSetValueNameFn setNameFn) {
  auto resultGroup0 = getODSResults(0);
  if (!llvm::empty(resultGroup0))
    setNameFn(*resultGroup0.begin(), "s");
  auto resultGroup1 = getODSResults(1);
  if (!llvm::empty(resultGroup1))
    setNameFn(*resultGroup1.begin(), "u");
  auto resultGroup2 = getODSResults(2);
  if (!llvm::empty(resultGroup2))
    setNameFn(*resultGroup2.begin(), "v");
}

::llvm::StringRef XlaSvdOp::getOperationName() {
  return "tf.XlaSvd";
}

std::pair<unsigned, unsigned> XlaSvdOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range XlaSvdOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value XlaSvdOp::a() {
  return *getODSOperands(0).begin();
}

::mlir::MutableOperandRange XlaSvdOp::aMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> XlaSvdOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range XlaSvdOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value XlaSvdOp::s() {
  return *getODSResults(0).begin();
}

::mlir::Value XlaSvdOp::u() {
  return *getODSResults(1).begin();
}

::mlir::Value XlaSvdOp::v() {
  return *getODSResults(2).begin();
}

::mlir::IntegerAttr XlaSvdOp::max_iterAttr() {
  return this->getAttr("max_iter").cast<::mlir::IntegerAttr>();
}

uint64_t XlaSvdOp::max_iter() {
  auto attr = max_iterAttr();
  return attr.getValue().getZExtValue();
}

::mlir::FloatAttr XlaSvdOp::epsilonAttr() {
  return this->getAttr("epsilon").cast<::mlir::FloatAttr>();
}

::llvm::APFloat XlaSvdOp::epsilon() {
  auto attr = epsilonAttr();
  return attr.getValue();
}

::mlir::StringAttr XlaSvdOp::precision_configAttr() {
  return this->getAttr("precision_config").cast<::mlir::StringAttr>();
}

::llvm::StringRef XlaSvdOp::precision_config() {
  auto attr = precision_configAttr();
  return attr.getValue();
}

Type XlaSvdOp::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

bool XlaSvdOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "T") return true;
 return false;
}

::mlir::DictionaryAttr XlaSvdOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())}
    }, ctx);
}

void XlaSvdOp::max_iterAttr(::mlir::IntegerAttr attr) {
  this->getOperation()->setAttr("max_iter", attr);
}

void XlaSvdOp::epsilonAttr(::mlir::FloatAttr attr) {
  this->getOperation()->setAttr("epsilon", attr);
}

void XlaSvdOp::precision_configAttr(::mlir::StringAttr attr) {
  this->getOperation()->setAttr("precision_config", attr);
}

void XlaSvdOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type s, ::mlir::Type u, ::mlir::Type v, ::mlir::Value a, ::mlir::IntegerAttr max_iter, ::mlir::FloatAttr epsilon, ::mlir::StringAttr precision_config) {
  odsState.addOperands(a);
  odsState.addAttribute("max_iter", max_iter);
  odsState.addAttribute("epsilon", epsilon);
  odsState.addAttribute("precision_config", precision_config);
  odsState.addTypes(s);
  odsState.addTypes(u);
  odsState.addTypes(v);
}

void XlaSvdOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value a, ::mlir::IntegerAttr max_iter, ::mlir::FloatAttr epsilon, ::mlir::StringAttr precision_config) {
  odsState.addOperands(a);
  odsState.addAttribute("max_iter", max_iter);
  odsState.addAttribute("epsilon", epsilon);
  odsState.addAttribute("precision_config", precision_config);
  assert(resultTypes.size() == 3u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void XlaSvdOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type s, ::mlir::Type u, ::mlir::Type v, ::mlir::Value a, uint64_t max_iter, ::llvm::APFloat epsilon, ::llvm::StringRef precision_config) {
  odsState.addOperands(a);
  odsState.addAttribute("max_iter", odsBuilder.getIntegerAttr(odsBuilder.getIntegerType(64), max_iter));
  odsState.addAttribute("epsilon", odsBuilder.getFloatAttr(odsBuilder.getF32Type(), epsilon));
  odsState.addAttribute("precision_config", odsBuilder.getStringAttr(precision_config));
  odsState.addTypes(s);
  odsState.addTypes(u);
  odsState.addTypes(v);
}

void XlaSvdOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value a, uint64_t max_iter, ::llvm::APFloat epsilon, ::llvm::StringRef precision_config) {
  odsState.addOperands(a);
  odsState.addAttribute("max_iter", odsBuilder.getIntegerAttr(odsBuilder.getIntegerType(64), max_iter));
  odsState.addAttribute("epsilon", odsBuilder.getFloatAttr(odsBuilder.getF32Type(), epsilon));
  odsState.addAttribute("precision_config", odsBuilder.getStringAttr(precision_config));
  assert(resultTypes.size() == 3u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void XlaSvdOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 3u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult XlaSvdOp::verify() {
  if (failed(XlaSvdOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of bfloat16 or 128-bit complex or 64-bit complex or 16-bit float or 32-bit float or 64-bit float or 16-bit integer or 32-bit integer or 64-bit integer or 8-bit integer or 32-bit quantized integer or 8-bit quantized integer or 8-bit quantized unsigned integer or 16-bit unsigned integer or 32-bit unsigned integer or 64-bit unsigned integer or 8-bit unsigned integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>())))))) {
        return emitOpError("result #") << index << " must be tensor of bfloat16 or 128-bit complex or 64-bit complex or 16-bit float or 32-bit float or 64-bit float or 16-bit integer or 32-bit integer or 64-bit integer or 8-bit integer or 32-bit quantized integer or 8-bit quantized integer or 8-bit quantized unsigned integer or 16-bit unsigned integer or 32-bit unsigned integer or 64-bit unsigned integer or 8-bit unsigned integer values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSResults(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>())))))) {
        return emitOpError("result #") << index << " must be tensor of bfloat16 or 128-bit complex or 64-bit complex or 16-bit float or 32-bit float or 64-bit float or 16-bit integer or 32-bit integer or 64-bit integer or 8-bit integer or 32-bit quantized integer or 8-bit quantized integer or 8-bit quantized unsigned integer or 16-bit unsigned integer or 32-bit unsigned integer or 64-bit unsigned integer or 8-bit unsigned integer values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup2 = getODSResults(2);
    for (::mlir::Value v : valueGroup2) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && ((((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Qint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8Type>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Quint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>())))))) {
        return emitOpError("result #") << index << " must be tensor of bfloat16 or 128-bit complex or 64-bit complex or 16-bit float or 32-bit float or 64-bit float or 16-bit integer or 32-bit integer or 64-bit integer or 8-bit integer or 32-bit quantized integer or 8-bit quantized integer or 8-bit quantized unsigned integer or 16-bit unsigned integer or 32-bit unsigned integer or 64-bit unsigned integer or 8-bit unsigned integer values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void XlaSvdOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::Xlog1pyOp definitions
//===----------------------------------------------------------------------===//

Xlog1pyOpAdaptor::Xlog1pyOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

Xlog1pyOpAdaptor::Xlog1pyOpAdaptor(Xlog1pyOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> Xlog1pyOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange Xlog1pyOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value Xlog1pyOpAdaptor::x() {
  return *getODSOperands(0).begin();
}

::mlir::Value Xlog1pyOpAdaptor::y() {
  return *getODSOperands(1).begin();
}

::mlir::LogicalResult Xlog1pyOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

::llvm::StringRef Xlog1pyOp::getOperationName() {
  return "tf.Xlog1py";
}

std::pair<unsigned, unsigned> Xlog1pyOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range Xlog1pyOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value Xlog1pyOp::x() {
  return *getODSOperands(0).begin();
}

::mlir::Value Xlog1pyOp::y() {
  return *getODSOperands(1).begin();
}

::mlir::MutableOperandRange Xlog1pyOp::xMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange Xlog1pyOp::yMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> Xlog1pyOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range Xlog1pyOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value Xlog1pyOp::z() {
  return *getODSResults(0).begin();
}

Type Xlog1pyOp::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

bool Xlog1pyOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "T") return true;
 return false;
}

::mlir::DictionaryAttr Xlog1pyOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())}
    }, ctx);
}

void Xlog1pyOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type z, ::mlir::Value x, ::mlir::Value y) {
  odsState.addOperands(x);
  odsState.addOperands(y);
  odsState.addTypes(z);
}

void Xlog1pyOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value x, ::mlir::Value y) {
  odsState.addOperands(x);
  odsState.addOperands(y);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void Xlog1pyOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult Xlog1pyOp::verify() {
  if (failed(Xlog1pyOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of 128-bit complex or 64-bit complex or 16-bit float or 32-bit float or 64-bit float values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of 128-bit complex or 64-bit complex or 16-bit float or 32-bit float or 64-bit float values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())))))) {
        return emitOpError("result #") << index << " must be tensor of 128-bit complex or 64-bit complex or 16-bit float or 32-bit float or 64-bit float values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void Xlog1pyOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::XlogyOp definitions
//===----------------------------------------------------------------------===//

XlogyOpAdaptor::XlogyOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

XlogyOpAdaptor::XlogyOpAdaptor(XlogyOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> XlogyOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange XlogyOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value XlogyOpAdaptor::x() {
  return *getODSOperands(0).begin();
}

::mlir::Value XlogyOpAdaptor::y() {
  return *getODSOperands(1).begin();
}

::mlir::LogicalResult XlogyOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

::llvm::StringRef XlogyOp::getOperationName() {
  return "tf.Xlogy";
}

std::pair<unsigned, unsigned> XlogyOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range XlogyOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value XlogyOp::x() {
  return *getODSOperands(0).begin();
}

::mlir::Value XlogyOp::y() {
  return *getODSOperands(1).begin();
}

::mlir::MutableOperandRange XlogyOp::xMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange XlogyOp::yMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> XlogyOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range XlogyOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value XlogyOp::z() {
  return *getODSResults(0).begin();
}

Type XlogyOp::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

bool XlogyOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "T") return true;
 return false;
}

::mlir::DictionaryAttr XlogyOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())}
    }, ctx);
}

void XlogyOp::build(OpBuilder &builder, OperationState &result, Value  x, Value  y) {
  auto resultType =
      OpTrait::util::getBroadcastedType(x.getType(), y.getType());
  if (!resultType)
    mlir::emitError(result.location, "non-broadcastable operands");
  return build(builder, result, resultType, x, y);
}

void XlogyOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type z, ::mlir::Value x, ::mlir::Value y) {
  odsState.addOperands(x);
  odsState.addOperands(y);
  odsState.addTypes(z);
}

void XlogyOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value x, ::mlir::Value y) {
  odsState.addOperands(x);
  odsState.addOperands(y);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void XlogyOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult XlogyOp::verify() {
  if (failed(XlogyOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of 128-bit complex or 64-bit complex or 16-bit float or 32-bit float or 64-bit float values, but got " << v.getType();
      }
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())))))) {
        return emitOpError("operand #") << index << " must be tensor of 128-bit complex or 64-bit complex or 16-bit float or 32-bit float or 64-bit float values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())))))) {
        return emitOpError("result #") << index << " must be tensor of 128-bit complex or 64-bit complex or 16-bit float or 32-bit float or 64-bit float values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void XlogyOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::YieldOp definitions
//===----------------------------------------------------------------------===//

YieldOpAdaptor::YieldOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

YieldOpAdaptor::YieldOpAdaptor(YieldOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> YieldOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  bool isVariadic[] = {true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (odsOperands.size() - 0) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::mlir::ValueRange YieldOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::ValueRange YieldOpAdaptor::operands() {
  return getODSOperands(0);
}

::mlir::LogicalResult YieldOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

::llvm::StringRef YieldOp::getOperationName() {
  return "tf.Yield";
}

std::pair<unsigned, unsigned> YieldOp::getODSOperandIndexAndLength(unsigned index) {
  bool isVariadic[] = {true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (getOperation()->getNumOperands() - 0) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::mlir::Operation::operand_range YieldOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Operation::operand_range YieldOp::operands() {
  return getODSOperands(0);
}

::mlir::MutableOperandRange YieldOp::operandsMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> YieldOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range YieldOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

void YieldOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange operands) {
  odsState.addOperands(operands);
}

void YieldOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 0u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult YieldOp::verify() {
  if (failed(YieldOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!((true))) {
        return emitOpError("operand #") << index << " must be any type, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
  }
  return ::mlir::success();
}

} // namespace TF
} // namespace mlir
namespace mlir {
namespace TF {

//===----------------------------------------------------------------------===//
// ::mlir::TF::ZerosLikeOp definitions
//===----------------------------------------------------------------------===//

ZerosLikeOpAdaptor::ZerosLikeOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs)  : odsOperands(values), odsAttrs(attrs) {

}

ZerosLikeOpAdaptor::ZerosLikeOpAdaptor(ZerosLikeOp&op)  : odsOperands(op.getOperation()->getOperands()), odsAttrs(op.getOperation()->getAttrDictionary()) {

}

std::pair<unsigned, unsigned> ZerosLikeOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange ZerosLikeOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value ZerosLikeOpAdaptor::x() {
  return *getODSOperands(0).begin();
}

::mlir::LogicalResult ZerosLikeOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

::llvm::StringRef ZerosLikeOp::getOperationName() {
  return "tf.ZerosLike";
}

std::pair<unsigned, unsigned> ZerosLikeOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range ZerosLikeOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value ZerosLikeOp::x() {
  return *getODSOperands(0).begin();
}

::mlir::MutableOperandRange ZerosLikeOp::xMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> ZerosLikeOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range ZerosLikeOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value ZerosLikeOp::y() {
  return *getODSResults(0).begin();
}

Type ZerosLikeOp::T() {
  return mlir::getElementTypeOrSelf(*getODSOperands(0).begin());
}

bool ZerosLikeOp::isDerivedAttribute(::llvm::StringRef name) {
  if (name == "T") return true;
 return false;
}

::mlir::DictionaryAttr ZerosLikeOp::materializeDerivedAttributes() {
  ::mlir::MLIRContext* ctx = getContext();
  ::mlir::Builder odsBuilder(ctx); (void)odsBuilder;
  return ::mlir::DictionaryAttr::get({
    {::mlir::Identifier::get("T", ctx),
::mlir::TypeAttr::get(T())}
    }, ctx);
}

void ZerosLikeOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type y, ::mlir::Value x) {
  odsState.addOperands(x);
  odsState.addTypes(y);
}

void ZerosLikeOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value x) {
  odsState.addOperands(x);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void ZerosLikeOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

void ZerosLikeOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value x) {
  odsState.addOperands(x);
  odsState.addTypes({x.getType()});

}

void ZerosLikeOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  odsState.addTypes({operands[0].getType()});

}

::mlir::LogicalResult ZerosLikeOp::verify() {
  if (failed(ZerosLikeOpAdaptor(*this).verify(this->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>())))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::TensorFlowType>()))))) {
        return emitOpError("operand #") << index << " must be tensor of tf.dtype values, but got " << v.getType();
      }
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      (void)v;
      if (!(((v.getType().isa<::mlir::TensorType>())) && (((((v.getType().cast<::mlir::ShapedType>().getElementType().isF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF32())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isF64())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isBF16())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::HalfRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::FloatRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::DoubleRefType>())) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Bfloat16RefType>()))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF32()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex64RefType>()))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isa<::mlir::ComplexType>())) && ((v.getType().cast<::mlir::ShapedType>().getElementType().cast<::mlir::ComplexType>().getElementType().isF64()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Complex128RefType>())))) || (((((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Int64RefType>())))) || ((((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint8RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint16RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint32RefType>()))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::Uint64RefType>()))))) || (((v.getType().cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::BoolRefType>()))) || ((v.getType().cast<::mlir::ShapedType>().getElementType().isa<mlir::TF::TensorFlowType>()))))) {
        return emitOpError("result #") << index << " must be tensor of tf.dtype values, but got " << v.getType();
      }
      ++index;
    }
  }
  return ::mlir::success();
}

void ZerosLikeOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace TF
} // namespace mlir

#endif  // GET_OP_CLASSES

